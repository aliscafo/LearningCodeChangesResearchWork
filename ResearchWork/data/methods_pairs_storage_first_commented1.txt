709
#method_before
@Override
public void evict(Account.Id accountId) throws IOException {
    if (accountId != null) {
        byId.invalidate(accountId);
        index(accountId);
    }
}
#method_after
@Override
public void evict(Account.Id accountId) throws IOException {
    if (accountId != null) {
        byId.invalidate(accountId);
        indexer.get().index(accountId);
    }
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // 
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Collection<AccountProjectWatch> projectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException {
    Account account = db.accounts().get(who);
    if (account == null) {
        // Account no longer exists? They are anonymous.
        return missing(who);
    }
    Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    Collection<AccountProjectWatch> projectWatches = Collections.unmodifiableCollection(db.accountProjectWatches().byAccount(who).toList());
    return new AccountState(account, internalGroups, externalIds, projectWatches);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    // Adapt the capacity of this list when adding more default predicates.
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(11);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    // predicates.
    return Predicate.or(predicates);
}
#end_block

#method_before
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (suggest && (!suggestConfig || query.length() < suggestFrom)) {
        return Collections.emptyList();
    }
    Set<FillOptions> fillOptions = EnumSet.of(FillOptions.ID);
    if (suggest || options.contains(ListAccountsOption.DETAILS)) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
    }
    if (suggest || options.contains(ListAccountsOption.ALL_EMAILS)) {
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    accountLoader = accountLoaderFactory.create(fillOptions);
    AccountIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex != null) {
        return queryFromIndex();
    }
    if (!suggest) {
        throw new MethodNotAllowedException();
    }
    if (start != null) {
        throw new MethodNotAllowedException("option start not allowed");
    }
    return queryFromDb();
}
#method_after
@Override
public List<AccountInfo> apply(TopLevelResource rsrc) throws OrmException, BadRequestException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (suggest && (!suggestConfig || query.length() < suggestFrom)) {
        return Collections.emptyList();
    }
    Set<FillOptions> fillOptions = EnumSet.of(FillOptions.ID);
    if (options.contains(ListAccountsOption.DETAILS)) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
    }
    if (options.contains(ListAccountsOption.ALL_EMAILS)) {
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    if (suggest) {
        fillOptions.addAll(AccountLoader.DETAILED_OPTIONS);
        fillOptions.add(FillOptions.EMAIL);
        fillOptions.add(FillOptions.SECONDARY_EMAILS);
    }
    accountLoader = accountLoaderFactory.create(fillOptions);
    AccountIndex searchIndex = indexes.getSearchIndex();
    if (searchIndex != null) {
        return queryFromIndex();
    }
    if (!suggest) {
        throw new MethodNotAllowedException();
    }
    if (start != null) {
        throw new MethodNotAllowedException("option start not allowed");
    }
    return queryFromDb();
}
#end_block

#method_before
public static List<String> getEmails(Collection<AccountExternalId> ids) {
    List<String> emails = new ArrayList<>();
    for (AccountExternalId id : ids) {
        if (id.isScheme(SCHEME_MAILTO)) {
            emails.add(id.getSchemeRest());
        }
    }
    return emails;
}
#method_after
public static Set<String> getEmails(Collection<AccountExternalId> ids) {
    Set<String> emails = new HashSet<>();
    for (AccountExternalId id : ids) {
        if (id.isScheme(SCHEME_MAILTO)) {
            emails.add(id.getSchemeRest());
        }
    }
    return emails;
}
#end_block

#method_before
public List<String> getSecondaryEmails(Account account, Collection<AccountExternalId> externalIds) {
    List<String> emails = AccountState.getEmails(externalIds);
    if (account.getPreferredEmail() != null) {
        emails.remove(account.getPreferredEmail());
    }
    Collections.sort(emails);
    return emails;
}
#method_after
public List<String> getSecondaryEmails(Account account, Collection<AccountExternalId> externalIds) {
    List<String> emails = new ArrayList<>(AccountState.getEmails(externalIds));
    if (account.getPreferredEmail() != null) {
        emails.remove(account.getPreferredEmail());
    }
    Collections.sort(emails);
    return emails;
}
#end_block

#method_before
@Test
public void watchProject() throws Exception {
    // watch project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject);
    // push a change to watched project -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "my subject", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched project -> should not trigger email
    // notification
    String notWatchedProject = createProject("otherProject").get();
    TestRepository<InMemoryRepository> notWatchedRepo = cloneProject(new Project.NameKey(notWatchedProject), admin);
    r = pushFactory.create(db, admin.getIdent(), notWatchedRepo, "other subject", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: my subject\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchProject() throws Exception {
    // watch project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, null);
    // push a change to watched project -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched project -> should not trigger email
    // notification
    String notWatchedProject = createProject("otherProject").get();
    TestRepository<InMemoryRepository> notWatchedRepo = cloneProject(new Project.NameKey(notWatchedProject), admin);
    r = pushFactory.create(db, admin.getIdent(), notWatchedRepo, "DONT_TRIGGER", "a", "a1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
@Test
public void watchFile() throws Exception {
    // watch file in project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, "file:a.txt");
    // push a change to watched file -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "my subject", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched file -> should not trigger email
    // notification
    r = pushFactory.create(db, admin.getIdent(), testRepo, "other subject", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: my subject\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#method_after
@Test
public void watchFile() throws Exception {
    // watch file in project
    String watchedProject = createProject("watchedProject").get();
    setApiUser(user);
    watch(watchedProject, "file:a.txt");
    // push a change to watched file -> should trigger email notification
    setApiUser(admin);
    TestRepository<InMemoryRepository> watchedRepo = cloneProject(new Project.NameKey(watchedProject), admin);
    PushOneCommit.Result r = pushFactory.create(db, admin.getIdent(), watchedRepo, "TRIGGER", "a.txt", "a1").to("refs/for/master");
    r.assertOkStatus();
    // push a change to non-watched file -> should not trigger email
    // notification
    r = pushFactory.create(db, admin.getIdent(), testRepo, "DONT_TRIGGER", "b.txt", "b1").to("refs/for/master");
    r.assertOkStatus();
    // assert email notification
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Change subject: TRIGGER\n");
    assertThat(m.body()).contains("Gerrit-PatchSet: 1\n");
}
#end_block

#method_before
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(ChangeControl control, PatchSet.Id psId, IdentifiedUser user, ChangeUpdate update, Timestamp timestamp) throws OrmException {
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(db, control, psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
    byKey.put(submit.getKey(), submit);
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(control, byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    logDebug("Adding submit label " + submit);
    db.patchSetApprovals().upsert(normalized.getNormalized());
    db.patchSetApprovals().update(zero(normalized.deleted()));
    try {
        return saveToBatch(control, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                if (p.commit.name().equals(changes.get(0).currentPatchSet().getRevision().get())) {
                    // All PatchSets in push are currentPatchSet of target changes
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(changeRefsById(), db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (Iterator<ChangeLookup> itr = pending.iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, SetMultimap<ObjectId, Ref> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.put(ref.getObjectId(), ref);
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = changeRefsById();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@BeforeClass
public static void setTimeForTesting() {
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@BeforeClass
public static void setTimeForTesting() {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
}
#end_block

#method_before
@AfterClass
public static void restoreTime() {
    DateTimeUtils.setCurrentMillisSystem();
}
#method_after
@AfterClass
public static void restoreTime() {
    TestTimeUtil.useSystemTime();
}
#end_block

#method_before
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
}
#method_after
@Test
public void testCreateNewChangeForAllNotInTarget() throws Exception {
    ProjectConfig config = projectCache.checkedGet(project).getConfig();
    config.getProject().setCreateNewChangeForAllNotInTarget(InheritableBoolean.TRUE);
    saveProjectConfig(project, config);
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "a.txt", "content");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    r = push.to("refs/for/master");
    r.assertOkStatus();
    gApi.projects().name(project.get()).branch("otherBranch").create(new BranchInput());
    PushOneCommit.Result r2 = push.to("refs/for/otherBranch");
    r2.assertOkStatus();
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    List<ChangeInfo> changes = query(r.getCommitId().name());
    assertThat(changes).hasSize(2);
    ChangeInfo c1 = get(changes.get(0).id);
    ChangeInfo c2 = get(changes.get(1).id);
    assertThat(c1.project).isEqualTo(c2.project);
    assertThat(c1.branch).isNotEqualTo(c2.branch);
    assertThat(c1.changeId).isEqualTo(c2.changeId);
    assertThat(c1.currentRevision).isEqualTo(c2.currentRevision);
}
#method_after
@Test
public void testPushSameCommitTwiceUsingMagicBranchBaseOption() throws Exception {
    grant(Permission.PUSH, project, "refs/heads/master");
    PushOneCommit.Result rBase = pushTo("refs/heads/master");
    rBase.assertOkStatus();
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, "b.txt", "anotherContent");
    PushOneCommit.Result r = push.to("refs/for/master");
    r.assertOkStatus();
    PushResult pr = GitUtil.pushHead(testRepo, "refs/for/foo%base=" + rBase.getCommitId().name(), false, false);
    assertThat(pr.getMessages()).contains("changes: new: 1, refs: 1, done");
    assertTwoChangesWithSameRevision(r);
}
#end_block

#method_before
@Override
public ChangeKind getChangeKind(ReviewDb db, Repository repo, Change change, PatchSet patch) {
    return getChangeKindInternal(this, db, change, repo, patch, changeDataFactory, projectCache);
}
#method_after
@Override
public ChangeKind getChangeKind(Repository repo, ChangeData cd, PatchSet patch) {
    return getChangeKindInternal(this, repo, cd, patch, projectCache);
}
#end_block

#method_before
@Override
public ChangeKind getChangeKind(ReviewDb db, Repository repo, Change change, PatchSet patch) {
    return getChangeKindInternal(this, db, change, repo, patch, changeDataFactory, projectCache);
}
#method_after
@Override
public ChangeKind getChangeKind(Repository repo, ChangeData cd, PatchSet patch) {
    return getChangeKindInternal(this, repo, cd, patch, projectCache);
}
#end_block

#method_before
private static ChangeKind getChangeKindInternal(ChangeKindCache cache, ReviewDb db, Change change, PatchSet patch, ChangeData.Factory changeDataFactory, ProjectCache projectCache, GitRepositoryManager repoManager) {
    // TODO - dborowitz: add NEW_CHANGE type for default.
    ChangeKind kind = ChangeKind.REWORK;
    // the repository.
    if (patch.getId().get() > 1) {
        try (Repository repo = repoManager.openRepository(change.getProject())) {
            kind = getChangeKindInternal(cache, db, change, repo, patch, changeDataFactory, projectCache);
        } catch (IOException e) {
            // Do nothing; assume we have a complex change
            log.warn("Unable to get change kind for patchSet " + patch.getPatchSetId() + "of change " + change.getChangeId(), e);
        }
    }
    return kind;
}
#method_after
private static ChangeKind getChangeKindInternal(ChangeKindCache cache, Repository repo, ChangeData change, PatchSet patch, ProjectCache projectCache) {
    ChangeKind kind = ChangeKind.REWORK;
    // the repository.
    if (patch.getId().get() > 1) {
        try {
            ProjectState projectState = projectCache.checkedGet(change.project());
            Collection<PatchSet> patchSetCollection = change.patchSets();
            PatchSet priorPs = patch;
            for (PatchSet ps : patchSetCollection) {
                if (ps.getId().get() < patch.getId().get() && (ps.getId().get() > priorPs.getId().get() || priorPs == patch)) {
                    // We only want the previous patch set, so walk until the last one
                    priorPs = ps;
                }
            }
            // and deletes the draft.
            if (priorPs != patch) {
                kind = cache.getChangeKind(projectState, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(patch.getRevision().get()));
            }
        } catch (IOException | OrmException e) {
            // Do nothing; assume we have a complex change
            log.warn("Unable to get change kind for patchSet " + patch.getPatchSetId() + "of change " + change.getId(), e);
        }
    }
    return kind;
}
#end_block

#method_before
private static ChangeKind getChangeKindInternal(ChangeKindCache cache, ReviewDb db, Change change, PatchSet patch, ChangeData.Factory changeDataFactory, ProjectCache projectCache, GitRepositoryManager repoManager) {
    // TODO - dborowitz: add NEW_CHANGE type for default.
    ChangeKind kind = ChangeKind.REWORK;
    // the repository.
    if (patch.getId().get() > 1) {
        try (Repository repo = repoManager.openRepository(change.getProject())) {
            kind = getChangeKindInternal(cache, db, change, repo, patch, changeDataFactory, projectCache);
        } catch (IOException e) {
            // Do nothing; assume we have a complex change
            log.warn("Unable to get change kind for patchSet " + patch.getPatchSetId() + "of change " + change.getChangeId(), e);
        }
    }
    return kind;
}
#method_after
private static ChangeKind getChangeKindInternal(ChangeKindCache cache, ReviewDb db, Change change, PatchSet patch, ChangeData.Factory changeDataFactory, ProjectCache projectCache, GitRepositoryManager repoManager) {
    // TODO - dborowitz: add NEW_CHANGE type for default.
    ChangeKind kind = ChangeKind.REWORK;
    // the repository.
    if (patch.getId().get() > 1) {
        try (Repository repo = repoManager.openRepository(change.getProject())) {
            kind = getChangeKindInternal(cache, repo, changeDataFactory.create(db, change), patch, projectCache);
        } catch (IOException e) {
            // Do nothing; assume we have a complex change
            log.warn("Unable to get change kind for patchSet " + patch.getPatchSetId() + "of change " + change.getChangeId(), e);
        }
    }
    return kind;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        for (PatchSet in : map.values()) {
            if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
                res.put(in.getRevision().get(), toRevisionInfo(ctl, cd, in, repo));
            }
        }
        return res;
    }
}
#end_block

#method_before
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    RevisionInfo rev = toRevisionInfo(ctl, in);
    accountLoader.fill();
    return rev;
}
#method_after
public RevisionInfo getRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    try (Repository repo = repoManager.openRepository(ctl.getProject().getNameKey())) {
        RevisionInfo rev = toRevisionInfo(ctl, changeDataFactory.create(db.get(), ctl), in, repo);
        accountLoader.fill();
        return rev;
    }
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(db.get(), ctl.getChange(), in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, Repository repo) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    out.kind = changeKindCache.getChangeKind(repo, cd, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    // Append and push unknown permission
    config += "[access \"" + refsFor + "\"]\n" + "\tunknownPermission = group Registered Users\n";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to("refs/meta/config").assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    assertThat(config).containsMatch("unknownPermission");
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    assertThat(config).containsMatch("unknownPermission");
}
#method_after
@Test
public void unknownPermissionRemainsUnchanged() throws Exception {
    String access = "access";
    String unknownPermission = "unknownPermission";
    String registeredUsers = "group Registered Users";
    String refsFor = "refs/for/*";
    // Clone repository to forcefully add permission
    TestRepository<InMemoryRepository> allProjectsRepo = cloneProject(allProjects, admin);
    // Fetch permission ref
    GitUtil.fetch(allProjectsRepo, "refs/meta/config:cfg");
    allProjectsRepo.reset("cfg");
    // Load current permissions
    String config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    // Append and push unknown permission
    Config cfg = new Config();
    cfg.fromText(config);
    cfg.setString(access, refsFor, unknownPermission, registeredUsers);
    config = cfg.toText();
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allProjectsRepo, "Subject", "project.config", config);
    push.to("refs/meta/config").assertOkStatus();
    // Verify that unknownPermission is present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
    // Make permission change through API
    ProjectAccessInput accessInput = newProjectAccessInput();
    AccessSectionInfo accessSectionInfo = createDefaultAccessSectionInfo();
    accessInput.add.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    accessInput.add.clear();
    accessInput.remove.put(refsFor, accessSectionInfo);
    gApi.projects().name(allProjects.get()).access(accessInput);
    // Verify that unknownPermission is still present
    config = gApi.projects().name(allProjects.get()).branch("refs/meta/config").file("project.config").asString();
    cfg.fromText(config);
    assertThat(cfg.getString(access, refsFor, unknownPermission)).isEqualTo(registeredUsers);
}
#end_block

#method_before
public void remove(AccessSection section) {
    if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        if (!a.hasMoreConfig()) {
            accessSections.remove(a);
        } else {
            a.setPermissions(new ArrayList<Permission>());
        }
    }
}
#method_after
public void remove(AccessSection section) {
    if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        if (sectionsWithUnknownPermissions.contains(a)) {
            accessSections.remove(a);
        } else {
            a.setPermissions(new ArrayList<Permission>());
        }
    }
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    as.setHasMoreConfig(true);
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                } else {
                    sectionsWithUnknownPermissions.add(as);
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        Optional<ChangedLines> cl = Optional.absent();
        Change c = change();
        if (c != null) {
            PatchSet ps = currentPatchSet();
            if (ps != null) {
                PatchList p;
                try {
                    p = patchListCache.get(c, ps);
                    cl = Optional.of(new ChangedLines(p.getInsertions(), p.getDeletions()));
                } catch (PatchListNotAvailableException e) {
                // Leave as absent.
                }
            }
        }
        changedLines = cl;
    }
    return changedLines;
}
#method_after
public Optional<ChangedLines> changedLines() throws OrmException {
    if (changedLines == null) {
        changedLines = computeChangedLines();
    }
    return changedLines;
}
#end_block

#method_before
@Operator
public Predicate<AccountState> account(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return new AccountIdPredicate(self());
    }
    return new AccountIdPredicate(query);
}
#method_after
@Operator
public Predicate<AccountState> account(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return new AccountIdPredicate(self());
    }
    Integer id = Ints.tryParse(query);
    if (id != null) {
        return new AccountIdPredicate(new Account.Id(id));
    }
    throw error("User " + query + " not found");
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equals(query)) {
        return new AccountIdPredicate(self());
    }
    if (query.matches("^[1-9][0-9]*$")) {
        return new AccountIdPredicate(Account.Id.parse(query));
    }
    throw error("User " + query + " not found");
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return new AccountIdPredicate(self());
    }
    Integer id = Ints.tryParse(query);
    if (id != null) {
        return new AccountIdPredicate(new Account.Id(id));
    }
    throw error("User " + query + " not found");
}
#end_block

#method_before
@Operator
public Predicate<AccountState> email(String email) {
    return new EmailPredicate(email);
}
#method_after
@Operator
public Predicate<AccountState> email(String email) {
    return AccountPredicates.email(email);
}
#end_block

#method_before
@Operator
public Predicate<AccountState> is(String value) {
    if ("active".equalsIgnoreCase(value)) {
        return new IsActivePredicate();
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<AccountState> is(String value) throws QueryParseException {
    if ("active".equalsIgnoreCase(value)) {
        return AccountPredicates.isActive();
    }
    if ("inactive".equalsIgnoreCase(value)) {
        return AccountPredicates.isInactive();
    }
    throw error("Invalid query");
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    return account(query);
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return AccountPredicates.id(self());
    }
    List<Predicate<AccountState>> preds = Lists.newArrayListWithCapacity(3);
    Integer id = Ints.tryParse(query);
    if (id != null) {
        preds.add(AccountPredicates.id(new Account.Id(id)));
    }
    preds.add(name(query));
    preds.add(username(query));
    return Predicate.or(preds);
}
#end_block

#method_before
@Operator
public Predicate<AccountState> email(String email) {
    return new EmailPredicate(email);
}
#method_after
@Operator
public Predicate<AccountState> email(String email) {
    return AccountPredicates.email(email);
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    return account(query);
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    if ("self".equalsIgnoreCase(query)) {
        return AccountPredicates.id(self());
    }
    List<Predicate<AccountState>> preds = Lists.newArrayListWithCapacity(2);
    Integer id = Ints.tryParse(query);
    if (id != null) {
        preds.add(AccountPredicates.id(new Account.Id(id)));
    }
    preds.add(email(query));
    return Predicate.or(preds);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = ReviewDbUtil.unwrapDb(schemaFactory.open())) {
                        return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    sysInjector.injectMembers(this);
    if (!notesMigration.enabled()) {
        throw die("NoteDb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the NoteDb");
    final ImmutableMultimap<Project.NameKey, Change.Id> changesByProject = getChangesByProject();
    boolean ok;
    Stopwatch sw = Stopwatch.createStarted();
    try (Repository allUsersRepo = repoManager.openRepository(allUsersName)) {
        deleteRefs(RefNames.REFS_DRAFT_COMMENTS, allUsersRepo);
        List<ListenableFuture<Boolean>> futures = new ArrayList<>();
        List<Project.NameKey> projectNames = Ordering.usingToString().sortedCopy(changesByProject.keySet());
        for (final Project.NameKey project : projectNames) {
            ListenableFuture<Boolean> future = executor.submit(new Callable<Boolean>() {

                @Override
                public Boolean call() {
                    try (ReviewDb db = unwrapDb(schemaFactory.open())) {
                        return rebuilder.rebuildProject(db, changesByProject, project, allUsersRepo);
                    } catch (Exception e) {
                        log.error("Error rebuilding project " + project, e);
                        return false;
                    }
                }
            });
            futures.add(future);
        }
        try {
            ok = Iterables.all(Futures.allAsList(futures).get(), Predicates.equalTo(true));
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error rebuilding projects", e);
            ok = false;
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok ? 0 : 1;
}
#end_block

#method_before
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = ReviewDbUtil.unwrapDb(db).changes().get(Iterables.transform(changes, new Function<Integer, Change.Id>() {

                @Override
                public Change.Id apply(Integer in) {
                    return new Change.Id(in);
                }
            }));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : ReviewDbUtil.unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#method_after
private ImmutableMultimap<Project.NameKey, Change.Id> getChangesByProject() throws OrmException {
    // Memorize all changes so we can close the db connection and allow
    // rebuilder threads to use the full connection pool.
    Multimap<Project.NameKey, Change.Id> changesByProject = ArrayListMultimap.create();
    try (ReviewDb db = schemaFactory.open()) {
        if (projects.isEmpty() && !changes.isEmpty()) {
            Iterable<Change> todo = unwrapDb(db).changes().get(Iterables.transform(changes, new Function<Integer, Change.Id>() {

                @Override
                public Change.Id apply(Integer in) {
                    return new Change.Id(in);
                }
            }));
            for (Change c : todo) {
                changesByProject.put(c.getProject(), c.getId());
            }
        } else {
            for (Change c : unwrapDb(db).changes().all()) {
                boolean include = false;
                if (projects.isEmpty() && changes.isEmpty()) {
                    include = true;
                } else if (!projects.isEmpty() && projects.contains(c.getProject().get())) {
                    include = true;
                } else if (!changes.isEmpty() && changes.contains(c.getId().get())) {
                    include = true;
                }
                if (include) {
                    changesByProject.put(c.getProject(), c.getId());
                }
            }
        }
        return ImmutableMultimap.copyOf(changesByProject);
    }
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) ReviewDbUtil.unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    schemaUpdater.update(new UpdateUI() {

        @Override
        public void message(String msg) {
            System.err.println(msg);
            System.err.flush();
        }

        @Override
        public boolean yesno(boolean def, String msg) {
            return ui.yesno(def, msg);
        }

        @Override
        public boolean isBatch() {
            return ui.isBatch();
        }

        @Override
        public void pruneSchema(StatementExecutor e, List<String> prune) {
            for (String p : prune) {
                if (!pruneList.contains(p)) {
                    pruneList.add(p);
                }
            }
        }
    });
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    // Use local unwrap as we need to handle BatchUpdateReviewDb as well.
    ReviewDb db = unwrap(ctx.getDb());
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(change.getProject(), id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException, NoSuchChangeException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    ReviewDb db = unwrap(ctx.getDb());
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        accountPatchReviewStore.get().clearReviewed(ps.getId());
    }
    // Only delete from ReviewDb here; deletion from NoteDb is handled in
    // BatchUpdate.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(db.patchSets().byChange(id));
    db.changeMessages().delete(db.changeMessages().byChange(id));
    // Non-atomic operation on Accounts table; not much we can do to make it
    // atomic.
    starredChangesUtil.unstarAll(change.getProject(), id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return r;
}
#method_after
@Override
public Result execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    db = ReviewDbUtil.unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    Result r = manager.stageAndApplyDelta(change);
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        if (!migration.failChangeWrites()) {
            manager.execute();
        } else {
            // results instead of reading from the repo.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return r;
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    ChangeNotes notes = create(db, c.getProject(), c.getId());
    if (notes.getChange() == null) {
        throw new NoSuchChangeException(c.getId());
    }
    return notes;
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Change c) throws OrmException, NoSuchChangeException {
    return createChecked(db, c.getProject(), c.getId());
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    ChangeNotes notes = create(db, project, changeId);
    if (notes.getChange() == null) {
        throw new NoSuchChangeException(changeId);
    }
    return notes;
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    Change change = ReviewDbUtil.unwrapDb(db).changes().get(changeId);
    if (change == null || !change.getProject().equals(project)) {
        throw new NoSuchChangeException(changeId);
    }
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(ReviewDbUtil.unwrapDb(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    return new ChangeNotes(args, change).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#method_after
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(ReviewDbUtil.unwrapDb(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    // request scope for the rebuilder to open the db.
                    return new ChangeNotes(args, change, false, null).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#end_block

#method_before
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.writeChanges()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#method_after
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // this is a programmer error.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.commitChangeWrites()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    try {
        ChangeContext ctx;
        NoteDbUpdateManager updateManager = null;
        boolean dirty = false;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                return;
            }
            deleted = ctx.deleted;
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.writeChanges()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                db.changes().insert(cs);
            } else if (deleted) {
                db.changes().delete(cs);
            } else {
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.writeChanges()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void call(ReviewDb db, Repository repo, RevWalk rw) throws Exception {
    try {
        ChangeContext ctx;
        NoteDbUpdateManager updateManager = null;
        boolean dirty = false;
        db.changes().beginTransaction(id);
        try {
            ctx = newChangeContext(db, repo, rw, id);
            // Call updateChange on each op.
            for (Op op : changeOps) {
                dirty |= op.updateChange(ctx);
            }
            if (!dirty) {
                return;
            }
            deleted = ctx.deleted;
            // Stage the NoteDb update and store its state in the Change.
            if (notesMigration.commitChangeWrites()) {
                updateManager = stageNoteDbUpdate(ctx, deleted);
            }
            // Bump lastUpdatedOn or rowVersion and commit.
            Iterable<Change> cs = changesToUpdate(ctx);
            if (newChanges.containsKey(id)) {
                // Insert rather than upsert in case of a race on change IDs.
                db.changes().insert(cs);
            } else if (deleted) {
                db.changes().delete(cs);
            } else {
                db.changes().update(cs);
            }
            db.commit();
        } finally {
            db.rollback();
        }
        if (notesMigration.commitChangeWrites()) {
            try {
                // Do not execute the NoteDbUpdateManager, as we don't want too much
                // contention on the underlying repo, and we would rather use a
                // single ObjectInserter/BatchRefUpdate later.
                // 
                // TODO(dborowitz): May or may not be worth trying to batch
                // together flushed inserters as well.
                noteDbResult = updateManager.stage().get(id);
            } catch (IOException ex) {
                // Ignore all errors trying to update NoteDb at this point. We've
                // already written the NoteDbChangeState to ReviewDb, which means
                // if the state is out of date it will be rebuilt the next time it
                // is needed.
                log.debug("Ignoring NoteDb update error after ReviewDb write", ex);
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
@Override
public boolean match(final T object) throws OrmException {
    for (Predicate<T> c : children) {
        checkState(c.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", c, MatchablePredicate.class.getName());
        if (!c.asMatchable().match(object)) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
public boolean match(final T object) throws OrmException {
    for (Predicate<T> c : children) {
        checkState(c.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", c, Matchable.class.getName());
        if (!c.asMatchable().match(object)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (source != null && fromSource.get(cd) == source) {
        return true;
    }
    Predicate<ChangeData> pred = getChild(0);
    checkState(pred.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", pred, MatchablePredicate.class.getName());
    return pred.asMatchable().match(cd);
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    if (source != null && fromSource.get(cd) == source) {
        return true;
    }
    Predicate<ChangeData> pred = getChild(0);
    checkState(pred.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", pred, Matchable.class.getName());
    return pred.asMatchable().match(cd);
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorChangePredicate(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitTypeRecord str = object.submitTypeRecord();
                if (!str.isOk()) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, str.type, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.run(str.type, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new ChangeOperatorPredicate(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitTypeRecord str = object.submitTypeRecord();
                if (!str.isOk()) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, str.type, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.run(str.type, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@Override
public boolean match(final T object) throws OrmException {
    checkState(that.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", that, MatchablePredicate.class.getName());
    return !that.asMatchable().match(object);
}
#method_after
@Override
public boolean match(final T object) throws OrmException {
    checkState(that.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", that, Matchable.class.getName());
    return !that.asMatchable().match(object);
}
#end_block

#method_before
@Override
public int getCost() {
    return that.getCost();
}
#method_after
@Override
public int getCost() {
    return that.estimateCost();
}
#end_block

#method_before
public boolean isMatchable() {
    return this instanceof MatchablePredicate;
}
#method_after
public boolean isMatchable() {
    return this instanceof Matchable;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public MatchablePredicate<T> asMatchable() {
    checkState(isMatchable(), "not matchable");
    return (MatchablePredicate<T>) this;
}
#method_after
@SuppressWarnings("unchecked")
public Matchable<T> asMatchable() {
    checkState(isMatchable(), "not matchable");
    return (Matchable<T>) this;
}
#end_block

#method_before
@Override
public int compare(Predicate<T> a, Predicate<T> b) {
    int ai = a instanceof DataSource ? 0 : 1;
    int bi = b instanceof DataSource ? 0 : 1;
    int cmp = ai - bi;
    if (cmp == 0) {
        cmp = a.getCost() - b.getCost();
    }
    if (cmp == 0 && a instanceof DataSource && b instanceof DataSource) {
        DataSource<?> as = (DataSource<?>) a;
        DataSource<?> bs = (DataSource<?>) b;
        cmp = as.getCardinality() - bs.getCardinality();
    }
    return cmp;
}
#method_after
@Override
public int compare(Predicate<T> a, Predicate<T> b) {
    int ai = a instanceof DataSource ? 0 : 1;
    int bi = b instanceof DataSource ? 0 : 1;
    int cmp = ai - bi;
    if (cmp == 0) {
        cmp = a.estimateCost() - b.estimateCost();
    }
    if (cmp == 0 && a instanceof DataSource && b instanceof DataSource) {
        DataSource<?> as = (DataSource<?>) a;
        DataSource<?> bs = (DataSource<?>) b;
        cmp = as.getCardinality() - bs.getCardinality();
    }
    return cmp;
}
#end_block

#method_before
@Override
public boolean match(final T object) throws OrmException {
    for (final Predicate<T> c : children) {
        checkState(c.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", c, MatchablePredicate.class.getName());
        if (c.asMatchable().match(object)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean match(final T object) throws OrmException {
    for (final Predicate<T> c : children) {
        checkState(c.isMatchable(), "match invoked, but child predicate %s " + "doesn't implement %s", c, Matchable.class.getName());
        if (c.asMatchable().match(object)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Test
public void validateTopLevelDomains() throws Exception {
    try (InputStream in = this.getClass().getResourceAsStream("tlds-alpha-by-domain.txt")) {
        if (in == null) {
            throw new Exception("TLD list not found");
        }
        BufferedReader r = new BufferedReader(new InputStreamReader(in));
        String tld;
        EmailValidator validator = EmailValidator.getInstance();
        while ((tld = r.readLine()) != null) {
            if (tld.startsWith("#") || tld.startsWith("XN--")) {
                // Ignore comments and non-latin domains
                continue;
            }
            String test = "test@example." + tld.toLowerCase();
            assert_().withFailureMessage("failed to validate TLD \"" + test + "\"").that(validator.isValid(test)).isTrue();
        }
    }
}
#method_after
@Test
public void validateTopLevelDomains() throws Exception {
    try (InputStream in = this.getClass().getResourceAsStream("tlds-alpha-by-domain.txt")) {
        if (in == null) {
            throw new Exception("TLD list not found");
        }
        BufferedReader r = new BufferedReader(new InputStreamReader(in));
        String tld;
        EmailValidator validator = EmailValidator.getInstance();
        while ((tld = r.readLine()) != null) {
            if (tld.startsWith("# ") || tld.startsWith("XN--")) {
                // Ignore comments and non-latin domains
                continue;
            }
            if (tld.startsWith(UNSUPPORTED_PREFIX)) {
                String test = "test@example." + tld.toLowerCase().substring(UNSUPPORTED_PREFIX.length());
                assert_().withFailureMessage("expected invalid TLD \"" + test + "\"").that(validator.isValid(test)).isFalse();
            } else {
                String test = "test@example." + tld.toLowerCase();
                assert_().withFailureMessage("failed to validate TLD \"" + test + "\"").that(validator.isValid(test)).isTrue();
            }
        }
    }
}
#end_block

#method_before
@VisibleForTesting
static QueryOptions convertOptions(QueryOptions opts) {
    opts = QueryOptions.convert(opts);
    return IndexedChangeQuery.createOptions(opts.config(), opts.start(), opts.limit(), opts.fields());
}
#method_after
@VisibleForTesting
static QueryOptions convertOptions(QueryOptions opts) {
    opts = opts.convertForBackend();
    return IndexedChangeQuery.createOptions(opts.config(), opts.start(), opts.limit(), opts.fields());
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> enforceVisibility(Predicate<ChangeData> pred) {
    return new AndChangeSource(ImmutableList.of(pred, new IsVisibleToPredicate(db, notesFactory, changeControlFactory, userProvider.get())), start);
}
#method_after
@Override
public ChangeQueryProcessor enforceVisibility(boolean enforce) {
    super.enforceVisibility(enforce);
    return this;
}
#end_block

#method_before
@Operator
public Predicate<AccountState> account(String query) throws QueryParseException, OrmException {
    Set<Account.Id> ids = parseAccount(query);
    List<Predicate<AccountState>> p = Lists.newArrayListWithCapacity(ids.size());
    for (Account.Id id : ids) {
        p.add(new AccountIdPredicate(id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<AccountState> account(String query) throws QueryParseException {
    if ("self".equals(query)) {
        return new AccountIdPredicate(self());
    }
    if (query.matches("^[1-9][0-9]*$")) {
        return new AccountIdPredicate(Account.Id.parse(query));
    }
    throw error("User " + query + " not found");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> limit(String limit) throws QueryParseException {
    return new LimitPredicate<>(FIELD_LIMIT, Integer.parseInt(limit));
}
#method_after
@Operator
public Predicate<AccountState> limit(String query) throws QueryParseException {
    Integer limit = Ints.tryParse(query);
    if (limit == null) {
        throw error("Invalid limit: " + query);
    }
    return new LimitPredicate<>(FIELD_LIMIT, limit);
}
#end_block

#method_before
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    try {
        return account(query);
    } catch (OrmException e) {
        throw new QueryParseException("Invalid account query");
    }
}
#method_after
@Override
protected Predicate<AccountState> defaultField(String query) throws QueryParseException {
    return account(query);
}
#end_block

#method_before
private List<QueryResult<T>> query(List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    long startNanos = System.nanoTime();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + "of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, page, limit, getRequestedFields());
        Predicate<T> pred = postRewrite(rewriter.rewrite(q, opts));
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#method_after
private List<QueryResult<T>> query(List<String> queryStrings, List<Predicate<T>> queries) throws OrmException, QueryParseException {
    long startNanos = System.nanoTime();
    int cnt = queries.size();
    // Parse and rewrite all queries.
    List<Integer> limits = new ArrayList<>(cnt);
    List<Predicate<T>> predicates = new ArrayList<>(cnt);
    List<DataSource<T>> sources = new ArrayList<>(cnt);
    for (Predicate<T> q : queries) {
        int limit = getEffectiveLimit(q);
        limits.add(limit);
        if (limit == getBackendSupportedLimit()) {
            limit--;
        }
        int page = (start / limit) + 1;
        if (page > indexConfig.maxPages()) {
            throw new QueryParseException("Cannot go beyond page " + indexConfig.maxPages() + "of results");
        }
        // Always bump limit by 1, even if this results in exceeding the permitted
        // max for this user. The only way to see if there are more entities is to
        // ask for one more result from the query.
        QueryOptions opts = createOptions(indexConfig, page, limit, getRequestedFields());
        Predicate<T> pred = postRewrite(rewriter.rewrite(q, opts));
        predicates.add(pred);
        @SuppressWarnings("unchecked")
        DataSource<T> s = (DataSource<T>) pred;
        sources.add(s);
    }
    // Run each query asynchronously, if supported.
    List<ResultSet<T>> matches = new ArrayList<>(cnt);
    for (DataSource<T> s : sources) {
        matches.add(s.read());
    }
    List<QueryResult<T>> out = new ArrayList<>(cnt);
    for (int i = 0; i < cnt; i++) {
        out.add(QueryResult.create(queryStrings != null ? queryStrings.get(i) : null, predicates.get(i), limits.get(i), matches.get(i).toList()));
    }
    // only measure successful queries
    metrics.executionTime.record(schemaDef.getName(), System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
    return out;
}
#end_block

#method_before
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).submit();
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#method_after
@Test
public void nonVotingReviewerStaysAfterSubmit() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID owners = SystemGroupBackend.getGroup(CHANGE_OWNER).getUUID();
    AccountGroup.UUID registered = SystemGroupBackend.getGroup(REGISTERED_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(verified.getName()), -1, 1, owners, heads);
    Util.allow(cfg, Permission.forLabel("Code-Review"), -2, +2, registered, heads);
    saveProjectConfig(project, cfg);
    // Set Code-Review+2 and Verified+1 as admin (change owner)
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String commit = r.getCommit().name();
    ReviewInput input = ReviewInput.approve();
    input.label(verified.getName(), 1);
    gApi.changes().id(changeId).revision(commit).review(input);
    // Reviewers should only be "admin"
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    // Add the user as reviewer
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(changeId).addReviewer(in);
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    // Approve the change as user, then remove the approval
    // (only to confirm that the user does have Code-Review+2 permission)
    setApiUser(user);
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.approve());
    gApi.changes().id(changeId).revision(commit).review(ReviewInput.noScore());
    // Submit the change
    setApiUser(admin);
    gApi.changes().id(changeId).revision(commit).submit();
    // User should still be on the change
    assertThat(getReviewers(changeId)).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
}
#end_block

#method_before
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Failed"), value(0, "No score"), value(-1, "Passes"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), verified);
    cfg.getLabelSections().put(custom2.getName(), verified);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#method_after
@Test
public void commitFooters() throws Exception {
    LabelType verified = category("Verified", value(1, "Passes"), value(0, "No score"), value(-1, "Failed"));
    LabelType custom1 = category("Custom1", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    LabelType custom2 = category("Custom2", value(1, "Positive"), value(0, "No score"), value(-1, "Negative"));
    ProjectConfig cfg = projectCache.checkedGet(project).getConfig();
    cfg.getLabelSections().put(verified.getName(), verified);
    cfg.getLabelSections().put(custom1.getName(), custom1);
    cfg.getLabelSections().put(custom2.getName(), custom2);
    String heads = "refs/heads/*";
    AccountGroup.UUID anon = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel("Verified"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom1"), -1, 1, anon, heads);
    Util.allow(cfg, Permission.forLabel("Custom2"), -1, 1, anon, heads);
    saveProjectConfig(project, cfg);
    PushOneCommit.Result r1 = createChange();
    r1.assertOkStatus();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new content", r1.getChangeId()).to("refs/for/master");
    r2.assertOkStatus();
    ReviewInput in = new ReviewInput();
    in.label("Code-Review", 1);
    in.label("Verified", 1);
    in.label("Custom1", -1);
    in.label("Custom2", 1);
    gApi.changes().id(r2.getChangeId()).current().review(in);
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.COMMIT_FOOTERS);
    ChangeInfo actual = gApi.changes().id(r2.getChangeId()).get(options);
    assertThat(actual.revisions).hasSize(2);
    // No footers except on latest patch set.
    assertThat(actual.revisions.get(r1.getCommit().getName()).commitWithFooters).isNull();
    List<String> footers = new ArrayList<>(Arrays.asList(actual.revisions.get(r2.getCommit().getName()).commitWithFooters.split("\\n")));
    // remove subject + blank line
    footers.remove(0);
    footers.remove(0);
    List<String> expectedFooters = Arrays.asList("Change-Id: " + r2.getChangeId(), "Reviewed-on: " + canonicalWebUrl.get() + r2.getChange().getId(), "Reviewed-by: Administrator <admin@example.com>", "Custom2: Administrator <admin@example.com>", "Tested-by: Administrator <admin@example.com>");
    assertThat(footers).containsExactlyElementsIn(expectedFooters);
}
#end_block

#method_before
public List<QueryResult> queryChanges(List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    return queryChanges(null, queries);
}
#method_after
public List<QueryResult> queryChanges(List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    try {
        return queryChanges(null, queries);
    } catch (OrmException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), QueryParseException.class);
        throw e;
    }
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<ChangeData> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    possibleLimits.add(getPermittedLimit());
    if (limitFromCaller > 0) {
        possibleLimits.add(limitFromCaller);
    }
    Integer limitFromPredicate = LimitPredicate.getLimit(ChangeQueryBuilder.FIELD_LIMIT, p);
    if (limitFromPredicate != null) {
        possibleLimits.add(limitFromPredicate);
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<ChangeData> p) {
    List<Integer> possibleLimits = new ArrayList<>(4);
    possibleLimits.add(getBackendSupportedLimit());
    possibleLimits.add(getPermittedLimit());
    if (limitFromCaller > 0) {
        possibleLimits.add(limitFromCaller);
    }
    Integer limitFromPredicate = LimitPredicate.getLimit(FIELD_LIMIT, p);
    if (limitFromPredicate != null) {
        possibleLimits.add(limitFromPredicate);
    }
    return Ordering.natural().min(possibleLimits);
}
#end_block

#method_before
@Override
public Predicate<AccountState> rewrite(Predicate<AccountState> in, QueryOptions opts) throws QueryParseException {
    AccountIndex index = indexes.getSearchIndex();
    return new IndexedAccountQuery(index, in, opts);
}
#method_after
@Override
public Predicate<AccountState> rewrite(Predicate<AccountState> in, QueryOptions opts) throws QueryParseException {
    AccountIndex index = indexes.getSearchIndex();
    checkNotNull(index, "no active search index configured for accounts");
    return new IndexedAccountQuery(index, in, opts);
}
#end_block

#method_before
public List<QueryResult> queryChanges(List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    return queryChanges(null, queries);
}
#method_after
public List<QueryResult> queryChanges(List<Predicate<ChangeData>> queries) throws OrmException, QueryParseException {
    try {
        return queryChanges(null, queries);
    } catch (OrmException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), QueryParseException.class);
        throw e;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    factory(AccountIndexer.Factory.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountIndexRewriter.class);
    bind(AccountIndexCollection.class);
    listener().to(AccountIndexCollection.class);
    bind(ChangeIndexRewriter.class);
    bind(ChangeIndexCollection.class);
    listener().to(ChangeIndexCollection.class);
    factory(ChangeIndexer.Factory.class);
}
#end_block

#method_before
private ResultSet<ChangeData> readImpl() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    List<ChangeData> r = new ArrayList<>();
    ChangeData last = null;
    int nextStart = 0;
    boolean skipped = false;
    for (ChangeData data : buffer(source, source.read())) {
        if (match(data)) {
            r.add(data);
        } else {
            skipped = true;
        }
        last = data;
        nextStart++;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        Paginated p = (Paginated) source;
        while (skipped && r.size() < p.getOptions().limit() + start) {
            skipped = false;
            ResultSet<ChangeData> next = p.restart(nextStart);
            for (ChangeData data : buffer(source, next)) {
                if (match(data)) {
                    r.add(data);
                } else {
                    skipped = true;
                }
                nextStart++;
            }
        }
    }
    if (start >= r.size()) {
        r = ImmutableList.of();
    } else if (start > 0) {
        r = ImmutableList.copyOf(r.subList(start, r.size()));
    }
    return new ListResultSet<>(r);
}
#method_after
private ResultSet<ChangeData> readImpl() throws OrmException {
    ChangeDataSource source = source();
    if (source == null) {
        throw new OrmException("No ChangeDataSource: " + this);
    }
    List<ChangeData> r = new ArrayList<>();
    ChangeData last = null;
    int nextStart = 0;
    boolean skipped = false;
    for (ChangeData data : buffer(source, source.read())) {
        if (match(data)) {
            r.add(data);
        } else {
            skipped = true;
        }
        last = data;
        nextStart++;
    }
    if (skipped && last != null && source instanceof Paginated) {
        // If our source is a paginated source and we skipped at
        // least one of its results, we may not have filled the full
        // limit the caller wants.  Restart the source and continue.
        // 
        @SuppressWarnings("unchecked")
        Paginated<ChangeData> p = (Paginated<ChangeData>) source;
        while (skipped && r.size() < p.getOptions().limit() + start) {
            skipped = false;
            ResultSet<ChangeData> next = p.restart(nextStart);
            for (ChangeData data : buffer(source, next)) {
                if (match(data)) {
                    r.add(data);
                } else {
                    skipped = true;
                }
                nextStart++;
            }
        }
    }
    if (start >= r.size()) {
        r = ImmutableList.of();
    } else if (start > 0) {
        r = ImmutableList.copyOf(r.subList(start, r.size()));
    }
    return new ListResultSet<>(r);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    globalConfig = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    disableChangeCache();
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    sysInjector.injectMembers(this);
    try {
        boolean ok = true;
        for (IndexDefinition<?, ?, ?> def : indexDefs) {
            if (listIndices) {
                System.out.format("%s\n", def.getName());
            } else {
                ok &= reindex(def);
            }
        }
        return ok ? 0 : 1;
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    } finally {
        sysManager.stop();
        dbManager.stop();
    }
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    globalConfig = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    disableChangeCache();
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    sysInjector.injectMembers(this);
    try {
        boolean ok = list ? list() : reindex();
        return ok ? 0 : 1;
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    } finally {
        sysManager.stop();
        dbManager.stop();
    }
}
#end_block

#method_before
private <K, V, I extends Index<K, V>> boolean reindex(IndexDefinition<K, V, I> def) throws IOException {
    I index = def.getIndexCollection().getSearchIndex();
    checkNotNull(index, "no active search index configured for %s", def.getName());
    index.markReady(false);
    index.deleteAll();
    SiteIndexer<K, V, I> siteIndexer = def.getSiteIndexer();
    siteIndexer.setProgressOut(System.err);
    siteIndexer.setVerboseOut(verbose ? System.out : NullOutputStream.INSTANCE);
    SiteIndexer.Result result = siteIndexer.indexAll(index);
    int n = result.doneCount() + result.failedCount();
    double t = result.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d documents in %s index in %.01fs (%.01f/s)\n", n, def.getName(), t, n / t);
    if (result.success()) {
        index.markReady(true);
    }
    return result.success();
}
#method_after
private boolean reindex() throws IOException {
    boolean ok = true;
    for (IndexDefinition<?, ?, ?> def : indexDefs) {
        ok &= reindex(def);
    }
    return ok;
}
#end_block

#method_before
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = Lists.newArrayList();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    // Scan changes from git instead of relying on the secondary index, as we
    // will have just deleted the old (possibly corrupt) index.
    modules.add(ScanningChangeCacheImpl.module());
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    Map<String, Integer> versions = new HashMap<>();
    if (changesVersion != null) {
        versions.put(ChangeSchemaDefinitions.INSTANCE.getName(), changesVersion);
    }
    List<Module> modules = new ArrayList<>();
    Module indexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            indexModule = LuceneIndexModule.singleVersionWithExplicitVersions(versions, threads);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(indexModule);
    modules.add(dbInjector.getInstance(BatchProgramModule.class));
    modules.add(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ChangeResource.Factory.class);
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private static Directory dir(Schema<AccountState> schema, Config cfg, SitePaths sitePaths, String base) throws IOException {
    if (LuceneIndexModule.isInMemoryTest(cfg)) {
        Path indexDir = base != null ? Paths.get(base) : LuceneVersionManager.getDir(sitePaths, ACCOUNTS + "_", schema);
        return FSDirectory.open(indexDir);
    } else {
        return new RAMDirectory();
    }
}
#method_after
private static Directory dir(Schema<AccountState> schema, Config cfg, SitePaths sitePaths) throws IOException {
    if (LuceneIndexModule.isInMemoryTest(cfg)) {
        return new RAMDirectory();
    }
    Path indexDir = LuceneVersionManager.getDir(sitePaths, ACCOUNTS + "_", schema);
    return FSDirectory.open(indexDir);
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.notes.getChangeId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.notes.getChange(), u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).notes = notes;
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = notes.getChange().currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(notes);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (notes.getChange().getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = notes.getChange().currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), notes.getChangeId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, notes.getChange().currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, change.getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(change.getId(), replaceOp);
    if (progress != null) {
        bu.addOp(change.getId(), new ChangeProgressOp(progress));
    }
}
#method_after
void addOps(BatchUpdate bu, @Nullable Task progress) throws IOException {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        // TODO(dborowitz): When does this happen? Only when an edit ref is
        // involved?
        cmd.execute(rp);
    }
    if (magicBranch != null && magicBranch.edit) {
        return;
    }
    RevWalk rw = rp.getRevWalk();
    // TODO(dborowitz): Move to ReplaceOp#updateRepo.
    RevCommit newCommit = rw.parseCommit(newCommitId);
    rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, notes.getChange().getDest(), checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    bu.addOp(notes.getChangeId(), replaceOp);
    if (progress != null) {
        bu.addOp(notes.getChangeId(), new ChangeProgressOp(progress));
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.change.getId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, ChangeNotes> byKey = null;
        List<ReplaceRequest> replaceAndClose = new ArrayList<>();
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    // Hold onto this until we're done with the walk, as the call to
                    // req.validate below calls isMergedInto which resets the walk.
                    ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                    req.notes = onto;
                    replaceAndClose.add(req);
                    continue COMMIT;
                }
            }
        }
        for (final ReplaceRequest req : replaceAndClose) {
            Change.Id id = req.notes.getChangeId();
            if (!req.validate(true)) {
                continue;
            }
            req.addOps(bu, null);
            bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                @Override
                public PatchSet get() {
                    return req.replaceOp.getPatchSet();
                }
            }));
            bu.addOp(id, new ChangeProgressOp(closeProgress));
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, ChangeNotes> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, ChangeNotes> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.notes());
    }
    return r;
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    final List<String> idList = receiveEvent.commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = receiveEvent.commit.getShortMessage();
            String changeIdPrefix = FooterConstants.CHANGE_ID.getName() + ":";
            if (shortMsg.startsWith(changeIdPrefix) && shortMsg.substring(changeIdPrefix.length()).trim().matches("^I[0-9a-f]{8,}.*$")) {
                throw new CommitValidationException("missing subject; Change-Id must be in commit message footer");
            } else {
                String errMsg = "missing Change-Id in commit message footer";
                messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
                throw new CommitValidationException(errMsg, messages);
            }
        }
    } else if (idList.size() > 1) {
        throw new CommitValidationException("multiple Change-Id lines in commit message footer", messages);
    } else {
        final String v = idList.get(idList.size() - 1).trim();
        if (!v.matches("^I[0-9a-f]{8,}.*$")) {
            final String errMsg = "missing or invalid Change-Id line format in commit message footer";
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    } else {
        String v = idList.get(idList.size() - 1).trim();
        if (!CHANGE_ID.matcher(v).matches()) {
            String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
            throw new CommitValidationException(errMsg, messages);
        }
    }
    return Collections.emptyList();
}
#end_block

#method_before
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    final String changeId = "Change-Id:";
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(changeId) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(changeId) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert Change-Id, install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#method_after
private CommitValidationMessage getMissingChangeIdErrorMsg(final String errMsg, final RevCommit c) {
    StringBuilder sb = new StringBuilder();
    sb.append("ERROR: ").append(errMsg);
    if (c.getFullMessage().indexOf(CHANGE_ID_PREFIX) >= 0) {
        String[] lines = c.getFullMessage().trim().split("\n");
        String lastLine = lines.length > 0 ? lines[lines.length - 1] : "";
        if (lastLine.indexOf(CHANGE_ID_PREFIX) == -1) {
            sb.append('\n');
            sb.append('\n');
            sb.append("Hint: A potential ");
            sb.append(FooterConstants.CHANGE_ID.getName());
            sb.append("Change-Id was found, but it was not in the ");
            sb.append("footer (last paragraph) of the commit message.");
        }
    }
    sb.append('\n');
    sb.append('\n');
    sb.append("Hint: To automatically insert ");
    sb.append(FooterConstants.CHANGE_ID.getName());
    sb.append(", install the hook:\n");
    sb.append(getCommitMessageHookInstallationHint());
    sb.append('\n');
    sb.append("And then amend the commit:\n");
    sb.append("  git commit --amend\n");
    return new CommitValidationMessage(sb.toString(), false);
}
#end_block

#method_before
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#method_after
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    }
    return "http://" + getGerritHost(canonicalWebUrl);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return;
    }
    if (!ctx.getChangeControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = ctx.getChangeUpdate();
    ChangeNotes notes = update.getChangeNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updated.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
    }
    change = update.getChange();
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws AuthException, BadRequestException, OrmException, IOException {
    if (!notesMigration.readChanges()) {
        throw new BadRequestException("Cannot add hashtags; NoteDb is disabled");
    }
    if (input == null || (input.add == null && input.remove == null)) {
        updatedHashtags = ImmutableSortedSet.of();
        return false;
    }
    if (!ctx.getControl().canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    ChangeNotes notes = update.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updated = new HashSet<>();
    toAdd = new HashSet<>(extractTags(input.add));
    toRemove = new HashSet<>(extractTags(input.remove));
    try {
        for (HashtagValidationListener validator : validationListeners) {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    updated.addAll(existingHashtags);
    toAdd.removeAll(existingHashtags);
    toRemove.retainAll(existingHashtags);
    if (updated()) {
        updated.addAll(toAdd);
        updated.removeAll(toRemove);
        update.setHashtags(updated);
        addMessage(ctx, update);
    }
    updatedHashtags = ImmutableSortedSet.copyOf(updated);
    return true;
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectControl ctl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(CurrentUser user, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    gitRefUpdated.fire(config.getProject().getNameKey(), RefNames.REFS_CONFIG, base, commit.getId(), user.asIdentifiedUser().getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
public Response<?> apply(ProjectResource project, Input input) throws OrmException, IOException, ResourceConflictException {
    input = Input.init(input);
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ProjectResource project, DeleteBranchesInput input) throws OrmException, IOException, ResourceConflictException {
    if (input == null) {
        input = new DeleteBranchesInput();
    }
    if (input.branches == null) {
        input.branches = Lists.newArrayListWithCapacity(1);
    }
    try (Repository r = repoManager.openRepository(project.getNameKey())) {
        BatchRefUpdate batchUpdate = r.getRefDatabase().newBatchUpdate();
        for (String branch : input.branches) {
            batchUpdate.addCommand(createDeleteCommand(project, r, branch));
        }
        try (RevWalk rw = new RevWalk(r)) {
            batchUpdate.execute(rw, NullProgressMonitor.INSTANCE);
        }
        StringBuilder errorMessages = new StringBuilder();
        for (ReceiveCommand command : batchUpdate.getCommands()) {
            if (command.getResult() == Result.OK) {
                postDeletion(project, command);
            } else {
                appendAndLogErrorMessage(errorMessages, command);
            }
        }
        if (errorMessages.length() > 0) {
            throw new ResourceConflictException(errorMessages.toString());
        }
    }
    return Response.none();
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        ObjectId revid = RefUtil.parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        RevWalk rw = RefUtil.verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = RefUtil.getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = RefUtil.getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (RefUtil.InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst));
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.resetRetain(subOr.canMergeFlag);
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public Response<String> apply(ProjectResource resource, PutDescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new PutDescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(resource.getNameKey(), RefNames.REFS_CONFIG, baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Response<String> apply(ProjectResource resource, DescriptionInput input) throws AuthException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new DescriptionInput();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = ctl.getUser().asIdentifiedUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try (MetaDataUpdate md = updateFactory.create(resource.getNameKey())) {
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription(Strings.emptyToNull(input.description));
        String msg = MoreObjects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        md.setAuthor(user);
        md.setMessage(msg);
        config.commit(md);
        cache.evict(ctl.getProject());
        gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
        return Strings.isNullOrEmpty(project.getDescription()) ? Response.<String>none() : Response.ok(project.getDescription());
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            } else {
                itr.remove();
                continue;
            }
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            } else {
                itr.remove();
                continue;
            }
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#method_after
private void checkLabels(RevisionResource revision, boolean strict, Map<String, Short> labels) throws BadRequestException, AuthException {
    ChangeControl ctl = revision.getControl();
    Iterator<Map.Entry<String, Short>> itr = labels.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Short> ent = itr.next();
        LabelType lt = revision.getControl().getLabelTypes().byLabel(ent.getKey());
        if (lt == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\" is not a configured label", ent.getKey()));
            }
            itr.remove();
            continue;
        }
        if (ent.getValue() == null || ent.getValue() == 0) {
            // Later null/0 will be deleted and revoke the label.
            continue;
        }
        if (lt.getValue(ent.getValue()) == null) {
            if (strict) {
                throw new BadRequestException(String.format("label \"%s\": %d is not a valid value", ent.getKey(), ent.getValue()));
            }
            itr.remove();
            continue;
        }
        String name = lt.getName();
        PermissionRange range = ctl.getRange(Permission.forLabel(name));
        if (range == null || !range.contains(ent.getValue())) {
            if (strict) {
                throw new AuthException(String.format("Applying label \"%s\": %d is restricted", ent.getKey(), ent.getValue()));
            } else if (range == null || range.isEmpty()) {
                ent.setValue((short) 0);
            } else {
                ent.setValue((short) range.squash(ent.getValue()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change.getLastUpdatedOn().before(ctx.getWhen())) {
        change.setLastUpdatedOn(ctx.getWhen());
    }
    ps = ctx.getDb().patchSets().get(psId);
    ctx.getChangeUpdate().setPatchSetId(psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    if (dirty) {
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, change, ps, user.getAccountId(), message, comments).sendAsync();
    }
    commentAdded.fire(change, ps, user.getAccount(), message.getMessage(), categories, ctx.getWhen());
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (message == null) {
        return;
    }
    if (in.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(in.notify, notes, ps, user, message, comments).sendAsync();
    }
    commentAdded.fire(notes.getChange(), ps, user.getAccount(), message.getMessage(), approvals, oldApprovals, ctx.getWhen());
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(ctx.getWhen());
                setCommentRevId(e, patchListCache, ctx.getChange(), ps);
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(ctx.getDb(), ctx.getChangeUpdate(), del);
    plcUtil.upsertComments(ctx.getDb(), ctx.getChangeUpdate(), ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<PatchLineComment> del = new ArrayList<>();
    List<PatchLineComment> ups = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.<CommentSetEntry>emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, path), null), c.line != null ? c.line : 0, user.getAccountId(), parent, ctx.getWhen());
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(ctx.getWhen());
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setMessage(c.message);
            e.setTag(in.tag);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            if (e.getKey().get() == null) {
                e.getKey().set(ChangeUtil.messageUUID(ctx.getDb()));
            }
            ups.add(e);
        }
    }
    switch(firstNonNull(in.drafts, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                ups.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, ups);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    plcUtil.deleteComments(ctx.getDb(), u, del);
    plcUtil.putComments(ctx.getDb(), u, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getChangeNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#method_after
private Set<CommentSetEntry> readExistingComments(ChangeContext ctx) throws OrmException {
    Set<CommentSetEntry> r = new HashSet<>();
    for (PatchLineComment c : plcUtil.publishedByChange(ctx.getDb(), ctx.getNotes())) {
        r.add(CommentSetEntry.create(c));
    }
    return r;
}
#end_block

#method_before
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getChangeNotes(), user.getAccountId())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> changeDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByChangeAuthor(ctx.getDb(), ctx.getNotes(), user.getAccountId())) {
        c.setTag(in.tag);
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = Maps.newHashMap();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getChangeNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#method_after
private Map<String, PatchLineComment> patchSetDrafts(ChangeContext ctx) throws OrmException {
    Map<String, PatchLineComment> drafts = new HashMap<>();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(ctx.getDb(), psId, user.getAccountId(), ctx.getNotes())) {
        drafts.put(c.getKey().get(), c);
    }
    return drafts;
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> labels = in.labels;
    if (labels == null) {
        labels = Collections.emptyMap();
    }
    List<PatchSetApproval> del = Lists.newArrayList();
    List<PatchSetApproval> ups = Lists.newArrayList();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    ChangeUpdate update = ctx.getChangeUpdate();
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    for (Map.Entry<String, Short> ent : labels.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                }
                del.add(c);
                update.putApproval(ent.getKey(), (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putApproval(ent.getKey(), ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            categories.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), ReviewerState.REVIEWER);
            update.putApproval(ent.getKey(), ent.getValue());
        }
    }
    if (!del.isEmpty() || !ups.isEmpty()) {
        if (ctx.getChange().getStatus().isClosed()) {
            throw new ResourceConflictException("change is closed");
        }
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), lt.getLabelId()), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    if ((!del.isEmpty() || !ups.isEmpty()) && ctx.getChange().getStatus().isClosed()) {
        throw new ResourceConflictException("change is closed");
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getChangeControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, TimeUtil.nowTs());
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
}
#method_after
private void forceCallerAsReviewer(ChangeContext ctx, Map<String, PatchSetApproval> current, List<PatchSetApproval> ups, List<PatchSetApproval> del) {
    if (current.isEmpty() && ups.isEmpty()) {
        // TODO Find another way to link reviewers to changes.
        if (del.isEmpty()) {
            // If no existing label is being set to 0, hack in the caller
            // as a reviewer by picking the first server-wide LabelType.
            PatchSetApproval c = new PatchSetApproval(new PatchSetApproval.Key(psId, user.getAccountId(), ctx.getControl().getLabelTypes().getLabelTypes().get(0).getLabelId()), (short) 0, ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
        } else {
            // Pick a random label that is about to be deleted and keep it.
            Iterator<PatchSetApproval> i = del.iterator();
            PatchSetApproval c = i.next();
            c.setValue((short) 0);
            c.setGranted(ctx.getWhen());
            i.remove();
            ups.add(c);
        }
    }
    ctx.getUpdate(ctx.getChange().currentPatchSetId()).putReviewer(user.getAccountId(), REVIEWER);
}
#end_block

#method_before
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Map<String, PatchSetApproval> current = Maps.newHashMap();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getChangeControl(), psId, user.getAccountId())) {
        if (a.isSubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#method_after
private Map<String, PatchSetApproval> scanLabels(ChangeContext ctx, List<PatchSetApproval> del) throws OrmException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, PatchSetApproval> current = new HashMap<>();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctx.getControl(), psId, user.getAccountId())) {
        if (a.isLegacySubmit()) {
            continue;
        }
        LabelType lt = labelTypes.byLabel(a.getLabelId());
        if (lt != null) {
            current.put(lt.getName(), a);
        } else {
            del.add(a);
        }
    }
    return current;
}
#end_block

#method_before
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
    return true;
}
#method_after
private boolean insertMessage(ChangeContext ctx) throws OrmException {
    String msg = Strings.nullToEmpty(in.message).trim();
    StringBuilder buf = new StringBuilder();
    for (String d : labelDelta) {
        buf.append(" ").append(d);
    }
    if (comments.size() == 1) {
        buf.append("\n\n(1 comment)");
    } else if (comments.size() > 1) {
        buf.append(String.format("\n\n(%d comments)", comments.size()));
    }
    if (!msg.isEmpty()) {
        buf.append("\n\n").append(msg);
    }
    if (buf.length() == 0) {
        return false;
    }
    message = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), psId);
    message.setTag(in.tag);
    message.setMessage(String.format("Patch Set %d:%s", psId.get(), buf.toString()));
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), message);
    return true;
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            checkState(NEW_PATCHSET.matcher(replace.inputCommand.getRefName()).matches(), "expected a new patch set command as input when creating %s;" + " got %s", replace.cmd.getRefName(), replace.inputCommand.getRefName());
            try {
                replace.insertPatchSetWithoutBatchUpdate();
                replace.inputCommand.setResult(OK);
            } catch (IOException | UpdateException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                replace.addOps(bu, replaceProgress);
            }
        }
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.addOps(bu);
        }
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        magicBranch.cmd.setResult(OK);
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage != null) {
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException | IOException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addMessage(e.getMessage());
            reject(magicBranch.cmd, "conflict");
        } catch (RestApiException | OrmException e) {
            log.error("Error submit changes to " + project.getName(), e);
            reject(magicBranch.cmd, "error during submit");
        }
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntryType.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntryType.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        checkNotNull(r.change, "cannot submit new change %s; op may not have run", r.changeId);
        bySha.put(r.commitId, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.change);
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    checkState(tipChange != null, "tip of push does not correspond to a change; found these changes: %s", bySha);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    String refName = cmd.getRefName();
    checkState(!MagicBranch.isMagicBranch(refName), "shouldn't be auto-closing changes on magic branch %s", refName);
    RevWalk rw = rp.getRevWalk();
    // insertChangesAndPatchSets.
    try (BatchUpdate bu = batchUpdateFactory.create(db, projectControl.getProject().getNameKey(), user, TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter()) {
        bu.setRepository(repo, rp.getRevWalk(), ins).updateChangesInParallel();
        // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                continue COMMIT;
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    Change.Id id = onto.getId();
                    final ReplaceRequest req = new ReplaceRequest(id, c, cmd, false);
                    req.change = onto;
                    if (req.validate(true)) {
                        req.addOps(bu, null);
                        bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(new Provider<PatchSet>() {

                            @Override
                            public PatchSet get() {
                                return req.replaceOp.getPatchSet();
                            }
                        }));
                        bu.addOp(id, new ChangeProgressOp(closeProgress));
                    }
                    break;
                }
            }
        }
        bu.execute();
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(ctl, input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    Op op = new Op(input != null ? input : new Input());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newTopicName) ? Response.<String>none() : Response.ok(op.newTopicName);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    ChangeUtil.updated(change);
    ctx.getDb().changes().update(Collections.singleton(change));
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), caller.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), cmsg);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    newTopicName = Strings.nullToEmpty(input.topic);
    oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (oldTopicName.equals(newTopicName)) {
        return false;
    }
    String summary;
    if (oldTopicName.isEmpty()) {
        summary = "Topic set to " + newTopicName;
    } else if (newTopicName.isEmpty()) {
        summary = "Topic " + oldTopicName + " removed";
    } else {
        summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
    }
    change.setTopic(Strings.emptyToNull(newTopicName));
    update.setTopic(change.getTopic());
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    cmsg.setMessage(summary);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, caller.getAccount(), oldTopicName);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (change != null) {
        topicEdited.fire(change, ctx.getUser().asIdentifiedUser().getAccount(), oldTopicName);
    }
}
#end_block

#method_before
public ConfigInfo apply(ProjectControl ctrl, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = ctrl.getProject().getNameKey();
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.get().create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (serverEnableSignedPush) {
            if (input.enableSignedPush != null) {
                p.setEnableSignedPush(input.enableSignedPush);
            }
            if (input.requireSignedPush != null) {
                p.setRequireSignedPush(input.requireSignedPush);
            }
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(ctrl.getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equals(baseRev, commitRev)) {
                gitRefUpdated.fire(projectName, RefNames.REFS_CONFIG, baseRev, commitRev, user.get().asIdentifiedUser().getAccount());
            }
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                log.warn(String.format("Failed to update config of project %s.", projectName), e);
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(serverEnableSignedPush, state.controlFor(user.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, ConfigInput input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
    return apply(rsrc.getControl(), input);
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntryType.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        v.setValue(projectConfigEntry.preUpdate(v.getValue()));
                        value = v.getValue().value;
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                // $FALL-THROUGH$
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, v.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeMergedListener.class).to(ChangeHookApiListener.class);
    bind(ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    bind(CommentAddedListener.class).to(ChangeHookApiListener.class);
    bind(DraftPublishedListener.class).to(ChangeHookApiListener.class);
    bind(GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    bind(HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    bind(MergeFailedListener.class).to(ChangeHookApiListener.class);
    bind(NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    bind(ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    bind(RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    bind(TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), AgreementSignupListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeAbandonedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeMergedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ChangeRestoredListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommentAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), DraftPublishedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), HashtagsEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), ReviewerAddedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), RevisionCreatedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), TopicEditedListener.class).to(ChangeHookApiListener.class);
    DynamicSet.bind(binder(), CommitValidationListener.class).to(ChangeHookValidator.class);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = receiveEvent.commit.getParent(0);
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
          * If the ref-update hook tries to distinguish behavior between pushes to
          * refs/heads/... and refs/for/..., make sure we send it the correct refname.
          * Also, if this is targetting refs/for/, make sure we behave the same as
          * what a push to refs/for/ would behave; in particular, setting oldrev to
          * 0000000000000000000000000000000000000000.
          */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    IdentifiedUser user = receiveEvent.user;
    String refname = receiveEvent.refName;
    ObjectId old = ObjectId.zeroId();
    if (receiveEvent.commit.getParentCount() > 0) {
        old = receiveEvent.commit.getParent(0);
    }
    if (receiveEvent.command.getRefName().startsWith(REFS_CHANGES)) {
        /*
        * If the ref-update hook tries to distinguish behavior between pushes to
        * refs/heads/... and refs/for/..., make sure we send it the correct
        * refname.
        * Also, if this is targetting refs/for/, make sure we behave the same as
        * what a push to refs/for/ would behave; in particular, setting oldrev
        * to 0000000000000000000000000000000000000000.
        */
        refname = refname.replace(R_HEADS, "refs/for/refs/heads/");
        old = ObjectId.zeroId();
    }
    HookResult result = hooks.doRefUpdateHook(receiveEvent.project, refname, user.getAccount(), old, receiveEvent.commit);
    if (result != null && result.getExitValue() != 0) {
        throw new CommitValidationException(result.toString().trim());
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        hooks.doPatchsetCreatedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onRevisionCreated(RevisionCreatedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doPatchsetCreatedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("PatchsetCreated hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        hooks.doDraftPublishedHook(getChange(ev.getChange()), getPatchSet(ev.getRevision()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onDraftPublished(DraftPublishedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doDraftPublishedHook(notes.getChange(), getPatchSet(notes, ev.getRevision()), db.get());
    } catch (OrmException e) {
        log.error("DraftPublished hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = new HashMap<String, Short>();
    for (Entry<String, ApprovalInfo> e : ev.getApprovals().entrySet()) {
        approvals.put(e.getKey(), e.getValue().value.shortValue());
    }
    try {
        hooks.doCommentAddedHook(getChange(ev.getChange()), getAccount(ev.getAuthor()), getPatchSet(ev.getRevision()), ev.getComment(), approvals, db.get());
    } catch (OrmException e) {
        log.warn("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onCommentAdded(CommentAddedListener.Event ev) {
    Map<String, Short> approvals = convertApprovalsMap(ev.getApprovals());
    Map<String, Short> oldApprovals = convertApprovalsMap(ev.getOldApprovals());
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doCommentAddedHook(notes.getChange(), getAccount(ev.getAuthor()), getPatchSet(notes, ev.getRevision()), ev.getComment(), approvals, oldApprovals, db.get());
    } catch (OrmException e) {
        log.error("CommentAdded hook failed to fun" + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        hooks.doChangeMergedHook(getChange(ev.getChange()), getAccount(ev.getMerger()), getPatchSet(ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#method_after
@Override
public void onChangeMerged(ChangeMergedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeMergedHook(notes.getChange(), getAccount(ev.getMerger()), getPatchSet(notes, ev.getRevision()), db.get(), ev.getNewRevisionId());
    } catch (OrmException e) {
        log.error("ChangeMerged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        hooks.doChangeAbandonedHook(getChange(ev.getChange()), getAccount(ev.getAbandoner()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeAbandoned(ChangeAbandonedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeAbandonedHook(notes.getChange(), getAccount(ev.getAbandoner()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeAbandoned hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        hooks.doChangeRestoredHook(getChange(ev.getChange()), getAccount(ev.getRestorer()), getPatchSet(ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onChangeRestored(ChangeRestoredListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doChangeRestoredHook(notes.getChange(), getAccount(ev.getRestorer()), getPatchSet(notes, ev.getRevision()), ev.getReason(), db.get());
    } catch (OrmException e) {
        log.error("ChangeRestored hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        Change change = getChange(ev.getChange());
        PatchSet patch = db.get().patchSets().get(change.currentPatchSetId());
        hooks.doReviewerAddedHook(change, getAccount(ev.getReviewer()), patch, db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onReviewerAdded(ReviewerAddedListener.Event ev) {
    try {
        ChangeNotes notes = getNotes(ev.getChange());
        hooks.doReviewerAddedHook(notes.getChange(), getAccount(ev.getReviewer()), psUtil.current(db.get(), notes), db.get());
    } catch (OrmException e) {
        log.error("ReviewerAdded hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onTopicEdited(TopicEditedListener.Event ev) {
    try {
        hooks.doTopicChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), ev.getOldTopic(), db.get());
    } catch (OrmException e) {
        log.error("TopicChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getChange(ev.getChange()), getAccount(ev.getEditor()), new HashSet<String>(ev.getAddedHashtags()), new HashSet<String>(ev.getRemovedHashtags()), new HashSet<String>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
    }
}
#method_after
@Override
public void onHashtagsEdited(HashtagsEditedListener.Event ev) {
    try {
        hooks.doHashtagsChangedHook(getNotes(ev.getChange()).getChange(), getAccount(ev.getEditor()), new HashSet<>(ev.getAddedHashtags()), new HashSet<>(ev.getRemovedHashtags()), new HashSet<>(ev.getHashtags()), db.get());
    } catch (OrmException e) {
        log.error("HashtagsChanged hook failed to run " + ev.getChange()._number, e);
    }
}
#end_block

#method_before
private PatchSet getPatchSet(RevisionInfo info) throws OrmException {
    return db.get().patchSets().get(PatchSet.Id.fromRef(info.ref));
}
#method_after
private PatchSet getPatchSet(ChangeNotes notes, RevisionInfo info) throws OrmException {
    return psUtil.get(db.get(), notes, PatchSet.Id.fromRef(info.ref));
}
#end_block

#method_before
public PatchSetInserter setGroups(Iterable<String> groups) {
    this.groups = groups;
    return this;
}
#method_after
public PatchSetInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be null");
    this.groups = groups;
    return this;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    init();
    validate(ctx);
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, getPatchSetId().toRefName(), ReceiveCommand.Type.CREATE));
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException {
    ChangeControl ctl = ctx.getChangeControl();
    change = ctx.getChange();
    Change.Id id = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getChange().getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    // TODO(dborowitz): Throw ResourceConflictException instead of using
    // AtomicUpdate.
    change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isClosed() && !allowClosed) {
                return null;
            }
            if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                return null;
            }
            if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                change.setStatus(Change.Status.NEW);
            }
            change.setCurrentPatchSet(patchSetInfo);
            ChangeUtil.updated(change);
            return change;
        }
    });
    if (change == null) {
        throw new ChangeModifiedException(String.format("Change %s was modified", id));
    }
    approvalCopier.copy(db, ctl, patchSet);
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new ResourceConflictException(String.format("Cannot create new patch set of change %s because it is %s", change.getId(), change.getStatus().name().toLowerCase()));
    }
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        if (prevPs != null) {
            newGroups = prevPs.getGroups();
        }
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
            cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getUser().getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage);
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new patch set on change " + change.getId(), err);
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(refControl, sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws ResourceConflictException, IOException {
    CommitValidators cv = commitValidatorsFactory.create(origCtl.getRefControl(), sshInfo, ctx.getRepository());
    String refName = getPatchSetId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName.substring(0, refName.lastIndexOf('/') + 1) + "new"), origCtl.getProjectControl().getProject(), origCtl.getRefControl().getRefName(), commit, ctx.getUser().asIdentifiedUser());
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    }
}
#end_block

#method_before
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            // ToDo claSigned.fireClaSigned() instead of
            // hooks.doClaSignupHook(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
@Override
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        @Override
        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            agreementSignup.fire(account, ca.getName());
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException {
    Account member = rsrc.getUser().getAccount();
    ChangeControl control = rsrc.getControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc, result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = new HashMap<>();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    List<PatchSetApproval> added;
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        added = approvalsUtil.addReviewers(db, rsrc.getNotes(), update, rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(rsrc.getChange().getId());
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    indexFuture.checkedGet();
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            reviewerAdded.fire(rsrc.getChange(), patchSet, account);
        }
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    try {
        return new UiAction.Description().setLabel("Publish").setTitle(String.format("Publish revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    if (!ctx.getChangeControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!ctx.getControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    if (patchSet == null) {
        patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
        if (patchSet == null) {
            throw new ResourceNotFoundException(psId.toString());
        }
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
    return true;
}
#end_block

#method_before
private void saveChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
}
#method_after
private void saveChange(ChangeContext ctx) {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    wasDraftChange = change.getStatus() == Change.Status.DRAFT;
    if (wasDraftChange) {
        change.setStatus(Change.Status.NEW);
        update.setStatus(change.getStatus());
    }
}
#end_block

#method_before
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    patchSet = ctx.getDb().patchSets().get(psId);
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    patchSet.setDraft(false);
    // Force ETag invalidation if not done already
    if (!wasDraftChange) {
        ChangeUtil.updated(change);
        ctx.getDb().changes().update(Collections.singleton(change));
    }
    ctx.getDb().patchSets().update(Collections.singleton(patchSet));
}
#method_after
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    psUtil.publish(ctx.getDb(), ctx.getUpdate(psId), patchSet);
}
#end_block

#method_before
private void addReviewers(ChangeContext ctx) throws OrmException {
    LabelTypes labelTypes = ctx.getChangeControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getChangeNotes()).values();
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet, footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getChangeUpdate(), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#method_after
private void addReviewers(ChangeContext ctx) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).all();
    RevCommit commit = ctx.getRevWalk().parseCommit(ObjectId.fromString(patchSet.getRevision().get()));
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet.isDraft(), footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getUpdate(psId), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#end_block

#method_before
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendCreateChange(Context ctx) throws EmailException {
    CreateChangeSender cm = createChangeSenderFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(ctx.getUser().getAccountId());
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#method_after
private void sendReplacePatchSet(Context ctx) throws EmailException, OrmException {
    Account.Id accountId = ctx.getUser().getAccountId();
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), accountId, ctx.getWhen(), psId);
    msg.setMessage("Uploaded patch set " + psId.get() + ".");
    ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
    cm.setFrom(accountId);
    cm.setPatchSet(patchSet, patchSetInfo);
    cm.setChangeMessage(msg);
    cm.addReviewers(recipients.getReviewers());
    cm.addExtraCC(recipients.getCcOnly());
    cm.send();
}
#end_block

#method_before
@Override
public Change getChange() {
    return change;
}
#method_after
public Change getChange() {
    checkState(change != null, "getChange() only valid after creating change");
    return change;
}
#end_block

#method_before
public ChangeInserter setDraft(boolean draft) {
    change.setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
    patchSet.setDraft(draft);
    return this;
}
#method_after
public ChangeInserter setDraft(boolean draft) {
    checkState(change == null, "setDraft(boolean) only valid before creating change");
    return setStatus(draft ? Change.Status.DRAFT : Change.Status.NEW);
}
#end_block

#method_before
public ChangeInserter setGroups(Iterable<String> groups) {
    patchSet.setGroups(groups);
    return this;
}
#method_after
public ChangeInserter setGroups(List<String> groups) {
    checkNotNull(groups, "groups may not be empty");
    checkState(patchSet == null, "setGroups(Iterable<String>) only valid before creating change");
    this.groups = groups;
    return this;
}
#end_block

#method_before
public PatchSet getPatchSet() {
    return patchSet;
}
#method_after
public PatchSet getPatchSet() {
    checkState(patchSet != null, "getPatchSet() only valid after creating change");
    return patchSet;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws InvalidChangeOperationException, IOException {
    validate(ctx);
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    change.setCurrentPatchSet(patchSetInfo);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSet.getRefName()));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    if (updateRefCommand == null) {
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
    } else {
        ctx.addRefUpdate(updateRefCommand);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setChangeId(change.getKey().get());
    update.setSubjectForCommit("Create change");
    update.setBranch(change.getDest().get());
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    List<String> newGroups = groups;
    if (newGroups.isEmpty()) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, psId, commit, draft, newGroups, null);
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        ReviewDb db = ctx.getDb();
        if (approvals != null && !approvals.isEmpty()) {
            commentAdded.fire(change, patchSet, user.getAccount(), null, approvals, ctx.getWhen());
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException, NoSuchChangeException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getProject(), change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.setNotify(notify);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    /* For labels that are not set in this operation, show the "current" value
     * of 0, and no oldValue as the value was not modified by this operation.
     * For labels that are set in this operation, the value was modified, so
     * show a transition from an oldValue of 0 to the new value.
     */
    if (runHooks) {
        revisionCreated.fire(change, patchSet, ctx.getUser().getAccountId());
        if (approvals != null && !approvals.isEmpty()) {
            ChangeControl changeControl = changeControlFactory.controlFor(ctx.getDb(), change, ctx.getUser());
            List<LabelType> labels = changeControl.getLabelTypes().getLabelTypes();
            Map<String, Short> allApprovals = new HashMap<>();
            Map<String, Short> oldApprovals = new HashMap<>();
            for (LabelType lt : labels) {
                allApprovals.put(lt.getName(), (short) 0);
                oldApprovals.put(lt.getName(), null);
            }
            for (Map.Entry<String, Short> entry : approvals.entrySet()) {
                if (entry.getValue() != 0) {
                    allApprovals.put(entry.getKey(), entry.getValue());
                    oldApprovals.put(entry.getKey(), (short) 0);
                }
            }
            commentAdded.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), null, allApprovals, oldApprovals, ctx.getWhen());
        }
    }
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, InvalidChangeOperationException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
    String refName = patchSet.getId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, user);
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getUser().asIdentifiedUser());
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore(dbProvider.get())) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), caller.getAccountId(), change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Restored");
    if (!Strings.nullToEmpty(input.message).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(input.message.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change.getId());
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, caller.getAccount(), Strings.emptyToNull(input.message));
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(ctx.getProject(), change.getId());
        cm.setFrom(ctx.getUser().getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeRestored.fire(change, patchSet, ctx.getUser().asIdentifiedUser().getAccount(), Strings.emptyToNull(input.message));
}
#end_block

#method_before
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    initIndexType();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(true, /* enableMetrics */
        MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    if (!slave) {
        initIndexType();
    }
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (!slave) {
        modules.add(new ChangeCleanupRunner.Module());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : LuceneIndexModule.latestVersionWithOnlineUpgrade();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (!slave && indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new ConfigNotesMigration.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(false));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    switch(indexType) {
        case LUCENE:
            modules.add(new LuceneIndexModule());
            break;
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new EventBroker.Module());
    modules.add(new AccountPatchReviewStoreImpl.Module());
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new ChangeHookApiListener.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#method_after
public ChangeInfo format(Project.NameKey project, Change.Id id) throws OrmException, NoSuchChangeException {
    ChangeNotes notes;
    try {
        notes = notesFactory.createChecked(db.get(), project, id);
    } catch (OrmException | NoSuchChangeException e) {
        if (!has(CHECK)) {
            throw e;
        }
        return checkOnly(changeDataFactory.create(db.get(), project, id));
    }
    return format(changeDataFactory.create(db.get(), notes));
}
#end_block

#method_before
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        } else {
            return toChangeInfo(cd, limitToPsId);
        }
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#method_after
private ChangeInfo format(ChangeData cd, Optional<PatchSet.Id> limitToPsId, boolean fillAccountLoader) throws OrmException {
    try {
        if (fillAccountLoader) {
            accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
            ChangeInfo res = toChangeInfo(cd, limitToPsId);
            accountLoader.fill();
            return res;
        }
        return toChangeInfo(cd, limitToPsId);
    } catch (PatchListNotAvailableException | GpgException | OrmException | IOException | RuntimeException e) {
        if (!has(CHECK)) {
            Throwables.propagateIfPossible(e, OrmException.class);
            throw new OrmException(e);
        }
        return checkOnly(cd);
    }
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes());
        if (!infos.isEmpty() && r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    ensureLoaded(FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    }));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = new HashMap<>();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes());
        if (!infos.isEmpty() && r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    out.submittable = submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = Sets.newHashSet();
    allUsers.addAll(cd.reviewers().values());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, date));
        }
    }
}
#method_after
private void setAllApprovals(ChangeControl baseCtrl, ChangeData cd, Map<String, LabelWithStatus> labels) throws OrmException {
    // Include a user in the output for this label if either:
    // - They are an explicit reviewer.
    // - They ever voted on this change.
    Set<Account.Id> allUsers = new HashSet<>();
    allUsers.addAll(cd.reviewers().all());
    for (PatchSetApproval psa : cd.approvals().values()) {
        allUsers.add(psa.getAccountId());
    }
    Table<Account.Id, String, PatchSetApproval> current = HashBasedTable.create(allUsers.size(), baseCtrl.getLabelTypes().getLabelTypes().size());
    for (PatchSetApproval psa : cd.currentApprovals()) {
        current.put(psa.getAccountId(), psa.getLabel(), psa);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        for (Map.Entry<String, LabelWithStatus> e : labels.entrySet()) {
            LabelType lt = ctl.getLabelTypes().byLabel(e.getKey());
            if (lt == null) {
                // author didn't intend for the label to show up in the table.
                continue;
            }
            Integer value;
            String tag = null;
            Timestamp date = null;
            PatchSetApproval psa = current.get(accountId, lt.getName());
            if (psa != null) {
                value = Integer.valueOf(psa.getValue());
                if (value == 0) {
                    // This may be a dummy approval that was inserted when the reviewer
                    // was added. Explicitly check whether the user can vote on this
                    // label.
                    value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
                }
                tag = psa.getTag();
                date = psa.getGranted();
            } else {
                // Either the user cannot vote on this label, or they were added as a
                // reviewer but have not responded yet. Explicitly check whether the
                // user can vote on this label.
                value = labelNormalizer.canVote(ctl, lt, accountId) ? 0 : null;
            }
            addApproval(e.getValue().label(), approvalInfo(accountId, value, tag, date));
        }
    }
}
#end_block

#method_before
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = Sets.newHashSet();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = Sets.newHashSet();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> labelsForClosedChange(ChangeData cd, LabelTypes labelTypes, boolean standard, boolean detailed) throws OrmException {
    Set<Account.Id> allUsers = new HashSet<>();
    if (detailed) {
        // the latest patch set (in the next loop).
        for (PatchSetApproval psa : cd.approvals().values()) {
            allUsers.add(psa.getAccountId());
        }
    }
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Set<String> labelNames = new HashSet<>();
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals()) {
        allUsers.add(a.getAccountId());
        LabelType type = labelTypes.byLabel(a.getLabelId());
        if (type != null) {
            labelNames.add(type.getName());
            // Not worth the effort to distinguish between votable/non-votable for 0
            // values on closed changes, since they can't vote anyway.
            current.put(a.getAccountId(), a);
        }
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (String name : labelNames) {
        LabelType type = labelTypes.byLabel(name);
        LabelWithStatus l = LabelWithStatus.create(new LabelInfo(), null);
        if (detailed) {
            setLabelValues(type, l);
        }
        labels.put(type.getName(), l);
    }
    for (Account.Id accountId : allUsers) {
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        if (detailed) {
            for (Map.Entry<String, LabelWithStatus> entry : labels.entrySet()) {
                ApprovalInfo ai = approvalInfo(accountId, 0, null, null);
                byLabel.put(entry.getKey(), ai);
                addApproval(entry.getValue().label(), ai);
            }
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            LabelType type = labelTypes.byLabel(psa.getLabelId());
            if (type == null) {
                continue;
            }
            short val = psa.getValue();
            ApprovalInfo info = byLabel.get(type.getName());
            if (info != null) {
                info.value = Integer.valueOf(val);
                info.date = psa.getGranted();
                info.tag = psa.getTag();
            }
            if (!standard) {
                continue;
            }
            setLabelScores(type, labels.get(type.getName()), val, accountId);
        }
    }
    return labels;
}
#end_block

#method_before
private ApprovalInfo approvalInfo(Account.Id id, Integer value, Timestamp date) {
    ApprovalInfo ai = new ApprovalInfo(id.get());
    ai.value = value;
    ai.date = date;
    accountLoader.put(ai);
    return ai;
}
#method_after
private ApprovalInfo approvalInfo(Account.Id id, Integer value, String tag, Timestamp date) {
    ApprovalInfo ai = getApprovalInfo(id, value, tag, date);
    accountLoader.put(ai);
    return ai;
}
#end_block

#method_before
private void setLabelValues(LabelType type, LabelWithStatus l) {
    l.label().defaultValue = type.getDefaultValue();
    l.label().values = Maps.newLinkedHashMap();
    for (LabelValue v : type.getValues()) {
        l.label().values.put(v.formatValue(), v.getText());
    }
    if (isOnlyZero(l.label().values.keySet())) {
        l.label().values = null;
    }
}
#method_after
private void setLabelValues(LabelType type, LabelWithStatus l) {
    l.label().defaultValue = type.getDefaultValue();
    l.label().values = new LinkedHashMap<>();
    for (LabelValue v : type.getValues()) {
        l.label().values.put(v.formatValue(), v.getText());
    }
    if (isOnlyZero(l.label().values.keySet())) {
        l.label().values = null;
    }
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeControl ctl, ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    List<ChangeMessage> messages = cmUtil.byChange(db.get(), cd.notes());
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi.tag = message.getTag();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeControl ctl, Map<PatchSet.Id, PatchSet> map) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Map<String, RevisionInfo> res = new LinkedHashMap<>();
    for (PatchSet in : map.values()) {
        if ((has(ALL_REVISIONS) || in.getId().equals(ctl.getChange().currentPatchSetId())) && ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(ctl, in));
        }
    }
    return res;
}
#end_block

#method_before
public RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(db, in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, PatchSet in) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    Change c = ctl.getChange();
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(c.currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.created = in.getCreatedOn();
    out.uploader = accountLoader.get(in.getUploader());
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    boolean setCommit = has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT));
    boolean addFooters = out.isCurrent && has(COMMIT_FOOTERS);
    if (setCommit || addFooters) {
        Project.NameKey project = c.getProject();
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = new RevWalk(repo)) {
            String rev = in.getRevision().get();
            RevCommit commit = rw.parseCommit(ObjectId.fromString(rev));
            rw.parseBody(commit);
            if (setCommit) {
                out.commit = toCommit(ctl, rw, commit, has(WEB_LINKS));
            }
            if (addFooters) {
                out.commitWithFooters = mergeUtilFactory.create(projectCache.get(project)).createCherryPickCommitMessage(commit, ctl, in.getId());
            }
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        out.files = fileInfoJson.toFileInfoMap(c, in);
        out.files.remove(Patch.COMMIT_MSG);
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(changeResourceFactory.create(ctl), in));
    }
    if (has(PUSH_CERTIFICATES)) {
        if (in.getPushCertificate() != null) {
            out.pushCertificate = gpgApi.checkPushCertificate(in.getPushCertificate(), userFactory.create(in.getUploader()));
        } else {
            out.pushCertificate = new PushCertificateInfo();
        }
    }
    return out;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = new LinkedHashMap<>();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = Maps.newTreeMap();
    }
    fetchInfo.commands.put(commandName, c);
}
#method_after
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = new TreeMap<>();
    }
    fetchInfo.commands.put(commandName, c);
}
#end_block

#method_before
private static void addApproval(LabelInfo label, ApprovalInfo approval) {
    if (label.all == null) {
        label.all = Lists.newArrayList();
    }
    label.all.add(approval);
}
#method_after
private static void addApproval(LabelInfo label, ApprovalInfo approval) {
    if (label.all == null) {
        label.all = new ArrayList<>();
    }
    label.all.add(approval);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, final AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message, caller.getAccount());
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl control = req.getControl();
    if (!control.canAbandon(dbProvider.get())) {
        throw new AuthException("abandon not permitted");
    }
    Change change = abandon(control, input.message);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#end_block

#method_before
public Change abandon(ChangeControl control, final String msgTxt, final Account account) throws RestApiException, UpdateException {
    Op op = new Op(msgTxt, account);
    Change c = control.getChange();
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), c.getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(c.getId(), op).execute();
    }
    return op.change;
}
#method_after
public Change abandon(ChangeControl control, String msgTxt) throws RestApiException, UpdateException {
    CurrentUser user = control.getUser();
    Account account = user.isIdentifiedUser() ? user.asIdentifiedUser().getAccount() : null;
    Op op = new Op(msgTxt, account);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), control.getProject().getNameKey(), user, TimeUtil.nowTs())) {
        u.addOp(control.getId(), op).execute();
    }
    return op.change;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    update.setStatus(change.getStatus());
    message = newMessage(ctx);
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
private ChangeMessage newMessage(ReviewDb db) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), account != null ? account.getId() : null, change.getLastUpdatedOn(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#method_after
private ChangeMessage newMessage(ChangeContext ctx) throws OrmException {
    StringBuilder msg = new StringBuilder();
    msg.append("Abandoned");
    if (!Strings.nullToEmpty(msgTxt).trim().isEmpty()) {
        msg.append("\n\n");
        msg.append(msgTxt.trim());
    }
    ChangeMessage message = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), account != null ? account.getId() : null, ctx.getWhen(), change.currentPatchSetId());
    message.setMessage(msg.toString());
    return message;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        changeAbandoned.fire(change, patchSet, account, msgTxt);
    } catch (PatchListNotAvailableException | GpgException | IOException e) {
        throw new OrmException(e);
    }
    hooks.doChangeAbandonedHook(change, account, patchSet, Strings.emptyToNull(msgTxt), ctx.getDb());
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(ctx.getProject(), change.getId());
        if (account != null) {
            cm.setFrom(account.getId());
        }
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    changeAbandoned.fire(change, patchSet, account, msgTxt);
    hooks.doChangeAbandonedHook(change, account, patchSet, Strings.emptyToNull(msgTxt), ctx.getDb());
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && resource.getChange().getStatus() != Change.Status.DRAFT && resource.getControl().canAbandon());
}
#method_after
@Override
public UiAction.Description getDescription(ChangeResource resource) {
    boolean canAbandon = false;
    try {
        canAbandon = resource.getControl().canAbandon(dbProvider.get());
    } catch (OrmException e) {
        log.error("Cannot check canAbandon status. Assuming false.", e);
    }
    return new UiAction.Description().setLabel("Abandon").setTitle("Abandon the change").setVisible(resource.getChange().getStatus().isOpen() && resource.getChange().getStatus() != Change.Status.DRAFT && canAbandon);
}
#end_block

#method_before
public void fire(ChangeInfo change, RevisionInfo revision, AccountInfo abandoner, String reason) {
    Event e = new Event(change, revision, abandoner, reason);
    for (ChangeAbandonedListener l : listeners) {
        l.onChangeAbandoned(e);
    }
}
#method_after
public void fire(ChangeInfo change, RevisionInfo revision, AccountInfo abandoner, String reason) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    Event e = new Event(change, revision, abandoner, reason);
    for (ChangeAbandonedListener l : listeners) {
        l.onChangeAbandoned(e);
    }
}
#end_block

#method_before
public void fire(Change change, PatchSet ps, Account abandoner, String reason) throws OrmException, PatchListNotAvailableException, GpgException, IOException {
    ChangeJson changeJson = changeJsonFactory.create(ChangeJson.NO_OPTIONS);
    ChangeInfo changeInfo = changeJson.format(change);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    ChangeControl ctl = cd.changeControl();
    RevisionInfo revisionInfo = changeJson.toRevisionInfo(ctl, ps);
    AccountInfo ai = new AccountInfo(abandoner.getId().get());
    ai.email = abandoner.getPreferredEmail();
    ai.name = abandoner.getFullName();
    ai.username = abandoner.getUserName();
    fire(changeInfo, revisionInfo, ai, reason);
}
#method_after
public void fire(Change change, PatchSet ps, Account abandoner, String reason) {
    if (!listeners.iterator().hasNext()) {
        return;
    }
    try {
        fire(util.changeInfo(change), util.revisionInfo(change.getProject(), ps), util.accountInfo(abandoner), reason);
    } catch (PatchListNotAvailableException | GpgException | IOException | OrmException e) {
        log.error("Couldn't fire event", e);
    }
}
#end_block

#method_before
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectCtl.getProjectState().isAllUsers()) {
        refs = addUsersSelfSymref(refs);
    }
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(REFS_CONFIG))) {
        return fastHideRefsMetaConfig(refs);
    }
    Account.Id userId;
    boolean viewMetadata;
    if (projectCtl.getUser().isIdentifiedUser()) {
        IdentifiedUser user = projectCtl.getUser().asIdentifiedUser();
        userId = user.getAccountId();
        viewMetadata = user.getCapabilities().canAccessDatabase();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || accountId.equals(userId)) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectName).matcher(tagCache, db, filterTagsSeparately ? filter(db.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#method_after
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeparately) {
    if (projectCtl.getProjectState().isAllUsers() && projectCtl.getUser().isIdentifiedUser()) {
        Ref userRef = refs.get(RefNames.refsUsers(projectCtl.getUser().getAccountId()));
        if (userRef != null) {
            SymbolicRef refsUsersSelf = new SymbolicRef(RefNames.REFS_USERS_SELF, userRef);
            refs = new HashMap<>(refs);
            refs.put(refsUsersSelf.getName(), refsUsersSelf);
        }
    }
    if (projectCtl.allRefsAreVisible(ImmutableSet.of(RefNames.REFS_CONFIG))) {
        Map<String, Ref> r = Maps.newHashMap(refs);
        if (!projectCtl.controlForRef(RefNames.REFS_CONFIG).isVisible()) {
            r.remove(RefNames.REFS_CONFIG);
        }
        return r;
    }
    Account.Id userId;
    boolean viewMetadata;
    if (projectCtl.getUser().isIdentifiedUser()) {
        IdentifiedUser user = projectCtl.getUser().asIdentifiedUser();
        userId = user.getAccountId();
        viewMetadata = user.getCapabilities().canAccessDatabase();
        userEditPrefix = RefNames.refsEditPrefix(userId);
    } else {
        userId = null;
        viewMetadata = false;
    }
    Map<String, Ref> result = new HashMap<>();
    List<Ref> deferredTags = new ArrayList<>();
    for (Ref ref : refs.values()) {
        String name = ref.getName();
        Change.Id changeId;
        Account.Id accountId;
        if (name.startsWith(REFS_CACHE_AUTOMERGE) || (!showMetadata && isMetadata(name))) {
            continue;
        } else if (RefNames.isRefsEdit(name)) {
            // Edits are visible only to the owning user, if change is visible.
            if (viewMetadata || visibleEdit(name)) {
                result.put(name, ref);
            }
        } else if ((changeId = Change.Id.fromRef(name)) != null) {
            // Change ref is visible only if the change is visible.
            if (viewMetadata || visible(changeId)) {
                result.put(name, ref);
            }
        } else if ((accountId = Account.Id.fromRef(name)) != null) {
            // Account ref is visible only to corresponding account.
            if (viewMetadata || (accountId.equals(userId) && projectCtl.controlForRef(name).isVisible())) {
                result.put(name, ref);
            }
        } else if (isTag(ref)) {
            // If its a tag, consider it later.
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            result.put(name, ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeparately)) {
        TagMatcher tags = tagCache.get(projectName).matcher(tagCache, db, filterTagsSeparately ? filter(db.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#method_after
@Test
public void addReviewer() throws Exception {
    TestTimeUtil.resetWithClockStep(1, SECONDS);
    sender.clear();
    PushOneCommit.Result r = createChange();
    ChangeResource rsrc = parseResource(r);
    String oldETag = rsrc.getETag();
    Timestamp oldTs = rsrc.getChange().getLastUpdatedOn();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    Message m = messages.get(0);
    assertThat(m.rcpt()).containsExactly(user.emailAddress);
    assertThat(m.body()).contains("Hello " + user.fullName + ",\n");
    assertThat(m.body()).contains("I'd like you to do a code review.");
    assertThat(m.body()).contains("Change subject: " + PushOneCommit.SUBJECT + "\n");
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When NoteDb is enabled adding a reviewer records that user as reviewer
    // in NoteDb. When NoteDb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = NoteDbMode.readWrite() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).isNotNull();
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
    // Ensure ETag and lastUpdatedOn are updated.
    rsrc = parseResource(r);
    assertThat(rsrc.getETag()).isNotEqualTo(oldETag);
    assertThat(rsrc.getChange().getLastUpdatedOn()).isNotEqualTo(oldTs);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    if (input.notify.compareTo(NotifyHandling.NONE) > 0) {
        try {
            ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(changeMessage);
            cm.setNotify(input.notify);
            cm.send();
        } catch (Exception e) {
            log.error("Cannot email update for change " + change.getId(), e);
        }
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook invocation failed", e);
    }
}
#end_block

#method_before
public <T> List<T> getTaskInfos(TaskInfoFactory<T> factory) {
    List<T> taskInfos = Lists.newArrayList();
    for (Executor exe : queues) {
        for (Task<?> task : exe.getTasks()) {
            taskInfos.add(factory.getTaskInfo(task));
        }
    }
    return taskInfos;
}
#method_after
public <T> List<T> getTaskInfos(TaskInfoFactory<T> factory) {
    List<T> taskInfos = new ArrayList<>();
    for (Executor exe : queues) {
        for (Task<?> task : exe.getTasks()) {
            taskInfos.add(factory.getTaskInfo(task));
        }
    }
    return taskInfos;
}
#end_block

#method_before
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            } else {
                result = t;
            }
        }
    }
    return result;
}
#method_after
public Task<?> getTask(final int id) {
    Task<?> result = null;
    for (final Executor e : queues) {
        final Task<?> t = e.getTask(id);
        if (t != null) {
            if (result != null) {
                // Don't return the task if we have a duplicate. Lie instead.
                return null;
            }
            result = t;
        }
    }
    return result;
}
#end_block

#method_before
public State getState() {
    if (isCancelled()) {
        return State.CANCELLED;
    } else if (isDone() && !isPeriodic()) {
        return State.DONE;
    } else if (running.get()) {
        return State.RUNNING;
    }
    final long delay = getDelay(TimeUnit.MILLISECONDS);
    if (delay <= 0) {
        return State.READY;
    } else {
        return State.SLEEPING;
    }
}
#method_after
public State getState() {
    if (isCancelled()) {
        return State.CANCELLED;
    } else if (isDone() && !isPeriodic()) {
        return State.DONE;
    } else if (running.get()) {
        return State.RUNNING;
    }
    final long delay = getDelay(TimeUnit.MILLISECONDS);
    if (delay <= 0) {
        return State.READY;
    }
    return State.SLEEPING;
}
#end_block

#method_before
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CancelledWhileRunning) {
                ((CancelledWhileRunning) runnable).setCancelledWhileRunning();
            }
        }
        executor.remove(this);
        executor.purge();
        return true;
    } else {
        return false;
    }
}
#method_after
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (task.cancel(mayInterruptIfRunning)) {
        // 
        if (runnable instanceof CancelableRunnable) {
            if (running.compareAndSet(false, true)) {
                ((CancelableRunnable) runnable).cancel();
            } else if (runnable instanceof CanceledWhileRunning) {
                ((CanceledWhileRunning) runnable).setCanceledWhileRunning();
            }
        }
        executor.remove(this);
        executor.purge();
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    // is wrapped into a ListenableFutureTask.
    if (runnable instanceof ListenableFutureTask<?>) {
        String errorMessage;
        try {
            for (Field field : ListenableFutureTask.class.getSuperclass().getDeclaredFields()) {
                if (field.getType().isAssignableFrom(Callable.class)) {
                    field.setAccessible(true);
                    return ((Callable<?>) field.get(runnable)).toString();
                }
            }
            errorMessage = "Cannot find wrapped Callable field";
        } catch (SecurityException | IllegalArgumentException | IllegalAccessException e) {
            errorMessage = "Cannot call toString on Callable field";
        }
        log.debug("Cannot get a proper name for ListenableFutureTask: {}", errorMessage);
    }
    return runnable.toString();
}
#method_after
@Override
public String toString() {
    // is wrapped into a TrustedListenableFutureTask.
    try {
        if (runnable.getClass().isAssignableFrom(Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask"))) {
            Class<?> trustedFutureInterruptibleTask = Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask");
            for (Field field : runnable.getClass().getDeclaredFields()) {
                if (field.getType().isAssignableFrom(trustedFutureInterruptibleTask)) {
                    field.setAccessible(true);
                    Object innerObj = field.get(runnable);
                    for (Field innerField : innerObj.getClass().getDeclaredFields()) {
                        if (innerField.getType().isAssignableFrom(Callable.class)) {
                            innerField.setAccessible(true);
                            return ((Callable<?>) innerField.get(innerObj)).toString();
                        }
                    }
                }
            }
        }
    } catch (ClassNotFoundException | IllegalArgumentException | IllegalAccessException e) {
        log.debug("Cannot get a proper name for TrustedListenableFutureTask: {}", e.getMessage());
    }
    return runnable.toString();
}
#end_block

#method_before
@Override
public void cancel() {
    repLog.info("Replication {} was cancelled", getURI());
    cancelledByReplication();
    pool.pushWasCancelled(this);
}
#method_after
@Override
public void cancel() {
    repLog.info("Replication {} was canceled", getURI());
    canceledByReplication();
    pool.pushWasCanceled(this);
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!cancelled) {
            repLog.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to " + uri + " started...");
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to " + uri + " completed in " + (elapsed) + "ms, " + (delay) + "ms delay, " + retryCount + " retries");
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to " + uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    MDC.put(ID_MDC_KEY, IdGenerator.format(id));
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            repLog.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    repLog.info("Replication to " + uri + " started...");
    Timer1.Context context = metrics.start(config.getName());
    try {
        long startedAt = context.getStartTime();
        long delay = NANOSECONDS.toMillis(startedAt - createdAt);
        metrics.record(config.getName(), delay, retryCount);
        git = gitManager.openRepository(projectName);
        runImpl();
        long elapsed = NANOSECONDS.toMillis(context.stop());
        repLog.info("Replication to " + uri + " completed in " + (elapsed) + "ms, " + (delay) + "ms delay, " + retryCount + " retries");
    } catch (RepositoryNotFoundException e) {
        stateLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        String msg = e.getMessage();
        if (msg.contains("access denied") || msg.contains("no such repository")) {
            createRepository();
        } else {
            repLog.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            repLog.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            repLog.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                if (canceledWhileRunning.get()) {
                    logCanceledWhileRunningException(e);
                } else {
                    pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
                }
            } else {
                repLog.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            if (canceledWhileRunning.get()) {
                logCanceledWhileRunningException(e);
            } else {
                repLog.error("Cannot replicate to " + uri, e);
                // The remote push operation should be retried.
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            }
        }
    } catch (IOException e) {
        stateLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException | Error e) {
        stateLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void logCanceledWhileRunningException(TransportException e) {
    repLog.info("Cannot replicate to " + uri + " it was canceled while running", e);
}
#method_after
private void logCanceledWhileRunningException(TransportException e) {
    repLog.info("Cannot replicate to " + uri + "." + " It was canceled while running", e);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        try (ReviewDb db = schema.open()) {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } catch (OrmException e) {
            stateLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = new HashMap<>();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        try (ReviewDb db = schema.open()) {
            local = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, git, pc, db, true).filter(local, true);
        } catch (OrmException e) {
            stateLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = new ArrayList<>();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = new ArrayList<>();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            // Second try to ensure that the ref is truly not found locally
            if (srcRef == null) {
                srcRef = git.exactRef(src);
            }
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#method_after
void schedule(Project.NameKey project, String ref, URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!shouldReplicate(project, state)) {
        return;
    }
    if (!config.replicatePermissions()) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, config.getDelay(), TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, config.getDelay());
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancelledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.canceledByReplication();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, config.getDelay(), TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, config.getRetryDelay(), TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
boolean requestRunway(PushOne op) {
    synchronized (stateLock) {
        if (op.wasCancelled()) {
            return false;
        }
        pending.remove(op.getURI());
        if (inFlight.containsKey(op.getURI())) {
            return false;
        }
        inFlight.put(op.getURI(), op);
    }
    return true;
}
#method_after
boolean requestRunway(PushOne op) {
    synchronized (stateLock) {
        if (op.wasCanceled()) {
            return false;
        }
        pending.remove(op.getURI());
        if (inFlight.containsKey(op.getURI())) {
            return false;
        }
        inFlight.put(op.getURI(), op);
    }
    return true;
}
#end_block

#method_before
PushOne notifyFinished(PushOne op) {
    synchronized (stateLock) {
        return inFlight.remove(op.getURI());
    }
}
#method_after
void notifyFinished(PushOne op) {
    synchronized (stateLock) {
        inFlight.remove(op.getURI());
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    String[] projects = config.getProjects();
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    if (!shouldReplicate(project)) {
        return false;
    }
    // by default push all projects
    List<String> projects = config.getProjects();
    if (projects.isEmpty()) {
        return true;
    }
    return (new ReplicationFilter(projects)).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    String[] projects = config.getProjects();
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    List<String> projects = config.getProjects();
    boolean ret = (projects.size() == 1);
    if (ret) {
        String projectMatch = projects.get(0);
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
String[] getAdminUrls() {
    return config.getAdminUrls();
}
#method_after
ImmutableList<String> getAdminUrls() {
    return config.getAdminUrls();
}
#end_block

#method_before
String[] getUrls() {
    return config.getUrls();
}
#method_after
ImmutableList<String> getUrls() {
    return config.getUrls();
}
#end_block

#method_before
String[] getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#method_after
ImmutableList<String> getAuthGroupNames() {
    return config.getAuthGroupNames();
}
#end_block

#method_before
String[] getProjects() {
    return config.getProjects();
}
#method_after
ImmutableList<String> getProjects() {
    return config.getProjects();
}
#end_block

#method_before
private static boolean toBoolean(String v) {
    if (Strings.isNullOrEmpty(v)) {
        return false;
    }
    return v.equalsIgnoreCase("Y");
}
#method_after
private static boolean toBoolean(String v) {
    return !Strings.isNullOrEmpty(v) && v.equalsIgnoreCase("Y");
}
#end_block

#method_before
private List<ChangeData> getForOpenChange(Change c, CurrentUser user) throws OrmException, IOException, AuthException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user);
    if (cs.furtherHiddenChanges()) {
        throw new AuthException("topic includes hidden change");
    }
    return cs.changes().asList();
}
#method_after
private List<ChangeData> getForOpenChange(Change c, CurrentUser user) throws OrmException, IOException, AuthException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), c, user);
    if (cs.furtherHiddenChanges()) {
        throw new AuthException("change would be submitted with a change that you cannot see");
    }
    return cs.changes().asList();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is hidden");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller, submissionId);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        if (cs.furtherHiddenChanges()) {
            throw new AuthException("A change to be submitted with " + change.getId() + " is not visible");
        }
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    try {
        return (List<ChangeInfo>) submittedTogether.apply(change);
    } catch (Exception e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<ChangeInfo> submittedTogether() throws RestApiException {
    try {
        return (List<ChangeInfo>) submittedTogether.apply(change);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot query submittedTogether", e);
    }
}
#end_block

#method_before
private SubmitType submitType(ChangeData cd, boolean visible) throws OrmException {
    // changes that would be submitted together with the visible ones.
    if (visible) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (!str.isOk()) {
            logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
        }
        return str.type;
    } else {
        return cd.changeControl().getProject().getSubmitType();
    }
}
#method_after
private SubmitType submitType(ChangeData cd, boolean visible) throws OrmException {
    // would be submitted together with the visible ones.
    if (!visible) {
        return cd.changeControl().getProject().getSubmitType();
    }
    SubmitTypeRecord str = cd.submitTypeRecord();
    if (!str.isOk()) {
        logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
    }
    return str.type;
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> visibleChanges = new ArrayList<>();
    List<ChangeData> nonVisibleChanges = new ArrayList<>();
    Multimap<Project.NameKey, ChangeData> pc = byProject(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (ChangeData cd : pc.get(project)) {
                checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
                boolean visible = changes.ids().contains(cd.getId());
                if (visible && !cd.changeControl().isVisible(db, cd)) {
                    // We thought the change was visible, but it isn't.
                    // This can happen if the ACL changes during the
                    // completeChangeSet computation, example.
                    visible = false;
                }
                List<ChangeData> dest = visible ? visibleChanges : nonVisibleChanges;
                if (submitType(cd, visible) == SubmitType.CHERRY_PICK) {
                    dest.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        chd.changeControl(user);
                        dest.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> visibleChanges = new ArrayList<>();
    List<ChangeData> nonVisibleChanges = new ArrayList<>();
    Multimap<Project.NameKey, ChangeData> pc = byProject(Iterables.concat(changes.changes(), changes.nonVisibleChanges()));
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (ChangeData cd : pc.get(project)) {
                checkState(cd.hasChangeControl(), "completeChangeSet forgot to set changeControl for current user" + " at ChangeData creation time");
                boolean visible = changes.ids().contains(cd.getId());
                if (visible && !cd.changeControl().isVisible(db, cd)) {
                    // We thought the change was visible, but it isn't.
                    // This can happen if the ACL changes during the
                    // completeChangeSet computation, for example.
                    visible = false;
                }
                List<ChangeData> dest = visible ? visibleChanges : nonVisibleChanges;
                if (submitType(cd, visible) == SubmitType.CHERRY_PICK) {
                    dest.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        chd.changeControl(user);
                        dest.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(visibleChanges, nonVisibleChanges);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes, user);
    while (!done) {
        List<ChangeData> visibleChanges = new ArrayList<>();
        List<ChangeData> nonVisibleChanges = new ArrayList<>();
        done = true;
        for (boolean visible : ImmutableList.of(true, false)) {
            for (ChangeData cd : visible ? newCs.changes() : newCs.nonVisibleChanges()) {
                if (visible) {
                    visibleChanges.add(cd);
                } else {
                    nonVisibleChanges.add(cd);
                }
                String topic = cd.change().getTopic();
                if (Strings.isNullOrEmpty(topic) || topicsTraversed.contains(topic)) {
                    continue;
                }
                for (ChangeData topicCd : query().byTopicOpen(topic)) {
                    topicCd.changeControl(user);
                    if (visible && topicCd.changeControl().isVisible(db, topicCd)) {
                        visibleChanges.add(topicCd);
                    } else {
                        nonVisibleChanges.add(topicCd);
                    }
                }
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(visibleChanges, nonVisibleChanges);
        newCs = completeChangeSetWithoutTopic(db, changes, user);
    }
    return newCs;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsSeen = new HashSet<>();
    Set<String> visibleTopicsSeen = new HashSet<>();
    int oldSeen;
    int seen = 0;
    do {
        oldSeen = seen;
        changes = completeChangeSetWithoutTopic(db, changes, user);
        changes = topicClosure(db, changes, user, topicsSeen, visibleTopicsSeen);
        seen = topicsSeen.size() + visibleTopicsSeen.size();
    } while (seen != oldSeen);
    return changes;
}
#end_block

#method_before
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        text.setText(info.topic());
        text.setTargetHistoryToken(PageLinks.toChangeQuery(PageLinks.op("topic", info.topic()) + "+" + "is:open"));
    }
}
#method_after
private void initTopicLink(ChangeInfo info) {
    if (info.topic() != null && !info.topic().isEmpty()) {
        String topic = info.topic();
        text.setText(topic);
        text.setTargetHistoryToken(PageLinks.topicQuery(info.status(), topic));
    }
}
#end_block

#method_before
private NoteDbChangeState execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    NoteDbChangeState newState = NoteDbChangeState.applyDelta(change, manager.stage().get(changeId));
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!oldNoteDbState.equals(change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return newState;
}
#method_after
private NoteDbChangeState execute(ReviewDb db, Change.Id changeId, NoteDbUpdateManager manager) throws NoSuchChangeException, OrmException, IOException {
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    final String oldNoteDbState = change.getNoteDbState();
    NoteDbChangeState newState = NoteDbChangeState.applyDelta(change, manager.stage());
    final String newNoteDbState = change.getNoteDbState();
    try {
        db.changes().atomicUpdate(changeId, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (!Objects.equals(oldNoteDbState, change.getNoteDbState())) {
                    throw new AbortUpdateException();
                }
                change.setNoteDbState(newNoteDbState);
                return change;
            }
        });
        manager.execute();
    } catch (AbortUpdateException e) {
    // Drop this rebuild; another thread completed it.
    }
    return newState;
}
#end_block

#method_before
@Override
public NoteDbChangeState rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return NoteDbChangeState.applyDelta(change, manager.stage().get(change.getId()));
}
#method_after
@Override
public NoteDbChangeState rebuild(NoteDbUpdateManager manager, ChangeBundle bundle) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    Change change = new Change(bundle.getChange());
    buildUpdates(manager, bundle);
    return NoteDbChangeState.applyDelta(change, manager.stage());
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            case GITLINK:
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        }
        renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    try (TreeWalk tw = new TreeWalk(rw.getObjectReader())) {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    return null;
}
#method_after
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw = new TreeWalk(rw.getObjectReader());
    try {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    tw.close();
    return null;
}
#end_block

#method_before
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#method_after
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#end_block

#method_before
public Builder setRepositoryName(String repositoryName) {
    if (type == Type.HOST_INDEX) {
        throw new IllegalStateException(String.format("cannot set repository name on %s view", type));
    }
    this.repositoryName = checkNotNull(repositoryName);
    return this;
}
#method_after
public Builder setRepositoryName(String repositoryName) {
    switch(type) {
        case HOST_INDEX:
            throw new IllegalStateException(String.format("cannot set repository name on %s view", type));
        default:
            this.repositoryName = checkNotNull(repositoryName);
            return this;
    }
}
#end_block

#method_before
public Builder setRevision(Revision revision) {
    switch(type) {
        case HOST_INDEX:
        case REPOSITORY_INDEX:
        case REFS:
        case DESCRIBE:
            throw new IllegalStateException(String.format("cannot set revision on %s view", type));
        case ARCHIVE:
        case BLAME:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            this.revision = checkNotNull(revision);
            return this;
    }
}
#method_after
public Builder setRevision(Revision revision) {
    switch(type) {
        case HOST_INDEX:
        case REPOSITORY_INDEX:
        case REFS:
        case DESCRIBE:
            throw new IllegalStateException(String.format("cannot set revision on %s view", type));
        default:
            this.revision = checkNotNull(revision);
            return this;
    }
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#method_after
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#end_block

#method_before
public Builder setPathPart(String path) {
    switch(type) {
        case PATH:
        case DIFF:
        case SHOW:
            checkState(path != null, "cannot set null path on %s view", type);
            break;
        case BLAME:
        case ARCHIVE:
        case DESCRIBE:
        case REFS:
        case LOG:
        case DOC:
        case ROOTED_DOC:
            break;
        case HOST_INDEX:
        case REPOSITORY_INDEX:
        case REVISION:
        default:
            checkState(path == null, "cannot set path on %s view", type);
            break;
    }
    this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
    return this;
}
#method_after
public Builder setPathPart(String path) {
    switch(type) {
        case PATH:
        case DIFF:
        case SHOW:
            checkState(path != null, "cannot set null path on %s view", type);
            break;
        case BLAME:
        case ARCHIVE:
        case DESCRIBE:
        case REFS:
        case LOG:
        case DOC:
        case ROOTED_DOC:
            break;
        default:
            checkState(path == null, "cannot set path on %s view", type);
            break;
    }
    this.path = path != null ? maybeTrimLeadingAndTrailingSlash(path) : null;
    return this;
}
#end_block

#method_before
public Builder setExtension(String extension) {
    if (type != Type.ARCHIVE) {
        checkState(extension == null, "cannot set extension on %s view", type);
    }
    this.extension = extension;
    return this;
}
#method_after
public Builder setExtension(String extension) {
    switch(type) {
        default:
            checkState(extension == null, "cannot set extension on %s view", type);
        // $FALL-THROUGH$
        case ARCHIVE:
            this.extension = extension;
            break;
    }
    return this;
}
#end_block

#method_before
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DOC:
            case HOST_INDEX:
            case PATH:
            case REFS:
            case REPOSITORY_INDEX:
            case REVISION:
            case ROOTED_DOC:
            case SHOW:
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#method_after
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#end_block

#method_before
private Builder copyWithPath(boolean isLeaf) {
    Builder copy;
    switch(type) {
        case DIFF:
            copy = diff();
            break;
        case LOG:
            copy = log();
            break;
        case BLAME:
            copy = isLeaf ? blame() : path();
            break;
        case ARCHIVE:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            copy = path();
            break;
    }
    return copy.copyFrom(this);
}
#method_after
private Builder copyWithPath(boolean isLeaf) {
    Builder copy;
    switch(type) {
        case DIFF:
            copy = diff();
            break;
        case LOG:
            copy = log();
            break;
        case BLAME:
            copy = isLeaf ? blame() : path();
            break;
        default:
            copy = path();
            break;
    }
    return copy.copyFrom(this);
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    try (Writer writer = startRenderText(req, res)) {
        for (RepositoryDescription repo : descs.values()) {
            for (String name : branches) {
                String ref = repo.branches.get(name);
                if (ref == null) {
                    // Print stub (forty '-' symbols)
                    ref = "----------------------------------------";
                }
                writer.write(ref);
                writer.write(' ');
            }
            writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
            writer.write('\n');
        }
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#end_block

#method_before
public Builder setRepositoryPrefix(String prefix) {
    switch(type) {
        case HOST_INDEX:
            this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
            return this;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DIFF:
        case DOC:
        case LOG:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
    }
}
#method_after
public Builder setRepositoryPrefix(String prefix) {
    if (type == Type.HOST_INDEX) {
        this.repositoryPrefix = prefix != null ? Strings.emptyToNull(maybeTrimLeadingAndTrailingSlash(prefix)) : null;
        return this;
    }
    throw new IllegalStateException(String.format("cannot set repository prefix on %s view", type));
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            break;
        case ARCHIVE:
        case BLAME:
        case DESCRIBE:
        case DOC:
        case HOST_INDEX:
        case PATH:
        case REFS:
        case REPOSITORY_INDEX:
        case REVISION:
        case ROOTED_DOC:
        case SHOW:
        default:
            revision = firstNonNull(revision, Revision.NULL);
            checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
            break;
    }
    this.oldRevision = revision;
    return this;
}
#method_after
public Builder setOldRevision(Revision revision) {
    if (type != Type.DIFF && type != Type.LOG) {
        revision = firstNonNull(revision, Revision.NULL);
        checkState(revision == Revision.NULL, "cannot set old revision on %s view", type);
    }
    this.oldRevision = revision;
    return this;
}
#end_block

#method_before
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        switch(type) {
            case LOG:
            case DIFF:
                // tree/commit.
                return revision.getName() + "^!";
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DOC:
            case HOST_INDEX:
            case PATH:
            case REFS:
            case REPOSITORY_INDEX:
            case REVISION:
            case ROOTED_DOC:
            case SHOW:
            default:
                // revision.
                return null;
        }
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#method_after
public String getRevisionRange() {
    if (oldRevision == Revision.NULL) {
        if (type == Type.LOG || type == Type.DIFF) {
            // tree/commit.
            return revision.getName() + "^!";
        }
        // revision.
        return null;
    } else if (type == Type.DIFF && isFirstParent(revision, oldRevision)) {
        return revision.getName() + "^!";
    } else {
        return oldRevision.getName() + ".." + revision.getName();
    }
}
#end_block

#method_before
public Map<String, Object> toSoyData(ObjectId treeId, TreeWalk tw) throws MissingObjectException, IOException {
    ReadmeHelper readme = new ReadmeHelper(reader, view, MarkdownConfig.get(cfg), rootTree, requestUri);
    List<Object> entries = Lists.newArrayList();
    GitilesView.Builder urlBuilder = GitilesView.path().copyFrom(view);
    while (tw.next()) {
        FileType type = FileType.forEntry(tw);
        String name = tw.getNameString();
        switch(view.getType()) {
            case PATH:
                urlBuilder.setPathPart(view.getPathPart() + "/" + name);
                break;
            case REVISION:
                // Got here from a tag pointing at a tree.
                urlBuilder.setPathPart(name);
                break;
            case ARCHIVE:
            case BLAME:
            case DESCRIBE:
            case DIFF:
            case DOC:
            case HOST_INDEX:
            case LOG:
            case REFS:
            case REPOSITORY_INDEX:
            case ROOTED_DOC:
            case SHOW:
            default:
                throw new IllegalStateException(String.format("Cannot render TreeSoyData from %s view", view.getType()));
        }
        String url = urlBuilder.toUrl();
        if (type == FileType.TREE) {
            name += "/";
            url += "/";
        }
        Map<String, String> entry = Maps.newHashMapWithExpectedSize(4);
        entry.put("type", type.toString());
        entry.put("name", name);
        entry.put("url", url);
        if (type == FileType.SYMLINK) {
            String target = new String(reader.open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            entry.put("targetName", getTargetDisplayName(target));
            String targetUrl = resolveTargetUrl(view, target);
            if (targetUrl != null) {
                entry.put("targetUrl", targetUrl);
            }
        } else {
            readme.considerEntry(tw);
        }
        entries.add(entry);
    }
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    data.put("sha", treeId.name());
    data.put("entries", entries);
    if (view.getType() == GitilesView.Type.PATH && view.getRevision().getPeeledType() == OBJ_COMMIT) {
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("archiveUrl", GitilesView.archive().copyFrom(view).setPathPart(Strings.emptyToNull(view.getPathPart())).setExtension(archiveFormat.getDefaultSuffix()).toUrl());
        data.put("archiveType", archiveFormat.getShortName());
    }
    if (readme.isPresent()) {
        data.put("readmePath", readme.getPath());
        data.put("readmeHtml", readme.render());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(ObjectId treeId, TreeWalk tw) throws MissingObjectException, IOException {
    ReadmeHelper readme = new ReadmeHelper(reader, view, MarkdownConfig.get(cfg), rootTree, requestUri);
    List<Object> entries = Lists.newArrayList();
    GitilesView.Builder urlBuilder = GitilesView.path().copyFrom(view);
    while (tw.next()) {
        FileType type = FileType.forEntry(tw);
        String name = tw.getNameString();
        GitilesView.Type viewType = view.getType();
        if (viewType == GitilesView.Type.PATH) {
            urlBuilder.setPathPart(view.getPathPart() + "/" + name);
        } else if (viewType == GitilesView.Type.REVISION) {
            // Got here from a tag pointing at a tree.
            urlBuilder.setPathPart(name);
        } else {
            throw new IllegalStateException(String.format("Cannot render TreeSoyData from %s view", viewType));
        }
        String url = urlBuilder.toUrl();
        if (type == FileType.TREE) {
            name += "/";
            url += "/";
        }
        Map<String, String> entry = Maps.newHashMapWithExpectedSize(4);
        entry.put("type", type.toString());
        entry.put("name", name);
        entry.put("url", url);
        if (type == FileType.SYMLINK) {
            String target = new String(reader.open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            entry.put("targetName", getTargetDisplayName(target));
            String targetUrl = resolveTargetUrl(view, target);
            if (targetUrl != null) {
                entry.put("targetUrl", targetUrl);
            }
        } else {
            readme.considerEntry(tw);
        }
        entries.add(entry);
    }
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    data.put("sha", treeId.name());
    data.put("entries", entries);
    if (view.getType() == GitilesView.Type.PATH && view.getRevision().getPeeledType() == OBJ_COMMIT) {
        data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
        data.put("archiveUrl", GitilesView.archive().copyFrom(view).setPathPart(Strings.emptyToNull(view.getPathPart())).setExtension(archiveFormat.getDefaultSuffix()).toUrl());
        data.put("archiveType", archiveFormat.getShortName());
    }
    if (readme.isPresent()) {
        data.put("readmePath", readme.getPath());
        data.put("readmeHtml", readme.render());
    }
    return data;
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        }
        renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    try (TreeWalk tw = new TreeWalk(rw.getObjectReader())) {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    return null;
}
#method_after
private static WalkResult forPath(RevWalk rw, GitilesView view, boolean recursive) throws IOException {
    if (recursive) {
        return recursivePath(rw, view);
    }
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw = new TreeWalk(rw.getObjectReader());
    try {
        tw.addTree(root);
        tw.setRecursive(false);
        if (path.isEmpty()) {
            return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
        }
        AutoDiveFilter f = new AutoDiveFilter(path);
        tw.setFilter(f);
        while (tw.next()) {
            if (f.isDone(tw)) {
                FileType type = FileType.forEntry(tw);
                ObjectId id = tw.getObjectId(0);
                if (type == FileType.TREE) {
                    tw.enterSubtree();
                    tw.setRecursive(false);
                }
                return new WalkResult(tw, path, root, id, type, f.hasSingleTree);
            } else if (tw.isSubtree()) {
                tw.enterSubtree();
            }
        }
    } catch (IOException | RuntimeException e) {
    // Fallthrough.
    }
    tw.close();
    return null;
}
#end_block

#method_before
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format.get()) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format.get()) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        case DEFAULT:
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view, GitilesAccess access) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    setTreeFilter(walk, view, access);
    List<RevFilter> filters = new ArrayList<>(3);
    if (isTrue(Iterables.getFirst(view.getParameters().get("no-merges"), null))) {
        filters.add(RevFilter.NO_MERGES);
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        filters.add(IdentRevFilter.author(author));
    }
    String committer = Iterables.getFirst(view.getParameters().get("committer"), null);
    if (committer != null) {
        filters.add(IdentRevFilter.committer(committer));
    }
    if (filters.size() > 1) {
        walk.setRevFilter(AndRevFilter.create(filters));
    } else if (filters.size() == 1) {
        walk.setRevFilter(filters.get(0));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view, GitilesAccess access) throws MissingObjectException, IOException {
    RevWalk walk = new RevWalk(repo);
    try {
        walk.markStart(walk.parseCommit(view.getRevision().getId()));
        if (view.getOldRevision() != Revision.NULL) {
            walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
        }
    } catch (IncorrectObjectTypeException iote) {
        return null;
    }
    setTreeFilter(walk, view, access);
    List<RevFilter> filters = new ArrayList<>(3);
    if (isTrue(Iterables.getFirst(view.getParameters().get("no-merges"), null))) {
        filters.add(RevFilter.NO_MERGES);
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        filters.add(IdentRevFilter.author(author));
    }
    String committer = Iterables.getFirst(view.getParameters().get("committer"), null);
    if (committer != null) {
        filters.add(IdentRevFilter.committer(committer));
    }
    if (filters.size() > 1) {
        walk.setRevFilter(AndRevFilter.create(filters));
    } else if (filters.size() == 1) {
        walk.setRevFilter(filters.get(0));
    }
    return walk;
}
#end_block

#method_before
private static Paginator newPaginator(Repository repo, GitilesView view, GitilesAccess access) throws IOException {
    if (view == null) {
        return null;
    }
    try (RevWalk walk = newWalk(repo, view, access)) {
        Optional<ObjectId> start;
        try {
            start = getStart(view.getParameters(), walk.getObjectReader());
        } catch (IOException e) {
            throw e;
        }
        if (start == null) {
            return null;
        }
        return new Paginator(walk, getLimit(view), start.orNull());
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
}
#method_after
private static Paginator newPaginator(Repository repo, GitilesView view, GitilesAccess access) throws IOException {
    if (view == null) {
        return null;
    }
    try (RevWalk walk = newWalk(repo, view, access)) {
        if (walk == null) {
            return null;
        }
        Optional<ObjectId> start = getStart(view.getParameters(), walk.getObjectReader());
        if (start == null) {
            return null;
        }
        return new Paginator(walk, getLimit(view), start.orNull());
    }
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, false)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        // which would be bad.
        switch(wr.type) {
            case SYMLINK:
            case REGULAR_FILE:
            case EXECUTABLE_FILE:
                writeBlobText(req, res, wr);
                break;
            case TREE:
                writeTreeText(req, res, wr);
                break;
            case GITLINK:
            default:
                renderTextError(req, res, SC_NOT_FOUND, "Not a file");
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    String recursiveStr = req.getParameter("recursive");
    boolean recursive = (recursiveStr != null) && (recursiveStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(recursiveStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view, recursive)) {
        if (wr == null || wr.type != FileType.TREE) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes, recursive), TreeJsonData.Tree.class);
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    // Change 2 is a fast-forward, no need to merge.
    submit(change2.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getCommitterIdent());
    // We need to merge changes 3 and 4.
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // First change stays untouched.
    assertNew(change.getChangeId());
    // The two submit operations should have resulted in two ref-update events
    // and three change-merged events.
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change2.getChangeId(), headAfterFirstSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change4.getChangeId(), headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    PushOneCommit.Result change5 = createChange("Change 5", "f", "f");
    // Change 2 is a fast-forward, no need to merge.
    submit(change2.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterFirstSubmit.getCommitterIdent());
    // We need to merge changes 3, 4 and 5.
    approve(change3.getChangeId());
    approve(change4.getChangeId());
    submit(change5.getChangeId());
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change5.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // First change stays untouched.
    assertNew(change.getChangeId());
    // The two submit operations should have resulted in two ref-update events
    // and three change-merged events.
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change2.getChangeId(), headAfterFirstSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change4.getChangeId(), headAfterSecondSubmit.name(), change5.getChangeId(), headAfterSecondSubmit.name());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    submit(change.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 1"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit two changes at the same time
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    approve(change2.getChangeId());
    submit(change3.getChangeId());
    // Submitting change 3 should result in change 2 also being submitted
    assertMerged(change2.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 3".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change = createChange("Change 1", "b", "b");
    submit(change.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 1"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit three changes at the same time
    PushOneCommit.Result change2 = createChange("Change 2", "c", "c");
    PushOneCommit.Result change3 = createChange("Change 3", "d", "d");
    PushOneCommit.Result change4 = createChange("Change 4", "e", "e");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    // Submitting change 4 should result in changes 2 and 3 also being submitted
    assertMerged(change2.getChangeId());
    assertMerged(change3.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 4".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    assertRefUpdatedEvents(initialHead, headAfterFirstSubmit, headAfterFirstSubmit, headAfterSecondSubmit);
    assertChangeMergedEvents(change.getChangeId(), headAfterFirstSubmit.name(), change2.getChangeId(), headAfterSecondSubmit.name(), change3.getChangeId(), headAfterSecondSubmit.name(), change4.getChangeId(), headAfterSecondSubmit.name());
}
#end_block

#method_before
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    db = unwrap(db);
    for (Change.Id id : ids) {
        Change change = db.changes().get(id);
        if (change == null) {
            log.warn("skipping change {} found in project {} but not in ReviewDb", id.get(), project.get());
            continue;
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#method_after
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    db = unwrap(db);
    for (Change.Id id : ids) {
        Change change = db.changes().get(id);
        if (change == null) {
            log.warn("skipping change {} found in project {} " + "but not in ReviewDb", id, project);
            continue;
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} " + "because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        log.debug("adding change {} found in project {}", id, project);
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#end_block

#method_before
public void assertRefUpdatedEvents(String project, String branch, String... expected) throws Exception {
    ImmutableList<RefUpdatedEvent> events = getRefUpdatedEvents(project, branch, expected.length / 2);
    int i = 0;
    for (RefUpdatedEvent event : events) {
        RefUpdateAttribute actual = event.refUpdate.get();
        String oldRev = expected[i] == null ? "0000000000000000000000000000000000000000" : expected[i];
        String newRev = expected[i + 1] == null ? "0000000000000000000000000000000000000000" : expected[i + 1];
        assertThat(actual.oldRev).isEqualTo(oldRev);
        assertThat(actual.newRev).isEqualTo(newRev);
        i += 2;
    }
}
#method_after
public void assertRefUpdatedEvents(String project, String branch, String... expected) throws Exception {
    ImmutableList<RefUpdatedEvent> events = getRefUpdatedEvents(project, branch, expected.length / 2);
    int i = 0;
    for (RefUpdatedEvent event : events) {
        RefUpdateAttribute actual = event.refUpdate.get();
        String oldRev = expected[i] == null ? ObjectId.zeroId().name() : expected[i];
        String newRev = expected[i + 1] == null ? ObjectId.zeroId().name() : expected[i + 1];
        assertThat(actual.oldRev).isEqualTo(oldRev);
        assertThat(actual.newRev).isEqualTo(newRev);
        i += 2;
    }
}
#end_block

#method_before
// TODO(dborowitz): Support async operations?
public void postUpdate(Context ctx) throws Exception {
}
#method_after
/**
 * Override this method to perform operations after the update.
 *
 * @param ctx context
 */
public void postUpdate(Context ctx) throws Exception {
}
#end_block

#method_before
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void close() {
    MoreExecutors.shutdownAndAwaitTermination(executor, Long.MAX_VALUE, TimeUnit.SECONDS);
    try {
        openIndex.close();
    } finally {
        closedIndex.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects").to(PostWatchedProjects.class);
    post(ACCOUNT_KIND, "watched.projects:delete").to(DeleteWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "oauthtoken").to(GetOAuthToken.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName()) || MagicBranch.isMagicBranchWithAutoClose(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches, "receiveID");
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            String refName = c.getRefName();
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), refName, c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), refName));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(refName) && !refName.startsWith(REFS_CHANGES)) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), refName), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user, "receiveID");
        SubmoduleOp op = subOpFactory.create(orm);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    }
    reject(cmd, "not a commit");
    return false;
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    } else {
        return new RequestState(project.getNameKey());
    }
}
#method_after
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    }
    return new RequestState(project.getNameKey());
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : "null";
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    EnumSet<SubmittedTogetherOption> o = EnumSet.noneOf(SubmittedTogetherOption.class);
    assertSubmittedTogether(chId, o, expected);
}
#end_block

#method_before
protected void assertSubmittedTogether(String chId, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether();
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : "null";
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#method_after
protected void assertSubmittedTogether(String chId, EnumSet<SubmittedTogetherOption> o, String... expected) throws Exception {
    List<ChangeInfo> actual = gApi.changes().id(chId).submittedTogether(o);
    assertThat(actual).hasSize(expected.length);
    assertThat(Iterables.transform(actual, new Function<ChangeInfo, String>() {

        @Override
        public String apply(ChangeInfo input) {
            return input.changeId != null ? input.changeId : input.subject;
        }
    })).containsExactly((Object[]) expected).inOrder();
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
    cd.changeControl(user);
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd), user);
    }
    return completeChangeSetWithoutTopic(db, new ChangeSet(cd), user);
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getProject(), change.getId());
    cd.changeControl(user);
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd, db, null), user);
    }
    return completeChangeSetWithoutTopic(db, new ChangeSet(cd, db, null), user);
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    boolean furtherHiddenChanges = false;
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, project, cId);
                cd.changeControl(user);
                SubmitTypeRecord str = cd.submitTypeRecord();
                if (cd.currentPatchSet().isDraft()) {
                    furtherHiddenChanges = true;
                    continue;
                }
                if (!str.isOk()) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
                }
                if (str.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret, furtherHiddenChanges);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, project, cId);
                SubmitTypeRecord str = cd.submitTypeRecord();
                if (!str.isOk()) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId() + ": " + str.errorMessage);
                }
                if (str.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                // Always include the input, even if merged. This allows
                // SubmitStrategyOp to correct the situation later, assuming it gets
                // returned by byCommitsOnBranchNotMerged below.
                hashes.add(objIdStr);
                for (RevCommit c : rw) {
                    if (!c.equals(commit)) {
                        hashes.add(c.name());
                    }
                }
                if (!hashes.isEmpty()) {
                    Iterable<ChangeData> destChanges = query().byCommitsOnBranchNotMerged(repo, db, cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret, db, user);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes, user);
    while (!done) {
        List<ChangeData> chgs = new ArrayList<>();
        done = true;
        for (ChangeData cd : newCs.changes()) {
            chgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                chgs.addAll(query().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(chgs, newCs.isComplete());
        newCs = completeChangeSetWithoutTopic(db, changes, user);
    }
    return newCs;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes, CurrentUser user) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    while (!done) {
        done = true;
        List<ChangeData> newChgs = new ArrayList<>();
        for (ChangeData cd : changes.changes()) {
            newChgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                newChgs.addAll(query().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = completeChangeSetWithoutTopic(db, new ChangeSet(newChgs, db, null), null);
    }
    return completeChangeSetWithoutTopic(db, changes, user);
}
#end_block

#method_before
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet without having to
    // touch the database. This provides reasonable performance when loading the
    // change screen; callers that care about reading the latest value of these
    // fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#method_after
private InternalChangeQuery query() {
    // Request fields required for completing the ChangeSet without having to
    // touch the database. This provides reasonable performance when loading the
    // change screen; callers that care about reading the latest value of these
    // fields should clear them explicitly using reloadChanges().
    Set<String> fields = ImmutableSet.of(ChangeField.CHANGE.getName(), ChangeField.PATCH_SET.getName(), ChangeField.REVIEWER.getName());
    return queryProvider.get().setRequestedFields(fields);
}
#end_block

#method_before
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        boolean addHiddenDummy = false;
        Change c = resource.getChange();
        List<ChangeData> cds;
        if (c.getStatus().isOpen()) {
            ChangeSet cs = getForOpenChange(c, resource.getControl().getUser());
            cds = cs.changes().asList();
            addHiddenDummy = !cs.isComplete();
        } else if (c.getStatus().asChangeStatus() == ChangeStatus.MERGED) {
            cds = getForMergedChange(c);
        } else {
            cds = getForAbandonedChange();
        }
        if (cds.size() <= 1 && !addHiddenDummy) {
            cds = Collections.emptyList();
        } else {
            // Skip sorting for singleton lists, to avoid WalkSorter opening the
            // repo just to fill out the commit field in PatchSetData.
            cds = sort(cds);
        }
        List<ChangeInfo> ret = json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds);
        if (addHiddenDummy) {
            ChangeInfo i = new ChangeInfo();
            i.subject = "Some Changes are hidden";
            ret.add(i);
        }
        return ret;
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#method_after
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        boolean addHiddenDummy = false;
        Change c = resource.getChange();
        List<ChangeData> cds;
        if (c.getStatus().isOpen()) {
            ChangeSet cs = getForOpenChange(c, resource.getControl().getUser());
            cds = cs.changes().asList();
            addHiddenDummy = !cs.isComplete();
        } else if (c.getStatus().asChangeStatus() == ChangeStatus.MERGED) {
            cds = getForMergedChange(c);
        } else {
            cds = getForAbandonedChange();
        }
        addHiddenDummy &= options.contains(SubmittedTogetherOption.DUMMY);
        if (cds.size() <= 1 && !addHiddenDummy) {
            cds = Collections.emptyList();
        } else {
            // Skip sorting for singleton lists, to avoid WalkSorter opening the
            // repo just to fill out the commit field in PatchSetData.
            cds = sort(cds);
        }
        List<ChangeInfo> ret = json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).formatChangeDatas(cds);
        if (addHiddenDummy) {
            ChangeInfo i = new ChangeInfo();
            i.subject = "Some changes are not visible";
            i.project = null;
            i.branch = null;
            i.submittable = false;
            i.mergeable = false;
            i.changeId = null;
            i._number = 0;
            i.currentRevision = "0";
            i.status = ChangeStatus.NEW;
            RevisionInfo ri = new RevisionInfo();
            ri.commit = new CommitInfo();
            ri.commit.subject = "Some changes are not visible";
            Map<String, RevisionInfo> revs = new LinkedHashMap<>();
            i.revisions = revs;
            i.revisions.put("0", ri);
            ret.add(i);
        }
        return ret;
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#end_block

#method_before
@Test
public void testHiddenDraftChange() throws Exception {
    setApiUser(admin);
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/drafts/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    setApiUser(user);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    String draftId = "null";
    if (isSubmitWholeTopicEnabled()) {
        setApiUser(admin);
        assertSubmittedTogether(id1, draftId);
        assertSubmittedTogether(id2, draftId);
        setApiUser(user);
        assertSubmittedTogether(id2, draftId);
    } else {
        setApiUser(admin);
        assertSubmittedTogether(id1, draftId);
        assertSubmittedTogether(id2);
        setApiUser(user);
        assertSubmittedTogether(id2);
    }
}
#method_after
@Test
public void testHiddenDraftChange() throws Exception {
    setApiUser(admin);
    RevCommit initialHead = getRemoteHead();
    // Create two independent commits and push.
    RevCommit c1_1 = commitBuilder().add("a.txt", "1").message("subject: 1").create();
    String id1 = getChangeId(c1_1);
    pushHead(testRepo, "refs/drafts/master/" + name("connectingTopic"), false);
    testRepo.reset(initialHead);
    setApiUser(user);
    RevCommit c2_1 = commitBuilder().add("b.txt", "2").message("subject: 2").create();
    String id2 = getChangeId(c2_1);
    pushHead(testRepo, "refs/for/master/" + name("connectingTopic"), false);
    String draftId = "Some changes are not visible";
    EnumSet<SubmittedTogetherOption> o1 = EnumSet.noneOf(SubmittedTogetherOption.class);
    EnumSet<SubmittedTogetherOption> o2 = EnumSet.of(SubmittedTogetherOption.DUMMY);
    if (isSubmitWholeTopicEnabled()) {
        setApiUser(admin);
        assertSubmittedTogether(id1, o1, id2, id1);
        assertSubmittedTogether(id2, o1, id2, id1);
        assertSubmittedTogether(id1, o2, id2, id1);
        assertSubmittedTogether(id2, o2, id2, id1);
        setApiUser(user);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id2, o2, id2, draftId);
    } else {
        setApiUser(admin);
        assertSubmittedTogether(id1, o1);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id1, o2);
        assertSubmittedTogether(id2, o2);
        setApiUser(user);
        assertSubmittedTogether(id2, o1);
        assertSubmittedTogether(id2, o2);
    }
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(change.getCommit().name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit headAfterSecondSubmit = getRemoteHead();
    assertThat(headAfterSecondSubmit.getParent(0)).isEqualTo(headAfterFirstSubmit);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, headAfterSecondSubmit);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getCommitterIdent());
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#end_block

#method_before
@Test
public void submitWithRebaseMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    assertThat(headAfterFirstSubmit.name()).isEqualTo(change1.getCommit().name());
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    assertThat(change2.getCommit().getParent(0)).isNotEqualTo(change1.getCommit());
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "third content");
    approve(change2.getChangeId());
    submit(change3.getChangeId());
    assertRebase(testRepo, false);
    assertApproved(change2.getChangeId());
    assertApproved(change3.getChangeId());
    RevCommit headAfterSecondSubmit = parse(getRemoteHead());
    assertThat(headAfterSecondSubmit.getShortMessage()).isEqualTo("Change 3");
    assertThat(headAfterSecondSubmit).isNotEqualTo(change3.getCommit());
    assertCurrentRevision(change3.getChangeId(), 2, headAfterSecondSubmit);
    RevCommit parent = parse(headAfterSecondSubmit.getParent(0));
    assertThat(parent.getShortMessage()).isEqualTo("Change 2");
    assertThat(parent).isNotEqualTo(change2.getCommit());
    assertCurrentRevision(change2.getChangeId(), 2, parent);
    RevCommit grandparent = parse(parent.getParent(0));
    assertThat(grandparent).isEqualTo(change1.getCommit());
    assertCurrentRevision(change1.getChangeId(), 1, grandparent);
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(change1.getCommit().name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitWithRebaseMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content");
    submit(change1.getChangeId());
    RevCommit headAfterFirstSubmit = getRemoteHead();
    assertThat(headAfterFirstSubmit.name()).isEqualTo(change1.getCommit().name());
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    assertThat(change2.getCommit().getParent(0)).isNotEqualTo(change1.getCommit());
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "third content");
    approve(change2.getChangeId());
    submit(change3.getChangeId());
    assertRebase(testRepo, false);
    assertApproved(change2.getChangeId());
    assertApproved(change3.getChangeId());
    RevCommit headAfterSecondSubmit = parse(getRemoteHead());
    assertThat(headAfterSecondSubmit.getShortMessage()).isEqualTo("Change 3");
    assertThat(headAfterSecondSubmit).isNotEqualTo(change3.getCommit());
    assertCurrentRevision(change3.getChangeId(), 2, headAfterSecondSubmit);
    RevCommit parent = parse(headAfterSecondSubmit.getParent(0));
    assertThat(parent.getShortMessage()).isEqualTo("Change 2");
    assertThat(parent).isNotEqualTo(change2.getCommit());
    assertCurrentRevision(change2.getChangeId(), 2, parent);
    RevCommit grandparent = parse(parent.getParent(0));
    assertThat(grandparent).isEqualTo(change1.getCommit());
    assertCurrentRevision(change1.getChangeId(), 1, grandparent);
    ImmutableList<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#end_block

#method_before
public ChangeMergedEvent getOneChangeMerged(String project, String branch, final String changeNumber) throws Exception {
    String key = key(ChangeMergedEvent.TYPE, project, branch.startsWith(R_HEADS) ? branch : R_HEADS + branch);
    assertThat(recordedEvents).containsKey(key);
    List<RefEvent> events = FluentIterable.from(recordedEvents.get(key)).filter(new Predicate<RefEvent>() {

        @Override
        public boolean apply(RefEvent input) {
            assertThat(input).isInstanceOf(ChangeMergedEvent.class);
            ChangeMergedEvent e = (ChangeMergedEvent) input;
            return e.change.get().number.equals(changeNumber);
        }
    }).toList();
    assertThat(events).hasSize(1);
    return (ChangeMergedEvent) (events.get(0));
}
#method_after
public ChangeMergedEvent getOneChangeMerged(String project, String branch, final String changeNumber) throws Exception {
    String key = key(ChangeMergedEvent.TYPE, project, branch.startsWith(R_HEADS) ? branch : R_HEADS + branch);
    assertThat(recordedEvents).containsKey(key);
    List<RefEvent> events = FluentIterable.from(recordedEvents.get(key)).filter(new Predicate<RefEvent>() {

        @Override
        public boolean apply(RefEvent input) {
            assertThat(input).isInstanceOf(ChangeMergedEvent.class);
            ChangeMergedEvent e = (ChangeMergedEvent) input;
            return e.change.get().number.equals(changeNumber);
        }
    }).toList();
    assertThat(events).hasSize(1);
    return (ChangeMergedEvent) events.get(0);
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    submit(change2.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 2"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit two changes at the same time
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    // Submitting change 4 should result in change 3 also being submitted
    assertMerged(change3.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 4".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // The two submit operations should have resulted in two ref-update events
    List<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    // Submit a change so that the remote head advances
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    submit(change2.getChangeId());
    // The remote head should now be a merge of the previous head
    // and "Change 2"
    RevCommit headAfterFirstSubmit = getRemoteLog().get(0);
    assertThat(headAfterFirstSubmit.getParent(1).getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(headAfterFirstSubmit.getParent(0).getId()).isEqualTo(initialHead.getId());
    // Submit two changes at the same time
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    // Submitting change 4 should result in change 3 also being submitted
    assertMerged(change3.getChangeId());
    // The remote head should now be a merge of the new head after
    // the previous submit, and "Change 4".
    RevCommit headAfterSecondSubmit = getRemoteLog().get(0);
    assertThat(headAfterSecondSubmit.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getShortMessage()).isEqualTo(headAfterFirstSubmit.getShortMessage());
    assertThat(headAfterSecondSubmit.getParent(0).getId()).isEqualTo(headAfterFirstSubmit.getId());
    assertPersonEquals(admin.getIdent(), headAfterSecondSubmit.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), headAfterSecondSubmit.getCommitterIdent());
    // The two submit operations should have resulted in two ref-update events
    List<RefEvent> refUpdates = eventRecorder.getRefUpdates(project.get(), "refs/heads/master", 2);
    RefUpdateAttribute refUpdate = ((RefUpdatedEvent) (refUpdates.get(0))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(initialHead.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterFirstSubmit.name());
    refUpdate = ((RefUpdatedEvent) (refUpdates.get(1))).refUpdate.get();
    assertThat(refUpdate.oldRev).isEqualTo(headAfterFirstSubmit.name());
    assertThat(refUpdate.newRev).isEqualTo(headAfterSecondSubmit.name());
}
#end_block

#method_before
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdateAttribute refUpdate = getOneRefUpdate(project.get() + "-refs/heads/master");
    assertThat(refUpdate).isNotNull();
    assertThat(refUpdate.oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.newRev).isEqualTo(updatedHead.name());
}
#method_after
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    RevCommit originalHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    String id1 = change.getChangeId();
    String id2 = change2.getChangeId();
    approve(id1);
    submit(id2);
    RevCommit updatedHead = getRemoteHead();
    assertThat(updatedHead.getId()).isEqualTo(change2.getCommit());
    assertThat(updatedHead.getParent(0).getId()).isEqualTo(change.getCommit());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), updatedHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), updatedHead.getCommitterIdent());
    assertSubmittedTogether(id1, id2, id1);
    assertSubmittedTogether(id2, id2, id1);
    RefUpdatedEvent refUpdate = eventRecorder.getOneRefUpdate(project.get(), "refs/heads/master");
    assertThat(refUpdate.refUpdate.get().oldRev).isEqualTo(originalHead.name());
    assertThat(refUpdate.refUpdate.get().newRev).isEqualTo(updatedHead.name());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    changeMergedEvents = new HashMap<>();
    refUpdatedEvents = HashMultimap.create();
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (event instanceof ChangeMergedEvent) {
                ChangeMergedEvent e = (ChangeMergedEvent) event;
                ChangeAttribute c = e.change.get();
                PatchSetAttribute ps = e.patchSet.get();
                log.debug("Merged {},{} as {}", ps.number, c.number, e.newRev);
                changeMergedEvents.put(e.change.get().number, e.newRev);
            } else if (event instanceof RefUpdatedEvent) {
                RefUpdatedEvent e = (RefUpdatedEvent) event;
                RefUpdateAttribute r = e.refUpdate.get();
                log.debug("Branch {} ref updated from {} to {}", r.refName, r.oldRev, r.newRev);
                refUpdatedEvents.put(r.project + "-" + r.refName, r);
            }
        }

        @Override
        public CurrentUser getUser() {
            return factory.create(user.id);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    eventRecorder = eventRecorderFactory.create(user);
}
#end_block

#method_before
@After
public void cleanup() {
    eventListenerRegistration.remove();
    db.close();
}
#method_after
@After
public void cleanup() {
    eventRecorder.close();
    db.close();
}
#end_block

#method_before
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#method_after
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertMerged(change.changeId);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#end_block

#method_before
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    assertThat(changeMergedEvents).isNotEmpty();
    String newRev = changeMergedEvents.get(Integer.toString(change._number));
    assertThat(newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(newRev);
}
#method_after
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    ChangeMergedEvent event = eventRecorder.getOneChangeMerged(change.project, change.branch, Integer.toString(change._number));
    assertThat(event.newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(event.newRev);
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeSet cs, Project.NameKey project, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CLICK_FAILURE_OTHER_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CLICK_FAILURE_OTHER_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getProject(), resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change(), resource.getControl().getUser());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#end_block

#method_before
@Override
public int compareTo(ProjectHolder other) {
    return other.size < this.size ? -1 : 1;
}
#method_after
@Override
public int compareTo(ProjectHolder other) {
    return ComparisonChain.start().compare(other.size, size).compare(other.name.get(), name.get()).result();
}
#end_block

#method_before
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey project : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(project)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(project, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
            return new Result(sw, false, 0, 0);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#method_after
@Override
public Result indexAll(ChangeIndex index) {
    ProgressMonitor pm = new TextProgressMonitor();
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    SortedSet<ProjectHolder> projects = new TreeSet<>();
    int changeCount = 0;
    Stopwatch sw = Stopwatch.createStarted();
    for (Project.NameKey name : projectCache.all()) {
        try (Repository repo = repoManager.openRepository(name)) {
            int size = ChangeNotes.Factory.scan(repo).size();
            changeCount += size;
            projects.add(new ProjectHolder(name, size));
        } catch (IOException e) {
            log.error("Error collecting projects", e);
            return new Result(sw, false, 0, 0);
        }
        pm.update(1);
    }
    pm.endTask();
    setTotalWork(changeCount);
    return indexAll(index, projects);
}
#end_block

#method_before
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public SiteIndexer.Result indexAll(ChangeIndex index, Iterable<ProjectHolder> projects) {
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", (projects instanceof Collection) ? ((Collection<?>) projects).size() : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, totalWork >= 0 ? totalWork : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = new ArrayList<>();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final ProjectHolder project : projects) {
        ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(executor, index), project.name, doneTask, failedTask, verboseWriter));
        addErrorListener(future, "project " + project.name, projTask, ok);
        futures.add(future);
    }
    try {
        mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    // If too many changes failed, maybe there was a bug in the indexer. Don't
    // trust the results. This is not an exact percentage since we bump the same
    // failure counter if a project can't be read, but close enough.
    int nFailed = failedTask.getCount();
    int nTotal = nFailed + doneTask.getCount();
    double pctFailed = ((double) nFailed) / nTotal * 100;
    if (pctFailed > 10) {
        log.error("Failed {}/{} changes ({}%); not marking new index as ready", nFailed, nTotal, Math.round(pctFailed));
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Map<String, Ref> visibleTags(ProjectControl control, Repository repo, Map<String, Ref> tags) {
    return new VisibleRefFilter(tagCache, changeCache, repo, control, dbProvider.get(), false).filter(tags, true);
}
#method_after
private Map<String, Ref> visibleTags(ProjectControl control, Repository repo, Map<String, Ref> tags) {
    return new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, control, dbProvider.get(), false).filter(tags, true);
}
#end_block

#method_before
boolean isMergedIntoVisibleRef(Repository repo, ReviewDb db, RevWalk rw, RevCommit commit, Collection<Ref> unfilteredRefs) throws IOException {
    VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, this, db, true);
    Map<String, Ref> m = Maps.newHashMapWithExpectedSize(unfilteredRefs.size());
    for (Ref r : unfilteredRefs) {
        m.put(r.getName(), r);
    }
    Map<String, Ref> refs = filter.filter(m, true);
    return !refs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, refs.values());
}
#method_after
boolean isMergedIntoVisibleRef(Repository repo, ReviewDb db, RevWalk rw, RevCommit commit, Collection<Ref> unfilteredRefs) throws IOException {
    VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, this, db, true);
    Map<String, Ref> m = Maps.newHashMapWithExpectedSize(unfilteredRefs.size());
    for (Ref r : unfilteredRefs) {
        m.put(r.getName(), r);
    }
    Map<String, Ref> refs = filter.filter(m, true);
    return !refs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, refs.values());
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    Account userAccount;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    try (Repository repo = repoManager.openRepository(userProjectControl.getProject().getNameKey())) {
        try {
            Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
            for (final String ref : refsMap.keySet()) {
                if (!onlyRefsHeads || ref.startsWith(RefNames.REFS_HEADS)) {
                    stdout.println(ref);
                }
            }
        } catch (IOException e) {
            throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e);
        }
    } catch (RepositoryNotFoundException e) {
        throw die("'" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw die("Error opening: '" + projectControl.getProject().getNameKey());
    }
}
#method_after
@Override
protected void run() throws Failure {
    Account userAccount;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    try (Repository repo = repoManager.openRepository(userProjectControl.getProject().getNameKey())) {
        try {
            Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
            for (final String ref : refsMap.keySet()) {
                if (!onlyRefsHeads || ref.startsWith(RefNames.REFS_HEADS)) {
                    stdout.println(ref);
                }
            }
        } catch (IOException e) {
            throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e);
        }
    } catch (RepositoryNotFoundException e) {
        throw die("'" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw die("Error opening: '" + projectControl.getProject().getNameKey());
    }
}
#end_block

#method_before
@Override
public UploadPack create(Context req, final Repository repo) throws ServiceNotAuthorizedException {
    // Set the request context, but don't bother unsetting, since we don't
    // have an easy way to run code when this instance is done being used.
    // Each operation is run in its own thread, so we don't need to recover
    // its original context anyway.
    threadContext.setContext(req);
    current.set(req);
    try {
        ProjectControl ctl = projectControlFactory.controlFor(req.project, userProvider.get());
        if (!ctl.canRunUploadPack()) {
            throw new ServiceNotAuthorizedException();
        }
        UploadPack up = new UploadPack(repo);
        up.setPackConfig(transferConfig.getPackConfig());
        up.setTimeout(transferConfig.getTimeout());
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, ctl, dbProvider.get(), true));
        List<PreUploadHook> hooks = Lists.newArrayList(preUploadHooks);
        hooks.add(uploadValidatorsFactory.create(ctl.getProject(), repo, "localhost-test"));
        up.setPreUploadHook(PreUploadHookChain.newChain(hooks));
        return up;
    } catch (NoSuchProjectException | IOException e) {
        throw new RuntimeException(e);
    }
}
#method_after
@Override
public UploadPack create(Context req, final Repository repo) throws ServiceNotAuthorizedException {
    // Set the request context, but don't bother unsetting, since we don't
    // have an easy way to run code when this instance is done being used.
    // Each operation is run in its own thread, so we don't need to recover
    // its original context anyway.
    threadContext.setContext(req);
    current.set(req);
    try {
        ProjectControl ctl = projectControlFactory.controlFor(req.project, userProvider.get());
        if (!ctl.canRunUploadPack()) {
            throw new ServiceNotAuthorizedException();
        }
        UploadPack up = new UploadPack(repo);
        up.setPackConfig(transferConfig.getPackConfig());
        up.setTimeout(transferConfig.getTimeout());
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, ctl, dbProvider.get(), true));
        List<PreUploadHook> hooks = Lists.newArrayList(preUploadHooks);
        hooks.add(uploadValidatorsFactory.create(ctl.getProject(), repo, "localhost-test"));
        up.setPreUploadHook(PreUploadHookChain.newChain(hooks));
        return up;
    } catch (NoSuchProjectException | IOException e) {
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
private Set<Change.Id> visibleChanges() {
    if (!showMetadata) {
        return Collections.emptySet();
    }
    Project project = projectCtl.getProject();
    try {
        Set<Change.Id> visibleChanges = new HashSet<>();
        for (ChangeData cd : changeCache.getChangeData(reviewDb, project.getNameKey())) {
            if (projectCtl.controlForIndexedChange(cd.change()).isVisible(reviewDb, cd)) {
                visibleChanges.add(cd.getId());
            }
        }
        return visibleChanges;
    } catch (OrmException e) {
        log.error("Cannot load changes for project " + project.getName() + ", assuming no changes are visible", e);
        return Collections.emptySet();
    }
}
#method_after
private Set<Change.Id> visibleChanges() {
    if (!showMetadata) {
        return Collections.emptySet();
    } else if (changeCache == null) {
        return visibleChangesByScan();
    }
    return visibleChangesBySearch();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db, true));
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPostUploadHook(uploadMetrics);
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
        session.setPeerAgent(up.getPeerUserAgent());
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, projectControl, db, true));
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPostUploadHook(uploadMetrics);
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
        session.setPeerAgent(up.getPeerUserAgent());
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeNotesFactory, changeCache, repo, pc, db.get(), true));
    next.doFilter(request, response);
}
#end_block

#method_before
private void assertRefs(String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try (Repository repo = repoManager.openRepository(project)) {
        ProjectControl ctl = projectControlFactory.controlFor(project, userProvider.get());
        VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, ctl, new DisabledReviewDb(), true);
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        enableDb(ctx);
    }
}
#method_after
private void assertRefs(String... expectedWithMeta) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        assertRefs(repo, new VisibleRefFilter(tagCache, notesFactory, changeCache, repo, projectControl(), new DisabledReviewDb(), true), true, expectedWithMeta);
    }
}
#end_block

#method_before
private void assertRefs(String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = disableDb();
    try (Repository repo = repoManager.openRepository(project)) {
        ProjectControl ctl = projectControlFactory.controlFor(project, userProvider.get());
        VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, ctl, new DisabledReviewDb(), true);
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        enableDb(ctx);
    }
}
#method_after
private void assertRefs(Repository repo, VisibleRefFilter filter, boolean disableDb, String... expectedWithMeta) throws Exception {
    List<String> expected = new ArrayList<>(expectedWithMeta.length);
    for (String r : expectedWithMeta) {
        if (notesMigration.writeChanges() || !r.endsWith(RefNames.META_SUFFIX)) {
            expected.add(r);
        }
    }
    AcceptanceTestRequestScope.Context ctx = null;
    if (disableDb) {
        ctx = disableDb();
    }
    try {
        Map<String, Ref> all = repo.getAllRefs();
        assertThat(filter.filter(all, false).keySet()).containsExactlyElementsIn(expected);
    } finally {
        if (disableDb) {
            enableDb(ctx);
        }
    }
}
#end_block

#method_before
@Test
public void gitLink() {
    MarkdownToHtml md = MarkdownToHtml.builder().setGitilesView(view).setConfig(new MarkdownConfig(config)).setFilePath("index.md").build();
    String url;
    url = "git://example.com/repo.git";
    assertThat(md.href(url)).isEqualTo(url);
    assertThat(md.href("git:example.com/repo.git")).isEqualTo("#zSoyz");
    assertThat(md.href("git://")).isEqualTo("#zSoyz");
}
#method_after
@Test
public void gitLink() {
    MarkdownToHtml md = MarkdownToHtml.builder().setGitilesView(view).setConfig(new MarkdownConfig(config)).setFilePath("index.md").build();
    String url;
    url = "git://example.com/repo.git";
    assertThat(md.href(url)).isEqualTo(url);
    assertThat(md.href("git:example.com/repo.git")).isEqualTo("#zSoyz");
    assertThat(md.href("git://")).isEqualTo("#zSoyz");
    assertThat(md.href("git://example.com/../root")).isEqualTo("#zSoyz");
    assertThat(md.href("git://example.com/root/..")).isEqualTo("#zSoyz");
}
#end_block

#method_before
@Test
public void getDiffPreferences() throws Exception {
    DiffPreferencesInfo d = DiffPreferencesInfo.defaults();
    DiffPreferencesInfo o = gApi.accounts().id(admin.getId().toString()).getDiffPreferences();
    assertThat(o.context).isEqualTo(d.context);
    assertThat(o.tabSize).isEqualTo(d.tabSize);
    assertThat(o.lineLength).isEqualTo(d.lineLength);
    assertThat(o.cursorBlinkRate).isEqualTo(d.cursorBlinkRate);
    assertThat(o.expandAllComments).isNull();
    assertThat(o.intralineDifference).isEqualTo(d.intralineDifference);
    assertThat(o.manualReview).isNull();
    assertThat(o.retainHeader).isNull();
    assertThat(o.showLineEndings).isEqualTo(d.showLineEndings);
    assertThat(o.showTabs).isEqualTo(d.showTabs);
    assertThat(o.showWhitespaceErrors).isEqualTo(d.showWhitespaceErrors);
    assertThat(o.skipDeleted).isNull();
    assertThat(o.skipUnchanged).isNull();
    assertThat(o.skipUncommented).isNull();
    assertThat(o.syntaxHighlighting).isEqualTo(d.syntaxHighlighting);
    assertThat(o.hideTopMenu).isNull();
    assertThat(o.autoHideDiffTableHeader).isEqualTo(d.autoHideDiffTableHeader);
    assertThat(o.hideLineNumbers).isNull();
    assertThat(o.renderEntireFile).isNull();
    assertThat(o.hideEmptyPane).isNull();
    assertThat(o.matchBrackets).isNull();
    assertThat(o.ignoreWhitespace).isEqualTo(d.ignoreWhitespace);
    assertThat(o.theme).isEqualTo(d.theme);
}
#method_after
@Test
public void getDiffPreferences() throws Exception {
    DiffPreferencesInfo d = DiffPreferencesInfo.defaults();
    DiffPreferencesInfo o = gApi.accounts().id(admin.getId().toString()).getDiffPreferences();
    assertPrefs(o, d);
}
#end_block

#method_before
@Test
public void setDiffPreferences() throws Exception {
    DiffPreferencesInfo i = DiffPreferencesInfo.defaults();
    // change all default values
    i.context *= -1;
    i.tabSize *= -1;
    i.lineLength *= -1;
    i.cursorBlinkRate = 500;
    i.theme = Theme.MIDNIGHT;
    i.ignoreWhitespace = Whitespace.IGNORE_ALL;
    i.expandAllComments ^= true;
    i.intralineDifference ^= true;
    i.manualReview ^= true;
    i.retainHeader ^= true;
    i.showLineEndings ^= true;
    i.showTabs ^= true;
    i.showWhitespaceErrors ^= true;
    i.skipDeleted ^= true;
    i.skipUnchanged ^= true;
    i.skipUncommented ^= true;
    i.syntaxHighlighting ^= true;
    i.hideTopMenu ^= true;
    i.autoHideDiffTableHeader ^= true;
    i.hideLineNumbers ^= true;
    i.renderEntireFile ^= true;
    i.hideEmptyPane ^= true;
    i.matchBrackets ^= true;
    DiffPreferencesInfo o = gApi.accounts().id(admin.getId().toString()).setDiffPreferences(i);
    assertThat(o.context).isEqualTo(i.context);
    assertThat(o.tabSize).isEqualTo(i.tabSize);
    assertThat(o.lineLength).isEqualTo(i.lineLength);
    assertThat(o.cursorBlinkRate).isEqualTo(i.cursorBlinkRate);
    assertThat(o.expandAllComments).isEqualTo(i.expandAllComments);
    assertThat(o.intralineDifference).isNull();
    assertThat(o.manualReview).isEqualTo(i.manualReview);
    assertThat(o.retainHeader).isEqualTo(i.retainHeader);
    assertThat(o.showLineEndings).isNull();
    assertThat(o.showTabs).isNull();
    assertThat(o.showWhitespaceErrors).isNull();
    assertThat(o.skipDeleted).isEqualTo(i.skipDeleted);
    assertThat(o.skipUnchanged).isEqualTo(i.skipUnchanged);
    assertThat(o.skipUncommented).isEqualTo(i.skipUncommented);
    assertThat(o.syntaxHighlighting).isNull();
    assertThat(o.hideTopMenu).isEqualTo(i.hideTopMenu);
    assertThat(o.autoHideDiffTableHeader).isNull();
    assertThat(o.hideLineNumbers).isEqualTo(i.hideLineNumbers);
    assertThat(o.renderEntireFile).isEqualTo(i.renderEntireFile);
    assertThat(o.hideEmptyPane).isEqualTo(i.hideEmptyPane);
    assertThat(o.matchBrackets).isEqualTo(i.matchBrackets);
    assertThat(o.ignoreWhitespace).isEqualTo(i.ignoreWhitespace);
    assertThat(o.theme).isEqualTo(i.theme);
    // Partially fill input record
    i = new DiffPreferencesInfo();
    i.tabSize = 42;
    DiffPreferencesInfo a = gApi.accounts().id(admin.getId().toString()).setDiffPreferences(i);
    assertThat(a.context).isEqualTo(o.context);
    assertThat(a.tabSize).isEqualTo(42);
    assertThat(a.lineLength).isEqualTo(o.lineLength);
    assertThat(a.expandAllComments).isEqualTo(o.expandAllComments);
    assertThat(a.intralineDifference).isNull();
    assertThat(a.manualReview).isEqualTo(o.manualReview);
    assertThat(a.retainHeader).isEqualTo(o.retainHeader);
    assertThat(a.showLineEndings).isNull();
    assertThat(a.showTabs).isNull();
    assertThat(a.showWhitespaceErrors).isNull();
    assertThat(a.skipDeleted).isEqualTo(o.skipDeleted);
    assertThat(a.skipUnchanged).isEqualTo(o.skipUnchanged);
    assertThat(a.skipUncommented).isEqualTo(o.skipUncommented);
    assertThat(a.syntaxHighlighting).isNull();
    assertThat(a.hideTopMenu).isEqualTo(o.hideTopMenu);
    assertThat(a.autoHideDiffTableHeader).isNull();
    assertThat(a.hideLineNumbers).isEqualTo(o.hideLineNumbers);
    assertThat(a.renderEntireFile).isEqualTo(o.renderEntireFile);
    assertThat(a.hideEmptyPane).isEqualTo(o.hideEmptyPane);
    assertThat(a.ignoreWhitespace).isEqualTo(o.ignoreWhitespace);
    assertThat(a.theme).isEqualTo(o.theme);
}
#method_after
@Test
public void setDiffPreferences() throws Exception {
    DiffPreferencesInfo i = DiffPreferencesInfo.defaults();
    // change all default values
    i.context *= -1;
    i.tabSize *= -1;
    i.lineLength *= -1;
    i.cursorBlinkRate = 500;
    i.theme = Theme.MIDNIGHT;
    i.ignoreWhitespace = Whitespace.IGNORE_ALL;
    i.expandAllComments ^= true;
    i.intralineDifference ^= true;
    i.manualReview ^= true;
    i.retainHeader ^= true;
    i.showLineEndings ^= true;
    i.showTabs ^= true;
    i.showWhitespaceErrors ^= true;
    i.skipDeleted ^= true;
    i.skipUnchanged ^= true;
    i.skipUncommented ^= true;
    i.syntaxHighlighting ^= true;
    i.hideTopMenu ^= true;
    i.autoHideDiffTableHeader ^= true;
    i.hideLineNumbers ^= true;
    i.renderEntireFile ^= true;
    i.hideEmptyPane ^= true;
    i.matchBrackets ^= true;
    DiffPreferencesInfo o = gApi.accounts().id(admin.getId().toString()).setDiffPreferences(i);
    assertPrefs(o, i);
    // Partially fill input record
    i = new DiffPreferencesInfo();
    i.tabSize = 42;
    DiffPreferencesInfo a = gApi.accounts().id(admin.getId().toString()).setDiffPreferences(i);
    assertPrefs(a, o, "tabSize");
    assertThat(a.tabSize).isEqualTo(42);
}
#end_block

#method_before
@Test
public void getDiffPreferencesWithConfiguredDefaults() throws Exception {
    DiffPreferencesInfo d = DiffPreferencesInfo.defaults();
    int newLineLength = d.lineLength + 10;
    int newTabSize = d.tabSize * 2;
    DiffPreferencesInfo update = new DiffPreferencesInfo();
    update.lineLength = newLineLength;
    update.tabSize = newTabSize;
    gApi.config().server().setDefaultDiffPreferences(update);
    DiffPreferencesInfo o = gApi.accounts().id(admin.getId().toString()).getDiffPreferences();
    // assert configured defaults
    assertThat(o.lineLength).isEqualTo(newLineLength);
    assertThat(o.tabSize).isEqualTo(newTabSize);
    // assert hard-coded defaults
    assertThat(o.context).isEqualTo(d.context);
    assertThat(o.cursorBlinkRate).isEqualTo(d.cursorBlinkRate);
    assertThat(o.expandAllComments).isNull();
    assertThat(o.intralineDifference).isEqualTo(d.intralineDifference);
    assertThat(o.manualReview).isNull();
    assertThat(o.retainHeader).isNull();
    assertThat(o.showLineEndings).isEqualTo(d.showLineEndings);
    assertThat(o.showTabs).isEqualTo(d.showTabs);
    assertThat(o.showWhitespaceErrors).isEqualTo(d.showWhitespaceErrors);
    assertThat(o.skipDeleted).isNull();
    assertThat(o.skipUnchanged).isNull();
    assertThat(o.skipUncommented).isNull();
    assertThat(o.syntaxHighlighting).isEqualTo(d.syntaxHighlighting);
    assertThat(o.hideTopMenu).isNull();
    assertThat(o.autoHideDiffTableHeader).isEqualTo(d.autoHideDiffTableHeader);
    assertThat(o.hideLineNumbers).isNull();
    assertThat(o.renderEntireFile).isNull();
    assertThat(o.hideEmptyPane).isNull();
    assertThat(o.matchBrackets).isNull();
    assertThat(o.ignoreWhitespace).isEqualTo(d.ignoreWhitespace);
    assertThat(o.theme).isEqualTo(d.theme);
}
#method_after
@Test
public void getDiffPreferencesWithConfiguredDefaults() throws Exception {
    DiffPreferencesInfo d = DiffPreferencesInfo.defaults();
    int newLineLength = d.lineLength + 10;
    int newTabSize = d.tabSize * 2;
    DiffPreferencesInfo update = new DiffPreferencesInfo();
    update.lineLength = newLineLength;
    update.tabSize = newTabSize;
    gApi.config().server().setDefaultDiffPreferences(update);
    DiffPreferencesInfo o = gApi.accounts().id(admin.getId().toString()).getDiffPreferences();
    // assert configured defaults
    assertThat(o.lineLength).isEqualTo(newLineLength);
    assertThat(o.tabSize).isEqualTo(newTabSize);
    // assert hard-coded defaults
    assertPrefs(o, d, "lineLength", "tabSize");
}
#end_block

#method_before
public static ObjectId parseBaseRevision(Repository repo, Project.NameKey projectName, String baseRevision) throws InvalidRevisionException {
    try {
        final ObjectId revid = repo.resolve(baseRevision);
        if (revid == null) {
            throw new InvalidRevisionException();
        }
        return revid;
    } catch (IOException err) {
        log.error("Cannot resolve \"" + baseRevision + "\" in project \"" + projectName.get() + "\"", err);
        throw new InvalidRevisionException();
    } catch (RevisionSyntaxException err) {
        log.error("Invalid revision syntax \"" + baseRevision + "\"", err);
        throw new InvalidRevisionException();
    }
}
#method_after
public static ObjectId parseBaseRevision(Repository repo, Project.NameKey projectName, String baseRevision) throws InvalidRevisionException {
    try {
        ObjectId revid = repo.resolve(baseRevision);
        if (revid == null) {
            throw new InvalidRevisionException();
        }
        return revid;
    } catch (IOException err) {
        log.error("Cannot resolve \"" + baseRevision + "\" in project \"" + projectName.get() + "\"", err);
        throw new InvalidRevisionException();
    } catch (RevisionSyntaxException err) {
        log.error("Invalid revision syntax \"" + baseRevision + "\"", err);
        throw new InvalidRevisionException();
    }
}
#end_block

#method_before
public static String getRefPrefix(final String refName) {
    final int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#method_after
public static String getRefPrefix(String refName) {
    int i = refName.lastIndexOf('/');
    if (i > Constants.R_HEADS.length() - 1) {
        return refName.substring(0, i);
    }
    return Constants.R_HEADS;
}
#end_block

#method_before
private void initAllUsers(Repository git) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription("Individual user settings and preferences.");
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, false, true, registered);
        grant(config, users, Permission.PUSH, false, true, registered);
        AccessSection defaults = config.getAccessSection(RefNames.REFS_USERS_DEFAULT, true);
        defaults.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.READ, admin);
        defaults.getPermission(Permission.PUSH, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.PUSH, admin);
        defaults.getPermission(Permission.CREATE, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.CREATE, admin);
        config.commit(md);
    }
}
#method_after
private void initAllUsers(Repository git) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        ProjectConfig config = ProjectConfig.read(md);
        Project project = config.getProject();
        project.setDescription("Individual user settings and preferences.");
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        LabelType cr = AllProjectsCreator.initCodeReviewLabel(config);
        grant(config, users, Permission.READ, false, true, registered);
        grant(config, users, Permission.PUSH, false, true, registered);
        grant(config, users, Permission.SUBMIT, false, true, registered);
        grant(config, users, cr, -2, 2, registered);
        AccessSection defaults = config.getAccessSection(RefNames.REFS_USERS_DEFAULT, true);
        defaults.getPermission(Permission.READ, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.READ, admin);
        defaults.getPermission(Permission.PUSH, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.PUSH, admin);
        defaults.getPermission(Permission.CREATE, true).setExclusiveGroup(true);
        grant(config, defaults, Permission.CREATE, admin);
        config.commit(md);
    }
}
#end_block

#method_before
@Test
public void pushToUserBranchForReview() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    String userRefName = RefNames.refsUsers(admin.id);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRefName + ":userRef");
    allUsersRepo.reset("userRef");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    PushOneCommit.Result r = push.to(MagicBranch.NEW_CHANGE + userRefName);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    r = push.to(MagicBranch.NEW_CHANGE + RefNames.REFS_USERS_SELF);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
}
#method_after
@Test
public void pushToUserBranchForReview() throws Exception {
    // change something in the user preferences to ensure that the user branch
    // is created
    GeneralPreferencesInfo input = new GeneralPreferencesInfo();
    input.changesPerPage = GeneralPreferencesInfo.defaults().changesPerPage + 10;
    gApi.accounts().self().setPreferences(input);
    String userRefName = RefNames.refsUsers(admin.id);
    TestRepository<InMemoryRepository> allUsersRepo = cloneProject(allUsers);
    fetch(allUsersRepo, userRefName + ":userRef");
    allUsersRepo.reset("userRef");
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    PushOneCommit.Result r = push.to(MagicBranch.NEW_CHANGE + userRefName);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
    push = pushFactory.create(db, admin.getIdent(), allUsersRepo);
    r = push.to(MagicBranch.NEW_CHANGE + RefNames.REFS_USERS_SELF);
    r.assertOkStatus();
    assertThat(r.getChange().change().getDest().get()).isEqualTo(userRefName);
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).current().submit();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        config.getAccessSection(RefNames.REFS_USERS + "*", true).remove(new Permission(Permission.READ));
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, true, registered);
        grant(config, users, Permission.PUSH, true, registered);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    try (Repository git = repoManager.openRepository(allUsersName);
        MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        config.getAccessSection(RefNames.REFS_USERS + "*", true).remove(new Permission(Permission.READ));
        GroupReference registered = SystemGroupBackend.getGroup(REGISTERED_USERS);
        AccessSection users = config.getAccessSection(RefNames.REFS_USERS + "${" + RefPattern.USERID_SHARDED + "}", true);
        grant(config, users, Permission.READ, true, registered);
        grant(config, users, Permission.PUSH, true, registered);
        grant(config, users, Permission.SUBMIT, true, registered);
        for (LabelType lt : getLabelTypes(config)) {
            if ("Code-Review".equals(lt.getName()) || "Verified".equals(lt.getName())) {
                grant(config, users, lt, lt.getMin().getValue(), lt.getMax().getValue(), registered);
            }
        }
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        md.setMessage(COMMIT_MSG);
        config.commit(md);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
@Override
int getCmLine(int line, DisplaySide side) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(side, line, 0, 0, // Dummy DiffChunkInfo
    false), getDiffChunkComparator());
    if (res >= 0) {
        return chunks.get(res).getCmLine();
    }
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        if (side == DisplaySide.A && info.isEdit() && info.getSide() == DisplaySide.B) {
            // Need to use the start and cmLine of the deletion chunk
            UnifiedDiffChunkInfo delete = chunks.get(res - 2);
            if (line <= delete.getEnd()) {
                return delete.getCmLine() + line - delete.getStart();
            }
            // Need to add the length of the insertion chunk
            return delete.getCmLine() + line - delete.getStart() + info.getEnd() - info.getStart() + 1;
        } else if (side == info.getSide()) {
            return info.getCmLine() + line - info.getStart();
        } else {
            return info.getCmLine() + lineMapper.lineOnOther(side, line).getLine() - info.getStart();
        }
    }
    return line;
}
#method_after
@Override
int getCmLine(int line, DisplaySide side) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(side, line, 0, 0, // Dummy DiffChunkInfo
    false), getDiffChunkComparator());
    if (res >= 0) {
        return chunks.get(res).getCmLine();
    }
    // The line might be within a DiffChunk
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        if (side == DisplaySide.A && info.isEdit() && info.getSide() == DisplaySide.B) {
            // Need to use the start and cmLine of the deletion chunk
            UnifiedDiffChunkInfo delete = chunks.get(res - 2);
            if (line <= delete.getEnd()) {
                return delete.getCmLine() + line - delete.getStart();
            }
            // Need to add the length of the insertion chunk
            return delete.getCmLine() + line - delete.getStart() + info.getEnd() - info.getStart() + 1;
        } else if (side == info.getSide()) {
            return info.getCmLine() + line - info.getStart();
        } else {
            return info.getCmLine() + lineMapper.lineOnOther(side, line).getLine() - info.getStart();
        }
    }
    return line;
}
#end_block

#method_before
LineRegionInfo getLineRegionInfoFromCmLine(int cmLine) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(DisplaySide.A, 0, 0, cmLine, // Dummy DiffChunkInfo
    false), getDiffChunkComparatorCmLine());
    if (res >= 0) {
        // The line is right at the start of a diff chunk.
        UnifiedDiffChunkInfo info = chunks.get(res);
        return new LineRegionInfo(info.getStart(), displaySideToRegionType(info.getSide()));
    }
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        int lineOnInfoSide = info.getStart() + cmLine - info.getCmLine();
        if (lineOnInfoSide > info.getEnd()) {
            // After a diff chunk
            if (info.getSide() == DisplaySide.A) {
                // on side B with a common region.
                return new LineRegionInfo(lineMapper.lineOnOther(DisplaySide.A, lineOnInfoSide).getLine(), RegionType.COMMON);
            }
            return new LineRegionInfo(lineOnInfoSide, RegionType.COMMON);
        }
        // Within a diff chunk
        return new LineRegionInfo(lineOnInfoSide, displaySideToRegionType(info.getSide()));
    }
    // belongs to a common region.
    return new LineRegionInfo(cmLine, RegionType.COMMON);
}
#method_after
LineRegionInfo getLineRegionInfoFromCmLine(int cmLine) {
    int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(DisplaySide.A, 0, 0, cmLine, // Dummy DiffChunkInfo
    false), getDiffChunkComparatorCmLine());
    if (res >= 0) {
        // The line is right at the start of a diff chunk.
        UnifiedDiffChunkInfo info = chunks.get(res);
        return new LineRegionInfo(info.getStart(), displaySideToRegionType(info.getSide()));
    }
    // The line might be within or after a diff chunk.
    res = -res - 1;
    if (res > 0) {
        UnifiedDiffChunkInfo info = chunks.get(res - 1);
        int lineOnInfoSide = info.getStart() + cmLine - info.getCmLine();
        if (lineOnInfoSide > info.getEnd()) {
            // After a diff chunk
            if (info.getSide() == DisplaySide.A) {
                // on side B with a common region.
                return new LineRegionInfo(lineMapper.lineOnOther(DisplaySide.A, lineOnInfoSide).getLine(), RegionType.COMMON);
            }
            return new LineRegionInfo(lineOnInfoSide, RegionType.COMMON);
        }
        // Within a diff chunk
        return new LineRegionInfo(lineOnInfoSide, displaySideToRegionType(info.getSide()));
    }
    // belongs to a common region.
    return new LineRegionInfo(cmLine, RegionType.COMMON);
}
#end_block

#method_before
public static boolean isRefsEditOf(String ref, Account.Id accountId) {
    String prefix = new StringBuilder(refsUsers(accountId)).append('/').append(EDIT_PREFIX).toString();
    return ref.startsWith(prefix);
}
#method_after
public static boolean isRefsEditOf(String ref, Account.Id accountId) {
    if (accountId == null) {
        return false;
    }
    String prefix = new StringBuilder(refsUsers(accountId)).append('/').append(EDIT_PREFIX).toString();
    return ref.startsWith(prefix);
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = new ArrayList<>();
    List<PluginEntry> servlets = new ArrayList<>();
    List<PluginEntry> restApis = new ArrayList<>();
    List<PluginEntry> docs = new ArrayList<>();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, final String prefix, final String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = new ArrayList<>();
    List<PluginEntry> servlets = new ArrayList<>();
    List<PluginEntry> restApis = new ArrayList<>();
    List<PluginEntry> docs = new ArrayList<>();
    PluginEntry about = null;
    Predicate<PluginEntry> filter = new Predicate<PluginEntry>() {

        @Override
        public boolean apply(PluginEntry entry) {
            String name = entry.getName();
            Optional<Long> size = entry.getSize();
            if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent()) {
                if (size.get() <= 0 || size.get() > SMALL_RESOURCE) {
                    log.warn(String.format("Plugin %s: %s omitted from document index. " + "Size %d out of range (0,%d).", pluginName, name.substring(prefix.length()), size.get(), SMALL_RESOURCE));
                    return false;
                }
                return true;
            }
            return false;
        }
    };
    List<PluginEntry> entries = FluentIterable.from(Collections.list(scanner.entries())).filter(filter).toList();
    for (PluginEntry entry : entries) {
        String name = entry.getName().substring(prefix.length());
        if (name.startsWith("cmd-")) {
            cmds.add(entry);
        } else if (name.startsWith("servlet-")) {
            servlets.add(entry);
        } else if (name.startsWith("rest-api-")) {
            restApis.add(entry);
        } else if (name.startsWith("about.")) {
            if (about == null) {
                about = entry;
            } else {
                log.warn(String.format("Plugin %s: Multiple 'about' documents found; using %s", pluginName, about.getName().substring(prefix.length())));
            }
        } else {
            docs.add(entry);
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#method_after
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
        return Iterables.concat(emails, ImmutableSet.of(user.getUserName()));
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#end_block

#method_before
public void remove(ContributorAgreement section) {
    if (section != null) {
        accessSections.remove(section.getName());
    }
}
#method_after
public void remove(AccessSection section, Permission permission) {
    if (permission == null) {
        remove(section);
    } else if (section != null) {
        AccessSection a = accessSections.get(section.getName());
        a.remove(permission);
        if (a.getPermissions().isEmpty()) {
            remove(a);
        }
    }
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) & isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private List<String> getUsernames(CurrentUser user) {
    List<String> r;
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        r = new ArrayList<>(emails.size() + 1);
        r.addAll(emails);
    } else {
        r = new ArrayList<>(1);
    }
    if (user.getUserName() != null) {
        r.add(user.getUserName());
    }
    return r;
}
#method_after
private Iterable<String> getUsernames(CurrentUser user) {
    if (user.isIdentifiedUser()) {
        Set<String> emails = user.asIdentifiedUser().getEmailAddresses();
        if (user.getUserName() == null) {
            return emails;
        } else if (emails.isEmpty()) {
            return ImmutableSet.of(user.getUserName());
        }
        Iterables.concat(emails, ImmutableSet.of(user.getUserName()));
    }
    if (user.getUserName() != null) {
        return ImmutableSet.of(user.getUserName());
    }
    return ImmutableSet.of();
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, CurrentUser user) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = new LinkedHashMap<>();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (sm.match(ref, user)) {
                sectionToProject.put(sm.section, sm.project);
                break;
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#end_block

#method_before
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = Lists.newArrayList();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#method_after
private Capable verifyActiveContributorAgreement() {
    if (!(user.isIdentifiedUser())) {
        return new Capable("Must be logged in to verify Contributor Agreement");
    }
    final IdentifiedUser iUser = user.asIdentifiedUser();
    List<AccountGroup.UUID> okGroupIds = new ArrayList<>();
    for (ContributorAgreement ca : contributorAgreements) {
        List<AccountGroup.UUID> groupIds;
        groupIds = okGroupIds;
        for (PermissionRule rule : ca.getAccepted()) {
            if ((rule.getAction() == Action.ALLOW) && (rule.getGroup() != null) && (rule.getGroup().getUUID() != null)) {
                groupIds.add(new AccountGroup.UUID(rule.getGroup().getUUID().get()));
            }
        }
    }
    if (iUser.getEffectiveGroups().containsAnyOf(okGroupIds)) {
        return Capable.OK;
    }
    final StringBuilder msg = new StringBuilder();
    msg.append(" A Contributor Agreement must be completed before uploading");
    if (canonicalWebUrl != null) {
        msg.append(":\n\n  ");
        msg.append(canonicalWebUrl);
        msg.append("#");
        msg.append(PageLinks.SETTINGS_AGREEMENTS);
        msg.append("\n");
    } else {
        msg.append(".");
    }
    msg.append("\n");
    return new Capable(msg.toString());
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().values();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getUser().isIdentifiedUser()) {
        Collection<Account.Id> results = changeData(db, cd).reviewers().all();
        return results.contains(getUser().getAccountId());
    }
    return false;
}
#end_block

#method_before
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSuperProjects(db, branches, "receiveID");
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : batch.getCommands()) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user);
        op.updateSuperProjects(branches, "receiveID", orm);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (allUsersName.equals(projectControl.getProject().getNameKey()) && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            cmd.setResult(OK);
            String userRefName = RefNames.refsUsers(user.getAccountId());
            try {
                Ref userRef = rp.getRepository().getRefDatabase().exactRef(userRefName);
                ObjectId oldId = userRef != null ? userRef.getObjectId() : ObjectId.zeroId();
                ReceiveCommand.Type type;
                switch(cmd.getType()) {
                    case CREATE:
                    case UPDATE:
                        type = userRef != null ? ReceiveCommand.Type.UPDATE : ReceiveCommand.Type.CREATE;
                        break;
                    case DELETE:
                    case UPDATE_NONFASTFORWARD:
                        type = cmd.getType();
                        break;
                    default:
                        reject(cmd);
                        continue;
                }
                cmd = new ReceiveCommand(oldId, cmd.getNewId(), userRefName, type);
            } catch (IOException e) {
                log.error(String.format("Failed to lookup %s refs in %s", userRefName, project.getName()));
                reject(cmd);
            }
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(cmd.getRefName())) {
            final ReceiveCommand orgCmd = cmd;
            cmd = new ReceiveCommand(cmd.getOldId(), cmd.getNewId(), RefNames.refsUsers(user.getAccountId()), cmd.getType()) {

                @Override
                public void setResult(Result s, String m) {
                    super.setResult(s, m);
                    orgCmd.setResult(s, m);
                }
            };
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(rp.getRevWalk(), cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectControl.getProjectState().isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, SetMultimap<ObjectId, Ref> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.put(ref.getObjectId(), ref);
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        SetMultimap<ObjectId, Ref> existing = HashMultimap.create();
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.keySet().contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ctx.saveChange();
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
public static String refsDraftComments(Account.Id accountId, Change.Id changeId) {
    StringBuilder r = buildRefsPrefix(REFS_DRAFT_COMMENTS, accountId.get());
    r.append(changeId.get());
    return r.toString();
}
#method_after
public static String refsDraftComments(Change.Id changeId, Account.Id accountId) {
    StringBuilder r = buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get());
    r.append(accountId.get());
    return r.toString();
}
#end_block

#method_before
public static String refsDraftCommentsPrefix(Account.Id accountId) {
    return buildRefsPrefix(REFS_DRAFT_COMMENTS, accountId.get()).toString();
}
#method_after
public static String refsDraftCommentsPrefix(Change.Id changeId) {
    return buildRefsPrefix(REFS_DRAFT_COMMENTS, changeId.get()).toString();
}
#end_block

#method_before
public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) {
    logDebug("Checking for a subscription of " + src);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    if (subscriptions == null) {
        return ret;
    }
    for (SubmoduleSubscription s : subscriptions) {
        if (s.getSubmodule().equals(src)) {
            logDebug("Found " + s);
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> subscribedTo(Branch.NameKey src) {
    logDebug("Checking for a subscription of " + src);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    for (SubmoduleSubscription s : subscriptions) {
        if (s.getSubmodule().equals(src)) {
            logDebug("Found " + s);
            ret.add(s);
        }
    }
    return ret;
}
#end_block

#method_before
protected void prepareRelativeSubmoduleConfigEntry(Config config, String subscribeToRepoPrefix, String subscribeToRepo, String subscribeToBranch) {
    subscribeToRepo = name(subscribeToRepo);
    // The submodule subscription module checks for gerrit.canonicalWebUrl to
    // detect if it's configured for automatic updates. It doesn't matter if
    // it serves from that URL.
    String url = subscribeToRepoPrefix + subscribeToRepo;
    config.setString("submodule", subscribeToRepo, "path", subscribeToRepo);
    config.setString("submodule", subscribeToRepo, "url", url);
    if (subscribeToBranch != null) {
        config.setString("submodule", subscribeToRepo, "branch", subscribeToBranch);
    }
}
#method_after
protected void prepareRelativeSubmoduleConfigEntry(Config config, String subscribeToRepoPrefix, String subscribeToRepo, String subscribeToBranch) {
    subscribeToRepo = name(subscribeToRepo);
    String url = subscribeToRepoPrefix + subscribeToRepo;
    config.setString("submodule", subscribeToRepo, "path", subscribeToRepo);
    config.setString("submodule", subscribeToRepo, "url", url);
    if (subscribeToBranch != null) {
        config.setString("submodule", subscribeToRepo, "branch", subscribeToBranch);
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getRevision().get()) : ObjectId.fromString(edit.getBasePatchSet().getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws IOException {
    try {
        ChangeEdit edit = rsrc.getChangeEdit();
        return Response.ok(fileContentUtil.getContent(rsrc.getControl().getProjectControl().getProjectState(), base ? ObjectId.fromString(edit.getBasePatchSet().getRevision().get()) : ObjectId.fromString(edit.getRevision().get()), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
public static void get(PatchSet.Id id, String path, boolean base, HttpCallback<NativeString> cb) {
    RestApi api;
    if (id.get() != 0) {
        // Read from a published revision, when change edit doesn't
        // exist for the caller, or is not currently active.
        api = ChangeApi.revision(id).view("files").id(path).view("content");
    } else if (Patch.COMMIT_MSG.equals(path)) {
        api = editMessage(id.getParentKey().get());
    } else {
        api = editFile(id.getParentKey().get(), path);
    }
    api.addParameter("base", base).get(cb);
}
#method_after
public static void get(PatchSet.Id id, String path, boolean base, HttpCallback<NativeString> cb) {
    RestApi api;
    if (id.get() != 0) {
        // Read from a published revision, when change edit doesn't
        // exist for the caller, or is not currently active.
        api = ChangeApi.revision(id).view("files").id(path).view("content");
    } else if (Patch.COMMIT_MSG.equals(path)) {
        api = editMessage(id.getParentKey().get()).addParameter("base", base);
    } else {
        api = editFile(id.getParentKey().get(), path).addParameter("base", base);
    }
    api.get(cb);
}
#end_block

#method_before
@Deprecated
public // To be used only by IsStarredByLegacyPredicate.
Set<Change.Id> byAccount(final Account.Id accountId, final String label) throws OrmException {
    try (final Repository repo = repoManager.openRepository(allUsers)) {
        return FluentIterable.from(getRefNames(repo, RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

            @Override
            public boolean apply(String refPart) {
                return refPart.endsWith("/" + accountId.get());
            }
        }).transform(new Function<String, Change.Id>() {

            @Override
            public Change.Id apply(String refPart) {
                return Change.Id.fromRefPart(refPart);
            }
        }).filter(new Predicate<Change.Id>() {

            @Override
            public boolean apply(Change.Id changeId) {
                try {
                    return readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)).contains(label);
                } catch (IOException e) {
                    log.error(String.format("Cannot query stars by account %d on change %d", accountId.get(), changeId.get()), e);
                    return false;
                }
            }
        }).toSet();
    } catch (IOException e) {
        throw new OrmException(String.format("Get changes that were starred by %d failed", accountId.get()), e);
    }
}
#method_after
@Deprecated
public // To be used only for IsStarredByLegacyPredicate.
Set<Change.Id> byAccount(final Account.Id accountId, final String label) throws OrmException {
    try (final Repository repo = repoManager.openRepository(allUsers)) {
        return FluentIterable.from(getRefNames(repo, RefNames.REFS_STARRED_CHANGES)).filter(new Predicate<String>() {

            @Override
            public boolean apply(String refPart) {
                return refPart.endsWith("/" + accountId.get());
            }
        }).transform(new Function<String, Change.Id>() {

            @Override
            public Change.Id apply(String refPart) {
                return Change.Id.fromRefPart(refPart);
            }
        }).filter(new Predicate<Change.Id>() {

            @Override
            public boolean apply(Change.Id changeId) {
                try {
                    return readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)).contains(label);
                } catch (IOException e) {
                    log.error(String.format("Cannot query stars by account %d on change %d", accountId.get(), changeId.get()), e);
                    return false;
                }
            }
        }).toSet();
    } catch (IOException e) {
        throw new OrmException(String.format("Get changes that were starred by %d failed", accountId.get()), e);
    }
}
#end_block

#method_before
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(StarredChangesUtil.DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#method_after
@Test
public void starUnstarChange() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    gApi.accounts().self().starChange(triplet);
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).contains(DEFAULT_LABEL);
    gApi.accounts().self().unstarChange(triplet);
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).isNull();
}
#end_block

#method_before
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "red", "blue"))));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", StarredChangesUtil.DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList("yellow")), new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue"))));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#method_after
@Test
public void starUnstarChangeWithLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    assertThat(gApi.accounts().self().getStars(triplet)).isEmpty();
    assertThat(gApi.accounts().self().getStarredChanges()).isEmpty();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "red", "blue")));
    ChangeInfo change = info(triplet);
    assertThat(change.starred).isTrue();
    assertThat(change.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    List<ChangeInfo> starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    ChangeInfo starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isTrue();
    assertThat(starredChange.stars).containsExactly("blue", "red", DEFAULT_LABEL).inOrder();
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of("yellow"), ImmutableSet.of(DEFAULT_LABEL, "blue")));
    change = info(triplet);
    assertThat(change.starred).isNull();
    assertThat(change.stars).containsExactly("red", "yellow").inOrder();
    assertThat(gApi.accounts().self().getStars(triplet)).containsExactly("red", "yellow").inOrder();
    starredChanges = gApi.accounts().self().getStarredChanges();
    assertThat(starredChanges).hasSize(1);
    starredChange = starredChanges.get(0);
    assertThat(starredChange._number).isEqualTo(r.getChange().getId().get());
    assertThat(starredChange.starred).isNull();
    assertThat(starredChange.stars).containsExactly("red", "yellow").inOrder();
    setApiUser(user);
    exception.expect(AuthException.class);
    exception.expectMessage("not allowed to get stars of another account");
    gApi.accounts().id(Integer.toString((admin.id.get()))).getStars(triplet);
}
#end_block

#method_before
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "invalid label", "blue", "another invalid label"))));
}
#method_after
@Test
public void starWithInvalidLabels() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("invalid labels: another invalid label, invalid label");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "invalid label", "blue", "another invalid label")));
}
#end_block

#method_before
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + StarredChangesUtil.DEFAULT_LABEL + " and " + StarredChangesUtil.IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(new HashSet<>(Arrays.asList(StarredChangesUtil.DEFAULT_LABEL, "blue", StarredChangesUtil.IGNORE_LABEL))));
}
#method_after
@Test
public void starWithDefaultAndIgnoreLabel() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    exception.expect(BadRequestException.class);
    exception.expectMessage("The labels " + DEFAULT_LABEL + " and " + IGNORE_LABEL + " are mutually exclusive." + " Only one of them can be set.");
    gApi.accounts().self().setStars(triplet, new StarsInput(ImmutableSet.of(DEFAULT_LABEL, "blue", IGNORE_LABEL)));
}
#end_block

#method_before
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(StarredChangesUtil.IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(sender.getMessages()).hasSize(0);
}
#method_after
@Test
public void ignoreChange() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    TestAccount user2 = accounts.user2();
    in = new AddReviewerInput();
    in.reviewer = user2.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    setApiUser(user);
    gApi.accounts().self().setStars(r.getChangeId(), new StarsInput(ImmutableSet.of(IGNORE_LABEL)));
    sender.clear();
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).abandon();
    List<Message> messages = sender.getMessages();
    assertThat(messages).hasSize(1);
    assertThat(messages.get(0).rcpt()).containsExactly(user2.emailAddress);
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Add an existing key again
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
}
#method_after
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#end_block

#method_before
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    super.removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#method_after
protected void bccStarredBy() {
    if (!NotifyHandling.ALL.equals(notify)) {
        return;
    }
    try {
        // BCC anyone who has starred this change
        // and remove anyone who has ignored this change.
        // 
        Multimap<Account.Id, String> stars = args.starredChangesUtil.byChangeFromIndex(change.getId());
        for (Map.Entry<Account.Id, Collection<String>> e : stars.asMap().entrySet()) {
            if (e.getValue().contains(StarredChangesUtil.DEFAULT_LABEL)) {
                super.add(RecipientType.BCC, e.getKey());
            }
            if (e.getValue().contains(StarredChangesUtil.IGNORE_LABEL)) {
                AccountState accountState = args.accountCache.get(e.getKey());
                if (accountState != null) {
                    removeUser(accountState.getAccount());
                }
            }
        }
    } catch (OrmException | NoSuchChangeException err) {
        // Just don't BCC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot BCC users that starred updated change", err);
    }
}
#end_block

#method_before
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        try {
            Account.Id accountId = Account.Id.parse(s.substring(0, p));
            String label = s.substring(p + 1);
            return create(accountId, label);
        } catch (NumberFormatException e) {
            return null;
        }
    }
    return null;
}
#method_after
public static StarField parse(String s) {
    int p = s.indexOf(SEPARATOR);
    if (p >= 0) {
        Integer id = Ints.tryParse(s.substring(0, p));
        if (id == null) {
            return null;
        }
        Account.Id accountId = new Account.Id(id);
        String label = s.substring(p + 1);
        return create(accountId, label);
    }
    return null;
}
#end_block

#method_before
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            if (labels.contains(DEFAULT_LABEL) && labels.contains(IGNORE_LABEL)) {
                throw IllegalLabelException.mutuallyExclusiveLabels(DEFAULT_LABEL, IGNORE_LABEL);
            }
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#method_after
public ImmutableSortedSet<String> star(Account.Id accountId, Project.NameKey project, Change.Id changeId, Set<String> labelsToAdd, Set<String> labelsToRemove) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        String refName = RefNames.refsStarredChanges(changeId, accountId);
        ObjectId oldObjectId = getObjectId(repo, refName);
        SortedSet<String> labels = readLabels(repo, oldObjectId);
        if (labelsToAdd != null) {
            labels.addAll(labelsToAdd);
        }
        if (labelsToRemove != null) {
            labels.removeAll(labelsToRemove);
        }
        if (labels.isEmpty()) {
            deleteRef(repo, refName, oldObjectId);
        } else {
            checkMutuallyExclusiveLabels(labels);
            updateLabels(repo, refName, oldObjectId, labels);
        }
        indexer.index(dbProvider.get(), project, changeId);
        return ImmutableSortedSet.copyOf(labels);
    } catch (IOException e) {
        throw new OrmException(String.format("Star change %d for account %d failed", changeId.get(), accountId.get()), e);
    }
}
#end_block

#method_before
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Account.Id accountId = Account.Id.parse(refPart);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#method_after
public ImmutableMultimap<Account.Id, String> byChange(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        ImmutableMultimap.Builder<Account.Id, String> builder = new ImmutableMultimap.Builder<>();
        for (String refPart : getRefNames(repo, RefNames.refsStarredChangesPrefix(changeId))) {
            Integer id = Ints.tryParse(refPart);
            if (id == null) {
                continue;
            }
            Account.Id accountId = new Account.Id(id);
            builder.putAll(accountId, readLabels(repo, RefNames.refsStarredChanges(changeId, accountId)));
        }
        return builder.build();
    } catch (IOException e) {
        throw new OrmException(String.format("Get accounts that starred change %d failed", changeId.get()), e);
    }
}
#end_block

#method_before
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.WHITESPACE.matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#method_after
private static void validateLabels(Set<String> labels) {
    if (labels == null) {
        return;
    }
    SortedSet<String> invalidLabels = new TreeSet<>();
    for (String label : labels) {
        if (CharMatcher.whitespace().matchesAnyOf(label)) {
            invalidLabels.add(label);
        }
    }
    if (!invalidLabels.isEmpty()) {
        throw IllegalLabelException.invalidLabels(invalidLabels);
    }
}
#end_block

#method_before
@Test
public void diffChangesConsidersEmptyReviewDbTopicEquivalentToNullInNoteDb() throws Exception {
    Change c1 = TestChanges.newChange(new Project.NameKey("project"), new Account.Id(100));
    c1.setTopic("");
    Change c2 = clone(c1);
    c2.setTopic(null);
    // Both ReviewDb, exact match required.
    ChangeBundle b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " {} != {null}");
    // Topic ignored if ReviewDb is empty and NoteDb is null.
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    // Exact match still required if NoteDb has empty value (not realistic).
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " {} != {null}");
    // Null is not equal to a non-empty string.
    Change c3 = clone(c1);
    c3.setTopic("topic");
    b1 = new ChangeBundle(c3, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " {topic} != {null}");
    // Null is equal to a string that is all whitespace.
    Change c4 = clone(c1);
    c3.setTopic("  ");
    b1 = new ChangeBundle(c4, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#method_after
@Test
public void diffChangesConsidersEmptyReviewDbTopicEquivalentToNullInNoteDb() throws Exception {
    Change c1 = TestChanges.newChange(new Project.NameKey("project"), new Account.Id(100));
    c1.setTopic("");
    Change c2 = clone(c1);
    c2.setTopic(null);
    // Both ReviewDb, exact match required.
    ChangeBundle b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    ChangeBundle b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " {} != {null}");
    // Topic ignored if ReviewDb is empty and NoteDb is null.
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    // Exact match still required if NoteDb has empty value (not realistic).
    b1 = new ChangeBundle(c1, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " {} != {null}");
    // Null is not equal to a non-empty string.
    Change c3 = clone(c1);
    c3.setTopic("topic");
    b1 = new ChangeBundle(c3, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertDiffs(b1, b2, "topic differs for Change.Id " + c1.getId() + ":" + " {topic} != {null}");
    // Null is equal to a string that is all whitespace.
    Change c4 = clone(c1);
    c4.setTopic("  ");
    b1 = new ChangeBundle(c4, messages(), patchSets(), approvals(), comments(), reviewers(), REVIEW_DB);
    b2 = new ChangeBundle(c2, messages(), patchSets(), approvals(), comments(), reviewers(), NOTE_DB);
    assertNoDiffs(b1, b2);
    assertNoDiffs(b2, b1);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    final List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    List<CommitValidationMessage> messages = new LinkedList<>();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && shortMsg.substring(CHANGE_ID_PREFIX.length()).trim().matches(SHA1_PATTERN)) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    }
    String v = idList.get(idList.size() - 1).trim();
    if (!v.matches(SHA1_PATTERN)) {
        String sha1 = commit.getId().name().substring(0, SHA1_LENGTH);
        String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
        messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
        throw new CommitValidationException(errMsg, messages);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    RevCommit commit = receiveEvent.commit;
    List<CommitValidationMessage> messages = new LinkedList<>();
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    String sha1 = commit.abbreviate(SHA1_LENGTH).name();
    if (idList.isEmpty()) {
        if (projectControl.getProjectState().isRequireChangeID()) {
            String shortMsg = commit.getShortMessage();
            if (shortMsg.startsWith(CHANGE_ID_PREFIX) && CHANGE_ID.matcher(shortMsg.substring(CHANGE_ID_PREFIX.length()).trim()).matches()) {
                String errMsg = String.format(MISSING_SUBJECT_MSG, sha1);
                throw new CommitValidationException(errMsg);
            }
            String errMsg = String.format(MISSING_CHANGE_ID_MSG, sha1);
            messages.add(getMissingChangeIdErrorMsg(errMsg, commit));
            throw new CommitValidationException(errMsg, messages);
        }
    } else if (idList.size() > 1) {
        String errMsg = String.format(MULTIPLE_CHANGE_ID_MSG, sha1);
        throw new CommitValidationException(errMsg, messages);
    }
    String v = idList.get(idList.size() - 1).trim();
    if (!CHANGE_ID.matcher(v).matches()) {
        String errMsg = String.format(INVALID_CHANGE_ID_MSG, sha1);
        messages.add(getMissingChangeIdErrorMsg(errMsg, receiveEvent.commit));
        throw new CommitValidationException(errMsg, messages);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static boolean isSingleQuery(String query) {
    return (NUMERIC_ID.test(query) || CHANGE_ID.test(query) || COMMIT_SHA1.test(query));
}
#method_after
private static boolean isSingleQuery(String query) {
    return NUMERIC_ID.test(query) || CHANGE_ID.test(query) || COMMIT_SHA1.test(query);
}
#end_block

#method_before
private static boolean isSingleQuery(String query) {
    if (query.matches("^[1-9][0-9]*$")) {
        // 
        return true;
    }
    if (query.matches(CHANGE_ID_PATTERN) || query.matches(UNIQUE_CHANGE_ID_PATTERN)) {
        // Newer style Change-Id and Unique Change Id in format [project]~[ref]~[changeId]
        return true;
    }
    if (query.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        // 
        return true;
    }
    return false;
}
#method_after
private static boolean isSingleQuery(String query) {
    return NUMERIC_ID.test(query) || CHANGE_ID.test(query) || CHANGE_ID_TRIPLET.test(query) || COMMIT_SHA1.test(query);
}
#end_block

#method_before
public void addChange(String id, Map<Change.Id, ChangeResource> changes, ProjectControl projectControl) throws UnloggedFailure, OrmException {
    List<ChangeControl> matched = changeFinder.find(id, currentUser);
    List<ChangeControl> toAdd = new ArrayList<>(changes.size());
    for (ChangeControl ctl : matched) {
        if (!changes.containsKey(ctl.getId()) && inProject(projectControl, ctl.getProject()) && ctl.isVisible(db)) {
            toAdd.add(ctl);
        }
    }
    if (toAdd.isEmpty()) {
        throw new UnloggedFailure(1, "\"" + id + "\" no such change");
    } else if (toAdd.size() > 1) {
        throw new UnloggedFailure(1, "\"" + id + "\" matches multiple changes");
    }
    ChangeControl ctl = toAdd.get(0);
    changes.put(ctl.getId(), changesCollection.parse(ctl));
}
#method_after
public void addChange(String id, Map<Change.Id, ChangeResource> changes) throws UnloggedFailure, OrmException {
    addChange(id, changes, null);
}
#end_block

#method_before
@Override
public CurrentUser getUser() {
    boolean signedIn = isSignedIn();
    if (user == null || (signedIn && user == anonymousUser)) {
        if (signedIn) {
            user = identified.create(val.getAccountId());
        } else {
            user = anonymousUser = anonymousProvider.get();
        }
    }
    return user;
}
#method_after
@Override
public CurrentUser getUser() {
    if (user == null) {
        if (isSignedIn()) {
            user = identified.create(val.getAccountId());
        } else {
            user = anonymousProvider.get();
        }
    }
    return user;
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
    user = identified.create(val.getAccountId());
}
#end_block

#method_before
@Override
public void logout() {
    if (val != null) {
        manager.destroy(key);
        key = null;
        val = null;
        saveCookie();
    }
}
#method_after
@Override
public void logout() {
    if (val != null) {
        manager.destroy(key);
        key = null;
        val = null;
        saveCookie();
        user = anonymousProvider.get();
    }
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            for (SubmoduleSubscription ss : m.subscribedTo(branch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        logDebug("Checking subscribe section " + s);
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            for (SubmoduleSubscription ss : m.subscribedTo(branch)) {
                logDebug("Checking SubmoduleSubscription " + ss);
                if (projectCache.get(ss.getSubmodule().getParentKey()) != null) {
                    logDebug("Adding SubmoduleSubscription " + ss);
                    ret.add(ss);
                }
            }
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = new SubmoduleSectionParser(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = new SubmoduleSectionParser(bbc, canonicalWebUrl, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            String project;
            if (branch.equals(".")) {
                branch = superProjectBranch.get();
            }
            // relative URL
            if (url.startsWith("../")) {
                // prefix with a slash for easier relative path walks
                project = '/' + superProjectBranch.getParentKey().get();
                String hostPart = url;
                while (hostPart.startsWith("../")) {
                    int lastSlash = project.lastIndexOf('/');
                    if (lastSlash < 0) {
                        // too many levels up, ignore for now
                        return null;
                    }
                    project = project.substring(0, lastSlash);
                    hostPart = hostPart.substring(3);
                }
                project = project + "/" + hostPart;
                // remove leading '/'
                project = project.substring(1);
            } else {
                // It is actually an URI. It could be ssh://localhost/project-a.
                URI targetServerURI = new URI(url);
                URI thisServerURI = new URI(thisServer);
                if (!targetServerURI.getHost().equalsIgnoreCase(thisServerURI.getHost())) {
                    return null;
                }
                String p1 = targetServerURI.getPath();
                String p2 = thisServerURI.getPath();
                if (!p1.startsWith(p2)) {
                    // http://server/other-teams-gerrit/
                    return null;
                }
                // skip common part
                project = p1.substring(p2.length());
            }
            while (project.startsWith("/")) {
                project = project.substring(1);
            }
            if (project.endsWith(Constants.DOT_GIT_EXT)) {
                project = // 
                project.substring(// 
                0, project.length() - Constants.DOT_GIT_EXT.length());
            }
            Project.NameKey projectKey = new Project.NameKey(project);
            return new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return null;
}
#method_after
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            String project;
            if (branch.equals(".")) {
                branch = superProjectBranch.get();
            }
            // relative URL
            if (url.startsWith("../")) {
                // prefix with a slash for easier relative path walks
                project = '/' + superProjectBranch.getParentKey().get();
                String hostPart = url;
                while (hostPart.startsWith("../")) {
                    int lastSlash = project.lastIndexOf('/');
                    if (lastSlash < 0) {
                        // too many levels up, ignore for now
                        return null;
                    }
                    project = project.substring(0, lastSlash);
                    hostPart = hostPart.substring(3);
                }
                project = project + "/" + hostPart;
                // remove leading '/'
                project = project.substring(1);
            } else {
                // It is actually an URI. It could be ssh://localhost/project-a.
                URI targetServerURI = new URI(url);
                URI thisServerURI = new URI(canonicalWebUrl);
                String thisHost = thisServerURI.getHost();
                String targetHost = targetServerURI.getHost();
                if (thisHost == null || targetHost == null || !targetHost.equalsIgnoreCase(thisHost)) {
                    return null;
                }
                String p1 = targetServerURI.getPath();
                String p2 = thisServerURI.getPath();
                if (!p1.startsWith(p2)) {
                    // http://server/other-teams-gerrit/
                    return null;
                }
                // skip common part
                project = p1.substring(p2.length());
            }
            while (project.startsWith("/")) {
                project = project.substring(1);
            }
            if (project.endsWith(Constants.DOT_GIT_EXT)) {
                project = // 
                project.substring(// 
                0, project.length() - Constants.DOT_GIT_EXT.length());
            }
            Project.NameKey projectKey = new Project.NameKey(project);
            return new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return null;
}
#end_block

#method_before
@Test
public void testFollowMasterBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = localpath-to-a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "localpath-to-a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowMasterBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = localpath-to-a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "localpath-to-a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testFollowMatchingBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = .\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowMatchingBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = .\n");
    Branch.NameKey targetBranch1 = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res1 = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch1).parseAllSections();
    Set<SubmoduleSubscription> expected1 = Sets.newHashSet(new SubmoduleSubscription(targetBranch1, new Branch.NameKey(p, "master"), "a"));
    assertThat(res1).containsExactlyElementsIn(expected1);
    Branch.NameKey targetBranch2 = new Branch.NameKey(new Project.NameKey("project"), "somebranch");
    Set<SubmoduleSubscription> res2 = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch2).parseAllSections();
    Set<SubmoduleSubscription> expected2 = Sets.newHashSet(new SubmoduleSubscription(targetBranch2, new Branch.NameKey(p, "somebranch"), "a"));
    assertThat(res2).containsExactlyElementsIn(expected2);
}
#end_block

#method_before
@Test
public void testFollowAnotherBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = anotherbranch\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "anotherbranch"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowAnotherBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = anotherbranch\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "anotherbranch"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithAnotherURI() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithAnotherURI() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSlashesInProjectName() throws Exception {
    Project.NameKey p = createProject("project/with/slashes/a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"project/with/slashes/a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSlashesInProjectName() throws Exception {
    Project.NameKey p = createProject("project/with/slashes/a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"project/with/slashes/a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSlashesInPath() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a/b/c/d/e\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a/b/c/d/e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSlashesInPath() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a/b/c/d/e\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a/b/c/d/e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithMoreSections() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p1.get() + "\n" + // follow any branch including the master branch
    "branch = .\n" + "[submodule \"b\"]\n" + "    path = b\n" + "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithMoreSections() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "     path = a\n" + "     url = ssh://localhost/" + p1.get() + "\n" + "     branch = .\n" + "[submodule \"b\"]\n" + "		path = b\n" + "		url = http://localhost:80/" + p2.get() + "\n" + "		branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSubProjectFound() throws Exception {
    Project.NameKey p1 = createProject("a/b");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    String gitmodules = "\n" + "[submodule \"a/b\"]\n" + "path = a/b\n" + "url = ssh://localhost/" + p1.get() + "\n" + "branch = .\n" + "[submodule \"b\"]\n" + "path = b\n" + "url = http://localhost/" + p2.get() + "\n" + "branch = .\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a/b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSubProjectFound() throws Exception {
    Project.NameKey p1 = createProject("a/b");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a/b\"]\n" + "path = a/b\n" + "url = ssh://localhost/" + p1.get() + "\n" + "branch = .\n" + "[submodule \"b\"]\n" + "path = b\n" + "url = http://localhost/" + p2.get() + "\n" + "branch = .\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a/b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithAnInvalidSection() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Project.NameKey p3 = createProject("d");
    Project.NameKey p4 = createProject("e");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "    path = a\n" + "    url = ssh://localhost/" + p1.get() + "\n" + "    branch = .\n" + "[submodule \"b\"]\n" + // path missing
    "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n" + "[submodule \"c\"]\n" + "    path = c\n" + // url missing
    "    branch = .\n" + "[submodule \"d\"]\n" + "    path = d-parent/the-d-folder\n" + "    url = ssh://localhost/" + p3.get() + "\n" + // branch missing
    "[submodule \"e\"]\n" + "    path = e\n" + "    url = ssh://localhost/" + p4.get() + "\n" + "    branch = refs/heads/master\n");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p4, "master"), "e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithAnInvalidSection() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Project.NameKey p3 = createProject("d");
    Project.NameKey p4 = createProject("e");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "    path = a\n" + "    url = ssh://localhost/" + p1.get() + "\n" + "    branch = .\n" + "[submodule \"b\"]\n" + // path missing
    "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n" + "[submodule \"c\"]\n" + "    path = c\n" + // url missing
    "    branch = .\n" + "[submodule \"d\"]\n" + "    path = d-parent/the-d-folder\n" + "    url = ssh://localhost/" + p3.get() + "\n" + // branch missing
    "[submodule \"e\"]\n" + "    path = e\n" + "    url = ssh://localhost/" + p4.get() + "\n" + "    branch = refs/heads/master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p4, "master"), "e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSectionOfNonexistingProject() throws Exception {
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://non-localhost/a\n" + // Project "a" doesn't exist
    "branch = .\\n");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#method_after
@Test
public void testWithSectionOfNonexistingProject() throws Exception {
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://non-localhost/a\n" + // Project "a" doesn't exist
    "branch = .\\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#end_block

#method_before
@Test
public void testWithSectionToOtherServer() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]" + "path = a" + "url = ssh://non-localhost/" + p1.get() + "\n" + "branch = .");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#method_after
@Test
public void testWithSectionToOtherServer() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]" + "path = a" + "url = ssh://non-localhost/" + p1.get() + "\n" + "branch = .");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#end_block

#method_before
@Test
public void testWithRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../" + p1.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../" + p1.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithDeepRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../../" + p1.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("nested/project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithDeepRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../../" + p1.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("nested/project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testFollowMasterBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = localpath-to-a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "localpath-to-a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowMasterBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = localpath-to-a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "localpath-to-a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testFollowMatchingBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = .\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowMatchingBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = .\n");
    Branch.NameKey targetBranch1 = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res1 = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch1).parseAllSections();
    Set<SubmoduleSubscription> expected1 = Sets.newHashSet(new SubmoduleSubscription(targetBranch1, new Branch.NameKey(p, "master"), "a"));
    assertThat(res1).containsExactlyElementsIn(expected1);
    Branch.NameKey targetBranch2 = new Branch.NameKey(new Project.NameKey("project"), "somebranch");
    Set<SubmoduleSubscription> res2 = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch2).parseAllSections();
    Set<SubmoduleSubscription> expected2 = Sets.newHashSet(new SubmoduleSubscription(targetBranch2, new Branch.NameKey(p, "somebranch"), "a"));
    assertThat(res2).containsExactlyElementsIn(expected2);
}
#end_block

#method_before
@Test
public void testFollowAnotherBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = anotherbranch\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "anotherbranch"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testFollowAnotherBranch() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p.get() + "\n" + "branch = anotherbranch\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "anotherbranch"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithAnotherURI() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithAnotherURI() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSlashesInProjectName() throws Exception {
    Project.NameKey p = createProject("project/with/slashes/a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"project/with/slashes/a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSlashesInProjectName() throws Exception {
    Project.NameKey p = createProject("project/with/slashes/a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"project/with/slashes/a\"]\n" + "path = a\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSlashesInPath() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a/b/c/d/e\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a/b/c/d/e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSlashesInPath() throws Exception {
    Project.NameKey p = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a/b/c/d/e\n" + "url = http://localhost:80/" + p.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p, "master"), "a/b/c/d/e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithMoreSections() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://localhost/" + p1.get() + "\n" + // follow any branch including the master branch
    "branch = .\n" + "[submodule \"b\"]\n" + "    path = b\n" + "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithMoreSections() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "     path = a\n" + "     url = ssh://localhost/" + p1.get() + "\n" + "     branch = .\n" + "[submodule \"b\"]\n" + "		path = b\n" + "		url = http://localhost:80/" + p2.get() + "\n" + "		branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSubProjectFound() throws Exception {
    Project.NameKey p1 = createProject("a/b");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    String gitmodules = "\n" + "[submodule \"a/b\"]\n" + "path = a/b\n" + "url = ssh://localhost/" + p1.get() + "\n" + "branch = .\n" + "[submodule \"b\"]\n" + "path = b\n" + "url = http://localhost/" + p2.get() + "\n" + "branch = .\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a/b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithSubProjectFound() throws Exception {
    Project.NameKey p1 = createProject("a/b");
    Project.NameKey p2 = createProject("b");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a/b\"]\n" + "path = a/b\n" + "url = ssh://localhost/" + p1.get() + "\n" + "branch = .\n" + "[submodule \"b\"]\n" + "path = b\n" + "url = http://localhost/" + p2.get() + "\n" + "branch = .\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p2, "master"), "b"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a/b"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithAnInvalidSection() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Project.NameKey p3 = createProject("d");
    Project.NameKey p4 = createProject("e");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "    path = a\n" + "    url = ssh://localhost/" + p1.get() + "\n" + "    branch = .\n" + "[submodule \"b\"]\n" + // path missing
    "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n" + "[submodule \"c\"]\n" + "    path = c\n" + // url missing
    "    branch = .\n" + "[submodule \"d\"]\n" + "    path = d-parent/the-d-folder\n" + "    url = ssh://localhost/" + p3.get() + "\n" + // branch missing
    "[submodule \"e\"]\n" + "    path = e\n" + "    url = ssh://localhost/" + p4.get() + "\n" + "    branch = refs/heads/master\n");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p4, "master"), "e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithAnInvalidSection() throws Exception {
    Project.NameKey p1 = createProject("a");
    Project.NameKey p2 = createProject("b");
    Project.NameKey p3 = createProject("d");
    Project.NameKey p4 = createProject("e");
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "    path = a\n" + "    url = ssh://localhost/" + p1.get() + "\n" + "    branch = .\n" + "[submodule \"b\"]\n" + // path missing
    "    url = http://localhost:80/" + p2.get() + "\n" + "    branch = master\n" + "[submodule \"c\"]\n" + "    path = c\n" + // url missing
    "    branch = .\n" + "[submodule \"d\"]\n" + "    path = d-parent/the-d-folder\n" + "    url = ssh://localhost/" + p3.get() + "\n" + // branch missing
    "[submodule \"e\"]\n" + "    path = e\n" + "    url = ssh://localhost/" + p4.get() + "\n" + "    branch = refs/heads/master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"), new SubmoduleSubscription(targetBranch, new Branch.NameKey(p4, "master"), "e"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithSectionOfNonexistingProject() throws Exception {
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://non-localhost/a\n" + // Project "a" doesn't exist
    "branch = .\\n");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#method_after
@Test
public void testWithSectionOfNonexistingProject() throws Exception {
    Config cfg = new Config();
    cfg.fromText("\n" + "[submodule \"a\"]\n" + "path = a\n" + "url = ssh://non-localhost/a\n" + // Project "a" doesn't exist
    "branch = .\\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#end_block

#method_before
@Test
public void testWithSectionToOtherServer() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]" + "path = a" + "url = ssh://non-localhost/" + p1.get() + "\n" + "branch = .");
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#method_after
@Test
public void testWithSectionToOtherServer() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]" + "path = a" + "url = ssh://non-localhost/" + p1.get() + "\n" + "branch = .");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    assertThat(res).isEmpty();
}
#end_block

#method_before
@Test
public void testWithRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../" + p1.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../" + p1.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
@Test
public void testWithDeepRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    String gitmodules = "" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../../" + p1.get() + "\n" + "branch = master\n";
    cfg.fromText(gitmodules);
    String thisServer = THIS_SERVER;
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("nested/project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, thisServer, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#method_after
@Test
public void testWithDeepRelativeURI() throws Exception {
    Project.NameKey p1 = createProject("a");
    Config cfg = new Config();
    cfg.fromText("" + "[submodule \"a\"]\n" + "path = a\n" + "url = ../../" + p1.get() + "\n" + "branch = master\n");
    Branch.NameKey targetBranch = new Branch.NameKey(new Project.NameKey("nested/project"), "master");
    Set<SubmoduleSubscription> res = new SubmoduleSectionParser(projectCache, cfg, THIS_SERVER, targetBranch).parseAllSections();
    Set<SubmoduleSubscription> expected = Sets.newHashSet(new SubmoduleSubscription(targetBranch, new Branch.NameKey(p1, "master"), "a"));
    assertThat(res).containsExactlyElementsIn(expected);
}
#end_block

#method_before
void load(ProjectCache cache) throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = new SubmoduleSectionParser(cache, bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load(ProjectCache cache) throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = new SubmoduleSectionParser(cache, bbc, canonicalWebUrl, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    SubmoduleSubscription ss = null;
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            String project;
            if (branch.equals(".")) {
                branch = superProjectBranch.get();
            }
            // relative URL
            if (url.startsWith("../")) {
                // prefix with a slash for easier relative path walks
                project = '/' + superProjectBranch.getParentKey().get();
                String hostPart = url;
                while (hostPart.startsWith("../")) {
                    int lastSlash = project.lastIndexOf('/');
                    if (lastSlash < 0) {
                        // too many levels up, ignore for now
                        return null;
                    }
                    project = project.substring(0, lastSlash);
                    hostPart = hostPart.substring(3);
                }
                project = project + "/" + hostPart;
                // remove leading '/'
                project = project.substring(1);
            } else {
                // It is actually an URI. It could be ssh://localhost/project-a.
                URI targetServerURI = new URI(url);
                URI thisServerURI = new URI(thisServer);
                if (!targetServerURI.getHost().equalsIgnoreCase(thisServerURI.getHost())) {
                    return null;
                }
                String p1 = targetServerURI.getPath();
                String p2 = thisServerURI.getPath();
                if (!p1.startsWith(p2)) {
                    // http://server/other-teams-gerrit/
                    return null;
                }
                // skip common part
                project = p1.substring(p2.length());
            }
            while (project.startsWith("/")) {
                project = project.substring(1);
            }
            if (project.endsWith(Constants.DOT_GIT_EXT)) {
                project = // 
                project.substring(// 
                0, project.length() - Constants.DOT_GIT_EXT.length());
            }
            Project.NameKey projectKey = new Project.NameKey(project);
            if (projectCache.get(projectKey) != null) {
                ss = new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
            }
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return ss;
}
#method_after
private SubmoduleSubscription parse(final String id) {
    final String url = bbc.getString("submodule", id, "url");
    final String path = bbc.getString("submodule", id, "path");
    String branch = bbc.getString("submodule", id, "branch");
    SubmoduleSubscription ss = null;
    try {
        if (url != null && url.length() > 0 && path != null && path.length() > 0 && branch != null && branch.length() > 0) {
            // All required fields filled.
            String project;
            if (branch.equals(".")) {
                branch = superProjectBranch.get();
            }
            // relative URL
            if (url.startsWith("../")) {
                // prefix with a slash for easier relative path walks
                project = '/' + superProjectBranch.getParentKey().get();
                String hostPart = url;
                while (hostPart.startsWith("../")) {
                    int lastSlash = project.lastIndexOf('/');
                    if (lastSlash < 0) {
                        // too many levels up, ignore for now
                        return null;
                    }
                    project = project.substring(0, lastSlash);
                    hostPart = hostPart.substring(3);
                }
                project = project + "/" + hostPart;
                // remove leading '/'
                project = project.substring(1);
            } else {
                // It is actually an URI. It could be ssh://localhost/project-a.
                URI targetServerURI = new URI(url);
                URI thisServerURI = new URI(canonicalWebUrl);
                String thisHost = thisServerURI.getHost();
                String targetHost = targetServerURI.getHost();
                if (thisHost == null || targetHost == null || !targetHost.equalsIgnoreCase(thisHost)) {
                    return null;
                }
                String p1 = targetServerURI.getPath();
                String p2 = thisServerURI.getPath();
                if (!p1.startsWith(p2)) {
                    // http://server/other-teams-gerrit/
                    return null;
                }
                // skip common part
                project = p1.substring(p2.length());
            }
            while (project.startsWith("/")) {
                project = project.substring(1);
            }
            if (project.endsWith(Constants.DOT_GIT_EXT)) {
                project = // 
                project.substring(// 
                0, project.length() - Constants.DOT_GIT_EXT.length());
            }
            Project.NameKey projectKey = new Project.NameKey(project);
            if (projectCache.get(projectKey) != null) {
                ss = new SubmoduleSubscription(superProjectBranch, new Branch.NameKey(projectKey, branch), path);
            }
        }
    } catch (URISyntaxException e) {
    // Error in url syntax (in fact it is uri syntax)
    }
    return ss;
}
#end_block

#method_before
private void index(Change.Id id, String operation) throws IOException, OrmException {
    AtomicInteger changeIdLock = getAndIncrementChangeIdLock(id);
    synchronized (changeIdLock) {
        if ("index".equals(operation)) {
            try (ReviewDb db = schemaFactory.open()) {
                Change change = db.changes().get(id);
                if (change == null) {
                    indexer.delete(id);
                    return;
                }
                indexer.index(db, change);
            }
            logger.debug("Change {} successfully indexed", id);
        } else if ("delete".equals(operation)) {
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
        }
    }
    if (changeIdLock.decrementAndGet() == 0) {
        removeChangeIdLock(id);
    }
}
#method_after
private void index(Change.Id id, String operation) throws IOException, OrmException {
    AtomicInteger changeIdLock = getAndIncrementChangeIdLock(id);
    synchronized (changeIdLock) {
        if ("index".equals(operation)) {
            try (ReviewDb db = schemaFactory.open()) {
                Change change = db.changes().get(id);
                if (change == null) {
                    indexer.delete(id);
                    return;
                }
                indexer.index(db, change);
            }
            logger.debug("Change {} successfully indexed", id);
        }
        if ("delete".equals(operation)) {
            indexer.delete(id);
            logger.debug("Change {} successfully deleted from index", id);
        }
    }
    if (changeIdLock.decrementAndGet() == 0) {
        removeChangeIdLock(id);
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE, identifiedUser.get().getAccount());
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                case FORCED:
                case IO_FAILURE:
                case NOT_ATTEMPTED:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
public void setMessageSender(final MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#method_after
public void setMessageSender(MessageSender ms) {
    messageSender = ms != null ? ms : new ReceivePackMessageSender();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setPushCertificate(rp.getPushCertificate());
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(user)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c, user.getAccount());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), user.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try (MergeOpRepoManager orm = ormProvider.get()) {
        orm.setContext(db, TimeUtil.nowTs(), user);
        op.updateSuperProjects(db, branches, "receiveID", orm);
    } catch (SubmoduleException e) {
        log.error("Can't update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, c.change.getSubject(), false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, u.info.getSubject(), edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change, String subject, boolean edit) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(subject));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    if (edit) {
        m.append(" [EDIT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to change %d in project %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = new ArrayList<>();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = new ArrayList<>();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (ResourceConflictException e) {
        addMessage(e.getMessage());
        reject(magicBranch.cmd, "conflict");
    } catch (RestApiException err) {
        log.error("Can't insert change/patch set for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error: " + err.getMessage());
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), user.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(Collection<ReceiveCommand> commands) {
    for (ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !user.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + user.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#method_after
private void parseUpdate(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, RefNames.REFS_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private boolean isCommit(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#method_after
private boolean isCommit(ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName(), err);
        reject(cmd, "invalid object");
        return false;
    }
    if (obj instanceof RevCommit) {
        return true;
    } else {
        reject(cmd, "not a commit");
        return false;
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#method_after
private void parseDelete(ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.getRefName().startsWith(REFS_CHANGES)) {
        errors.put(Error.DELETE_CHANGES, ctl.getRefName());
        reject(cmd, "cannot delete changes");
    } else if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (RefNames.REFS_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(final String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#method_after
@Option(name = "--label", aliases = { "-l" }, metaVar = "LABEL+VALUE", usage = "label(s) to assign (defaults to +1 if no value provided")
void addLabel(String token) throws CmdLineException {
    LabelVote v = LabelVote.parse(token);
    try {
        LabelType.checkName(v.label());
        ApprovalsUtil.checkLabel(labelTypes, v.label(), v.value());
    } catch (IllegalArgumentException e) {
        throw clp.reject(e.getMessage());
    }
    labels.put(v.label(), v.value());
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.enabled()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw clp.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        RevCommit h = walk.parseCommit(targetRef.getObjectId());
        RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void parseReplaceCommand(final ReceiveCommand cmd, final Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    final RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    final Change changeEnt;
    try {
        changeEnt = db.changes().get(changeId);
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    }
    if (changeEnt == null) {
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IOException e) {
        log.error("Cannot parse " + cmd.getNewId().name() + " as commit", e);
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (OrmException e) {
        log.error("Cannot lookup existing change " + changeId, e);
        reject(cmd, "database error");
        return;
    } catch (NoSuchChangeException e) {
        log.error("Change not found " + changeId, e);
        reject(cmd, "change " + changeId + " not found");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    requestReplace(cmd, true, changeEnt, newCommit);
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#method_after
private boolean requestReplace(ReceiveCommand cmd, boolean checkMergedInto, Change change, RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + canonicalWebUrl + change.getId() + " closed");
        return false;
    }
    ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = new ArrayList<>();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory, project.getNameKey());
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = new ArrayList<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException | NoSuchChangeException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException {
            if (caller == Thread.currentThread()) {
                insertChange(ReceiveCommits.this.db);
            } else {
                try (ReviewDb threadLocalDb = schemaFactory.open()) {
                    insertChange(threadLocalDb);
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> insertChange() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, RestApiException, UpdateException, RepositoryNotFoundException, IOException, NoSuchChangeException {
            try (RequestState state = requestState(caller)) {
                insertChange(state);
            }
            synchronizedIncrement(newProgress);
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        bu.execute();
    }
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    Account.Id me = user.getAccountId();
    List<FooterLine> footerLines = commit.getFooterLines();
    MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (!magicBranch.hashtags.isEmpty()) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        }
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException, NoSuchChangeException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, new SubmitInput());
    }
    addMessage("");
    Change c = notesFactory.createChecked(db, project.getNameKey(), rsrc.getChange().getId()).getChange();
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<Change, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(db.changes().getAsync(request.ontoChange));
    }
    for (CheckedFuture<Change, OrmException> f : futures) {
        Change c = f.checkedGet();
        if (c != null) {
            replaceByChange.get(c.getId()).change = c;
        }
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    List<CheckedFuture<ChangeNotes, OrmException>> futures = Lists.newArrayListWithCapacity(replaceByChange.size());
    for (ReplaceRequest request : replaceByChange.values()) {
        futures.add(notesFactory.createAsync(changeUpdateExector, db, project.getNameKey(), request.ontoChange));
    }
    for (CheckedFuture<ChangeNotes, OrmException> f : futures) {
        ChangeNotes notes = f.checkedGet();
        if (notes.getChange() != null) {
            replaceByChange.get(notes.getChangeId()).change = notes.getChange();
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannot retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommitId, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommitId, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                }
                try (RequestState state = requestState(caller)) {
                    return insertPatchSet(state);
                }
            } catch (OrmException | IOException e) {
                log.error("Failed to insert patch set", e);
                throw e;
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    Timestamp ts = TimeUtil.nowTs();
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals, ts);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    revisionCreated.fire(change, newPatchSet, user.getAccountId());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        changeMerged.fire(change, newPatchSet, user.getAccount(), newCommit.getName());
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        commentAdded.fire(change, newPatchSet, user.getAccount(), null, approvals, ts);
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    ReplaceOp replaceOp = replaceOpFactory.create(requestScopePropagator, projectControl, checkMergedInto, priorPatchSet, priorCommit, psId, newCommit, info, groups, magicBranch, rp.getPushCertificate());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.addOp(change.getId(), replaceOp);
        bu.execute();
    }
    if (replaceOp.getRejectMessage() != null) {
        reject(inputCommand, replaceOp.getRejectMessage());
        return null;
    }
    groups = replaceOp.getGroups();
    // TODO(ekempin): mark changes as merged inside of ReplaceOp
    if (replaceOp.getMergedIntoRef() != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, replaceOp.getMergedIntoRef());
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    PatchSet newPatchSet = replaceOp.getPatchSet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit, user.getAccount());
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
private void updateGroups(RequestState state) throws RestApiException, UpdateException {
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.addOp(psId.getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
                List<String> oldGroups = ps.getGroups();
                if (oldGroups == null) {
                    if (groups == null) {
                        return false;
                    }
                } else if (sameGroups(oldGroups, groups)) {
                    return false;
                }
                psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                updateGroups(db);
            } else {
                try (ReviewDb db = schemaFactory.open()) {
                    updateGroups(db);
                }
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<Void, RestApiException> updateGroups() {
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            try (RequestState state = requestState(caller)) {
                updateGroups(state);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(user.getAccount().getFullName());
    RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        RevObject parsedObject = walk.parseAny(cmd.getNewId());
        if (!(parsedObject instanceof RevCommit)) {
            return;
        }
        walk.markStart((RevCommit) parsedObject);
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(walk, ctl, cmd, c)) {
                break;
            }
            if (defaultName && user.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(user.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        user.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(RevWalk rw, RefControl ctl, ReceiveCommand cmd, ObjectId id) throws IOException {
    if (validCommits.contains(id)) {
        return true;
    }
    RevCommit c = rw.parseCommit(id);
    rw.parseBody(c);
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, user);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c.copy());
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (ReplaceRequest req : toClose) {
            PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommitId);
                closeProgress.update(1);
            }
        }
    } catch (RestApiException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException | OrmException | UpdateException e) {
        log.error("Can't scan for changes to close", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    changeMerged.fire(change, result.newPatchSet, user.getAccount(), commit.getName());
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException, UpdateException, RestApiException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change;
    try {
        change = notesFactory.createChecked(db, project.getNameKey(), cid).getChange();
    } catch (NoSuchChangeException e) {
        log.warn(project.getName() + " change " + cid + " is missing");
        return null;
    }
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (ps == null) {
        log.warn(project.getName() + " patch set " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByBranch(Branch.NameKey branch) throws OrmException {
    Map<Change.Key, Change> r = new HashMap<>();
    for (ChangeData cd : queryProvider.get().byBranchOpen(branch)) {
        r.put(cd.change().getKey(), cd.change());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, final String mergedIntoRef) throws UpdateException, RestApiException {
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user, TimeUtil.nowTs())) {
        bu.addOp(info.getKey().getParentKey(), new BatchUpdate.Op() {

            @Override
            public boolean updateChange(ChangeContext ctx) throws OrmException {
                Change change = ctx.getChange();
                ChangeUpdate update = ctx.getUpdate(info.getKey());
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    // we cannot reconstruct the submit records for when this change was
                    // submitted, this is why we must fix the status
                    update.fixStatus(Change.Status.MERGED);
                }
                StringBuilder msgBuf = new StringBuilder();
                msgBuf.append("Change has been successfully pushed");
                if (!mergedIntoRef.equals(change.getDest().get())) {
                    msgBuf.append(" into ");
                    if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                        msgBuf.append("branch ");
                        msgBuf.append(Repository.shortenRefName(mergedIntoRef));
                    } else {
                        msgBuf.append(mergedIntoRef);
                    }
                }
                msgBuf.append(".");
                ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), info.getKey());
                msg.setMessage(msgBuf.toString());
                cmUtil.addChangeMessage(ctx.getDb(), update, msg);
                PatchSetApproval submitter = new PatchSetApproval(new PatchSetApproval.Key(change.currentPatchSetId(), ctx.getUser().getAccountId(), LabelId.legacySubmit()), (short) 1, ctx.getWhen());
                update.putApproval(submitter.getLabel(), submitter.getValue());
                ctx.getDb().patchSetApprovals().upsert(Collections.singleton(submitter));
                return true;
            }
        });
        bu.execute();
    }
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(project.getNameKey(), ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#method_after
private void reject(ReceiveCommand cmd) {
    reject(cmd, "prohibited by Gerrit");
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(ReceiveCommand cmd, String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
private static boolean isHead(final ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#method_after
private static boolean isHead(ReceiveCommand cmd) {
    return cmd.getRefName().startsWith(Constants.R_HEADS);
}
#end_block

#method_before
private static boolean isConfig(final ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#method_after
private static boolean isConfig(ReceiveCommand cmd) {
    return cmd.getRefName().equals(RefNames.REFS_CONFIG);
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    boolean sameAuthorForAll = true;
    try (Repository pdb = repoManager.openRepository(subscriber.getParentKey())) {
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                if (verboseSuperProject) {
                    msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                    msgbuf.append(" " + s.getSubmodule().getShortName());
                    msgbuf.append(" " + updateTo.getName());
                    msgbuf.append("\n\n");
                    try {
                        rw.markStart(newCommit);
                        rw.markUninteresting(rw.parseCommit(oldId));
                        for (RevCommit c : rw) {
                            msgbuf.append(c.getFullMessage() + "\n\n");
                        }
                    } catch (IOException e) {
                        logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                    }
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
public Repository getRepository() throws IOException {
    initRepository();
    return repo;
}
#method_after
@Override
public Repository getRepository() throws IOException {
    return BatchUpdate.this.getRepository();
}
#end_block

#method_before
public ObjectInserter getInserter() throws IOException {
    initRepository();
    return inserter;
}
#method_after
public ObjectInserter getInserter() throws IOException {
    return BatchUpdate.this.getObjectInserter();
}
#end_block

#method_before
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    getBatchRefUpdate().addCommand(cmd);
}
#method_after
public void addRefUpdate(ReceiveCommand cmd) throws IOException {
    initRepository();
    commands.add(cmd);
}
#end_block

#method_before
public Change getChange() {
    return update.getChange();
}
#method_after
public Change getChange() {
    Change c = ctl.getChange();
    checkNotNull(c);
    return c;
}
#end_block

#method_before
@SuppressWarnings("unused")
public void updateChange(ChangeContext ctx) throws Exception {
}
#method_after
@SuppressWarnings("unused")
public boolean updateChange(ChangeContext ctx) throws Exception {
    return false;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    try {
        Order order = getOrder(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        for (BatchUpdate u : updates) {
            u.executePostOps();
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    return this;
}
#method_after
public BatchUpdate setRepository(Repository repo, RevWalk revWalk, ObjectInserter inserter) {
    checkState(this.repo == null, "repo already set");
    closeRepo = false;
    this.repo = checkNotNull(repo, "repo");
    this.revWalk = checkNotNull(revWalk, "revWalk");
    this.inserter = checkNotNull(inserter, "inserter");
    commands = new ChainedReceiveCommands(repo);
    return this;
}
#end_block

#method_before
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
    }
}
#method_after
private void initRepository() throws IOException {
    if (repo == null) {
        this.repo = repoManager.openRepository(project);
        closeRepo = true;
        inserter = repo.newObjectInserter();
        revWalk = new RevWalk(inserter.newReader());
        commands = new ChainedReceiveCommands(repo);
    }
}
#end_block

#method_before
public BatchUpdate insertChange(InsertChangeOp op) {
    Change c = op.getChange();
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#method_after
public BatchUpdate insertChange(InsertChangeOp op) {
    Context ctx = new Context();
    Change c = op.createChange(ctx);
    checkArgument(!newChanges.containsKey(c.getId()), "only one op allowed to create change %s", c.getId());
    newChanges.put(c.getId(), c);
    ops.get(c.getId()).add(0, op);
    return this;
}
#end_block

#method_before
public void execute() throws UpdateException, RestApiException {
    try {
        executeRefUpdates();
        executeChangeOps();
        reindexChanges();
        if (batchRefUpdate != null) {
            // Fire ref update events only after all mutations are finished, since
            // callers may assume a patch set ref being created means the change was
            // created, or a branch advancing meaning some changes were closed.
            gitRefUpdated.fire(project, batchRefUpdate, user.getAccountId());
        }
        executePostOps();
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
public void execute() throws UpdateException, RestApiException {
    execute(Listener.NONE);
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (repo == null || batchRefUpdate == null || batchRefUpdate.getCommands().isEmpty()) {
        return;
    }
    inserter.flush();
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            try {
                ctx = newChangeContext(id);
                for (Op op : e.getValue()) {
                    op.updateChange(ctx);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            ctx.getChangeUpdate().commit();
            indexFutures.add(indexer.indexAsync(id));
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = stageNoteDbUpdate(ctx);
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (newChanges.containsKey(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    db.changes().insert(cs);
                } else if (ctx.deleted) {
                    db.changes().delete(cs);
                } else {
                    db.changes().update(cs);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = db.changes().get(id);
    }
    // - attempting to read a change that doesn't exist yet
    return new ChangeContext(changeControlFactory.controlFor(c, user));
}
#method_after
private ChangeContext newChangeContext(Change.Id id) throws Exception {
    Change c = newChanges.get(id);
    if (c == null) {
        c = unwrap(db).changes().get(id);
    }
    // Pass in preloaded change to controlFor, to avoid:
    // - reading from a db that does not belong to this update
    // - attempting to read a change that doesn't exist yet
    ChangeNotes notes = changeNotesFactory.createForNew(c);
    ChangeContext ctx = new ChangeContext(changeControlFactory.controlFor(notes, user), new BatchUpdateReviewDb(db));
    return ctx;
}
#end_block

#method_before
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            AccountInfo gerrit = new AccountInfo(null);
            gerrit.name = gerritIdent.getName();
            gerrit.email = gerritIdent.getEmailAddress();
            gitRefUpdated.fire(project, refUpdate, gerrit);
            break;
        }
    }
}
#method_after
private void updateRef(String notesBranch) throws IOException, MissingObjectException, IncorrectObjectTypeException, CorruptObjectException, ConcurrentRefUpdateException {
    if (baseCommit != null && oursCommit.getTree().equals(baseCommit.getTree())) {
        // Avoid saving this commit as it has no new information.
        return;
    }
    int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
    RefUpdate refUpdate = createRefUpdate(notesBranch, oursCommit, baseCommit);
    for (; ; ) {
        Result result = refUpdate.update();
        if (result == Result.LOCK_FAILURE) {
            if (--remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException e) {
                // ignore
                }
            } else {
                throw new ConcurrentRefUpdateException("Failed to lock the ref: " + notesBranch, refUpdate.getRef(), result);
            }
        } else if (result == Result.REJECTED) {
            RevCommit theirsCommit = revWalk.parseCommit(refUpdate.getOldObjectId());
            NoteMap theirs = NoteMap.read(revWalk.getObjectReader(), theirsCommit);
            NoteMapMerger merger = new NoteMapMerger(db, getNoteMerger(), MergeStrategy.RESOLVE);
            NoteMap merged = merger.merge(base, ours, theirs);
            RevCommit mergeCommit = createCommit(merged, gerritIdent, "Merged note commits\n", theirsCommit, oursCommit);
            refUpdate = createRefUpdate(notesBranch, mergeCommit, theirsCommit);
            remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        } else if (result == Result.IO_FAILURE) {
            throw new IOException("Couldn't update " + notesBranch + ". " + result.name());
        } else {
            gitRefUpdated.fire(project, refUpdate, (AccountInfo) null);
            break;
        }
    }
}
#end_block

#method_before
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setAuthor(createPersonIdent(user));
    md.getCommitBuilder().setCommitter(serverIdent);
    return md;
}
#method_after
public MetaDataUpdate create(Project.NameKey name, Repository repository, IdentifiedUser user, BatchRefUpdate batch) {
    MetaDataUpdate md = factory.create(name, repository, batch);
    md.getCommitBuilder().setCommitter(serverIdent);
    md.setAuthor(user);
    return md;
}
#end_block

#method_before
public void setAuthor(IdentifiedUser user) {
    this.user = user;
    getCommitBuilder().setAuthor(user.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#method_after
public void setAuthor(IdentifiedUser author) {
    this.author = author;
    getCommitBuilder().setAuthor(author.newCommitterIdent(getCommitBuilder().getCommitter().getWhen(), getCommitBuilder().getCommitter().getTimeZone()));
}
#end_block

#method_before
public void close() {
    getRepository().close();
}
#method_after
@Override
public void close() {
    getRepository().close();
}
#end_block

#method_before
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, user.getAccount());
}
#method_after
void fireGitRefUpdatedEvent(RefUpdate ru) {
    gitRefUpdated.fire(projectName, ru, author == null ? null : author.getAccount());
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ResourceNotFoundException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(ProjectUtil.stripGitSuffix(name));
    String parentName = MoreObjects.firstNonNull(Strings.emptyToNull(input.parent), allProjects.get());
    args.newParent = projectsCollection.get().parse(parentName).getControl();
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = normalizeBranchNames(input.branches);
    if (input.owners == null || input.owners.isEmpty()) {
        args.ownerIds = new ArrayList<>(projectOwnerGroups.create(args.getProject()).get());
    } else {
        args.ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            args.ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProject(args);
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(projectControl, in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject());
    try {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#method_after
private void createProjectConfig(CreateProjectArgs args) throws IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(args.getProject())) {
        ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(args.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(args.submitType, repositoryCfg.getDefaultSubmitType(args.getProject())));
        newProject.setUseContributorAgreements(args.contributorAgreements);
        newProject.setUseSignedOffBy(args.signedOffBy);
        newProject.setUseContentMerge(args.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(args.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(args.changeIdRequired);
        newProject.setMaxObjectSizeLimit(args.maxObjectSizeLimit);
        if (args.newParent != null) {
            newProject.setParentName(args.newParent.getProject().getNameKey());
        }
        if (!args.ownerIds.isEmpty()) {
            AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : args.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    }
    projectCache.onCreateProject(args.getProject());
    repoManager.setProjectDescription(args.getProject(), args.projectDescription);
}
#end_block

#method_before
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#method_after
private void createEmptyCommits(Repository repo, Project.NameKey project, List<String> refs) throws IOException {
    try (ObjectInserter oi = repo.newObjectInserter()) {
        CommitBuilder cb = new CommitBuilder();
        cb.setTreeId(oi.insert(Constants.OBJ_TREE, new byte[] {}));
        cb.setAuthor(metaDataUpdateFactory.getUserPersonIdent());
        cb.setCommitter(serverIdent);
        cb.setMessage("Initial empty repository\n");
        ObjectId id = oi.insert(cb);
        oi.flush();
        for (String ref : refs) {
            RefUpdate ru = repo.updateRef(ref);
            ru.setNewObjectId(id);
            Result result = ru.update();
            switch(result) {
                case NEW:
                    referenceUpdated.fire(project, ru, ReceiveCommand.Type.CREATE, currentUser.get().getAccountId());
                    break;
                case FAST_FORWARD:
                case FORCED:
                case IO_FAILURE:
                case LOCK_FAILURE:
                case NOT_ATTEMPTED:
                case NO_CHANGE:
                case REJECTED:
                case REJECTED_CURRENT_BRANCH:
                case RENAMED:
                default:
                    {
                        throw new IOException(String.format("Failed to create ref \"%s\": %s", ref, result.name()));
                    }
            }
        }
    } catch (IOException e) {
        log.error("Cannot create empty commit for " + project.get(), e);
        throw e;
    }
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        case LOCK_FAILURE:
        case NOT_ATTEMPTED:
        case OK:
        case REJECTED_MISSING_OBJECT:
        case REJECTED_NOCREATE:
        case REJECTED_NODELETE:
        case REJECTED_NONFASTFORWARD:
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private void postDeletion(ProjectResource project, ReceiveCommand cmd) throws OrmException {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
    ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(branchKey);
    dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
}
#method_after
private void postDeletion(ProjectResource project, ReceiveCommand cmd) {
    referenceUpdated.fire(project.getNameKey(), cmd, identifiedUser.get().getAccount());
    Branch.NameKey branchKey = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
    hooks.doRefUpdatedHook(branchKey, cmd.getOldId(), cmd.getNewId(), identifiedUser.get().getAccount());
}
#end_block

#method_before
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                ResultSet<SubmoduleSubscription> submoduleSubscriptions = dbProvider.get().submoduleSubscriptions().bySuperProject(rsrc.getBranchKey());
                dbProvider.get().submoduleSubscriptions().delete(submoduleSubscriptions);
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(BranchResource rsrc, Input input) throws AuthException, ResourceConflictException, OrmException, IOException {
    if (!rsrc.getControl().controlForRef(rsrc.getBranchKey()).canDelete()) {
        throw new AuthException("Cannot delete branch");
    }
    if (!queryProvider.get().setLimit(1).byBranchOpen(rsrc.getBranchKey()).isEmpty()) {
        throw new ResourceConflictException("branch " + rsrc.getBranchKey() + " has open changes");
    }
    try (Repository r = repoManager.openRepository(rsrc.getNameKey())) {
        RefUpdate.Result result;
        RefUpdate u = r.updateRef(rsrc.getRef());
        u.setForceUpdate(true);
        int remainingLockFailureCalls = MAX_LOCK_FAILURE_CALLS;
        for (; ; ) {
            try {
                result = u.delete();
            } catch (LockFailedException e) {
                result = RefUpdate.Result.LOCK_FAILURE;
            } catch (IOException e) {
                log.error("Cannot delete " + rsrc.getBranchKey(), e);
                throw e;
            }
            if (result == RefUpdate.Result.LOCK_FAILURE && --remainingLockFailureCalls > 0) {
                try {
                    Thread.sleep(SLEEP_ON_LOCK_FAILURE_MS);
                } catch (InterruptedException ie) {
                // ignore
                }
            } else {
                break;
            }
        }
        switch(result) {
            case NEW:
            case NO_CHANGE:
            case FAST_FORWARD:
            case FORCED:
                referenceUpdated.fire(rsrc.getNameKey(), u, ReceiveCommand.Type.DELETE, identifiedUser.get().getAccount());
                hooks.doRefUpdatedHook(rsrc.getBranchKey(), u, identifiedUser.get().getAccount());
                break;
            case REJECTED_CURRENT_BRANCH:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete current branch");
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case REJECTED:
            case RENAMED:
            default:
                log.error("Cannot delete " + rsrc.getBranchKey() + ": " + result.name());
                throw new ResourceConflictException("cannot delete branch: " + result.name());
        }
    }
    return Response.none();
}
#end_block

#method_before
@Test
public void testPushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.: my test message");
    }
}
#method_after
@Test
public void testPushForMasterWithMessage() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master/%m=my_test_message");
    r.assertOkStatus();
    r.assertChange(Change.Status.NEW, null);
    ChangeInfo ci = get(r.getChangeId());
    Collection<ChangeMessageInfo> changeMessages = ci.messages;
    assertThat(changeMessages).hasSize(1);
    for (ChangeMessageInfo cm : changeMessages) {
        assertThat(cm.message).isEqualTo("Uploaded patch set 1.\nmy test message");
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap());
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg = msg + ": " + magicBranch.message;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException, NoSuchChangeException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    checkNotNull(magicBranch);
    recipients.add(magicBranch.getMailRecipients());
    approvals = magicBranch.labels;
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    StringBuilder msg = new StringBuilder(ApprovalsUtil.renderMessageWithApprovals(psId.get(), approvals, Collections.<String, PatchSetApproval>emptyMap()));
    if (!Strings.isNullOrEmpty(magicBranch.message)) {
        msg.append("\n").append(magicBranch.message);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg.toString()).setNotify(magicBranch.notify).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
        if (!Strings.isNullOrEmpty(magicBranch.topic)) {
            bu.addOp(changeId, new BatchUpdate.Op() {

                @Override
                public boolean updateChange(ChangeContext ctx) {
                    ctx.getUpdate(psId).setTopic(magicBranch.topic);
                    return true;
                }
            });
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String branchMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        branchMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, change.getDest().get(), commit);
        mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getUser().getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    recipients.add(oldRecipients);
    String approvalMessage = renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    String message = approvalMessage;
    String kindMessage = changeKindMessage(changeKind);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message = message + kindMessage;
    }
    if (!Strings.isNullOrEmpty(branchMessage)) {
        message = message + ": " + branchMessage;
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message);
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedIntoRef == null) {
        resetChange(ctx, msg);
    }
    ctx.saveChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    change = ctx.getChange();
    if (change == null || change.getStatus().isClosed()) {
        rejectMessage = CHANGE_IS_CLOSED;
        return false;
    }
    if (groups.isEmpty()) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        groups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
    }
    ChangeUpdate update = ctx.getUpdate(patchSetId);
    update.setSubjectForCommit("Create patch set " + patchSetId.get());
    String reviewMessage = null;
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        reviewMessage = magicBranch.message;
        approvals.putAll(magicBranch.labels);
        Set<String> hashtags = magicBranch.hashtags;
        if (hashtags != null && !hashtags.isEmpty()) {
            hashtags.addAll(ctx.getNotes().getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(ctx.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    boolean draft = magicBranch != null && magicBranch.draft;
    newPatchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), update, patchSetId, commit, draft, groups, pushCertificate != null ? pushCertificate.toTextWithSignature() : null);
    if (checkMergedInto) {
        Ref mergedInto = findMergedInto(ctx, change.getDest().get(), commit);
        mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, draft, commit.getFooterLines()));
    recipients.remove(ctx.getUser().getAccountId());
    ChangeData cd = changeDataFactory.create(ctx.getDb(), ctx.getControl());
    MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
    approvalCopier.copy(ctx.getDb(), ctx.getControl(), newPatchSet);
    approvalsUtil.addReviewers(ctx.getDb(), update, projectControl.getLabelTypes(), change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
    approvalsUtil.addApprovals(ctx.getDb(), update, projectControl.getLabelTypes(), newPatchSet, ctx.getControl(), approvals);
    recipients.add(oldRecipients);
    String approvalMessage = ApprovalsUtil.renderMessageWithApprovals(patchSetId.get(), approvals, scanLabels(ctx, approvals));
    StringBuilder message = new StringBuilder(approvalMessage);
    String kindMessage = changeKindMessage(changeKind);
    if (!Strings.isNullOrEmpty(kindMessage)) {
        message.append(kindMessage);
    }
    if (!Strings.isNullOrEmpty(reviewMessage)) {
        message.append("\n").append(reviewMessage);
    }
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    msg.setMessage(message.toString());
    cmUtil.addChangeMessage(ctx.getDb(), update, msg);
    if (mergedIntoRef == null) {
        resetChange(ctx, msg);
    }
    ctx.saveChange();
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    changeMergedEvents = new HashMap<>();
    refUpdatedEvents = new HashMap<>();
    eventListenerRegistration = eventListeners.add(new UserScopedEventListener() {

        @Override
        public void onEvent(Event event) {
            if (event instanceof ChangeMergedEvent) {
                ChangeMergedEvent e = (ChangeMergedEvent) event;
                ChangeAttribute c = e.change.get();
                PatchSetAttribute ps = e.patchSet.get();
                log.debug("Merged {},{} as {}", ps.number, c.number, e.newRev);
                changeMergedEvents.put(e.change.get().number, e.newRev);
            } else if (event instanceof RefUpdatedEvent) {
                RefUpdatedEvent e = (RefUpdatedEvent) event;
                RefUpdateAttribute r = e.refUpdate.get();
                log.debug("Branch {} ref updated to {}", r.refName, r.newRev);
                refUpdatedEvents.put(r.refName, r.newRev);
            }
        }

        @Override
        public CurrentUser getUser() {
            return factory.create(user.id);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    mergeResults = Maps.newHashMap();
    refUpdatedEvents = Maps.newHashMap();
    CurrentUser listenerUser = factory.create(user.id);
    source.addEventListener(new EventListener() {

        @Override
        public void onEvent(Event event) {
            if (event instanceof ChangeMergedEvent) {
                ChangeMergedEvent changeMergedEvent = (ChangeMergedEvent) event;
                mergeResults.put(changeMergedEvent.change.number, changeMergedEvent.newRev);
            } else if (event instanceof RefUpdatedEvent) {
                RefUpdatedEvent e = (RefUpdatedEvent) event;
                RefUpdateAttribute r = e.refUpdate;
                refUpdatedEvents.put(r.project + "-" + r.refName, r.newRev);
            }
        }
    }, listenerUser);
}
#end_block

#method_before
@After
public void cleanup() {
    eventListenerRegistration.remove();
    db.close();
}
#method_after
@After
public void cleanup() {
    db.close();
}
#end_block

#method_before
@Test
@TestProjectInput(createEmptyCommit = false)
public void submitToEmptyRepo() throws Exception {
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    assertThat(getRemoteHead().getId()).isEqualTo(change.getCommit());
}
#method_after
@Test
@TestProjectInput(createEmptyCommit = false)
public void submitToEmptyRepo() throws Exception {
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    assertThat(getRemoteHead().getId()).isEqualTo(change.getCommitId());
}
#end_block

#method_before
private void assertSubmitter(PushOneCommit.Result change) throws Exception {
    ChangeInfo info = get(change.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info.messages).isNotNull();
    Iterable<String> messages = Iterables.transform(info.messages, new Function<ChangeMessageInfo, String>() {

        @Override
        public String apply(ChangeMessageInfo in) {
            return in.message;
        }
    });
    assertThat(messages).hasSize(3);
    String last = Iterables.getLast(messages);
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        assertThat(last).startsWith("Change has been successfully cherry-picked as ");
    } else {
        assertThat(last).isEqualTo("Change has been successfully merged by Administrator");
    }
}
#method_after
private void assertSubmitter(PushOneCommit.Result change) throws Exception {
    ChangeInfo info = get(change.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info.messages).isNotNull();
    assertThat(info.messages).hasSize(3);
    if (getSubmitType() == SubmitType.CHERRY_PICK) {
        assertThat(Iterables.getLast(info.messages).message).startsWith("Change has been successfully cherry-picked as ");
    } else {
        assertThat(Iterables.getLast(info.messages).message).isEqualTo("Change has been successfully merged by Administrator");
    }
}
#end_block

#method_before
protected void submit(String changeId) throws Exception {
    submit(changeId, new SubmitInput(), null, null, true);
}
#method_after
protected void submit(String changeId) throws Exception {
    submit(changeId, HttpStatus.SC_OK, null);
}
#end_block

#method_before
protected void submitWithConflict(String changeId, String expectedError) throws Exception {
    submit(changeId, new SubmitInput(), ResourceConflictException.class, expectedError, true);
}
#method_after
protected void submitWithConflict(String changeId, String expectedError) throws Exception {
    submit(changeId, HttpStatus.SC_CONFLICT, expectedError);
}
#end_block

#method_before
protected void submit(String changeId, SubmitInput input, Class<? extends RestApiException> expectedExceptionType, String expectedExceptionMsg, boolean checkMergeResult) throws Exception {
    approve(changeId);
    if (expectedExceptionType == null) {
        assertSubmittable(changeId);
    }
    try {
        gApi.changes().id(changeId).current().submit(input);
        if (expectedExceptionType != null) {
            fail("Expected exception of type " + expectedExceptionType.getSimpleName());
        }
    } catch (RestApiException e) {
        if (expectedExceptionType == null) {
            throw e;
        }
        // us the stack trace.
        if (!expectedExceptionType.isAssignableFrom(e.getClass()) || !e.getMessage().equals(expectedExceptionMsg)) {
            throw new AssertionError("Expected exception of type " + expectedExceptionType.getSimpleName() + " with message: \"" + expectedExceptionMsg + "\" but got exception of type " + e.getClass().getSimpleName() + " with message \"" + e.getMessage() + "\"", e);
        }
        return;
    }
    ChangeInfo change = gApi.changes().id(changeId).info();
    assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
    if (checkMergeResult) {
        checkMergeResult(change);
    }
}
#method_after
private void submit(String changeId, int expectedStatus, String msg) throws Exception {
    approve(changeId);
    SubmitInput subm = new SubmitInput();
    RestResponse r = adminSession.post("/changes/" + changeId + "/submit", subm);
    assertThat(r.getStatusCode()).isEqualTo(expectedStatus);
    if (expectedStatus == HttpStatus.SC_OK) {
        checkArgument(msg == null, "msg must be null for successful submits");
        ChangeInfo change = newGson().fromJson(r.getReader(), new TypeToken<ChangeInfo>() {
        }.getType());
        assertThat(change.status).isEqualTo(ChangeStatus.MERGED);
        checkMergeResult(change);
    } else {
        checkArgument(!Strings.isNullOrEmpty(msg), "msg must be a valid string " + "containing an error message for unsuccessful submits");
        assertThat(r.getEntityContent()).isEqualTo(msg);
    }
    r.consume();
}
#end_block

#method_before
private void checkMergeResult(ChangeInfo change) throws Exception {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent and RefUpdatedEvent.
    BranchInfo branch = gApi.projects().name(change.project).branch(change.branch).get();
    assertThat(changeMergedEvents).isNotEmpty();
    assertThat(refUpdatedEvents).isNotEmpty();
    String newRev = changeMergedEvents.get(Integer.toString(change._number));
    assertThat(newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(newRev);
    newRev = refUpdatedEvents.get(branch.ref);
    assertThat(newRev).isNotNull();
    assertThat(branch.revision).isEqualTo(newRev);
}
#method_after
private void checkMergeResult(ChangeInfo change) throws IOException {
    // Get the revision of the branch after the submit to compare with the
    // newRev of the ChangeMergedEvent and RefUpdatedEvent.
    RestResponse b = adminSession.get("/projects/" + change.project + "/branches/" + change.branch);
    if (b.getStatusCode() == HttpStatus.SC_OK) {
        BranchInfo branch = newGson().fromJson(b.getReader(), new TypeToken<BranchInfo>() {
        }.getType());
        assertThat(mergeResults).isNotEmpty();
        assertThat(refUpdatedEvents).isNotEmpty();
        String newRev = mergeResults.get(Integer.toString(change._number));
        assertThat(newRev).isNotNull();
        assertThat(branch.revision).isEqualTo(newRev);
        newRev = refUpdatedEvents.get(change.project + "-" + branch.ref);
        assertThat(newRev).isNotNull();
        assertThat(branch.revision).isEqualTo(newRev);
    }
    b.consume();
}
#end_block

#method_before
protected void assertCurrentRevision(String changeId, int expectedNum, ObjectId expectedId) throws Exception {
    ChangeInfo c = get(changeId, CURRENT_REVISION);
    assertThat(c.currentRevision).isEqualTo(expectedId.name());
    assertThat(c.revisions.get(expectedId.name())._number).isEqualTo(expectedNum);
    try (Repository repo = repoManager.openRepository(new Project.NameKey(c.project))) {
        String refName = new PatchSet.Id(new Change.Id(c._number), expectedNum).toRefName();
        Ref ref = repo.exactRef(refName);
        assertThat(ref).named(refName).isNotNull();
        assertThat(ref.getObjectId()).isEqualTo(expectedId);
    }
}
#method_after
protected void assertCurrentRevision(String changeId, int expectedNum, ObjectId expectedId) throws Exception {
    ChangeInfo c = get(changeId, CURRENT_REVISION);
    assertThat(c.currentRevision).isEqualTo(expectedId.name());
    assertThat(c.revisions.get(expectedId.name())._number).isEqualTo(expectedNum);
    try (Repository repo = repoManager.openRepository(new Project.NameKey(c.project))) {
        String refName = new PatchSet.Id(new Change.Id(c._number), expectedNum).toRefName();
        Ref ref = repo.getRef(refName);
        assertThat(ref).named(refName).isNotNull();
        assertThat(ref.getObjectId()).isEqualTo(expectedId);
    }
}
#end_block

#method_before
protected void assertSubmitter(String changeId, int psId) throws Exception {
    Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change();
    ChangeNotes cn = notesFactory.createChecked(db, c);
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter).isNotNull();
    assertThat(submitter.isLegacySubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#method_after
protected void assertSubmitter(String changeId, int psId) throws OrmException {
    ChangeNotes cn = notesFactory.create(getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change());
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter.isSubmit()).isTrue();
    assertThat(submitter.getAccountId()).isEqualTo(admin.getId());
}
#end_block

#method_before
protected void assertNoSubmitter(String changeId, int psId) throws Exception {
    Change c = getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change();
    ChangeNotes cn = notesFactory.createChecked(db, c);
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter).isNull();
}
#method_after
protected void assertNoSubmitter(String changeId, int psId) throws OrmException {
    ChangeNotes cn = notesFactory.create(getOnlyElement(queryProvider.get().byKeyPrefix(changeId)).change());
    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, cn, new PatchSet.Id(cn.getChangeId(), psId));
    assertThat(submitter).isNull();
}
#end_block

#method_before
protected void assertCherryPick(TestRepository<?> testRepo, boolean contentMerge) throws Exception {
    assertRebase(testRepo, contentMerge);
    RevCommit remoteHead = getRemoteHead();
    assertThat(remoteHead.getFooterLines("Reviewed-On")).isNotEmpty();
    assertThat(remoteHead.getFooterLines("Reviewed-By")).isNotEmpty();
}
#method_after
protected void assertCherryPick(TestRepository<?> testRepo, boolean contentMerge) throws IOException {
    assertRebase(testRepo, contentMerge);
    RevCommit remoteHead = getRemoteHead();
    assertThat(remoteHead.getFooterLines("Reviewed-On")).isNotEmpty();
    assertThat(remoteHead.getFooterLines("Reviewed-By")).isNotEmpty();
}
#end_block

#method_before
protected void assertRebase(TestRepository<?> testRepo, boolean contentMerge) throws Exception {
    Repository repo = testRepo.getRepository();
    RevCommit localHead = getHead(repo);
    RevCommit remoteHead = getRemoteHead();
    assert_().withFailureMessage(String.format("%s not equal %s", localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId());
    assertThat(remoteHead.getParentCount()).isEqualTo(1);
    if (!contentMerge) {
        assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo));
    }
    assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage());
}
#method_after
protected void assertRebase(TestRepository<?> testRepo, boolean contentMerge) throws IOException {
    Repository repo = testRepo.getRepository();
    RevCommit localHead = getHead(repo);
    RevCommit remoteHead = getRemoteHead();
    assert_().withFailureMessage(String.format("%s not equal %s", localHead.name(), remoteHead.name())).that(localHead.getId()).isNotEqualTo(remoteHead.getId());
    assertThat(remoteHead.getParentCount()).isEqualTo(1);
    if (!contentMerge) {
        assertThat(getLatestRemoteDiff()).isEqualTo(getLatestDiff(repo));
    }
    assertThat(remoteHead.getShortMessage()).isEqualTo(localHead.getShortMessage());
}
#end_block

#method_before
private RevCommit getHead(Repository repo) throws Exception {
    return getHead(repo, "HEAD");
}
#method_after
private RevCommit getHead(Repository repo) throws IOException {
    return getHead(repo, "HEAD");
}
#end_block

#method_before
protected RevCommit getRemoteHead(Project.NameKey project, String branch) throws Exception {
    try (Repository repo = repoManager.openRepository(project)) {
        return getHead(repo, "refs/heads/" + branch);
    }
}
#method_after
protected RevCommit getRemoteHead(Project.NameKey project, String branch) throws IOException {
    try (Repository repo = repoManager.openRepository(project)) {
        return getHead(repo, "refs/heads/" + branch);
    }
}
#end_block

#method_before
protected RevCommit getRemoteHead() throws Exception {
    return getRemoteHead(project, "master");
}
#method_after
protected RevCommit getRemoteHead() throws IOException {
    return getRemoteHead(project, "master");
}
#end_block

#method_before
protected List<RevCommit> getRemoteLog(Project.NameKey project, String branch) throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        rw.markStart(rw.parseCommit(repo.exactRef("refs/heads/" + branch).getObjectId()));
        return Lists.newArrayList(rw);
    }
}
#method_after
protected List<RevCommit> getRemoteLog(Project.NameKey project, String branch) throws IOException {
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        rw.markStart(rw.parseCommit(repo.getRef("refs/heads/" + branch).getObjectId()));
        return Lists.newArrayList(rw);
    }
}
#end_block

#method_before
protected List<RevCommit> getRemoteLog() throws Exception {
    return getRemoteLog(project, "master");
}
#method_after
protected List<RevCommit> getRemoteLog() throws IOException {
    return getRemoteLog(project, "master");
}
#end_block

#method_before
private RevCommit getHead(Repository repo, String name) throws Exception {
    try (RevWalk rw = new RevWalk(repo)) {
        return rw.parseCommit(repo.exactRef(name).getObjectId());
    }
}
#method_after
private RevCommit getHead(Repository repo, String name) throws IOException {
    try (RevWalk rw = new RevWalk(repo)) {
        return rw.parseCommit(repo.getRef(name).getObjectId());
    }
}
#end_block

#method_before
private String getLatestDiff(Repository repo) throws Exception {
    ObjectId oldTreeId = repo.resolve("HEAD~1^{tree}");
    ObjectId newTreeId = repo.resolve("HEAD^{tree}");
    return getLatestDiff(repo, oldTreeId, newTreeId);
}
#method_after
private String getLatestDiff(Repository repo) throws IOException {
    ObjectId oldTreeId = repo.resolve("HEAD~1^{tree}");
    ObjectId newTreeId = repo.resolve("HEAD^{tree}");
    return getLatestDiff(repo, oldTreeId, newTreeId);
}
#end_block

#method_before
private String getLatestRemoteDiff() throws Exception {
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        ObjectId oldTreeId = repo.resolve("refs/heads/master~1^{tree}");
        ObjectId newTreeId = repo.resolve("refs/heads/master^{tree}");
        return getLatestDiff(repo, oldTreeId, newTreeId);
    }
}
#method_after
private String getLatestRemoteDiff() throws IOException {
    try (Repository repo = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        ObjectId oldTreeId = repo.resolve("refs/heads/master~1^{tree}");
        ObjectId newTreeId = repo.resolve("refs/heads/master^{tree}");
        return getLatestDiff(repo, oldTreeId, newTreeId);
    }
}
#end_block

#method_before
private String getLatestDiff(Repository repo, ObjectId oldTreeId, ObjectId newTreeId) throws Exception {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try (DiffFormatter fmt = new DiffFormatter(out)) {
        fmt.setRepository(repo);
        fmt.format(oldTreeId, newTreeId);
        fmt.flush();
        return out.toString();
    }
}
#method_after
private String getLatestDiff(Repository repo, ObjectId oldTreeId, ObjectId newTreeId) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    try (DiffFormatter fmt = new DiffFormatter(out)) {
        fmt.setRepository(repo);
        fmt.format(oldTreeId, newTreeId);
        fmt.flush();
        return out.toString();
    }
}
#end_block

#method_before
@Override
public Block getBlock() {
    return new TocBlock();
}
#method_after
@Override
public Block getBlock() {
    return block;
}
#end_block

#method_before
private static IframeBlock iframe(String html) {
    IframeBlock iframe = new IframeBlock();
    Matcher m = ATTR.matcher(html);
    while (m.find()) {
        String att = m.group(1).toLowerCase();
        String val = m.group(3);
        switch(att) {
            case "src":
                if (!HtmlBuilder.isValidHttpUri(val)) {
                    return null;
                }
                iframe.src = val;
                break;
            case "height":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.height = val;
                break;
            case "width":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.width = val;
                break;
            case "frameborder":
                iframe.border = !"0".equals(val);
                break;
        }
    }
    return iframe.src != null ? iframe : null;
}
#method_after
private static IframeBlock iframe(String html) {
    IframeBlock iframe = new IframeBlock();
    Matcher m = ATTR.matcher(html);
    while (m.find()) {
        String att = m.group(1).toLowerCase();
        String val = attributeValue(m);
        switch(att) {
            case "src":
                if (!HtmlBuilder.isValidHttpUri(val)) {
                    return null;
                }
                iframe.src = val;
                break;
            case "height":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.height = val;
                break;
            case "width":
                if (!HtmlBuilder.isValidCssDimension(val)) {
                    return null;
                }
                iframe.width = val;
                break;
            case "frameborder":
                iframe.border = !"0".equals(val);
                break;
        }
    }
    return iframe.src != null ? iframe : null;
}
#end_block

#method_before
public void visit(TableBlock node) {
    table = new TableState();
    wrapChildren("table", node);
    table = null;
}
#method_after
public void visit(TableBlock node) {
    wrapChildren("table", node);
}
#end_block

#method_before
private void visit(TableRow node) {
    mustBeInsideTable(node);
    table.startRow();
    wrapChildren("tr", node);
}
#method_after
private void visit(TableRow node) {
    wrapChildren("tr", node);
}
#end_block

#method_before
private void visit(TableCell cell) {
    mustBeInsideTable(cell);
    String tag = cell.isHeader() ? "th" : "td";
    html.open(tag);
    TableCell.Alignment alignment = cell.getAlignment();
    if (alignment != null) {
        html.attribute("align", toHtml(alignment));
    }
    // TODO(sop) colspan
    // if (node.getColSpan() > 1) {
    // html.attribute("colspan", Integer.toString(node.getColSpan()));
    // }
    visitChildren(cell);
    html.close(tag);
    table.done(cell);
}
#method_after
private void visit(TableCell cell) {
    String tag = cell.isHeader() ? "th" : "td";
    html.open(tag);
    TableCell.Alignment alignment = cell.getAlignment();
    if (alignment != null) {
        html.attribute("align", toHtml(alignment));
    }
    visitChildren(cell);
    html.close(tag);
}
#end_block

#method_before
private static String toHtml(TableCell.Alignment alignment) {
    switch(alignment) {
        case LEFT:
            return "left";
        case CENTER:
            return "center";
        case RIGHT:
            return "right";
        default:
            throw new IllegalStateException("unsupported alignment " + alignment);
    }
}
#method_after
private static String toHtml(TableCell.Alignment alignment) {
    switch(alignment) {
        case LEFT:
            return "left";
        case CENTER:
            return "center";
        case RIGHT:
            return "right";
        default:
            throw new IllegalArgumentException("unsupported alignment " + alignment);
    }
}
#end_block

#method_before
private void visit(SmartQuoted node) {
    switch(node.getType()) {
        case DOUBLE:
            html.entity("&ldquo;");
            visitChildren(node);
            html.entity("&rdquo;");
            break;
        case SINGLE:
            html.entity("&lsquo;");
            visitChildren(node);
            html.entity("&rsquo;");
            break;
        default:
            checkState(false, "unsupported quote %s", node.getType());
    }
}
#method_after
private void visit(SmartQuoted node) {
    switch(node.getType()) {
        case DOUBLE:
            html.entity("&ldquo;");
            visitChildren(node);
            html.entity("&rdquo;");
            break;
        case SINGLE:
            html.entity("&lsquo;");
            visitChildren(node);
            html.entity("&rsquo;");
            break;
        default:
            throw new IllegalArgumentException("unsupported quote " + node.getType());
    }
}
#end_block

#method_before
@Override
public void visit(CustomNode node) {
    if (node instanceof NamedAnchor) {
        visit((NamedAnchor) node);
    } else if (node instanceof SmartQuoted) {
        visit((SmartQuoted) node);
    } else if (node instanceof Strikethrough) {
        wrapChildren("del", node);
    } else if (node instanceof TableBody) {
        wrapChildren("tbody", node);
    } else if (node instanceof TableCell) {
        visit((TableCell) node);
    } else if (node instanceof TableHead) {
        wrapChildren("thead", node);
    } else if (node instanceof TableRow) {
        visit((TableRow) node);
    } else {
        checkState(false, "cannot render %s", node.getClass());
    }
}
#method_after
@Override
public void visit(CustomNode node) {
    if (node instanceof NamedAnchor) {
        visit((NamedAnchor) node);
    } else if (node instanceof SmartQuoted) {
        visit((SmartQuoted) node);
    } else if (node instanceof Strikethrough) {
        wrapChildren("del", node);
    } else if (node instanceof TableBody) {
        wrapChildren("tbody", node);
    } else if (node instanceof TableCell) {
        visit((TableCell) node);
    } else if (node instanceof TableHead) {
        wrapChildren("thead", node);
    } else if (node instanceof TableRow) {
        visit((TableRow) node);
    } else {
        throw new IllegalArgumentException("cannot render " + node.getClass());
    }
}
#end_block

#method_before
@Override
public void visit(CustomBlock node) {
    if (node instanceof BlockNote) {
        visit((BlockNote) node);
    } else if (node instanceof IframeBlock) {
        visit((IframeBlock) node);
    } else if (node instanceof MultiColumnBlock) {
        visit((MultiColumnBlock) node);
    } else if (node instanceof MultiColumnBlock.Column) {
        visit((MultiColumnBlock.Column) node);
    } else if (node instanceof TableBlock) {
        visit((TableBlock) node);
    } else if (node instanceof TocBlock) {
        toc.format();
    } else {
        checkState(false, "cannot render %s", node.getClass());
    }
}
#method_after
@Override
public void visit(CustomBlock node) {
    if (node instanceof BlockNote) {
        visit((BlockNote) node);
    } else if (node instanceof IframeBlock) {
        visit((IframeBlock) node);
    } else if (node instanceof MultiColumnBlock) {
        visit((MultiColumnBlock) node);
    } else if (node instanceof MultiColumnBlock.Column) {
        visit((MultiColumnBlock.Column) node);
    } else if (node instanceof TableBlock) {
        visit((TableBlock) node);
    } else if (node instanceof TocBlock) {
        toc.format();
    } else {
        throw new IllegalArgumentException("cannot render " + node.getClass());
    }
}
#end_block

#method_before
@Override
public void extend(Parser.Builder builder) {
    builder.customBlockParserFactory(new DivParserFactory());
}
#method_after
@Override
public void extend(Parser.Builder builder) {
    builder.customBlockParserFactory(new NoteParserFactory());
}
#end_block

#method_before
@Override
void clearLine(DisplaySide side, int line, CommentGroup group) {
    SortedMap<Integer, SideBySideCommentGroup> map = map(side);
    if (map.get(line) == group) {
        map.remove(line);
    }
}
#method_after
@Override
void clearLine(DisplaySide side, int line, CommentGroup group) {
    super.clearLine(side, line, group);
}
#end_block

#method_before
@Override
void newDraftOnGutterClick(CodeMirror cm, String gutterClass, int line) {
    insertNewDraft(cm.side(), line);
}
#method_after
@Override
void newDraftOnGutterClick(CodeMirror cm, String gutterClass, int line) {
    if (!Gerrit.isSignedIn()) {
        signInCallback(cm).run();
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#end_block

#method_before
private void newDraft(CodeMirror cm) {
    int line = cm.getLineNumber(cm.extras().activeLine()) + 1;
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        addDraftBox(cm.side(), CommentInfo.create(getPath(), getStoredSideFromDisplaySide(cm.side()), line, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(fromTo.to());
        cm.setSelection(cm.getCursor());
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#method_after
@Override
void newDraft(CodeMirror cm) {
    int line = cm.getLineNumber(cm.extras().activeLine()) + 1;
    if (cm.somethingSelected()) {
        FromTo fromTo = adjustSelection(cm);
        addDraftBox(cm.side(), CommentInfo.create(getPath(), getStoredSideFromDisplaySide(cm.side()), line, CommentRange.create(fromTo))).setEdit(true);
        cm.setCursor(fromTo.to());
        cm.setSelection(cm.getCursor());
    } else {
        insertNewDraft(cm.side(), line);
    }
}
#end_block

#method_before
private SideBySideCommentGroup group(DisplaySide side, int line) {
    SideBySideCommentGroup existing = map(side).get(line);
    if (existing != null) {
        return existing;
    }
    SideBySideCommentGroup newGroup = newGroup(side, line);
    Map<Integer, SideBySideCommentGroup> map = side == DisplaySide.A ? sideA : sideB;
    Map<Integer, SideBySideCommentGroup> otherMap = side == DisplaySide.A ? sideB : sideA;
    map.put(line, newGroup);
    int otherLine = host.lineOnOther(side, line - 1).getLine() + 1;
    existing = map(side.otherSide()).get(otherLine);
    SideBySideCommentGroup otherGroup;
    if (existing != null) {
        otherGroup = existing;
    } else {
        otherGroup = newGroup(side.otherSide(), otherLine);
        otherMap.put(otherLine, otherGroup);
    }
    SideBySideCommentGroup.pair(newGroup, otherGroup);
    if (isAttached()) {
        newGroup.init(host.getDiffTable());
        otherGroup.handleRedraw();
    }
    return newGroup;
}
#method_after
@Override
CommentGroup group(DisplaySide side, int line) {
    CommentGroup existing = map(side).get(line);
    if (existing != null) {
        return existing;
    }
    SideBySideCommentGroup newGroup = newGroup(side, line);
    Map<Integer, CommentGroup> map = side == DisplaySide.A ? sideA : sideB;
    Map<Integer, CommentGroup> otherMap = side == DisplaySide.A ? sideB : sideA;
    map.put(line, newGroup);
    int otherLine = host.lineOnOther(side, line - 1).getLine() + 1;
    existing = map(side.otherSide()).get(otherLine);
    CommentGroup otherGroup;
    if (existing != null) {
        otherGroup = existing;
    } else {
        otherGroup = newGroup(side.otherSide(), otherLine);
        otherMap.put(otherLine, otherGroup);
    }
    SideBySideCommentGroup.pair(newGroup, (SideBySideCommentGroup) otherGroup);
    if (isAttached()) {
        newGroup.init(host.getDiffTable());
        otherGroup.handleRedraw();
    }
    return newGroup;
}
#end_block

#method_before
protected TestRepository<?> createProjectWithPush(String name, Project.NameKey parent) throws Exception {
    Project.NameKey project = createProject(name, parent);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#method_after
protected TestRepository<?> createProjectWithPush(String name, @Nullable Project.NameKey parent) throws Exception {
    Project.NameKey project = createProject(name, parent);
    grant(Permission.PUSH, project, "refs/heads/*");
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/*");
    return cloneProject(project);
}
#end_block

#method_before
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    ObjectId subHEAD = pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEAD);
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
}
#method_after
@Test
public void testCircularSubscriptionIsDetected() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    allowSubmoduleSubscription("subscribed-to-project", "refs/heads/master", "super-project", "refs/heads/master");
    allowSubmoduleSubscription("super-project", "refs/heads/master", "subscribed-to-project", "refs/heads/master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    createSubmoduleSubscription(superRepo, "master", "subscribed-to-project", "master");
    createSubmoduleSubscription(subRepo, "master", "super-project", "master");
    pushChangeTo(subRepo, "master");
    pushChangeTo(superRepo, "master");
    assertThat(hasSubmodule(subRepo, "master", "super-project")).isFalse();
    assertThat(hasSubmodule(superRepo, "master", "subscribed-to-project")).isFalse();
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    ProjectState state = projectStateFactory.create(cfg);
    for (SubscribeSection s : state.getInheritedSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : projectStateFactory.create(cfg).getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu, account);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for" + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    for (Branch.NameKey updatedBranch : updatedBranches) {
        logDebug("Now processing " + updatedBranch);
        Set<Branch.NameKey> checkedTargets = new HashSet<>();
        Set<Branch.NameKey> targetsToProcess = new HashSet<>();
        targetsToProcess.add(updatedBranch);
        while (!targetsToProcess.isEmpty()) {
            Set<Branch.NameKey> newTargets = new HashSet<>();
            for (Branch.NameKey b : targetsToProcess) {
                try {
                    Collection<SubmoduleSubscription> subs = superProjectSubscriptionsForSubmoduleBranch(b, orm);
                    for (SubmoduleSubscription sub : subs) {
                        Branch.NameKey dst = sub.getSuperProject();
                        targets.put(dst, sub);
                        newTargets.add(dst);
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Cannot find superprojects for " + b, e);
                }
            }
            logDebug("adding to done " + targetsToProcess);
            checkedTargets.addAll(targetsToProcess);
            logDebug("completely done with " + checkedTargets);
            Set<Branch.NameKey> intersection = new HashSet<>(checkedTargets);
            intersection.retainAll(newTargets);
            if (!intersection.isEmpty()) {
                throw new SubmoduleException("Possible circular subscription involving " + updatedBranch);
            }
            targetsToProcess = newTargets;
        }
    }
    for (Branch.NameKey dst : targets.keySet()) {
        try {
            updateGitlinks(dst, targets.get(dst), orm);
        } catch (SubmoduleException e) {
            throw new SubmoduleException("Cannot update gitlinks for " + dst, e);
        }
    }
}
#end_block

#method_before
@Test
public void GetDiffPreferences() throws Exception {
    RestResponse r = adminRestSession.get("/config/server/preferences.diff");
    r.assertOK();
    DiffPreferencesInfo result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class);
    System.out.println("Context" + result.context);
    assertEquals(result, DiffPreferencesInfo.defaults());
}
#method_after
@Test
public void GetDiffPreferences() throws Exception {
    DiffPreferencesInfo result = get();
    assertPrefsEqual(result, DiffPreferencesInfo.defaults());
}
#end_block

#method_before
public void SetDiffPreferences() throws Exception {
    int defaultLineLength = DiffPreferencesInfo.defaults().lineLength;
    int newLineLength = defaultLineLength + 10;
    DiffPreferencesInfo update = new DiffPreferencesInfo();
    update.lineLength = newLineLength;
    RestResponse r = adminRestSession.put("/config/server/preferences.diff", update);
    r.assertOK();
    DiffPreferencesInfo result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class);
    assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength);
    r = adminRestSession.get("/config/server/preferences.diff");
    r.assertOK();
    result = newGson().fromJson(r.getReader(), DiffPreferencesInfo.class);
    assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength);
    DiffPreferencesInfo expectedDPI = DiffPreferencesInfo.defaults();
    expectedDPI.lineLength = newLineLength;
    assertEquals(result, expectedDPI);
}
#method_after
@Test
public void SetDiffPreferences() throws Exception {
    int newLineLength = DiffPreferencesInfo.defaults().lineLength + 10;
    DiffPreferencesInfo update = new DiffPreferencesInfo();
    update.lineLength = newLineLength;
    DiffPreferencesInfo result = put(update);
    assertThat(result.lineLength).named("lineLength").isEqualTo(newLineLength);
    result = get();
    DiffPreferencesInfo expected = DiffPreferencesInfo.defaults();
    expected.lineLength = newLineLength;
    assertPrefsEqual(result, expected);
}
#end_block

#method_before
@Override
public Object apply(ConfigResource configResource, DiffPreferencesInfo in) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    if (!in.hasSetFields()) {
        throw new BadRequestException("unsupported option");
    }
    return writeToGit(readFromGit(gitManager, allUsersName, in));
}
#method_after
@Override
public Object apply(ConfigResource configResource, DiffPreferencesInfo in) throws BadRequestException, Exception {
    if (in == null) {
        throw new BadRequestException("input must be provided");
    }
    if (!hasSetFields(in)) {
        throw new BadRequestException("unsupported option");
    }
    return writeToGit(readFromGit(gitManager, allUsersName, in));
}
#end_block

#method_before
@Override
public Object apply(ConfigResource configResource) throws BadRequestException, ResourceConflictException, Exception {
    return readFromGit(gitManager, allUsersName, null);
}
#method_after
@Override
public DiffPreferencesInfo apply(ConfigResource configResource) throws BadRequestException, ResourceConflictException, Exception {
    return readFromGit(gitManager, allUsersName, null);
}
#end_block

#method_before
static DiffPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, DiffPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        // Load all users prefs.
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(git);
        DiffPreferencesInfo allUserPrefs = new DiffPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.DIFF, null, allUserPrefs, DiffPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, DiffPreferencesInfo.updateDefaults(allUserPrefs), in);
        return prefs;
    }
}
#method_after
static DiffPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, DiffPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        // Load all users prefs.
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(git);
        DiffPreferencesInfo allUserPrefs = new DiffPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.DIFF, null, allUserPrefs, DiffPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, updateDefaults(allUserPrefs), in);
        return prefs;
    }
}
#end_block

#method_before
@Override
public void run() throws UnloggedFailure, OrmException {
    Account account;
    if (name.isEmpty()) {
        throw new UnloggedFailure(1, "You need to tell me who to find:  LastName,\\\\ Firstname, email@address.com, account id or an user name.  " + "Be sure to double-escape spaces, for example: \"show-account Last,\\\\ First\"");
    }
    Set<Id> idList = accountResolver.findAll(name);
    if (idList.isEmpty()) {
        throw new UnloggedFailure(1, "No accounts found for your query: \"" + name + "\"" + " Tip: Try double-escaping spaces, for example: \"show-account Last,\\\\ First\"");
    } else {
        stdout.println("Found " + idList.size() + " result" + (idList.size() > 1 ? "s" : "") + ": for query: \"" + name + "\"");
        stdout.println();
    }
    for (Id id : idList) {
        account = accountResolver.find(id.toString());
        if (account == null) {
            throw new UnloggedFailure("Account " + id.toString() + " does not exist.");
        }
        stdout.println("Full name:         " + account.getFullName());
        stdout.println("Account Id:        " + id.toString());
        stdout.println("Preferred Email:   " + account.getPreferredEmail());
        stdout.println("User Name:         " + account.getUserName());
        stdout.println("Active:            " + account.isActive());
        stdout.println("Registered on:     " + account.getRegisteredOn());
        try (final ReviewDb db = schema.open()) {
            stdout.println("");
            stdout.println("External Ids:");
            stdout.println(String.format("%-50s %s", "Email Address:", "External Id:"));
            for (AccountExternalId accountExternalId : db.accountExternalIds().byAccount(account.getId())) {
                stdout.println(String.format("%-50s %s", (accountExternalId.getEmailAddress() == null ? "" : accountExternalId.getEmailAddress()), accountExternalId.getExternalId()));
            }
            if (showKeys) {
                stdout.println("");
                stdout.println("Public Keys:");
                List<SshKeyInfo> sshKeys;
                try {
                    sshKeys = getSshKeys.get().apply(new AccountResource(userFactory.create(id)));
                } catch (AuthException | IOException | ConfigInvalidException e) {
                    stdout.println("Error getting ssh key info!");
                    e.printStackTrace();
                    sshKeys = null;
                }
                if (sshKeys == null || sshKeys.isEmpty()) {
                    stdout.println("None");
                } else {
                    stdout.println(String.format("%-9s %s", "Status:", "Key:"));
                    for (SshKeyInfo sshKey : sshKeys) {
                        stdout.println(String.format("%-9s %s", (sshKey.valid ? "Active" : "Inactive"), sshKey.sshPublicKey));
                    }
                }
            }
        }
        if (showGroups) {
            stdout.println();
            stdout.println("Member of groups" + (filterGroups == null ? "" : " (Filtering on \"" + filterGroups + "\")") + ":");
            List<GroupInfo> groupInfos = accountGetGroups.get().apply(new AccountResource(userFactory.create(id)));
            Collections.sort(groupInfos, new CustomComparator());
            for (GroupInfo groupInfo : groupInfos) {
                if (null == filterGroups || groupInfo.name.toLowerCase().contains(filterGroups.toLowerCase())) {
                    stdout.println(groupInfo.name);
                }
            }
        }
        stdout.println("");
    }
}
#method_after
@Override
public void run() throws UnloggedFailure, OrmException {
    Account account;
    if (name.isEmpty()) {
        throw new UnloggedFailure(1, "You need to tell me who to find:  LastName,\\\\ Firstname, email@address.com, account id or an user name.  " + "Be sure to double-escape spaces, for example: \"show-account Last,\\\\ First\"");
    }
    Set<Id> idList = accountResolver.findAll(name);
    if (idList.isEmpty()) {
        throw new UnloggedFailure(1, "No accounts found for your query: \"" + name + "\"" + " Tip: Try double-escaping spaces, for example: \"show-account Last,\\\\ First\"");
    } else {
        stdout.println("Found " + idList.size() + " result" + (idList.size() > 1 ? "s" : "") + ": for query: \"" + name + "\"");
        stdout.println();
    }
    for (Id id : idList) {
        account = accountResolver.find(id.toString());
        if (account == null) {
            throw new UnloggedFailure("Account " + id.toString() + " does not exist.");
        }
        stdout.println("Full name:         " + account.getFullName());
        stdout.println("Account Id:        " + id.toString());
        stdout.println("Preferred Email:   " + account.getPreferredEmail());
        stdout.println("User Name:         " + account.getUserName());
        stdout.println("Active:            " + account.isActive());
        stdout.println("Registered on:     " + account.getRegisteredOn());
        try (final ReviewDb db = schema.open()) {
            stdout.println("");
            stdout.println("External Ids:");
            stdout.println(String.format("%-50s %s", "Email Address:", "External Id:"));
            for (AccountExternalId accountExternalId : db.accountExternalIds().byAccount(account.getId())) {
                stdout.println(String.format("%-50s %s", (accountExternalId.getEmailAddress() == null ? "" : accountExternalId.getEmailAddress()), accountExternalId.getExternalId()));
            }
            if (showKeys) {
                stdout.println("");
                stdout.println("Public Keys:");
                List<SshKeyInfo> sshKeys;
                try {
                    sshKeys = getSshKeys.get().apply(new AccountResource(userFactory.create(id)));
                } catch (AuthException | IOException | ConfigInvalidException e) {
                    throw new UnloggedFailure(1, "Error getting sshkeys: " + e.getMessage(), e);
                }
                if (sshKeys == null || sshKeys.isEmpty()) {
                    stdout.println("None");
                } else {
                    stdout.println(String.format("%-9s %s", "Status:", "Key:"));
                    for (SshKeyInfo sshKey : sshKeys) {
                        stdout.println(String.format("%-9s %s", (sshKey.valid ? "Active" : "Inactive"), sshKey.sshPublicKey));
                    }
                }
            }
        }
        if (showGroups) {
            stdout.println();
            stdout.println("Member of groups" + (filterGroups == null ? "" : " (Filtering on \"" + filterGroups + "\")") + ":");
            List<GroupInfo> groupInfos = accountGetGroups.get().apply(new AccountResource(userFactory.create(id)));
            Collections.sort(groupInfos, new CustomComparator());
            for (GroupInfo groupInfo : groupInfos) {
                if (null == filterGroups || groupInfo.name.toLowerCase().contains(filterGroups.toLowerCase())) {
                    stdout.println(groupInfo.name);
                }
            }
        }
        stdout.println("");
    }
}
#end_block

#method_before
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#method_after
private List<HashtagsEvent> getHashtagsEvents(Change change, NoteDbUpdateManager manager) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = manager.getChangeRepo().getObjectId(refName);
    if (old == null) {
        return Collections.emptyList();
    }
    RevWalk rw = manager.getChangeRepo().rw;
    List<HashtagsEvent> events = new ArrayList<>();
    rw.reset();
    rw.markStart(rw.parseCommit(old));
    for (RevCommit commit : rw) {
        Account.Id authorId;
        try {
            authorId = changeNoteUtil.parseIdent(commit.getAuthorIdent(), change.getId());
        } catch (ConfigInvalidException e) {
            // Corrupt data, no valid hashtags in this commit.
            continue;
        }
        PatchSet.Id psId = parsePatchSetId(change, commit);
        Set<String> hashtags = parseHashtags(commit);
        if (authorId == null || psId == null || hashtags == null) {
            continue;
        }
        Timestamp commitTime = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
        events.add(new HashtagsEvent(psId, authorId, commitTime, hashtags, change.getCreatedOn()));
    }
    return events;
}
#end_block

#method_before
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = ChangeNoteUtil.changeRefName(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#method_after
private void deleteRef(Change change, Repository repo, ChainedReceiveCommands cmds) throws IOException {
    String refName = changeMetaRef(change.getId());
    ObjectId old = cmds.getObjectId(repo, refName);
    if (old != null) {
        cmds.add(new ReceiveCommand(old, ObjectId.zeroId(), refName));
    }
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = new HashMap<>();
    List<GroupInfo> result = new LinkedList<>();
    Account.Id me = control.getUser().getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = Lists.newLinkedList();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#method_after
private List<AccountInfo> toAccountInfoList(Set<Account.Id> accountIds) throws OrmException {
    List<AccountInfo> result = new LinkedList<>();
    AccountLoader loader = infoFactory.create(true);
    for (Account.Id accId : accountIds) {
        result.add(loader.get(accId));
    }
    loader.fill();
    return result;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(I) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = new LinkedList<>();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (added.isEmpty()) {
        return false;
    }
    patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    return true;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = Lists.newLinkedList();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<Account.Id, AccountGroupMember> members = getMembers(internalGroup.getId());
    final List<AccountGroupMember> toRemove = new LinkedList<>();
    for (final String nameOrEmail : input.members) {
        Account a = accounts.parse(nameOrEmail).getAccount();
        if (!control.canRemoveMember()) {
            throw new AuthException("Cannot delete member: " + a.getFullName());
        }
        final AccountGroupMember m = members.remove(a.getId());
        if (m != null) {
            toRemove.add(m);
        }
    }
    writeAudits(toRemove);
    db.get().accountGroupMembers().delete(toRemove);
    for (final AccountGroupMember m : toRemove) {
        accountCache.evict(m.getAccountId());
    }
    return Response.none();
}
#end_block

#method_before
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    String nameString = ident.getName() + " <" + ident.getEmailAddress() + ">";
    appendHeaderField(writer, AUTHOR, nameString);
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#method_after
private void appendOneComment(PrintWriter writer, PatchLineComment c) {
    // The CommentRange field for a comment is allowed to be null. If it is
    // null, then in the first line, we simply use the line number field for a
    // comment instead. If it isn't null, we write the comment range itself.
    CommentRange range = c.getRange();
    if (range != null) {
        writer.print(range.getStartLine());
        writer.print(':');
        writer.print(range.getStartCharacter());
        writer.print('-');
        writer.print(range.getEndLine());
        writer.print(':');
        writer.print(range.getEndCharacter());
    } else {
        writer.print(c.getLine());
    }
    writer.print("\n");
    writer.print(formatTime(serverIdent, c.getWrittenOn()));
    writer.print("\n");
    PersonIdent ident = newIdent(accountCache.get(c.getAuthor()).getAccount(), c.getWrittenOn(), serverIdent, anonymousCowardName);
    StringBuilder name = new StringBuilder();
    PersonIdent.appendSanitized(name, ident.getName());
    name.append(" <");
    PersonIdent.appendSanitized(name, ident.getEmailAddress());
    name.append('>');
    appendHeaderField(writer, AUTHOR, name.toString());
    String parent = c.getParentUuid();
    if (parent != null) {
        appendHeaderField(writer, PARENT, parent);
    }
    appendHeaderField(writer, UUID, c.getKey().get());
    if (c.getTag() != null) {
        appendHeaderField(writer, TAG, c.getTag());
    }
    byte[] messageBytes = c.getMessage().getBytes(UTF_8);
    appendHeaderField(writer, LENGTH, Integer.toString(messageBytes.length));
    writer.print(c.getMessage());
    writer.print("\n\n");
}
#end_block

#method_before
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = Lists.newLinkedList();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#method_after
private void startPlugin(PluginGuiceEnvironment env) throws Exception {
    Injector root = newRootInjector(env);
    serverManager = new LifecycleManager();
    serverManager.add(root);
    AutoRegisterModules auto = null;
    if (sysModule == null && sshModule == null && httpModule == null) {
        auto = new AutoRegisterModules(getName(), env, scanner, classLoader);
        auto.discover();
    }
    if (sysModule != null) {
        sysInjector = root.createChildInjector(root.getInstance(sysModule));
        serverManager.add(sysInjector);
    } else if (auto != null && auto.sysModule != null) {
        sysInjector = root.createChildInjector(auto.sysModule);
        serverManager.add(sysInjector);
    } else {
        sysInjector = root;
    }
    if (env.hasSshModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getSshModule());
        }
        if (sshModule != null) {
            modules.add(sysInjector.getInstance(sshModule));
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        } else if (auto != null && auto.sshModule != null) {
            modules.add(auto.sshModule);
            sshInjector = sysInjector.createChildInjector(modules);
            serverManager.add(sshInjector);
        }
    }
    if (env.hasHttpModule()) {
        List<Module> modules = new LinkedList<>();
        if (getApiType() == ApiType.PLUGIN) {
            modules.add(env.getHttpModule());
        }
        if (httpModule != null) {
            modules.add(sysInjector.getInstance(httpModule));
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        } else if (auto != null && auto.httpModule != null) {
            modules.add(auto.httpModule);
            httpInjector = sysInjector.createChildInjector(modules);
            serverManager.add(httpInjector);
        }
    }
    serverManager.start();
}
#end_block

#method_before
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> draftByChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChanges()) {
        return sort(byCommentStatus(db.patchComments().byChange(notes.getChangeId()), Status.DRAFT));
    }
    List<PatchLineComment> comments = new ArrayList<>();
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByChangeAuthor(db, notes, account));
        }
    }
    return sort(comments);
}
#end_block

#method_before
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (String refSuffix : getDraftRefs(notes.getChangeId()).keySet()) {
        Account.Id account = Account.Id.fromRefPart(refSuffix);
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#method_after
public List<PatchLineComment> byPatchSet(ReviewDb db, ChangeNotes notes, PatchSet.Id psId) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().byPatchSet(psId).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    comments.addAll(publishedByPatchSet(db, notes, psId));
    for (Ref ref : getDraftRefs(notes.getChangeId())) {
        Account.Id account = Account.Id.fromRefSuffix(ref.getName());
        if (account != null) {
            comments.addAll(draftByPatchSetAuthor(db, psId, account, notes));
        }
    }
    return sort(comments);
}
#end_block

#method_before
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    Set<String> refNames = getRefNamesAllUsers(RefNames.refsDraftCommentsPrefix(author));
    List<PatchLineComment> comments = new ArrayList<>();
    for (String refName : refNames) {
        Change.Id changeId = Change.Id.parse(refName);
        // Avoid loading notes for all affected changes just to be able to auto-
        // rebuild. This is only used in a corner case in the search codepath, so
        // returning slightly stale values is ok.
        DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
        comments.addAll(notes.load().getComments().values());
    }
    return sort(comments);
}
#method_after
// To be used only by HasDraftByLegacyPredicate.
@Deprecated
public List<PatchLineComment> draftByAuthor(ReviewDb db, Account.Id author) throws OrmException {
    if (!migration.readChanges()) {
        return sort(db.patchComments().draftByAuthor(author).toList());
    }
    List<PatchLineComment> comments = new ArrayList<>();
    try (Repository repo = repoManager.openRepository(allUsers)) {
        for (String refName : repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS).keySet()) {
            Account.Id accountId = Account.Id.fromRefSuffix(refName);
            Change.Id changeId = Change.Id.fromRefPart(refName);
            if (accountId == null || changeId == null) {
                continue;
            }
            // Avoid loading notes for all affected changes just to be able to auto-
            // rebuild. This is only used in a corner case in the search codepath,
            // so returning slightly stale values is ok.
            DraftCommentNotes notes = draftFactory.createWithAutoRebuildingDisabled(changeId, author);
            comments.addAll(notes.load().getComments().values());
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return sort(comments);
}
#end_block

#method_before
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId).values()) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#method_after
public void deleteAllDraftsFromAllUsers(Change.Id changeId) throws IOException {
    try (Repository repo = repoManager.openRepository(allUsers);
        RevWalk rw = new RevWalk(repo)) {
        BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
        for (Ref ref : getDraftRefs(repo, changeId)) {
            bru.addCommand(new ReceiveCommand(ref.getObjectId(), ObjectId.zeroId(), ref.getName()));
        }
        bru.setRefLogMessage("Delete drafts from NoteDb", false);
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        for (ReceiveCommand cmd : bru.getCommands()) {
            if (cmd.getResult() != ReceiveCommand.Result.OK) {
                throw new IOException(String.format("Failed to delete draft comment ref %s at %s: %s (%s)", cmd.getRefName(), cmd.getOldId(), cmd.getResult(), cmd.getMessage()));
            }
        }
    }
}
#end_block

#method_before
public Map<String, Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
public Collection<Ref> getDraftRefs(Change.Id changeId) throws OrmException {
    try (Repository repo = repoManager.openRepository(allUsers)) {
        return getDraftRefs(repo, changeId);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private Map<String, Ref> getDraftRefs(Repository repo, final Change.Id changeId) throws IOException {
    final String suffix = "/" + changeId.get();
    return Maps.filterKeys(repo.getRefDatabase().getRefs(RefNames.REFS_DRAFT_COMMENTS), new Predicate<String>() {

        @Override
        public boolean apply(String input) {
            return input.endsWith(suffix);
        }
    });
}
#method_after
private Collection<Ref> getDraftRefs(Repository repo, Change.Id changeId) throws IOException {
    return repo.getRefDatabase().getRefs(RefNames.refsDraftCommentsPrefix(changeId)).values();
}
#end_block

#method_before
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    boolean updateTs = commit.getParentCount() == 0;
    createdOn = ts;
    parseTag(commit);
    updateTs |= tag != null;
    if (branch == null) {
        branch = parseBranch(commit);
        updateTs |= branch != null;
    }
    if (status == null) {
        status = parseStatus(commit);
        updateTs |= status != null;
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
        updateTs |= changeId != null;
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
        updateTs = true;
    }
    updateTs |= parseChangeMessage(psId, accountId, commit, ts) != null;
    if (topic == null) {
        topic = parseTopic(commit);
        updateTs |= topic != null;
    }
    Set<String> oldHashtags = hashtags;
    parseHashtags(commit);
    updateTs |= hashtags != oldHashtags;
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
        updateTs |= submissionId != null;
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
        updateTs = true;
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
        updateTs |= !submitRecords.isEmpty();
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
        updateTs = true;
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (updateTs) {
        if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
            lastUpdatedOn = ts;
        }
    }
}
#method_after
private void parse(ChangeNotesCommit commit) throws ConfigInvalidException {
    Timestamp ts = new Timestamp(commit.getCommitterIdent().getWhen().getTime());
    createdOn = ts;
    parseTag(commit);
    if (branch == null) {
        branch = parseBranch(commit);
    }
    if (status == null) {
        status = parseStatus(commit);
    }
    PatchSet.Id psId = parsePatchSetId(commit);
    if (currentPatchSetId == null || psId.get() > currentPatchSetId.get()) {
        currentPatchSetId = psId;
    }
    PatchSetState psState = parsePatchSetState(commit);
    if (psState != null && !patchSetStates.containsKey(psId)) {
        patchSetStates.put(psId, psState);
    }
    Account.Id accountId = parseIdent(commit);
    if (accountId != null) {
        ownerId = accountId;
    }
    if (changeId == null) {
        changeId = parseChangeId(commit);
    }
    String currSubject = parseSubject(commit);
    if (currSubject != null) {
        if (subject == null) {
            subject = currSubject;
        }
        originalSubject = currSubject;
    }
    parseChangeMessage(psId, accountId, commit, ts);
    if (topic == null) {
        topic = parseTopic(commit);
    }
    parseHashtags(commit);
    if (submissionId == null) {
        submissionId = parseSubmissionId(commit);
    }
    ObjectId currRev = parseRevision(commit);
    if (currRev != null) {
        parsePatchSet(psId, currRev, accountId, ts);
    }
    parseGroups(psId, commit);
    if (submitRecords.isEmpty()) {
        // Only parse the most recent set of submit records; any older ones are
        // still there, but not currently used.
        parseSubmitRecords(commit.getFooterLineValues(FOOTER_SUBMITTED_WITH));
    }
    for (String line : commit.getFooterLineValues(FOOTER_LABEL)) {
        parseApproval(psId, accountId, ts, line);
    }
    for (ReviewerStateInternal state : ReviewerStateInternal.values()) {
        for (String line : commit.getFooterLineValues(state.getFooterKey())) {
            parseReviewer(state, line);
        }
    // Don't update timestamp when a reviewer was added, matching RevewDb
    // behavior.
    }
    if (lastUpdatedOn == null || ts.after(lastUpdatedOn)) {
        lastUpdatedOn = ts;
    }
}
#end_block

#method_before
private ChangeMessage parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return null;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return null;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return null;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return null;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
    return changeMessage;
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, ChangeNotesCommit commit, Timestamp ts) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, ts, psId);
    changeMessage.setMessage(changeMsgString);
    changeMessage.setTag(tag);
    changeMessagesByPatchSet.put(psId, changeMessage);
    allChangeMessages.add(changeMessage);
}
#end_block

#method_before
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = Lists.newLinkedList();
    List<RevCommit> after = Lists.newLinkedList();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#method_after
private boolean includedInOne(final Collection<Ref> refs) throws IOException {
    parseCommits(refs);
    List<RevCommit> before = new LinkedList<>();
    List<RevCommit> after = new LinkedList<>();
    partition(before, after);
    // Within the "before" set we are trying to handle cases arising from clock skew
    return !includedIn(after, 1).isEmpty() || !includedIn(before, 1).isEmpty();
}
#end_block

#method_before
private static WalkResult recursivePath(RevWalk rw, GitilesView view) throws IOException {
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw;
    if (!path.isEmpty()) {
        tw = TreeWalk.forPath(rw.getObjectReader(), path, root);
        if (tw == null) {
            return null;
        }
        ObjectId treeSHA = tw.getObjectId(0);
        tw.close();
        ObjectLoader treeLoader = rw.getObjectReader().open(treeSHA);
        if (treeLoader.getType() != Constants.OBJ_TREE) {
            return null;
        }
        tw = new TreeWalk(rw.getObjectReader());
        tw.addTree(treeSHA);
    } else {
        tw = new TreeWalk(rw.getObjectReader());
        tw.addTree(root);
    }
    tw.setRecursive(true);
    return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
}
#method_after
private static WalkResult recursivePath(RevWalk rw, GitilesView view) throws IOException {
    RevTree root = getRoot(view, rw);
    String path = view.getPathPart();
    TreeWalk tw;
    if (!path.isEmpty()) {
        try (TreeWalk toRoot = TreeWalk.forPath(rw.getObjectReader(), path, root)) {
            if (toRoot == null) {
                return null;
            }
            ObjectId treeSHA = toRoot.getObjectId(0);
            ObjectLoader treeLoader = rw.getObjectReader().open(treeSHA);
            if (treeLoader.getType() != Constants.OBJ_TREE) {
                return null;
            }
            tw = new TreeWalk(rw.getObjectReader());
            tw.addTree(treeSHA);
        }
    } else {
        tw = new TreeWalk(rw.getObjectReader());
        tw.addTree(root);
    }
    tw.setRecursive(true);
    return new WalkResult(tw, path, root, root, FileType.TREE, ImmutableList.<Boolean>of());
}
#end_block

#method_before
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            getSkipManager().removeAll();
            getSkipManager().render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#method_after
void setContext(final int context) {
    operation(new Runnable() {

        @Override
        public void run() {
            skipManager.removeAll();
            skipManager.render(context, diff);
            updateRenderEntireFile();
        }
    });
}
#end_block

#method_before
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("n");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#method_after
Runnable maybePrevVimSearch(final CodeMirror cm) {
    return new Runnable() {

        @Override
        public void run() {
            if (cm.vim().hasSearchHighlight()) {
                cm.vim().handleKey("N");
            } else {
                getCommentManager().commentNav(cm, Direction.NEXT).run();
            }
        }
    };
}
#end_block

#method_before
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        getSkipManager().removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        getSkipManager().render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#method_after
void reloadDiffInfo() {
    final int id = ++reloadVersionId;
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            if (id == reloadVersionId && isAttached()) {
                diff = diffInfo;
                operation(new Runnable() {

                    @Override
                    public void run() {
                        skipManager.removeAll();
                        getChunkManager().reset();
                        getDiffTable().scrollbar.removeDiffAnnotations();
                        setShowIntraline(prefs.intralineDifference());
                        render(diff);
                        skipManager.render(prefs.context(), diff);
                    }
                });
            }
        }
    });
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, final int line, final String gutterClass, NativeEvent clickEvent) {
            if (Element.as(clickEvent.getEventTarget()).hasClassName(getLineNumberClassName()) && clickEvent.getButton() == NativeEvent.BUTTON_LEFT && !clickEvent.getMetaKey() && !clickEvent.getAltKey() && !clickEvent.getCtrlKey() && !clickEvent.getShiftKey()) {
                cm.setCursor(Pos.create(line));
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        getCommentManager().newDraftOnGutterClick(cm, gutterClass, line + 1);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().getLineMapper().lineOnOther(side, line);
}
#method_after
LineOnOtherInfo lineOnOther(DisplaySide side, int line) {
    return getChunkManager().lineMapper.lineOnOther(side, line);
}
#end_block

#method_before
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user");
                    db.accountSshKeys().insert(Collections.singleton(sshKey));
                }
            }
        }
    }
}
#method_after
@Override
public void postRun() throws Exception {
    AuthType authType = flags.cfg.getEnum(AuthType.values(), "auth", null, "type", null);
    if (authType != AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        return;
    }
    try (ReviewDb db = dbFactory.open()) {
        if (db.accounts().anyAccounts().toList().isEmpty()) {
            ui.header("Gerrit Administrator");
            if (ui.yesno(true, "Create administrator user")) {
                Account.Id id = new Account.Id(db.nextAccountId());
                String username = ui.readString("admin", "username");
                String name = ui.readString("Administrator", "name");
                String httpPassword = ui.readString("secret", "HTTP password");
                AccountSshKey sshKey = readSshKey(id);
                String email = readEmail(sshKey);
                AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
                if (!Strings.isNullOrEmpty(httpPassword)) {
                    extUser.setPassword(httpPassword);
                }
                db.accountExternalIds().insert(Collections.singleton(extUser));
                if (email != null) {
                    AccountExternalId extMailto = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_MAILTO, email));
                    extMailto.setEmailAddress(email);
                    db.accountExternalIds().insert(Collections.singleton(extMailto));
                }
                Account a = new Account(id, TimeUtil.nowTs());
                a.setFullName(name);
                a.setPreferredEmail(email);
                db.accounts().insert(Collections.singleton(a));
                AccountGroupName adminGroup = db.accountGroupNames().get(new AccountGroup.NameKey("Administrators"));
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, adminGroup.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
                if (sshKey != null) {
                    VersionedAuthorizedKeysOnInit authorizedKeys = authorizedKeysFactory.create(id).load();
                    authorizedKeys.addKey(sshKey.getSshPublicKey());
                    authorizedKeys.save("Added SSH key for initial admin user\n");
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    super.onLoad();
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    revision = getRevision();
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
public void save(String message) throws IOException, ConfigInvalidException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#method_after
public void save(String message) throws IOException {
    save(new PersonIdent("Gerrit Initialization", "init@gerrit"), message);
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException, ConfigInvalidException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path)) {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try (RevWalk rw = new RevWalk(reader)) {
            RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
            newTree = readTree(srcTree);
            CommitBuilder commit = new CommitBuilder();
            commit.setAuthor(ident);
            commit.setCommitter(ident);
            commit.setMessage(msg);
            super.onSave(commit);
            ObjectId res = newTree.writeTree(inserter);
            if (res.equals(srcTree)) {
                return;
            }
            commit.setTreeId(res);
            if (revision != null) {
                commit.addParentId(revision);
            }
            ObjectId newRevision = inserter.insert(commit);
            updateRef(repo, ident, newRevision, "commit: " + msg);
            revision = newRevision;
        } finally {
            if (inserter != null) {
                inserter.close();
                inserter = null;
            }
            if (reader != null) {
                reader.close();
                reader = null;
            }
        }
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    File path = getPath();
    if (path == null) {
        throw new IOException(project + " does not exist.");
    }
    try (Repository repo = new FileRepository(path);
        ObjectInserter i = repo.newObjectInserter();
        ObjectReader r = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader)) {
        inserter = i;
        reader = r;
        RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
        newTree = readTree(srcTree);
        CommitBuilder commit = new CommitBuilder();
        commit.setAuthor(ident);
        commit.setCommitter(ident);
        commit.setMessage(msg);
        onSave(commit);
        ObjectId res = newTree.writeTree(inserter);
        if (res.equals(srcTree)) {
            return;
        }
        commit.setTreeId(res);
        if (revision != null) {
            commit.addParentId(revision);
        }
        ObjectId newRevision = inserter.insert(commit);
        updateRef(repo, ident, newRevision, "commit: " + msg);
        revision = newRevision;
    } finally {
        inserter = null;
        reader = null;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
            authorizedKeys.load(md);
            if (authorizedKeys.deleteKey(rsrc.getSshKey().getKey().get())) {
                authorizedKeys.commit(md);
            }
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), rsrc.getUser().getAccountId());
        if (keys.remove(rsrc.getSshKey())) {
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(rsrc.getUser().getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        }
    }
    dbProvider.get().accountSshKeys().deleteKeys(Collections.singleton(rsrc.getSshKey().getKey()));
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(AccountResource.SshKey rsrc, Input input) throws AuthException, OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to delete SSH keys");
    }
    authorizedKeys.deleteKey(rsrc.getUser().getAccountId(), rsrc.getSshKey().getKey().get());
    sshKeyCache.evict(rsrc.getUser().getUserName());
    return Response.none();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    keys = new TreeMap<>();
    int seq = 1;
    for (String line : readUTF8(FILE_NAME).split("\\r?\\n")) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT)) {
            String pub = line.substring(INVALID_KEY_COMMENT.length());
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), pub);
            key.setInvalid();
            keys.put(key.getKey().get(), Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.put(seq++, Optional.<AccountSshKey>absent());
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), line);
            keys.put(key.getKey().get(), Optional.of(key));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException {
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    StringBuilder b = new StringBuilder();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            if (!key.get().isValid()) {
                b.append(INVALID_KEY_COMMENT);
            }
            b.append(key.get().getSshPublicKey().trim());
        } else {
            b.append(DELETED_KEY_COMMENT);
        }
        b.append("\n");
    }
    saveUTF8(FILE_NAME, b.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException {
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    saveUTF8(AuthorizedKeys.FILE_NAME, AuthorizedKeys.serialize(keys));
    return true;
}
#end_block

#method_before
public List<AccountSshKey> getKeys() {
    checkState(keys != null, "SSH keys not loaded yet");
    List<AccountSshKey> result = new ArrayList<>();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            result.add(key.get());
        }
    }
    return result;
}
#method_after
private List<AccountSshKey> getKeys() {
    checkLoaded();
    return Lists.newArrayList(Optional.presentInstances(keys));
}
#end_block

#method_before
public AccountSshKey getKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    Optional<AccountSshKey> key = keys.get(seq);
    return key.isPresent() ? key.get() : null;
}
#method_after
private AccountSshKey getKey(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    return key.orNull();
}
#end_block

#method_before
public AccountSshKey addKey(String pub) {
    checkState(keys != null, "SSH keys not loaded yet");
    int seq = keys.isEmpty() ? 1 : keys.lastKey() + 1;
    AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), pub);
    keys.put(seq, Optional.of(key));
    return key;
}
#method_after
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    int seq = keys.size() + 1;
    AccountSshKey.Id keyId = new AccountSshKey.Id(accountId, seq);
    AccountSshKey key = sshKeyCreator.create(keyId, pub);
    keys.add(Optional.of(key));
    return key;
}
#end_block

#method_before
public boolean deleteKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    if (keys.containsKey(seq) && keys.get(seq).isPresent()) {
        keys.put(seq, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#method_after
private boolean deleteKey(int seq) {
    checkLoaded();
    if (seq <= keys.size() && keys.get(seq - 1).isPresent()) {
        keys.set(seq - 1, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#end_block

#method_before
public void markKeyInvalid(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    AccountSshKey key = getKey(seq);
    if (key != null) {
        key.setInvalid();
    }
}
#method_after
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    AccountSshKey key = getKey(seq);
    if (key != null && key.isValid()) {
        key.setInvalid();
        return true;
    }
    return false;
}
#end_block

#method_before
public void setKeys(List<AccountSshKey> newKeys) {
    keys = new TreeMap<>();
    for (AccountSshKey key : newKeys) {
        keys.put(key.getKey().get(), Optional.of(key));
    }
    for (int seq = 1; seq < keys.lastKey(); seq++) {
        if (!keys.containsKey(seq)) {
            keys.put(seq, Optional.<AccountSshKey>absent());
        }
    }
}
#method_after
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.natural().onResultOf(new Function<AccountSshKey, Integer>() {

        @Override
        public Integer apply(AccountSshKey sshKey) {
            return sshKey.getKey().get();
        }
    });
    keys = Collections.nCopies(o.max(newKeys).getKey().get(), Optional.<AccountSshKey>absent());
    for (AccountSshKey key : newKeys) {
        keys.set(key.getKey().get() - 1, Optional.of(key));
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
            bind(SshKeyCreator.class).to(SshKeyCreatorImpl.class);
        }
    };
}
#end_block

#method_before
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        final AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        final List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : readSshKeys(db, user.getAccountId())) {
            if (k.isValid()) {
                add(db, kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#method_after
@Override
public Iterable<SshKeyCacheEntry> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, username);
        AccountExternalId user = db.accountExternalIds().get(key);
        if (user == null) {
            return NO_SUCH_USER;
        }
        List<SshKeyCacheEntry> kl = new ArrayList<>(4);
        for (AccountSshKey k : authorizedKeys.getKeys(user.getAccountId())) {
            if (k.isValid()) {
                add(kl, k);
            }
        }
        if (kl.isEmpty()) {
            return NO_KEYS;
        }
        return Collections.unmodifiableList(kl);
    }
}
#end_block

#method_before
private void add(ReviewDb db, List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(db, k);
    }
}
#method_after
private void add(List<SshKeyCacheEntry> kl, AccountSshKey k) {
    try {
        kl.add(new SshKeyCacheEntry(k.getKey(), SshUtil.parse(k)));
    } catch (OutOfMemoryError e) {
        // 
        throw e;
    } catch (Throwable e) {
        markInvalid(k);
    }
}
#end_block

#method_before
private void markInvalid(ReviewDb db, AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        k.setInvalid();
        db.accountSshKeys().update(Collections.singleton(k));
        List<AccountSshKey> keys = readFromDb(db, k.getAccount());
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get(), userFactory.create(k.getAccount()));
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(k.getAccount());
            authorizedKeys.load(md);
            authorizedKeys.setKeys(keys);
            authorizedKeys.commit(md);
        }
    } catch (OrmException | IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#method_after
private void markInvalid(AccountSshKey k) {
    try {
        log.info("Flagging SSH key " + k.getKey() + " invalid");
        authorizedKeys.markKeyInvalid(k.getAccount(), k.getKey().get());
        k.setInvalid();
    } catch (IOException | ConfigInvalidException e) {
        log.error("Failed to mark SSH key" + k.getKey() + " invalid", e);
    }
}
#end_block

#method_before
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey;
        if (readFromGit) {
            try (Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(git);
                sshKey = authorizedKeys.getKey(seq);
            }
        } else {
            sshKey = dbProvider.get().accountSshKeys().get(new AccountSshKey.Id(user.getAccountId(), seq));
        }
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
public AccountResource.SshKey parse(IdentifiedUser user, IdString id) throws ResourceNotFoundException, IOException, ConfigInvalidException {
    try {
        int seq = Integer.parseInt(id.get(), 10);
        AccountSshKey sshKey = authorizedKeys.getKey(user.getAccountId(), seq);
        if (sshKey == null) {
            throw new ResourceNotFoundException(id);
        }
        return new AccountResource.SshKey(user, sshKey);
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    AccountSshKey sshKey;
    if (readFromGit) {
        try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
            Repository git = repoManager.openRepository(allUsersName.get())) {
            VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
            authorizedKeys.load(md);
            sshKey = authorizedKeys.addKey(sshPublicKey);
            authorizedKeys.commit(md);
        }
    } else {
        List<AccountSshKey> keys = readFromDb(dbProvider.get(), user.getAccountId());
        int max = keys.isEmpty() ? 0 : keys.get(keys.size() - 1).getKey().get();
        try {
            sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
            keys.add(sshKey);
            try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName.get());
                Repository git = repoManager.openRepository(allUsersName.get())) {
                VersionedAuthorizedKeys authorizedKeys = new VersionedAuthorizedKeys(user.getAccountId());
                authorizedKeys.load(md);
                authorizedKeys.setKeys(keys);
                authorizedKeys.commit(md);
            }
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
    try {
        addKeyFactory.create(user, sshKey).send();
    } catch (EmailException e) {
        log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
    }
    sshKeyCache.evict(user.getUserName());
    return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = authorizedKeys.addKey(user.getAccountId(), sshPublicKey);
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(GetSshKeys.newSshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (key != null) {
        addSshKey(db, key, username);
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException, ConfigInvalidException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    LinkedList<AccountExternalId> externalIds = new LinkedList<>();
    externalIds.add(extUser);
    for (AccountExternalIdCreator c : externalIdCreators) {
        externalIds.addAll(c.create(id, username, input.email));
    }
    try {
        db.accountExternalIds().insert(externalIds);
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            // Ignored
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (input.sshKey != null) {
        try {
            authorizedKeys.addKey(id, input.sshKey);
            sshKeyCache.evict(username);
        } catch (InvalidSshKeyException e) {
            throw new BadRequestException(e.getMessage());
        }
    }
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountLoader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        addSshKey(db, id, username, email, sshKey);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#method_after
public synchronized TestAccount create(String username, String email, String fullName, String... groups) throws Exception {
    TestAccount account = accounts.get(username);
    if (account != null) {
        return account;
    }
    try (ReviewDb db = reviewDbProvider.open()) {
        Account.Id id = new Account.Id(db.nextAccountId());
        AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
        String httpPass = "http-pass";
        extUser.setPassword(httpPass);
        db.accountExternalIds().insert(Collections.singleton(extUser));
        if (email != null) {
            AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(email));
            extMailto.setEmailAddress(email);
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        }
        Account a = new Account(id, TimeUtil.nowTs());
        a.setFullName(fullName);
        a.setPreferredEmail(email);
        db.accounts().insert(Collections.singleton(a));
        if (groups != null) {
            for (String n : groups) {
                AccountGroup.NameKey k = new AccountGroup.NameKey(n);
                AccountGroup g = groupCache.get(k);
                AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, g.getId()));
                db.accountGroupMembers().insert(Collections.singleton(m));
            }
        }
        KeyPair sshKey = genSshKey();
        authorizedKeys.addKey(id, publicKey(sshKey, email));
        sshKeyCache.evict(username);
        accountCache.evictByUsername(username);
        byEmailCache.evict(email);
        account = new TestAccount(id, username, email, fullName, sshKey, httpPass);
        accounts.put(username, account);
        return account;
    }
}
#end_block

#method_before
public TestAccount create(String username, String group) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, group);
}
#method_after
public TestAccount create(String username, String group) throws Exception {
    return create(username, null, username, group);
}
#end_block

#method_before
public TestAccount create(String username) throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create(username, null, username, (String[]) null);
}
#method_after
public TestAccount create(String username) throws Exception {
    return create(username, null, username, (String[]) null);
}
#end_block

#method_before
public TestAccount admin() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#method_after
public TestAccount admin() throws Exception {
    return create("admin", "admin@example.com", "Administrator", "Administrators");
}
#end_block

#method_before
public TestAccount admin2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#method_after
public TestAccount admin2() throws Exception {
    return create("admin2", "admin2@example.com", "Administrator2", "Administrators");
}
#end_block

#method_before
public TestAccount user() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user", "user@example.com", "User");
}
#method_after
public TestAccount user() throws Exception {
    return create("user", "user@example.com", "User");
}
#end_block

#method_before
public TestAccount user2() throws OrmException, JSchException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    return create("user2", "user2@example.com", "User2");
}
#method_after
public TestAccount user2() throws Exception {
    return create("user2", "user2@example.com", "User2");
}
#end_block

#method_before
public List<SshKeyInfo> apply(IdentifiedUser user) throws OrmException, RepositoryNotFoundException, IOException, ConfigInvalidException {
    List<AccountSshKey> keys = readFromGit ? readFromGit(user.getAccountId()) : readFromDb(dbProvider.get(), user.getAccountId());
    return Lists.transform(keys, new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#method_after
public List<SshKeyInfo> apply(IdentifiedUser user) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    return Lists.transform(authorizedKeys.getKeys(user.getAccountId()), new Function<AccountSshKey, SshKeyInfo>() {

        @Override
        public SshKeyInfo apply(AccountSshKey key) {
            return newSshKeyInfo(key);
        }
    });
}
#end_block

#method_before
@Override
public String getAvatarUrl(int size) throws RestApiException {
    GetAvatar myGetAvatar = getAvatar.get();
    myGetAvatar.setSize(size);
    return myGetAvatar.apply(account).location();
}
#method_after
@Override
public String getAvatarUrl(int size) throws RestApiException {
    getAvatar.setSize(size);
    return getAvatar.apply(account).location();
}
#end_block

#method_before
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#method_after
@Override
public void starChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        starredChangesCreate.setChange(rsrc);
        starredChangesCreate.apply(account, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot star change", e);
    }
}
#end_block

#method_before
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#method_after
@Override
public void unstarChange(String id) throws RestApiException {
    try {
        ChangeResource rsrc = changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(id));
        AccountResource.StarredChange starredChange = new AccountResource.StarredChange(account.getUser(), rsrc);
        starredChangesDelete.apply(starredChange, new StarredChanges.EmptyInput());
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot unstar change", e);
    }
}
#end_block

#method_before
@Override
protected void set(int newValue) {
    if (newValue < 0) {
        throw new IllegalArgumentException("invalid sequence number " + newValue);
    }
    seq = newValue;
}
#method_after
@Override
protected void set(int newValue) {
    seq = newValue;
}
#end_block

#method_before
public boolean isValid() {
    return valid;
}
#method_after
public boolean isValid() {
    return valid && id.isValid();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watchedprojects").to(GetWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(ACCOUNT_KIND, "watched.projects").to(GetWatchedProjects.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> getWatchedProjects() throws RestApiException {
    return getWatchedProjects.apply(account);
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    try {
        return getWatchedProjects.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot get watched projects", e);
    }
}
#end_block

#method_before
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#method_after
@Override
public List<SshKeyInfo> listSshKeys() throws RestApiException {
    try {
        return getSshKeys.apply(account);
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot list SSH keys", e);
    }
}
#end_block

#method_before
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#method_after
@Override
public SshKeyInfo addSshKey(String key) throws RestApiException {
    AddSshKey.Input in = new AddSshKey.Input();
    in.raw = RawInputUtil.create(key);
    try {
        return addSshKey.apply(account, in).value();
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot add SSH key", e);
    }
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> apply(AccountResource rsrc) {
    List<WatchedProjectInfo> watchedProjectInfos = new LinkedList<>();
    for (AccountProjectWatch a : rsrc.getUser().getNotificationFilters()) {
        WatchedProjectInfo wpi = new WatchedProjectInfo();
        wpi.filter = a.getFilter();
        wpi.projectName = a.getProjectNameKey().get();
        wpi.notifyAbandonedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        wpi.notifyNewChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_CHANGES));
        wpi.notifyNewPatchSets = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS));
        wpi.notifySubmittedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        wpi.notifyAllComments = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS));
        watchedProjectInfos.add(wpi);
    }
    return watchedProjectInfos;
}
#method_after
@Override
public List<ProjectWatchInfo> apply(AccountResource rsrc) throws OrmException, AuthException {
    if (self.get() != rsrc.getUser()) {
        throw new AuthException("It is not allowed to list project watches " + "of other users");
    }
    List<ProjectWatchInfo> projectWatchInfos = new LinkedList<>();
    Iterable<AccountProjectWatch> projectWatches = dbProvider.get().accountProjectWatches().byAccount(rsrc.getUser().getAccountId());
    for (AccountProjectWatch a : projectWatches) {
        ProjectWatchInfo pwi = new ProjectWatchInfo();
        pwi.filter = a.getFilter();
        pwi.project = a.getProjectNameKey().get();
        pwi.notifyAbandonedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ABANDONED_CHANGES));
        pwi.notifyNewChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_CHANGES));
        pwi.notifyNewPatchSets = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.NEW_PATCHSETS));
        pwi.notifySubmittedChanges = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.SUBMITTED_CHANGES));
        pwi.notifyAllComments = toBoolean(a.isNotify(AccountProjectWatch.NotifyType.ALL_COMMENTS));
        projectWatchInfos.add(pwi);
    }
    return projectWatchInfos;
}
#end_block

#method_before
@Override
public List<WatchedProjectInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public List<ProjectWatchInfo> getWatchedProjects() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, toBlob(inserter, content));
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, @Nullable String newFile, @Nullable RawInput content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = currentUser.get().asIdentifiedUser();
    Project.NameKey project = edit.getChange().getProject();
    try (Repository repo = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader()) {
        String refName = edit.getRefName();
        RevCommit prevEdit = edit.getEditCommit();
        ObjectId newTree = writeNewTree(op, rw, inserter, prevEdit, reader, file, newFile, content);
        if (ObjectId.equals(newTree, prevEdit.getTree())) {
            throw new InvalidChangeOperationException("no changes were made");
        }
        Timestamp now = TimeUtil.nowTs();
        ObjectId commit = createCommit(me, inserter, prevEdit, newTree, now);
        inserter.flush();
        return update(repo, me, refName, rw, prevEdit, commit, now);
    }
}
#end_block

#method_before
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, ObjectInserter ins, RevCommit prevEdit, final ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final ObjectId content) throws IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    if (ent.getRawMode() == 0) {
                        ent.setFileMode(FileMode.REGULAR_FILE);
                    }
                    FileMode mode = ent.getFileMode();
                    if (FileMode.GITLINK != mode) {
                        ent.setObjectId(content);
                    } else {
                        ent.setLength(0);
                        ent.setLastModified(0);
                        try {
                            ObjectId id = ObjectId.fromString(reader.open(content).getBytes(), 0);
                            ent.setObjectId(id);
                        } catch (LargeObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (MissingObjectException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        } catch (IOException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                    }
                }
            });
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#method_after
private static ObjectId writeNewTree(TreeOperation op, RevWalk rw, final ObjectInserter ins, RevCommit prevEdit, ObjectReader reader, String fileName, @Nullable String newFile, @Nullable final RawInput content) throws InvalidChangeOperationException, IOException {
    DirCache newTree = readTree(reader, prevEdit);
    DirCacheEditor dce = newTree.editor();
    switch(op) {
        case DELETE_ENTRY:
            dce.add(new DeletePath(fileName));
            break;
        case RENAME_ENTRY:
            rw.parseHeaders(prevEdit);
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), fileName, prevEdit.getTree());
            if (tw != null) {
                dce.add(new DeletePath(fileName));
                addFileToCommit(newFile, dce, tw);
            }
            break;
        case CHANGE_ENTRY:
            checkNotNull(content, "new content required");
            final AtomicReference<IOException> ioe = new AtomicReference<>(null);
            final AtomicReference<InvalidChangeOperationException> icoe = new AtomicReference<>(null);
            dce.add(new PathEdit(fileName) {

                @Override
                public void apply(DirCacheEntry ent) {
                    try {
                        if (ent.getFileMode() == FileMode.GITLINK) {
                            ent.setLength(0);
                            ent.setLastModified(0);
                            ent.setObjectId(ObjectId.fromString(ByteStreams.toByteArray(content.getInputStream()), 0));
                        } else {
                            if (ent.getRawMode() == 0) {
                                ent.setFileMode(FileMode.REGULAR_FILE);
                            }
                            ent.setObjectId(toBlob(ins, content));
                        }
                    } catch (IOException e) {
                        ioe.set(e);
                    } catch (InvalidObjectIdException e) {
                        icoe.set(new InvalidChangeOperationException("Invalid object id in submodule link: " + e.getMessage()));
                        icoe.get().initCause(e);
                    }
                }
            });
            if (ioe.get() != null) {
                throw ioe.get();
            }
            if (icoe.get() != null) {
                throw icoe.get();
            }
            break;
        case RESTORE_ENTRY:
            if (prevEdit.getParentCount() == 0) {
                dce.add(new DeletePath(fileName));
                break;
            }
            RevCommit base = prevEdit.getParent(0);
            rw.parseHeaders(base);
            tw = TreeWalk.forPath(rw.getObjectReader(), fileName, base.getTree());
            if (tw == null) {
                dce.add(new DeletePath(fileName));
                break;
            }
            addFileToCommit(fileName, dce, tw);
            break;
    }
    dce.finish();
    return newTree.writeTree(ins);
}
#end_block

#method_before
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    mergeOp.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = mergeOp.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#method_after
public Collection<Branch.NameKey> getDestinationBranches(Branch.NameKey src, SubscribeSection s, MergeOpRepoManager orm) throws IOException {
    Collection<Branch.NameKey> ret = new ArrayList<>();
    logDebug("Inspecting SubscribeSection " + s);
    for (RefSpec r : s.getRefSpecs()) {
        logDebug("Inspecting ref " + r);
        if (r.matchSource(src.get())) {
            if (r.getDestination() == null) {
                // no need to care for wildcard, as we matched already
                try {
                    orm.openRepo(s.getProject(), false);
                } catch (NoSuchProjectException e) {
                    // to subscribe to it. Allow this for now.
                    continue;
                }
                OpenRepo or = orm.getRepo(s.getProject());
                for (Ref ref : or.repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
                    ret.add(new Branch.NameKey(s.getProject(), ref.getName()));
                }
            } else if (r.isWildcard()) {
                // refs/heads/*:refs/heads/*
                ret.add(new Branch.NameKey(s.getProject(), r.expandFromSource(src.get()).getDestination()));
            } else {
                // e.g. refs/heads/master:refs/heads/stable
                ret.add(new Branch.NameKey(s.getProject(), r.getDestination()));
            }
        }
    }
    logDebug("Returning possible branches: " + ret + "for project " + s.getProject());
    return ret;
}
#end_block

#method_before
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#method_after
public Collection<SubmoduleSubscription> superProjectSubscriptionsForSubmoduleBranch(Branch.NameKey branch, MergeOpRepoManager orm) throws IOException {
    logDebug("Calculating possible superprojects for " + branch);
    Collection<SubmoduleSubscription> ret = new ArrayList<>();
    Project.NameKey project = branch.getParentKey();
    ProjectConfig cfg = projectCache.get(project).getConfig();
    for (SubscribeSection s : cfg.getSubscribeSections(branch)) {
        Collection<Branch.NameKey> branches = getDestinationBranches(branch, s, orm);
        for (Branch.NameKey targetBranch : branches) {
            GitModules m = gitmodulesFactory.create(targetBranch, updateId, orm);
            m.load();
            ret.addAll(m.subscribedTo(branch));
        }
    }
    logDebug("Calculated superprojects for " + branch + " are " + ret);
    return ret;
}
#end_block

#method_before
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest));
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Collection<Branch.NameKey> updatedBranches, String updateId, MergeOpRepoManager orm) throws SubmoduleException {
    if (!enableSuperProjectSubscriptions) {
        logDebug("Updating superprojects disabled");
        return;
    }
    this.updateId = updateId;
    logDebug("Updating superprojects");
    // These (repo/branch) will be updated later with all the given
    // individual submodule subscriptions
    Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
    try {
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : superProjectSubscriptionsForSubmoduleBranch(updatedBranch, orm)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
    } catch (IOException e) {
        throw new SubmoduleException("Could not calculate all superprojects");
    }
    updatedSubscribers.addAll(updatedBranches);
    // Update subscribers.
    for (Branch.NameKey dest : targets.keySet()) {
        try {
            if (!updatedSubscribers.add(dest)) {
                log.error("Possible circular subscription involving " + dest);
            } else {
                updateGitlinks(db, dest, targets.get(dest), orm);
            }
        } catch (SubmoduleException e) {
            log.warn("Cannot update gitlinks for " + dest, e);
        }
    }
}
#end_block

#method_before
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        mergeOp.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = mergeOp.getRepo(subscriber.getParentKey());
    Repository pdb = or.repo;
    try {
        if (pdb.exactRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.exactRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                mergeOp.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = mergeOp.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates, MergeOpRepoManager orm) throws SubmoduleException {
    PersonIdent author = null;
    StringBuilder msgbuf = new StringBuilder("Update git submodules\n\n");
    boolean sameAuthorForAll = true;
    try {
        orm.openRepo(subscriber.getParentKey(), false);
    } catch (NoSuchProjectException | IOException e) {
        throw new SubmoduleException("Cannot access superproject", e);
    }
    OpenRepo or = orm.getRepo(subscriber.getParentKey());
    try {
        Ref r = or.repo.exactRef(subscriber.get());
        if (r == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(r, or.rw);
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try {
                orm.openRepo(s.getSubmodule().getParentKey(), false);
            } catch (NoSuchProjectException | IOException e) {
                throw new SubmoduleException("Cannot access submodule", e);
            }
            OpenRepo subOr = orm.getRepo(s.getSubmodule().getParentKey());
            Repository subrepo = subOr.repo;
            Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
            if (ref == null) {
                ed.add(new DeletePath(s.getPath()));
                continue;
            }
            final ObjectId updateTo = ref.getObjectId();
            RevCommit newCommit = subOr.rw.parseCommit(updateTo);
            subOr.rw.parseBody(newCommit);
            if (author == null) {
                author = newCommit.getAuthorIdent();
            } else if (!author.equals(newCommit.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
            DirCacheEntry dce = dc.getEntry(s.getPath());
            ObjectId oldId;
            if (dce != null) {
                if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                    log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                    continue;
                }
                oldId = dce.getObjectId();
            } else {
                // This submodule did not exist before. We do not want to add
                // the full submodule history to the commit message, so omit it.
                oldId = updateTo;
            }
            ed.add(new PathEdit(s.getPath()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(updateTo);
                }
            });
            if (verboseSuperProject) {
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    subOr.rw.markStart(newCommit);
                    subOr.rw.markUninteresting(subOr.rw.parseCommit(oldId));
                    for (RevCommit c : subOr.rw) {
                        subOr.rw.parseBody(c);
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    throw new SubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = or.repo.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = or.repo.exactRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = or.repo.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            case FORCED:
            case IO_FAILURE:
            case LOCK_FAILURE:
            case NOT_ATTEMPTED:
            case NO_CHANGE:
            case REJECTED:
            case REJECTED_CURRENT_BRANCH:
            case RENAMED:
            default:
                throw new IOException(rfu.getResult().name());
        }
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber), updateId, orm);
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#method_after
private static DirCache readTree(final Ref branch, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final DirCache dc = DirCache.newInCore();
    final DirCacheBuilder b = dc.builder();
    // no prefix path
    b.addTree(// no prefix path
    new byte[0], // standard stage
    DirCacheEntry.STAGE_0, rw.getObjectReader(), rw.parseTree(branch.getObjectId()));
    b.finish();
    return dc;
}
#end_block

#method_before
@Override
public void close() {
    for (OpenRepo repo : openRepos.values()) {
        repo.close();
    }
}
#method_after
@Override
public void close() {
    orm.close();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules, SubmitInput submitInput) throws OrmException, RestApiException {
    this.submitInput = submitInput;
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    orm.setContext(db, ts, caller);
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change, caller);
        checkState(cs.ids().contains(change.getId()), "change %s missing from %s", change.getId(), cs);
        this.commits = new CommitStatus(cs);
        MergeSuperSet.reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Error from integrateIntoHistory", e);
            throw new ResourceConflictException(e.getMessage(), e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    SubmoduleOp subOp = subOpProvider.get();
    updateSuperProjects(subOp, br.values());
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    Multimap<Project.NameKey, Branch.NameKey> br;
    Multimap<Branch.NameKey, ChangeData> cbb;
    try {
        br = cs.branchesByProject();
        cbb = cs.changesByBranch();
    } catch (OrmException e) {
        throw new IntegrationException("Error reading changes to submit", e);
    }
    Set<Project.NameKey> projects = br.keySet();
    Collection<Branch.NameKey> branches = cbb.keySet();
    openRepos(projects);
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
    }
    // Done checks that don't involve running submit strategies.
    failFast(cs);
    List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
    for (Branch.NameKey branch : branches) {
        OpenRepo or = orm.getRepo(branch.getParentKey());
        OpenBranch ob = or.getBranch(branch);
        BranchBatch submitting = toSubmit.get(branch);
        checkNotNull(submitting.submitType(), "null submit type for %s; expected to previously fail fast", submitting);
        Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
        ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
        SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
        strategies.add(strategy);
        strategy.addOps(or.getUpdate(), commitsToSubmit);
    }
    try {
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(submitInput, strategies, commits));
    } catch (UpdateException e) {
        // BatchUpdate may have inadvertently wrapped an IntegrationException
        // thrown by some legacy SubmitStrategyOp code that intended the error
        // message to be user-visible. Copy the message from the wrapped
        // exception.
        // 
        // If you happen across one of these, the correct fix is to convert the
        // inner IntegrationException to a ResourceConflictException.
        String msg;
        if (e.getCause() instanceof IntegrationException) {
            msg = e.getCause().getMessage();
        } else {
            msg = "Error submitting change" + (cs.size() != 1 ? "s" : "");
        }
        throw new IntegrationException(msg, e);
    }
    updateSuperProjects(br.values());
}
#end_block

#method_before
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate());
    }
    return updates;
}
#method_after
private List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(orm.getRepo(project).getUpdate());
    }
    return updates;
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId, submitInput.notify);
}
#end_block

#method_before
private void updateSuperProjects(SubmoduleOp subOp, Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches, submissionId);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#method_after
private void updateSuperProjects(Collection<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    SubmoduleOp subOp = subOpProvider.get();
    try {
        subOp.updateSuperProjects(db, branches, submissionId, orm);
        logDebug("Updating superprojects done");
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#end_block

#method_before
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#method_after
private void openRepos(Collection<Project.NameKey> projects) throws IntegrationException {
    for (Project.NameKey project : projects) {
        try {
            orm.openRepo(project, true);
        } catch (NoSuchProjectException noProject) {
            logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
            abandonAllOpenChangeForDeletedProject(noProject.project());
        } catch (IOException e) {
            throw new IntegrationException("Error opening project " + project, e);
        }
    }
}
#end_block

#method_before
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        mergeOp.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = mergeOp.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#method_after
void load() throws IOException {
    Project.NameKey project = branch.getParentKey();
    logDebug("Loading .gitmodules of {} for project {}", branch, project);
    try {
        orm.openRepo(project, false);
    } catch (NoSuchProjectException e) {
        throw new IOException(e);
    }
    OpenRepo or = orm.getRepo(project);
    ObjectId id = or.repo.resolve(branch.get());
    if (id == null) {
        throw new IOException("Cannot open branch " + branch.get());
    }
    RevCommit commit = or.rw.parseCommit(id);
    TreeWalk tw = TreeWalk.forPath(or.repo, GIT_MODULES, commit.getTree());
    if (tw == null || (tw.getRawMode(0) & FileMode.TYPE_MASK) != FileMode.TYPE_FILE) {
        return;
    }
    try {
        BlobBasedConfig bbc = new BlobBasedConfig(null, or.repo, commit, GIT_MODULES);
        subscriptions = subSecParserFactory.create(bbc, thisServer, branch).parseAllSections();
    } catch (ConfigInvalidException e) {
        throw new IOException("Could not read .gitmodule file of super project: " + branch.getParentKey(), e);
    }
}
#end_block

#method_before
@Override
public String healthCheck(final Check check) throws IOException {
    if (check.equals(Check.ACCESS))
        return healthCheckAccess();
    else
        return healthCheckSysinfo();
}
#method_after
@Override
public String healthCheck(final Check check) throws IOException {
    return execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            if (check.equals(Check.ACCESS))
                return healthCheckAccess();
            else
                return healthCheckSysinfo();
        }
    });
}
#end_block

#method_before
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    try {
        log.debug("Adding comment {} to issue {}", comment, issueKey);
        client().addComment(issueKey, Comment.valueOf(comment));
        log.debug("Added comment {} to issue {}", comment, issueKey);
    } catch (IOException e) {
        log.error("Failed to add comment {} to issue {}", comment, issueKey);
    }
}
#method_after
@Override
public void addComment(final String issueKey, final String comment) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Adding comment {} to issue {}", comment, issueKey);
            client().addComment(issueKey, Comment.valueOf(comment));
            log.debug("Added comment {} to issue {}", comment, issueKey);
            return issueKey;
        }
    });
}
#end_block

#method_before
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    try {
        log.debug("Performing action {} on issue {}", actionName, issueKey);
        doPerformAction(issueKey, actionName);
    } catch (IOException e) {
        log.error("Failed to perform action {} on issue {}", actionName, issueKey);
        throw new IOException(e);
    }
}
#method_after
@Override
public void performAction(final String issueKey, final String actionName) throws IOException {
    execute(new Callable<String>() {

        @Override
        public String call() throws Exception {
            log.debug("Performing action {} on issue {}", actionName, issueKey);
            doPerformAction(issueKey, actionName);
            return issueKey;
        }
    });
}
#end_block

#method_before
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    try {
        boolean ret = client().doTransition(issueKey, actionName);
        if (ret) {
            log.debug("Action " + actionName + " successful on Issue " + issueKey);
        } else {
            log.debug("Transitioning to current status not possible");
        }
    } catch (IOException e) {
        StringBuilder sb = new StringBuilder();
        for (Transition t : client().getTransitions(issueKey)) {
            if (sb.length() > 0) {
                sb.append(',');
            }
            sb.append('\'');
            sb.append(t.getName());
            sb.append('\'');
        }
        log.error("Available Transitions: " + sb);
        throw e;
    }
}
#method_after
private void doPerformAction(final String issueKey, final String actionName) throws IOException {
    log.debug("Trying to perform action: " + actionName + " on issue " + issueKey);
    boolean ret = client().doTransition(issueKey, actionName);
    if (ret) {
        log.debug("Action " + actionName + " successful on Issue " + issueKey);
    } else {
        log.debug("Action {} on Issue {} not possible", actionName, issueKey);
    }
}
#end_block

#method_before
@Override
public boolean exists(final String issueKey) throws IOException {
    return client().issueExists(issueKey);
}
#method_after
@Override
public boolean exists(final String issueKey) throws IOException {
    return execute(new Callable<Boolean>() {

        @Override
        public Boolean call() throws Exception {
            return client().issueExists(issueKey);
        }
    });
}
#end_block

#method_before
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (URISyntaxException e) {
            log.error("Connecting failed at {} as user {}", getUrl(), getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#method_after
private JiraClient client() throws IOException {
    if (client == null) {
        try {
            log.debug("Connecting to jira at {}", getUrl());
            client = new JiraClient(getUrl(), getUsername(), getPassword());
            log.debug("Authenticating as User {}", getUsername());
        } catch (Exception e) {
            log.info("Unable to connect to " + getUrl() + " as " + getUsername());
            throw new IOException(e);
        }
    }
    return client;
}
#end_block

#method_before
private String healthCheckAccess() throws IOException {
    try {
        new JiraClient(getUrl(), getUsername(), getPassword()).sysInfo();
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#method_after
private String healthCheckAccess() throws IOException {
    client().sysInfo();
    final String result = "{\"status\"=\"ok\",\"username\"=\"" + getUsername() + "\"}";
    log.debug("Healtheck on access result: {}", result);
    return result;
}
#end_block

#method_before
public Issue getIssue(String issueKey) throws IOException {
    IssueRestClient issueClient = this.client.getIssueClient();
    Promise<Issue> promise = issueClient.getIssue(issueKey);
    try {
        return promise.claim();
    } catch (Exception e) {
        log.error("Failed to get issue by issuekey " + issueKey);
        throw new IOException(e);
    }
}
#method_after
public Issue getIssue(String issueKey) throws RestClientException {
    IssueRestClient issueClient = this.client.getIssueClient();
    return issueClient.getIssue(issueKey).claim();
}
#end_block

#method_before
public boolean issueExists(String issueKey) {
    try {
        getIssue(issueKey);
        return true;
    } catch (IOException e) {
        log.error("Issue " + issueKey + " not found " + e.getCause().getMessage());
        return false;
    }
}
#method_after
public boolean issueExists(String issueKey) throws RestClientException {
    boolean ret = true;
    try {
        getIssue(issueKey);
    } catch (RestClientException e) {
        if (e.getStatusCode().get() == 404) {
            log.error("Issue " + issueKey + " not found ");
            ret = false;
        } else {
            throw e;
        }
    }
    return ret;
}
#end_block

#method_before
public Iterable<Transition> getTransitions(String issueKey) throws IOException {
    try {
        return client.getIssueClient().getTransitions(getIssue(issueKey)).get();
    } catch (Exception e) {
        log.error("Failed to retrieve transitions of issue " + issueKey);
        throw new IOException("Transitions error", e);
    }
}
#method_after
public Iterable<Transition> getTransitions(String issueKey) throws RestClientException {
    return client.getIssueClient().getTransitions(getIssue(issueKey)).claim();
}
#end_block

#method_before
public void addComment(String issueKey, Comment comment) throws IOException {
    try {
        log.debug("Trying to add comment for issue " + issueKey);
        Issue issue = getIssue(issueKey);
        URI issueUri = new URI(issue.getSelf().toString() + "/comment/");
        IssueRestClient issueClient = client.getIssueClient();
        Promise<Void> promise = issueClient.addComment(issueUri, comment);
        promise.claim();
        log.debug("Comment added to issue " + issueKey);
    } catch (Exception e) {
        log.error("Could not add comment to issue " + issueKey);
        throw new IOException("Adding Comment to issue " + issueKey + " failed", e);
    }
}
#method_after
public void addComment(String issueKey, Comment comment) throws RestClientException, URISyntaxException {
    log.debug("Trying to add comment for issue " + issueKey);
    Issue issue = getIssue(issueKey);
    URI issueUri;
    issueUri = new URI(issue.getSelf().toString() + "/comment/");
    IssueRestClient issueClient = client.getIssueClient();
    Promise<Void> promise = issueClient.addComment(issueUri, comment);
    promise.claim();
    log.debug("Comment added to issue " + issueKey);
}
#end_block

#method_before
public boolean doTransition(String issueKey, String transition) {
    Transition t;
    boolean result = false;
    try {
        t = getTransitionByName(getTransitions(issueKey), transition);
        TransitionInput input;
        input = new TransitionInput(t.getId());
        log.debug("Setting transition input to: " + input.toString());
        client.getIssueClient().transition(getIssue(issueKey), input).claim();
        result = true;
    } catch (IOException e) {
        log.error(e.getMessage());
    }
    return result;
}
#method_after
public boolean doTransition(String issueKey, String transition) throws RestClientException, InvalidTransitionException {
    Transition t = getTransitionByName(getTransitions(issueKey), transition);
    if (t == null) {
        throw new InvalidTransitionException("Action " + transition + " not executable on issue " + issueKey);
    }
    TransitionInput input;
    input = new TransitionInput(t.getId());
    log.debug("Setting transition input to: " + input.toString());
    client.getIssueClient().transition(getIssue(issueKey), input).claim();
    return true;
}
#end_block

#method_before
public ServerInfo sysInfo() throws IOException {
    try {
        return client.getMetadataClient().getServerInfo().get();
    } catch (InterruptedException e) {
        log.error("Serverinfo request interrupted");
        throw new IOException(e);
    } catch (ExecutionException e) {
        log.error(e.getMessage());
        throw new IOException(e);
    }
}
#method_after
public ServerInfo sysInfo() throws RestClientException {
    return client.getMetadataClient().getServerInfo().claim();
}
#end_block

#method_before
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) throws IOException {
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            return t;
        }
    }
    throw new IOException("No matching transition found");
}
#method_after
private Transition getTransitionByName(Iterable<Transition> transitions, String transition) {
    Transition ret = null;
    for (Transition t : transitions) {
        if (transition.equals(t.getName())) {
            ret = t;
            break;
        }
    }
    return ret;
}
#end_block

#method_before
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException | IOException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#method_after
private boolean isJiraConnectSuccessful() {
    ui.message("Checking Jira connectivity ... ");
    try {
        new JiraClient(jiraUrl, jiraUsername, jiraPassword).sysInfo().getVersion();
        ui.message("[OK]\n");
        return true;
    } catch (URISyntaxException e) {
        ui.message("*FAILED* (%s)\n", e.toString());
        return false;
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                if (a.getPatchSetId().equals(control.getChange().currentPatchSetId()) && a.getValue() != 0) {
                    if (msg.length() == 0) {
                        msg.append("Removed the following votes:\n\n");
                    }
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getId(), db);
        db.patchSetApprovals().delete(del);
        update.removeReviewer(rsrc.getUser().getAccountId());
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getId(), ChangeUtil.messageUUID(db)), control.getUser().getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        emailReviewers(rsrc.getChange(), del);
        if (!del.isEmpty()) {
            PatchSet patchSet = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
            for (PatchSetApproval psa : del) {
                Account account = accountCache.get(psa.getAccountId()).getAccount();
                hooks.doReviewerDeletedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, rsrc.getChange());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getChangeResource().getProject(), rsrc.getChangeResource().getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc.getReviewerUser().getAccount());
        bu.addOp(rsrc.getChange().getId(), op);
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> approvals) {
    if (approvals.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(approvals.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : approvals) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Project.NameKey projectName, Change change, List<PatchSetApproval> dels, ChangeMessage changeMessage) {
    // The user knows they removed themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(dels.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : dels) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            DeleteReviewerSender cm = deleteReviewerSenderFactory.create(projectName, change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.setChangeMessage(changeMessage);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot email update for change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(BlameCache.class).to(BlameCacheImpl.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(DeleteReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    factory(GitModules.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#method_after
@Override
public void doReviewerDeletedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    ReviewerDeletedEvent event = new ReviewerDeletedEvent(change);
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (!approvals.isEmpty()) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerDeletedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    AccountState owner = accountCache.get(change.getOwner());
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    // append votes that were removed
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), reviewerDeletedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, String claName) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) {
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doReviewerDeletedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, Event event) {
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) {
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    ccExistingReviewers();
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    ccAllApprovals();
    bccStarredBy();
    ccExistingReviewers();
    includeWatchers(NotifyType.ALL_COMMENTS);
    add(RecipientType.TO, reviewers);
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    boolean includeSizes = !Strings.isNullOrEmpty(req.getParameter("long"));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes ? repo : null), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    String longStr = req.getParameter("long");
    boolean includeSizes = (longStr != null) && (longStr.isEmpty() || Boolean.TRUE.equals(StringUtils.toBooleanOrNull(longStr)));
    try (RevWalk rw = new RevWalk(repo);
        WalkResult wr = WalkResult.forPath(rw, view)) {
        if (wr == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        switch(wr.type) {
            case TREE:
                renderJson(req, res, TreeJsonData.toJsonData(wr.id, wr.tw, includeSizes), TreeJsonData.Tree.class);
                break;
            default:
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } catch (LargeObjectException e) {
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
    }
}
#end_block

#method_before
static Tree toJsonData(ObjectId id, TreeWalk tw, @Nullable Repository repoForSizes) throws IOException {
    ObjectReader reader = repoForSizes != null ? repoForSizes.newObjectReader() : null;
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (reader != null) {
            FileMode fmode = FileMode.fromBits(mode.getBits());
            if (fmode == FileMode.REGULAR_FILE || fmode == FileMode.EXECUTABLE_FILE) {
                SizedEntry se = new SizedEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.size = reader.getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
                e = se;
            } else if (fmode == FileMode.SYMLINK) {
                TargetEntry se = new TargetEntry();
                se.id = e.id;
                se.mode = e.mode;
                se.name = e.name;
                se.type = e.type;
                se.target = new String(repoForSizes.open(tw.getObjectId(0), Constants.OBJ_BLOB).getBytes(), UTF_8);
                e = se;
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#method_after
static Tree toJsonData(ObjectId id, TreeWalk tw, boolean includeSizes) throws IOException {
    Tree tree = new Tree();
    tree.id = id.name();
    tree.entries = Lists.newArrayList();
    while (tw.next()) {
        Entry e = new Entry();
        FileMode mode = tw.getFileMode(0);
        e.mode = mode.getBits();
        e.type = Constants.typeString(mode.getObjectType());
        e.id = tw.getObjectId(0).name();
        e.name = tw.getNameString();
        if (includeSizes) {
            if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_FILE) {
                e.size = tw.getObjectReader().getObjectSize(tw.getObjectId(0), Constants.OBJ_BLOB);
            } else if ((mode.getBits() & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) {
                e.target = new String(tw.getObjectReader().open(tw.getObjectId(0)).getCachedBytes(), UTF_8);
            }
        }
        tree.entries.add(e);
    }
    return tree;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    keys = new TreeMap<>();
    int seq = 1;
    for (String line : readUTF8(FILE_NAME).split("\\r?\\n")) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;
        } else if (line.startsWith(INVALID_KEY_COMMENT)) {
            String pub = line.substring(INVALID_KEY_COMMENT.length());
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), pub);
            key.setInvalid();
            keys.put(key.getKey().get(), Optional.of(key));
        } else if (line.startsWith(DELETED_KEY_COMMENT)) {
            keys.put(seq++, Optional.<AccountSshKey>absent());
        } else if (line.startsWith("#")) {
            continue;
        } else {
            AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq++), line);
            keys.put(key.getKey().get(), Optional.of(key));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException {
    keys = AuthorizedKeys.parse(accountId, readUTF8(AuthorizedKeys.FILE_NAME));
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    StringBuilder b = new StringBuilder();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            if (!key.get().isValid()) {
                b.append(INVALID_KEY_COMMENT);
            }
            b.append(key.get().getSshPublicKey().trim());
        } else {
            b.append(DELETED_KEY_COMMENT);
        }
        b.append("\n");
    }
    saveUTF8(FILE_NAME, b.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException {
    if (Strings.isNullOrEmpty(commit.getMessage())) {
        commit.setMessage("Updated SSH keys\n");
    }
    saveUTF8(AuthorizedKeys.FILE_NAME, AuthorizedKeys.serialize(keys));
    return true;
}
#end_block

#method_before
public List<AccountSshKey> getKeys() {
    checkState(keys != null, "SSH keys not loaded yet");
    List<AccountSshKey> result = new ArrayList<>();
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent()) {
            result.add(key.get());
        }
    }
    return result;
}
#method_after
private List<AccountSshKey> getKeys() {
    checkLoaded();
    return Lists.newArrayList(Optional.presentInstances(keys));
}
#end_block

#method_before
public AccountSshKey getKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    Optional<AccountSshKey> key = keys.get(seq);
    return key.isPresent() ? key.get() : null;
}
#method_after
private AccountSshKey getKey(int seq) {
    checkLoaded();
    Optional<AccountSshKey> key = keys.get(seq - 1);
    return key.orNull();
}
#end_block

#method_before
public AccountSshKey addKey(String pub) {
    checkState(keys != null, "SSH keys not loaded yet");
    for (Optional<AccountSshKey> key : keys.values()) {
        if (key.isPresent() && key.get().getSshPublicKey().trim().equals(pub.trim())) {
            return key.get();
        }
    }
    int seq = keys.isEmpty() ? 1 : keys.lastKey() + 1;
    AccountSshKey key = new AccountSshKey(new AccountSshKey.Id(accountId, seq), pub);
    keys.put(seq, Optional.of(key));
    return key;
}
#method_after
private AccountSshKey addKey(String pub) throws InvalidSshKeyException {
    checkLoaded();
    for (Optional<AccountSshKey> key : keys) {
        if (key.isPresent() && key.get().getSshPublicKey().trim().equals(pub.trim())) {
            return key.get();
        }
    }
    int seq = keys.size() + 1;
    AccountSshKey.Id keyId = new AccountSshKey.Id(accountId, seq);
    AccountSshKey key = sshKeyCreator.create(keyId, pub);
    keys.add(Optional.of(key));
    return key;
}
#end_block

#method_before
public boolean deleteKey(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    if (keys.containsKey(seq) && keys.get(seq).isPresent()) {
        keys.put(seq, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#method_after
private boolean deleteKey(int seq) {
    checkLoaded();
    if (seq <= keys.size() && keys.get(seq - 1).isPresent()) {
        keys.set(seq - 1, Optional.<AccountSshKey>absent());
        return true;
    }
    return false;
}
#end_block

#method_before
public void markKeyInvalid(int seq) {
    checkState(keys != null, "SSH keys not loaded yet");
    AccountSshKey key = getKey(seq);
    if (key != null) {
        key.setInvalid();
    }
}
#method_after
private boolean markKeyInvalid(int seq) {
    checkLoaded();
    AccountSshKey key = getKey(seq);
    if (key != null && key.isValid()) {
        key.setInvalid();
        return true;
    }
    return false;
}
#end_block

#method_before
public void setKeys(List<AccountSshKey> newKeys) {
    keys = new TreeMap<>();
    for (AccountSshKey key : newKeys) {
        keys.put(key.getKey().get(), Optional.of(key));
    }
    for (int seq = 1; seq < keys.lastKey(); seq++) {
        if (!keys.containsKey(seq)) {
            keys.put(seq, Optional.<AccountSshKey>absent());
        }
    }
}
#method_after
public void setKeys(Collection<AccountSshKey> newKeys) {
    Ordering<AccountSshKey> o = Ordering.natural().onResultOf(new Function<AccountSshKey, Integer>() {

        @Override
        public Integer apply(AccountSshKey sshKey) {
            return sshKey.getKey().get();
        }
    });
    keys = Collections.nCopies(o.max(newKeys).getKey().get(), Optional.<AccountSshKey>absent());
    for (AccountSshKey key : newKeys) {
        keys.set(key.getKey().get() - 1, Optional.of(key));
    }
}
#end_block

#method_before
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
}
#method_after
@Test
public void sshKeys() throws Exception {
    // The test account should initially have exactly one ssh key
    List<SshKeyInfo> info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(1);
    assertSequenceNumbers(info);
    SshKeyInfo key = info.get(0);
    String inital = AccountCreator.publicKey(admin.sshKey, admin.email);
    assertThat(key.sshPublicKey).isEqualTo(inital);
    // Add a new key
    String newKey = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add an existing key (the request succeeds, but the key isn't added again)
    gApi.accounts().self().addSshKey(inital);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertSequenceNumbers(info);
    // Add another new key
    String newKey2 = AccountCreator.publicKey(AccountCreator.genSshKey(), admin.email);
    gApi.accounts().self().addSshKey(newKey2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(3);
    assertSequenceNumbers(info);
    // Delete second key
    gApi.accounts().self().deleteSshKey(2);
    info = gApi.accounts().self().listSshKeys();
    assertThat(info).hasSize(2);
    assertThat(info.get(0).seq).isEqualTo(1);
    assertThat(info.get(1).seq).isEqualTo(3);
}
#end_block

