1306
#method_before
@Before
public void setUp() {
    Timestamp timestamp = new Timestamp(NOW);
    entry1 = new SQLEntry("name1", timestamp, "event1", Integer.MAX_VALUE);
    entry2 = new SQLEntry("name2", timestamp, "event2", Integer.MIN_VALUE);
    entry3 = new SQLEntry("name3", timestamp, "event3", 0);
}
#method_after
@Before
public void setUp() {
    Timestamp timestamp = new Timestamp(NOW);
    entry1 = new SQLEntry("name1", timestamp, "event1", Integer.MAX_VALUE);
    entry2 = new SQLEntry("name2", timestamp, "event2", Integer.MIN_VALUE);
    entry3 = new SQLEntry("name3", timestamp, "event3", 0);
    entry4 = new SQLEntry("name4", timestamp, "event4", Integer.MAX_VALUE);
}
#end_block

#method_before
@Test
public void testEquals() throws Exception {
    assertThat(entry1.equals(null)).isFalse();
    assertThat(entry1.equals("String object")).isFalse();
    assertThat(entry1.equals(entry1)).isTrue();
    assertThat(entry1.equals(entry2)).isFalse();
}
#method_after
@Test
public void testEquals() throws Exception {
    assertThat(entry1.equals(null)).isFalse();
    assertThat(entry1.equals("String object")).isFalse();
    assertThat(entry1.equals(entry1)).isTrue();
    assertThat(entry1.equals(entry2)).isFalse();
    assertThat(entry1.equals(entry4)).isTrue();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    return prime + id;
}
#method_after
@Override
public int hashCode() {
    return 31 + id;
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()));
}
#method_after
public List<ChangeInfo> format(Collection<Change.Id> ids) throws OrmException {
    List<ChangeData> changes = new ArrayList<>(ids.size());
    List<ChangeInfo> ret = new ArrayList<>(ids.size());
    ReviewDb reviewDb = db.get();
    for (Change.Id id : ids) {
        changes.add(changeDataFactory.create(reviewDb, id));
    }
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    for (ChangeData cd : changes) {
        ret.add(format(cd, Optional.<PatchSet.Id>absent(), false));
    }
    accountLoader.fill();
    return ret;
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent());
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()));
}
#method_after
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#end_block

#method_before
@Override
public Object apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), ChangeSet.create(resource.getChange()));
        json.addOptions(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS));
        return json.format(cs.ids());
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), ChangeSet.create(resource.getChange()));
        json.addOptions(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS));
        return json.format(cs.ids());
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#end_block

#method_before
public Project createProject(CreateProjectArgs args) throws BadRequestException, ResourceConflictException, IOException, ConfigInvalidException {
    final Project.NameKey nameKey = args.getProject();
    try {
        final String head = args.permissionsOnly ? RefNames.REFS_CONFIG : args.branch.get(0);
        try (Repository repo = repoManager.openRepository(nameKey)) {
            // Check if the repo already exists, and throw ResourceConflictException if it does.
            if (repo.getObjectDatabase().exists()) {
                throw new ResourceConflictException("project \"" + nameKey + "\" exists");
            }
        } catch (IOException e) {
        // It doesn't exist, safe to ignore.
        }
        Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                try {
                    l.onNewProjectCreated(event);
                } catch (RuntimeException e) {
                    log.warn("Failure in NewProjectCreatedListener", e);
                }
            }
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig(args);
            if (!args.permissionsOnly && args.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, args.branch);
            }
            return projectCache.get(nameKey).getProject();
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ResourceConflictException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.");
    } catch (RepositoryNotFoundException badName) {
        throw new BadRequestException("invalid project name: " + nameKey);
    } catch (ConfigInvalidException e) {
        String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw e;
    }
}
#method_after
public Project createProject(CreateProjectArgs args) throws BadRequestException, ResourceConflictException, IOException, ConfigInvalidException {
    final Project.NameKey nameKey = args.getProject();
    try {
        final String head = args.permissionsOnly ? RefNames.REFS_CONFIG : args.branch.get(0);
        try (Repository repo = repoManager.openRepository(nameKey)) {
            if (repo.getObjectDatabase().exists()) {
                throw new ResourceConflictException("project \"" + nameKey + "\" exists");
            }
        } catch (RepositoryNotFoundException e) {
        // It does not exist, safe to ignore.
        }
        try (Repository repo = repoManager.createRepository(nameKey)) {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                try {
                    l.onNewProjectCreated(event);
                } catch (RuntimeException e) {
                    log.warn("Failure in NewProjectCreatedListener", e);
                }
            }
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig(args);
            if (!args.permissionsOnly && args.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, args.branch);
            }
            return projectCache.get(nameKey).getProject();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ResourceConflictException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.");
    } catch (RepositoryNotFoundException badName) {
        throw new BadRequestException("invalid project name: " + nameKey);
    } catch (ConfigInvalidException e) {
        String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw e;
    }
}
#end_block

#method_before
@Override
public Rule[] inlinePluginRules() {
    return new Rule[] { namedAnchor(), namedAnchor2() };
}
#method_after
@Override
public Rule[] inlinePluginRules() {
    return new Rule[] { namedAnchorHtmlStyle(), namedAnchorMarkdownExtensionStyle() };
}
#end_block

#method_before
private void makeSiteConfig(final SitePaths site, final GerritConfig gerritConfig) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // 
        if (gerritConfig.getGitDaemonUrl() != null) {
            String url = gerritConfig.getGitDaemonUrl();
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (gerritConfig.getSshdAddress() != null) {
            String sshAddr = gerritConfig.getSshdAddress();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported Gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        Path root = repoManager.getBasePath();
        p.print("$projectroot = " + quoteForPerl(root) + ";\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#method_after
private void makeSiteConfig(SitePaths site, Config cfg, SshInfo sshInfo) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // Generate URLs using anonymous git://
        // 
        String url = cfg.getString("gerrit", null, "canonicalGitUrl");
        if (url != null) {
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
            String sshAddr = sshInfo.getHostKeys().get(0).getHost();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported Gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        Path root = repoManager.getBasePath();
        p.print("$projectroot = " + quoteForPerl(root) + ";\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    installAuthModule();
    if (options.enableMasterFeatures()) {
        install(new UrlModule(options, authConfig));
        install(new UiRpcModule());
    }
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module(options.enableMasterFeatures()));
    if (gitWebCgiConfig.getGitwebCgi() != null) {
        install(new GitWebModule());
    }
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    bind(ProxyProperties.class).toProvider(ProxyPropertiesProvider.class);
    listener().toInstance(registerInParentInjectors());
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    installAuthModule();
    if (options.enableMasterFeatures()) {
        install(new UrlModule(options, authConfig));
        install(new UiRpcModule());
    }
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module(options.enableMasterFeatures()));
    if (gitWebCgiConfig.getGitwebCgi() != null) {
        install(new GitWebModule());
    }
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    bind(ProxyProperties.class).toProvider(ProxyPropertiesProvider.class);
    listener().toInstance(registerInParentInjectors());
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    if (info.status() != null && info.status().equals(Change.Status.ABANDONED)) {
        sb.openSpan().setStyleName(RelatedChanges.R.css().strikedSubject());
    } else {
        sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    }
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    if (info.status() == Change.Status.ABANDONED) {
        sb.openSpan().setStyleName(RelatedChanges.R.css().strikedSubject());
    } else {
        sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    }
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebInfo gw = Gerrit.info().gitweb();
    if (gw != null && (!info.hasChangeNumber() || !info.hasRevisionNumber())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (AccountFieldNameInfo f : Natives.asList(_editableAccountFields())) {
        fields.add(f.get());
    }
    return fields;
}
#method_after
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(Account.FieldName.valueOf(f));
    }
    return fields;
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final ChangeInfo item) {
    return item.legacy_id();
}
#method_after
@Override
protected Object getRowItemKey(final ChangeInfo item) {
    return item.legacyId();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final ChangeInfo c = getRowItem(row);
    final Change.Id id = c.legacy_id();
    Gerrit.display(PageLinks.toChange(id));
}
#method_after
@Override
protected void onOpenRow(final int row) {
    final ChangeInfo c = getRowItem(row);
    final Change.Id id = c.legacyId();
    Gerrit.display(PageLinks.toChange(id));
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE;
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE;
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private static Widget getSizeWidget(ChangeInfo c) {
    int largeChangeSize = Gerrit.getServerInfo().change().largeChange();
    int changedLines = c.insertions() + c.deletions();
    int p = 100;
    if (changedLines < largeChangeSize) {
        p = changedLines * 100 / largeChangeSize;
    }
    int width = Math.max(2, 70 * p / 100);
    int red = p >= 50 ? 255 : (int) Math.round((p) * 5.12);
    int green = p <= 50 ? 255 : (int) Math.round(256 - (p - 50) * 5.12);
    String bg = "#" + toHex(red) + toHex(green) + "00";
    SimplePanel panel = new SimplePanel();
    panel.setStyleName(Gerrit.RESOURCES.css().changeSize());
    panel.setWidth(width + "px");
    panel.getElement().getStyle().setBackgroundColor(bg);
    return panel;
}
#method_after
private static Widget getSizeWidget(ChangeInfo c) {
    int largeChangeSize = Gerrit.info().change().largeChange();
    int changedLines = c.insertions() + c.deletions();
    int p = 100;
    if (changedLines < largeChangeSize) {
        p = changedLines * 100 / largeChangeSize;
    }
    int width = Math.max(2, 70 * p / 100);
    int red = p >= 50 ? 255 : (int) Math.round((p) * 5.12);
    int green = p <= 50 ? 255 : (int) Math.round(256 - (p - 50) * 5.12);
    String bg = "#" + toHex(red) + toHex(green) + "00";
    SimplePanel panel = new SimplePanel();
    panel.setStyleName(Gerrit.RESOURCES.css().changeSize());
    panel.setWidth(width + "px");
    panel.getElement().getStyle().setBackgroundColor(bg);
    return panel;
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request req, Callback cb) {
    if (req.getQuery().length() >= Gerrit.getServerInfo().suggest().from()) {
        _onRequestSuggestions(req, cb);
    } else {
        List<Suggestion> none = Collections.emptyList();
        cb.onSuggestionsReady(req, new Response(none));
    }
}
#method_after
@Override
protected void onRequestSuggestions(Request req, Callback cb) {
    if (req.getQuery().length() >= Gerrit.info().suggest().from()) {
        _onRequestSuggestions(req, cb);
    } else {
        List<Suggestion> none = Collections.emptyList();
        cb.onSuggestionsReady(req, new Response(none));
    }
}
#end_block

#method_before
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).is_edit()) {
        reply.setTitle(Gerrit.getServerInfo().change().replyLabel());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getServerInfo().change().replyLabel()).closeDiv());
        if (hasDraftComments) {
            reply.setStyleName(style.highlight());
        }
        reply.setVisible(true);
    }
}
#method_after
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).isEdit()) {
        reply.setTitle(Gerrit.info().change().replyLabel());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.info().change().replyLabel()).closeDiv());
        if (hasDraftComments) {
            reply.setStyleName(style.highlight());
        }
        reply.setVisible(true);
    }
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.hasActions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.projectNameKey(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.is_edit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.current_revision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#method_after
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.isEdit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.currentRevision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#end_block

#method_before
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccountInfo()._account_id();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._account_id() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#method_after
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccountInfo()._accountId();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._accountId() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#end_block

#method_before
private static NativeMap<JsArray<CommentInfo>> filterForRevision(NativeMap<JsArray<CommentInfo>> comments, int id) {
    NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
    for (String k : comments.keySet()) {
        JsArray<CommentInfo> allRevisions = comments.get(k);
        JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
        for (int i = 0; i < allRevisions.length(); i++) {
            CommentInfo c = allRevisions.get(i);
            if (c.patch_set() == id) {
                thisRevision.push(c);
            }
        }
        filtered.put(k, thisRevision);
    }
    return filtered;
}
#method_after
private static NativeMap<JsArray<CommentInfo>> filterForRevision(NativeMap<JsArray<CommentInfo>> comments, int id) {
    NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
    for (String k : comments.keySet()) {
        JsArray<CommentInfo> allRevisions = comments.get(k);
        JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
        for (int i = 0; i < allRevisions.length(); i++) {
            CommentInfo c = allRevisions.get(i);
            if (c.patchSet() == id) {
                thisRevision.push(c);
            }
        }
        filtered.put(k, thisRevision);
    }
    return filtered;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.current_revision()) || info.revision(revision).is_edit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || info.revision(revision).isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    initRevisionsAction(info, revision, actionMap);
    actions.reloadRevisionActions(actionMap);
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    initRevisionsAction(info, revision, actionMap);
    commit.setParentNotCurrent(actionMap.containsKey("rebase") && actionMap.get("rebase").enabled());
    actions.reloadRevisionActions(actionMap);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getServerInfo().user().anonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.info().user().anonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._accountId()), Change.Status.NEW));
}
#end_block

#method_before
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getServerInfo().change().updateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.info().change().updateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.base_change(emptyToNull(base));
    if (Gerrit.getServerInfo().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    if (Gerrit.info().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.wait_for_merge(true);
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.waitForMerge(true);
    call(id, commit, "submit").post(in, cb);
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            RpcStatus.INSTANCE = new RpcStatus();
            ConfigServerApi.serverInfo(new GerritCallback<ServerInfo>() {

                @Override
                public void onSuccess(ServerInfo info) {
                    myServerInfo = info;
                    onModuleLoad2(result);
                }
            });
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = getServerInfo().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = getServerInfo().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = getServerInfo().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.getServerInfo().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#method_after
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.info().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#end_block

#method_before
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = new AuthInfo(authConfig, realm);
    info.change = new ChangeInfo(config);
    info.contactStore = getContactStoreInfo();
    info.download = new DownloadInfo(downloadSchemes, downloadCommands, archiveFormats);
    info.gerrit = new GerritInfo(config, allProjectsName, allUsersName);
    info.gitWeb = getGitWebInfo(gitWebConfig);
    info.suggest = new SuggestInfo(config);
    info.user = new UserInfo(anonymousCowardName);
    return info;
}
#method_after
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = new AuthInfo(authConfig, realm);
    info.change = getChangeInfo(config);
    info.contactStore = getContactStoreInfo();
    info.download = new DownloadInfo(downloadSchemes, downloadCommands, archiveFormats);
    info.gerrit = getGerritInfo(config, allProjectsName, allUsersName);
    info.gitWeb = getGitWebInfo(gitWebConfig);
    info.suggest = getSuggestInfo(config);
    info.user = getUserInfo(anonymousCowardName);
    return info;
}
#end_block

#method_before
private GitWebInfo getGitWebInfo(GitWebConfig cfg) {
    return cfg.getUrl() != null && cfg.getGitWebType() != null ? new GitWebInfo(cfg) : null;
}
#method_after
private GitWebInfo getGitWebInfo(GitWebConfig cfg) {
    if (cfg.getUrl() == null || cfg.getGitWebType() == null) {
        return null;
    }
    GitWebInfo info = new GitWebInfo();
    info.url = cfg.getUrl();
    info.type = cfg.getGitWebType();
    return info;
}
#end_block

#method_before
public static String nameEmail(AccountInfo info) {
    String name = info.name();
    if (name == null || name.trim().isEmpty()) {
        name = Gerrit.getServerInfo().user().anonymousCowardName();
    }
    StringBuilder b = new StringBuilder().append(name);
    if (info.email() != null) {
        b.append(" <").append(info.email()).append(">");
    } else if (info._account_id() > 0) {
        b.append(" (").append(info._account_id()).append(")");
    }
    return b.toString();
}
#method_after
public static String nameEmail(AccountInfo info) {
    String name = info.name();
    if (name == null || name.trim().isEmpty()) {
        name = Gerrit.info().user().anonymousCowardName();
    }
    StringBuilder b = new StringBuilder().append(name);
    if (info.email() != null) {
        b.append(" <").append(info.email()).append(">");
    } else if (info._accountId() > 0) {
        b.append(" (").append(info._accountId()).append(")");
    }
    return b.toString();
}
#end_block

#method_before
static String authorName(MessageInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.getServerInfo().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#method_after
static String authorName(MessageInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.info().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    getDocIndex(cbg.add(new GerritCallback<DocInfo>() {

        @Override
        public void onSuccess(DocInfo indexInfo) {
            hasDocumentation = indexInfo != null;
        }
    }));
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    addDocumentationMenuBar();
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (hasDocumentation) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet.Id psId = change().currentPatchSetId();
    PatchSet ps = db.patchSets().get(psId);
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
static Predicate<ChangeData> create(Schema<ChangeData> schema, Collection<Account.Id> ids) throws QueryParseException {
    if (schema == null || schema.hasField(ChangeField.LEGACY_REVIEWED)) {
        throw new QueryParseException("Only is:reviewed is supported");
    }
    checkSchema(schema);
    List<Predicate<ChangeData>> predicates = new ArrayList<>();
    for (Account.Id id : ids) {
        predicates.add(new IsReviewedPredicate(Integer.toString(id.get())));
    }
    return Predicate.or(predicates);
}
#method_after
@SuppressWarnings("deprecation")
static Predicate<ChangeData> create(Schema<ChangeData> schema, Collection<Account.Id> ids) throws QueryParseException {
    if (schema == null || schema.hasField(ChangeField.LEGACY_REVIEWED)) {
        throw new QueryParseException("Only is:reviewed is supported");
    }
    checkSchema(schema);
    List<Predicate<ChangeData>> predicates = new ArrayList<>(ids.size());
    for (Account.Id id : ids) {
        predicates.add(new IsReviewedPredicate(id));
    }
    return Predicate.or(predicates);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    Set<Account.Id> reviewedBy = cd.reviewedBy();
    return !reviewedBy.isEmpty() ? reviewedBy.contains(id) : id == null;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    Set<Account.Id> reviewedBy = cd.reviewedBy();
    return !reviewedBy.isEmpty() ? reviewedBy.contains(id) : id == NOT_REVIEWED;
}
#end_block

#method_before
protected void assertBadQuery(QueryRequest query) throws Exception {
    try {
        query.get();
        fail("expected BadRequestException for query: " + query);
    } catch (BadRequestException e) {
    // Expected.
    }
}
#method_after
protected void assertBadQuery(QueryRequest query) throws Exception {
    exception.expect(BadRequestException.class);
    query.get();
}
#end_block

#method_before
@Test
public void getVersion() throws Exception {
    String version = gApi.config().server().getVersion();
    Truth.assertThat(version).is(Version.getVersion());
}
#method_after
@Test
public void getVersion() throws Exception {
    assertThat(gApi.config().server().getVersion()).isEqualTo(Version.getVersion());
}
#end_block

#method_before
private List<ChangeData> getChangesByTopic(String topic) {
    try {
        List<ChangeData> ret = Lists.newArrayList();
        for (ChangeData c : queryProvider.get().byTopicOpen(topic)) {
            if (topic.equals(c.change().getTopic())) {
                ret.add(c);
            }
        }
        return ret;
    } catch (OrmException e) {
        throw new OrmRuntimeException(e);
    }
}
#method_after
private List<ChangeData> getChangesByTopic(String topic) {
    try {
        return queryProvider.get().byExactTopicOpen(topic);
    } catch (OrmException e) {
        throw new OrmRuntimeException(e);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    changeId2 = newChange2(admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(admin.getIdent(), changeId);
    change = getChange(changeId);
    assertThat(ps).isNotNull();
    changeId2 = newChange2(admin.getIdent());
    change2 = getChange(changeId2);
    assertThat(change2).isNotNull();
    ps2 = getCurrentPatchSet(changeId2);
    assertThat(ps2).isNotNull();
}
#end_block

#method_before
@After
public void cleanup() {
    DateTimeUtils.setCurrentMillisSystem();
    db.close();
}
#method_after
@After
public void cleanup() {
    db.close();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Uploaded patch set 3: Published edit on patch set 2."));
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    editUtil.publish(editUtil.byChange(change).get());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(newCurrentPatchSet.getId()).isNotEqualTo(oldCurrentPatchSet.getId());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(modifier.createEdit(change, oldCurrentPatchSet)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.post(urlPublish());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.isPresent()).isFalse();
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertThat(newCurrentPatchSet.getId()).isNotEqualTo(oldCurrentPatchSet.getId());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Published edit on patch set 2."));
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Commit message was updated."));
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    editUtil.publish(edit.get());
    assertChangeMessages(change, ImmutableList.of("Uploaded patch set 1.", "Uploaded patch set 2.", "Patch set 3: Commit message was updated."));
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("git-upload-archive").to(Commands.key(git, "upload-archive"));
    command(git, "upload-archive").to(UploadArchive.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("git-upload-archive").to(Commands.key(git, "upload-archive"));
    command(git, "upload-archive").to(UploadArchive.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be run on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, SetHeadCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (slaveMode) {
        command("git-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command("gerrit-receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(git, "receive-pack").to(NotSupportedInSlaveModeFailureCommand.class);
        command(gerrit, "test-submit").to(NotSupportedInSlaveModeFailureCommand.class);
    } else {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
protected void readArguments() throws IOException, Failure {
    final String arg_cmd = "argument ";
    List<String> args = Lists.newArrayList();
    // Read arguments in Pkt-Line format
    PacketLineIn packetIn = new PacketLineIn(in);
    for (; ; ) {
        String s = packetIn.readString();
        if (s == PacketLineIn.END)
            break;
        if (!s.startsWith(arg_cmd)) {
            throw new Failure(1, "fatal: 'argument' token or flush expected");
        }
        String[] parts = s.substring(arg_cmd.length()).split("=", 2);
        for (String p : parts) args.add(p);
    }
    try {
        // Parse them into the 'm_options' field
        CmdLineParser parser = new CmdLineParser(m_options);
        parser.parseArgument(args);
    } catch (CmdLineException e) {
        throw new Failure(2, "fatal: unable to parse arguments, " + e);
    }
}
#method_after
protected void readArguments() throws IOException, Failure {
    String argCmd = "argument ";
    List<String> args = Lists.newArrayList();
    // Read arguments in Pkt-Line format
    PacketLineIn packetIn = new PacketLineIn(in);
    for (; ; ) {
        String s = packetIn.readString();
        if (s == PacketLineIn.END) {
            break;
        }
        if (!s.startsWith(argCmd)) {
            throw new Failure(1, "fatal: 'argument' token or flush expected");
        }
        String[] parts = s.substring(argCmd.length()).split("=", 2);
        for (String p : parts) {
            args.add(p);
        }
    }
    try {
        // Parse them into the 'options' field
        CmdLineParser parser = new CmdLineParser(options);
        parser.parseArgument(args);
        if (options.path == null || Arrays.asList(".").equals(options.path)) {
            options.path = Collections.emptyList();
        }
    } catch (CmdLineException e) {
        throw new Failure(2, "fatal: unable to parse arguments, " + e);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    PacketLineOut packetOut = new PacketLineOut(out);
    packetOut.setFlushOnEnd(true);
    packetOut.writeString("ACK");
    packetOut.end();
    try {
        // Parse Git arguments
        readArguments();
        // Verify the user has permissions to read the specified reference
        if (!projectControl.allRefsAreVisible()) {
            throw new Failure(4, "fatal: upload-archive not permitted on this server");
        }
        // Find out the object to get from the specified reference and requested path
        ObjectId treeId = repo.resolve(m_options.treeIsh);
        if (treeId.equals(ObjectId.zeroId())) {
            throw new Failure(5, "fatal: reference not found");
        }
        // Build the archive
        final String format = m_options.format;
        final boolean wasFormatRegistered = registerArchiveFormat(format);
        try {
            // The archive is sent in DATA sideband channel
            SideBandOutputStream sidebandOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, SideBandOutputStream.MAX_BUF, out);
            new ArchiveCommand(repo).setFormat(format).setTree(treeId).setPaths((m_options.path == null ? Collections.emptyList() : m_options.path).toArray(new String[0])).setPrefix(m_options.prefix).setOutputStream(sidebandOut).call();
            sidebandOut.flush();
            sidebandOut.close();
        } catch (GitAPIException e) {
            throw new Failure(6, "fatal: git api exception, " + e);
        } finally {
            if (wasFormatRegistered)
                unregisterArchiveFormat(format);
        }
    } catch (Failure f) {
        // Report the error in ERROR sideband channel
        SideBandOutputStream sidebandError = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.MAX_BUF, out);
        sidebandError.write(f.getMessage().getBytes());
        sidebandError.flush();
        sidebandError.close();
        throw f;
    } finally {
        // In any case, cleanly close the packetOut channel
        packetOut.end();
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    PacketLineOut packetOut = new PacketLineOut(out);
    packetOut.setFlushOnEnd(true);
    packetOut.writeString("ACK");
    packetOut.end();
    try {
        // Parse Git arguments
        readArguments();
        ArchiveFormat f = allowedFormats.getExtensions().get("." + options.format);
        if (f == null) {
            throw new Failure(3, "fatal: upload-archive not permitted");
        }
        // Find out the object to get from the specified reference and paths
        ObjectId treeId = repo.resolve(options.treeIsh);
        if (treeId.equals(ObjectId.zeroId())) {
            throw new Failure(4, "fatal: reference not found");
        }
        // Verify the user has permissions to read the specified reference
        if (!projectControl.allRefsAreVisible() && !canRead(treeId)) {
            throw new Failure(5, "fatal: cannot perform upload-archive operation");
        }
        try {
            // The archive is sent in DATA sideband channel
            SideBandOutputStream sidebandOut = new SideBandOutputStream(SideBandOutputStream.CH_DATA, SideBandOutputStream.MAX_BUF, out);
            new ArchiveCommand(repo).setFormat(f.name()).setFormatOptions(getFormatOptions(f)).setTree(treeId).setPaths(options.path.toArray(new String[0])).setPrefix(options.prefix).setOutputStream(sidebandOut).call();
            sidebandOut.flush();
            sidebandOut.close();
        } catch (GitAPIException e) {
            throw new Failure(7, "fatal: git api exception, " + e);
        }
    } catch (Failure f) {
        // Report the error in ERROR sideband channel
        SideBandOutputStream sidebandError = new SideBandOutputStream(SideBandOutputStream.CH_ERROR, SideBandOutputStream.MAX_BUF, out);
        sidebandError.write(f.getMessage().getBytes(UTF_8));
        sidebandError.flush();
        sidebandError.close();
        throw f;
    } finally {
        // In any case, cleanly close the packetOut channel
        packetOut.end();
    }
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    exception.expect(UnchangedCommitMessageException.class);
    exception.expectMessage("New commit message cannot be same as existing commit message");
    modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
}
#method_after
@Test
public void getFileNotFoundRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(adminSession.delete(urlEditFile()).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = adminSession.get(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    exception.expect(ResourceNotFoundException.class);
    fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME);
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, patchListCache, repoManager, projectCache, listChildProjects, indexes, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, indexes, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    for (Account.Id accountId : cd.editsByUser()) {
        if (accountId.equals(id)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    return cd.editsByUser().contains(id);
}
#end_block

#method_before
public static void ensureAllPatchSetsLoaded(Iterable<ChangeData> changes) throws OrmException {
    for (ChangeData cd : changes) {
        cd.patches();
    }
}
#method_after
public static void ensureAllPatchSetsLoaded(Iterable<ChangeData> changes) throws OrmException {
    for (ChangeData cd : changes) {
        cd.patchSets();
    }
}
#end_block

#method_before
public static void ensureCurrentPatchSetLoaded(Iterable<ChangeData> changes) throws OrmException {
    Map<PatchSet.Id, ChangeData> missing = Maps.newHashMap();
    for (ChangeData cd : changes) {
        if (cd.currentPatchSet == null && cd.patches == null) {
            missing.put(cd.change().currentPatchSetId(), cd);
        }
    }
    if (!missing.isEmpty()) {
        ReviewDb db = missing.values().iterator().next().db;
        for (PatchSet ps : db.patchSets().get(missing.keySet())) {
            ChangeData cd = missing.get(ps.getId());
            cd.currentPatchSet = ps;
        }
    }
}
#method_after
public static void ensureCurrentPatchSetLoaded(Iterable<ChangeData> changes) throws OrmException {
    Map<PatchSet.Id, ChangeData> missing = Maps.newHashMap();
    for (ChangeData cd : changes) {
        if (cd.currentPatchSet == null && cd.patchSets == null) {
            missing.put(cd.change().currentPatchSetId(), cd);
        }
    }
    if (!missing.isEmpty()) {
        ReviewDb db = missing.values().iterator().next().db;
        for (PatchSet ps : db.patchSets().get(missing.keySet())) {
            ChangeData cd = missing.get(ps.getId());
            cd.currentPatchSet = ps;
        }
    }
}
#end_block

#method_before
static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#method_after
public static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#end_block

#method_before
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patches()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#method_after
public PatchSet currentPatchSet() throws OrmException {
    if (currentPatchSet == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        for (PatchSet p : patchSets()) {
            if (p.getId().equals(c.currentPatchSetId())) {
                currentPatchSet = p;
                return p;
            }
        }
    }
    return currentPatchSet;
}
#end_block

#method_before
public Set<Account.Id> editsByUser() throws OrmException {
    if (editsByUser == null) {
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        try {
            editsByUser = editUtils.accountsByChange(c);
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    return editsByUser;
}
#method_after
public Set<Account.Id> editsByUser() throws OrmException {
    if (editsByUser == null) {
        Change c = change();
        if (c == null) {
            return Collections.emptySet();
        }
        editsByUser = new HashSet<>();
        Change.Id id = change.getId();
        try (Repository repo = repoManager.openRepository(change.getProject())) {
            for (String ref : repo.getRefDatabase().getRefs(RefNames.REFS_USERS).keySet()) {
                if (Change.Id.fromEditRefPart(ref).equals(id)) {
                    editsByUser.add(Account.Id.fromRefPart(ref));
                }
            }
        } catch (IOException e) {
            throw new OrmException(e);
        }
    }
    return editsByUser;
}
#end_block

#method_before
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_USER);
    int account = accountId.get();
    int m = account % 100;
    if (m < 10) {
        r.append('0');
    }
    r.append(m);
    r.append('/');
    r.append(account);
    return r.toString();
}
#method_after
public static String refsUsers(Account.Id accountId) {
    StringBuilder r = new StringBuilder();
    r.append(REFS_USERS);
    int account = accountId.get();
    int m = account % 100;
    if (m < 10) {
        r.append('0');
    }
    r.append(m);
    r.append('/');
    r.append(account);
    return r.toString();
}
#end_block

#method_before
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet));
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
        // The answer to the question "why it doesn't hurt to reload the change?"
        // is let as an exercise to the reader.
        indexer.index(changeDataFactory.create(db.get(), change.getId()));
    }
}
#method_after
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        Change updatedChange = insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet));
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
        indexer.index(db.get(), updatedChange);
    }
}
#end_block

#method_before
private void insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, PatchSet basePatchSet, RevCommit squashed) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    PatchSet ps = new PatchSet(ChangeUtil.nextPatchSetId(change.currentPatchSetId()));
    ps.setRevision(new RevId(ObjectId.toString(squashed)));
    ps.setUploader(edit.getUser().getAccountId());
    ps.setCreatedOn(TimeUtil.nowTs());
    PatchSetInserter insr = patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(change, edit.getUser()), squashed);
    insr.setPatchSet(ps).setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(String.format("Patch Set %d: Published edit on patch set %d", ps.getPatchSetId(), basePatchSet.getPatchSetId())).insert();
}
#method_after
private Change insertPatchSet(ChangeEdit edit, Change change, Repository repo, RevWalk rw, PatchSet basePatchSet, RevCommit squashed) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    PatchSet ps = new PatchSet(ChangeUtil.nextPatchSetId(change.currentPatchSetId()));
    ps.setRevision(new RevId(ObjectId.toString(squashed)));
    ps.setUploader(edit.getUser().getAccountId());
    ps.setCreatedOn(TimeUtil.nowTs());
    PatchSetInserter insr = patchSetInserterFactory.create(repo, rw, changeControlFactory.controlFor(change, edit.getUser()), squashed);
    return insr.setPatchSet(ps).setDraft(change.getStatus() == Status.DRAFT || basePatchSet.isDraft()).setMessage(String.format("Patch Set %d: Published edit on patch set %d", ps.getPatchSetId(), basePatchSet.getPatchSetId())).insert();
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        ChangeApi.includedIn(changeId.get(), new AsyncCallback<IncludedInInfo>() {

            @Override
            public void onSuccess(IncludedInInfo r) {
                branches.setInnerSafeHtml(formatList(r.branches()));
                tags.setInnerSafeHtml(formatList(r.tags()));
                for (String t : r.systemTypes()) {
                    appendRow(t, r.system(t));
                }
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        ChangeApi.includedIn(changeId.get(), new AsyncCallback<IncludedInInfo>() {

            @Override
            public void onSuccess(IncludedInInfo r) {
                branches.setInnerSafeHtml(formatList(r.branches()));
                tags.setInnerSafeHtml(formatList(r.tags()));
                for (String n : r.externalNames()) {
                    JsArrayString external = r.external(n);
                    if (external.length() > 0) {
                        appendRow(n, external);
                    }
                }
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = db.get().patchSets().get(ctl.getChange().currentPatchSetId());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInDetail d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> systems = new HashMap<>();
        for (DynamicMap.Entry<com.google.gerrit.extensions.config.IncludedIn> i : includedIn) {
            systems.put(i.getExportName(), i.getProvider().get().getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, systems);
    }
}
#method_after
@Override
public IncludedInInfo apply(ChangeResource rsrc) throws BadRequestException, ResourceConflictException, OrmException, IOException {
    ChangeControl ctl = rsrc.getControl();
    PatchSet ps = db.get().patchSets().get(ctl.getChange().currentPatchSetId());
    Project.NameKey project = ctl.getProject().getNameKey();
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        rw.setRetainBody(false);
        RevCommit rev;
        try {
            rev = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
        } catch (IncorrectObjectTypeException err) {
            throw new BadRequestException(err.getMessage());
        } catch (MissingObjectException err) {
            throw new ResourceConflictException(err.getMessage());
        }
        IncludedInDetail d = IncludedInResolver.resolve(r, rw, rev);
        Map<String, Collection<String>> external = new HashMap<>();
        for (DynamicMap.Entry<ExternalIncludedIn> i : includedIn) {
            external.put(i.getExportName(), i.getProvider().get().getIncludedIn(project.get(), rev.name(), d.getTags(), d.getBranches()));
        }
        return new IncludedInInfo(d, (!external.isEmpty() ? external : null));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), IncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            attachComments(result);
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#method_after
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
private void postReview() {
    in.message(message.getText().trim());
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#method_after
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
            for (String k : result.keySet()) {
                JsArray<CommentInfo> allRevisions = result.get(k);
                JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
                for (int i = 0; i < allRevisions.length(); i++) {
                    CommentInfo c = allRevisions.get(i);
                    if (!c.has_patch_set() || c.patch_set() == id) {
                        thisRevision.push(c);
                    }
                }
                filtered.put(k, thisRevision);
            }
            // Only count comments for the current revision in the file table, but
            // include all comments in the history table below.
            r.add(filtered);
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    cfg = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    int result = 0;
    try {
        index.markReady(false);
        index.deleteAll();
        result = indexAll();
        index.markReady(true);
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    }
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    checkNotSlaveMode();
    disableLuceneAutomaticCommit();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    int result = 0;
    try {
        index.markReady(false);
        index.deleteAll();
        result = indexAll();
        index.markReady(true);
    } catch (Exception e) {
        throw die(e.getMessage(), e);
    }
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private void checkNotSlaveMode() throws Die {
    if (cfg.getBoolean("container", "slave", false)) {
        throw die("Cannot run reindex in slave mode");
    }
}
#method_after
private void checkNotSlaveMode() throws Die {
    Config cfg = dbInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    if (cfg.getBoolean("container", "slave", false)) {
        throw die("Cannot run reindex in slave mode");
    }
}
#end_block

#method_before
public PatchSetInserter setMessage(ChangeMessage changeMessage) throws OrmException {
    this.changeMessage = changeMessage;
    return this;
}
#method_after
public PatchSetInserter setMessage(ChangeMessage changeMessage) {
    this.changeMessage = changeMessage;
    return this;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    return updatedChange;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    Futures.transform(executor.submit(new GetChanges(event)), new AsyncFunction<List<Change>, List<Void>>() {

        @Override
        public ListenableFuture<List<Void>> apply(List<Change> changes) {
            List<ListenableFuture<Void>> result = Lists.newArrayListWithCapacity(changes.size());
            for (Change c : changes) {
                result.add(executor.submit(new Index(c)));
            }
            return Futures.allAsList(result);
        }
    });
}
#method_after
@Override
public void onGitReferenceUpdated(final Event event) {
    Futures.transform(executor.submit(new GetChanges(event)), new AsyncFunction<List<Change>, List<Void>>() {

        @Override
        public ListenableFuture<List<Void>> apply(List<Change> changes) {
            List<ListenableFuture<Void>> result = Lists.newArrayListWithCapacity(changes.size());
            for (Change c : changes) {
                result.add(executor.submit(new Index(event, c)));
            }
            return Futures.allAsList(result);
        }
    });
}
#end_block

#method_before
@Override
public final V call() throws Exception {
    try {
        db = schemaFactory.open();
        return impl();
    } catch (Exception e) {
        log.error("Failed to reindex changes after ref update", e);
        throw e;
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
@Override
public final V call() throws Exception {
    try {
        db = schemaFactory.open();
        return impl();
    } catch (Exception e) {
        log.error("Failed to reindex changes after " + event, e);
        throw e;
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
@Before
public void createTempDirectory() throws Exception {
    sitePath = TempFileUtil.createTempDirectory().toPath();
}
#method_after
@Before
public void createTempDirectory() throws Exception {
    sitePath = TempFileUtil.createTempDirectory();
}
#end_block

#method_before
private void initSite() throws Exception {
    runGerrit("init", "-d", sitePath.toString(), "--batch", "--no-auto-start", "--skip-plugins", "--show-stack-trace");
}
#method_after
private void initSite() throws Exception {
    runGerrit("init", "-d", sitePath.getPath(), "--batch", "--no-auto-start", "--skip-plugins", "--show-stack-trace");
}
#end_block

#method_before
@Option(name = "--disable-httpd", usage = "Disable the internal HTTP daemon")
void setDisableHttpd(final boolean arg) {
    httpd = false;
}
#method_after
@Option(name = "--disable-httpd", usage = "Disable the internal HTTP daemon")
void setDisableHttpd(@SuppressWarnings("unused") boolean arg) {
    httpd = false;
}
#end_block

#method_before
@Option(name = "--disable-sshd", usage = "Disable the internal SSH daemon")
void setDisableSshd(final boolean arg) {
    sshd = false;
}
#method_after
@Option(name = "--disable-sshd", usage = "Disable the internal SSH daemon")
void setDisableSshd(@SuppressWarnings("unused") boolean arg) {
    sshd = false;
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless));
            if (test) {
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
    }
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
    }
    return change;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                if (c.getType() == UPDATE) {
                    // otherwise known as a fast-forward
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                }
                if (isHead(c) || isConfig(c)) {
                    switch(c.getType()) {
                        case CREATE:
                        case UPDATE:
                        case UPDATE_NONFASTFORWARD:
                            autoCloseChanges(c);
                            break;
                        case DELETE:
                            break;
                    }
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.destChanges.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change.Id> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change> r = new HashMap<>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c);
    }
    return r;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    Iterable<ChangeData> all = FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    });
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    Set<Change.Id> reviewed = Sets.newHashSet();
    if (has(REVIEWED)) {
        reviewed = loadReviewed(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes(), reviewed);
        if (r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatQueryResults(List<QueryResult> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    Iterable<ChangeData> all = FluentIterable.from(in).transformAndConcat(new Function<QueryResult, List<ChangeData>>() {

        @Override
        public List<ChangeData> apply(QueryResult in) {
            return in.changes();
        }
    });
    ChangeData.ensureChangeLoaded(all);
    if (has(ALL_REVISIONS)) {
        ChangeData.ensureAllPatchSetsLoaded(all);
    } else if (has(CURRENT_REVISION) || has(MESSAGES)) {
        ChangeData.ensureCurrentPatchSetLoaded(all);
    }
    Set<Change.Id> reviewed = Sets.newHashSet();
    if (has(REVIEWED)) {
        reviewed = loadReviewed(all);
    }
    ChangeData.ensureCurrentApprovalsLoaded(all);
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    Map<Change.Id, ChangeInfo> out = Maps.newHashMap();
    for (QueryResult r : in) {
        List<ChangeInfo> infos = toChangeInfo(out, r.changes(), reviewed);
        if (r.moreChanges()) {
            infos.get(infos.size() - 1)._moreChanges = true;
        }
        res.add(infos);
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    PatchSet ps = cd.currentPatchSet();
    if (ps == null) {
        return ImmutableList.of();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setPatchSet(ps).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#end_block

#method_before
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    atrScope.disableDb();
    assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).get()).hasSize(2);
}
#method_after
@Test
public void defaultSearchDoesNotTouchDatabase() throws Exception {
    PushOneCommit.Result r1 = createChange();
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).submit();
    createChange();
    // Identified user may async get stars from DB.
    setApiUserAnonymous();
    atrScope.disableDb();
    assertThat(gApi.changes().query().withQuery("project:{" + project.get() + "} (status:open OR status:closed)").withOption(ListChangesOption.LABELS).withOption(ListChangesOption.DETAILED_ACCOUNTS).get()).hasSize(2);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> query(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try {
        Repository git = args.repoManager.openRepository(allUsers);
        try {
            VersionedAccountQueries q = VersionedAccountQueries.forUser(self());
            q.load(git);
            String query = q.getQueryList().getQuery(name);
            if (query != null) {
                return parse(query);
            }
        } finally {
            git.close();
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named query (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    } catch (ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    }
    throw new QueryParseException("Unknown named query: " + name);
}
#method_after
@Operator
public Predicate<ChangeData> query(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountQueries q = VersionedAccountQueries.forUser(self());
        q.load(git);
        String query = q.getQueryList().getQuery(name);
        if (query != null) {
            return parse(query);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named query (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named query: " + name, e);
    }
    throw new QueryParseException("Unknown named query: " + name);
}
#end_block

#method_before
@Test
public void testParseSimple() {
    try {
        QueryList ql = QueryList.parse(F_SIMPLE, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseSimple() throws Exception {
    QueryList ql = QueryList.parse(F_SIMPLE, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseWHeader() {
    try {
        QueryList ql = QueryList.parse(HEADER + F_SIMPLE, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseWHeader() throws Exception {
    QueryList ql = QueryList.parse(HEADER + F_SIMPLE, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseWComments() {
    try {
        QueryList ql = QueryList.parse(C1 + F_SIMPLE + C2, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseWComments() throws Exception {
    QueryList ql = QueryList.parse(C1 + F_SIMPLE + C2, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseFooComment() {
    try {
        QueryList ql = QueryList.parse("#" + L_FOO + L_BAR, null);
        assertTrue(null == ql.getQuery(N_FOO));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseFooComment() throws Exception {
    QueryList ql = QueryList.parse("#" + L_FOO + L_BAR, null);
    assertThat(ql.getQuery(N_FOO)).isNull();
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParsePaddedFronts() {
    try {
        QueryList ql = QueryList.parse(F_PAD_F, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParsePaddedFronts() throws Exception {
    QueryList ql = QueryList.parse(F_PAD_F, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParsePaddedEnds() {
    try {
        QueryList ql = QueryList.parse(F_PAD_E, null);
        assertTrue(Q_P.equals(ql.getQuery(N_FOO)));
        assertTrue(Q_B.equals(ql.getQuery(N_BAR)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParsePaddedEnds() throws Exception {
    QueryList ql = QueryList.parse(F_PAD_E, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_P);
    assertThat(ql.getQuery(N_BAR)).isEqualTo(Q_B);
}
#end_block

#method_before
@Test
public void testParseComplex() {
    try {
        QueryList ql = QueryList.parse(L_COMPLEX, null);
        assertTrue(Q_COMPLEX.equals(ql.getQuery(N_FOO)));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testParseComplex() throws Exception {
    QueryList ql = QueryList.parse(L_COMPLEX, null);
    assertThat(ql.getQuery(N_FOO)).isEqualTo(Q_COMPLEX);
}
#end_block

#method_before
@Test
public void testParseBad() {
    try {
        QueryList ql = QueryList.parse(L_BAD, null);
        assertTrue(false);
    } catch (Exception e) {
        assertTrue(true);
    }
}
#method_after
@Test(expected = IOException.class)
public void testParseBad() throws Exception {
    ValidationError.Sink sink = createNiceMock(ValidationError.Sink.class);
    replay(sink);
    QueryList.parse(L_BAD, sink);
}
#end_block

#method_before
@Test
public void testAsText() {
    String text = HEADER + "#\n" + F_PROPER;
    try {
        QueryList ql = QueryList.parse(F_SIMPLE, null);
        String asText = ql.asText();
        assertTrue(text.equals(asText));
        ql = QueryList.parse(asText, null);
        asText = ql.asText();
        assertTrue(text.equals(asText));
    } catch (Exception e) {
        assertTrue(false);
    }
}
#method_after
@Test
public void testAsText() throws Exception {
    String expectedText = HEADER + "#\n" + F_PROPER;
    QueryList ql = QueryList.parse(F_SIMPLE, null);
    String asText = ql.asText();
    assertThat(asText).isEqualTo(expectedText);
    ql = QueryList.parse(asText, null);
    asText = ql.asText();
    assertThat(asText).isEqualTo(expectedText);
}
#end_block

#method_before
@Override
public void onProjectDeleted(Event event) {
    Project.NameKey p = new NameKey(event.getProjectName());
    repoSizeCache.remove(p);
    pushCounts.remove(p);
    fetchCounts.remove(p);
}
#method_after
@Override
public void onProjectDeleted(Event event) {
    repoSizeCache.evict(new Project.NameKey(event.getProjectName()));
}
#end_block

#method_before
@Test
public void testName() throws Exception {
    RepoSizeCache repoSizeCache = createMock(RepoSizeCache.class);
    Project.NameKey p = new Project.NameKey(MY_PROJECT);
    repoSizeCache.remove(p);
    PersistentCounter fetchCounts = createMock(PersistentCounter.class);
    fetchCounts.remove(p);
    PersistentCounter pushCounts = createMock(PersistentCounter.class);
    pushCounts.remove(p);
    DeletionListener classUnderTest = new DeletionListener(repoSizeCache, fetchCounts, pushCounts);
    replay(repoSizeCache, fetchCounts, pushCounts);
    ProjectDeletedListener.Event event = new ProjectDeletedListener.Event() {

        @Override
        public String getProjectName() {
            return MY_PROJECT;
        }
    };
    classUnderTest.onProjectDeleted(event);
    verify(repoSizeCache, fetchCounts, pushCounts);
}
#method_after
@Test
public void testName() throws Exception {
    RepoSizeCache repoSizeCache = createMock(RepoSizeCache.class);
    Project.NameKey p = new Project.NameKey(MY_PROJECT);
    repoSizeCache.evict(p);
    DeletionListener classUnderTest = new DeletionListener(repoSizeCache);
    replay(repoSizeCache);
    ProjectDeletedListener.Event event = new ProjectDeletedListener.Event() {

        @Override
        public String getProjectName() {
            return MY_PROJECT;
        }
    };
    classUnderTest.onProjectDeleted(event);
    verify(repoSizeCache);
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), ProjectCreationValidationListener.class).to(MaxRepositoriesQuotaValidator.class);
    DynamicSet.bind(binder(), ReceivePackInitializer.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), PostReceiveHook.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(DeletionListener.class);
    DynamicSet.bind(binder(), PostReceiveHook.class).to(FetchAndPushListener.class);
    DynamicSet.bind(binder(), PreUploadHook.class).to(FetchAndPushListener.class);
    DynamicSet.setOf(binder(), UsageDataEventCreator.class);
    install(MaxRepositorySizeQuota.module());
    install(PersistentCounter.module());
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "quota").to(GetQuota.class);
        }
    });
    bind(Publisher.class).in(Scopes.SINGLETON);
    bind(PublisherScheduler.class).in(Scopes.SINGLETON);
    bind(ProjectNameResolver.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(PublisherScheduler.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), ProjectCreationValidationListener.class).to(MaxRepositoriesQuotaValidator.class);
    DynamicSet.bind(binder(), ReceivePackInitializer.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), PostReceiveHook.class).to(MaxRepositorySizeQuota.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(DeletionListener.class);
    DynamicSet.setOf(binder(), UsageDataEventCreator.class);
    install(MaxRepositorySizeQuota.module());
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "quota").to(GetQuota.class);
        }
    });
    bind(Publisher.class).in(Scopes.SINGLETON);
    bind(PublisherScheduler.class).in(Scopes.SINGLETON);
    bind(ProjectNameResolver.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(PublisherScheduler.class);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    OAuthSession oauthSession = oauthSessionProvider.get();
    boolean link = request.getParameter("link") != null;
    String provider = httpRequest.getParameter("provider");
    OAuthServiceProvider service = ssoProvider == null ? oauthSession.getServiceProvider() : ssoProvider;
    if (link) {
        oauthSession.setLinkMode(link);
    }
    if (isGerritLogin(httpRequest) || oauthSession.isOAuthFinal(httpRequest)) {
        if (service == null && Strings.isNullOrEmpty(provider)) {
            selectProvider(httpRequest, httpResponse, null);
            return;
        } else {
            if (service == null) {
                service = findService(provider);
            }
            oauthSession.setServiceProvider(service);
            oauthSession.login(httpRequest, httpResponse, service);
        }
    } else {
        chain.doFilter(httpRequest, response);
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    OAuthSession oauthSession = oauthSessionProvider.get();
    if (request.getParameter("link") != null) {
        oauthSession.setLinkMode(true);
        oauthSession.setServiceProvider(null);
    }
    String provider = httpRequest.getParameter("provider");
    OAuthServiceProvider service = ssoProvider == null ? oauthSession.getServiceProvider() : ssoProvider;
    if (isGerritLogin(httpRequest) || oauthSession.isOAuthFinal(httpRequest)) {
        if (service == null && Strings.isNullOrEmpty(provider)) {
            selectProvider(httpRequest, httpResponse, null);
            return;
        } else {
            if (service == null) {
                service = findService(provider);
            }
            oauthSession.setServiceProvider(service);
            oauthSession.login(httpRequest, httpResponse, service);
        }
    } else {
        chain.doFilter(httpRequest, response);
    }
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        // Use case 1: claimed identity was provided during handshake phase
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                    // Both link to the same account, that's what we expected.
                    log.debug("OAuth2: claimed identity equals current id");
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // Claimed account already exists: link to it.
                // 
                log.info("OAuth2: linking claimed identity to {}", claimedId.toString());
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        } else if (linkMode) {
            // Use case 2: link mode activated from the UI
            try {
                accountManager.link(identifiedUser.get().getAccountId(), areq);
            } catch (OrmException e) {
                log.error("Cannot link: " + user.getExternalId() + " to user identity: " + identifiedUser.get().getAccountId());
                rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                return;
            } finally {
                linkMode = false;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectToken.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(suffix));
    rsp.sendRedirect(rdr.toString());
}
#method_after
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    AuthRequest areq = new AuthRequest(user.getExternalId());
    AuthResult arsp;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            if (!authenticateWithIdentityClaimedDuringHandshake(areq, rsp, claimedIdentifier)) {
                return;
            }
        } else if (linkMode) {
            if (!authenticateWithLinkedIdentity(areq, rsp)) {
                return;
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectToken.substring(OAuthWebFilter.GERRIT_LOGIN.length() + 1);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(suffix));
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
public final Runnable wrap(final Runnable runnable) {
    final Callable<Object> wrapped = wrap(Executors.callable(runnable));
    if (runnable instanceof ProjectRunnable) {
        return new ProjectRunnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (RuntimeException e) {
                    throw e;
                } catch (Exception e) {
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public NameKey getProjectNameKey() {
                return ((ProjectRunnable) runnable).getProjectNameKey();
            }

            @Override
            public String getRemoteName() {
                return ((ProjectRunnable) runnable).getRemoteName();
            }

            @Override
            public boolean hasCustomizedPrint() {
                return ((ProjectRunnable) runnable).hasCustomizedPrint();
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    } else {
        return new Runnable() {

            @Override
            public void run() {
                try {
                    wrapped.call();
                } catch (RuntimeException e) {
                    throw e;
                } catch (Exception e) {
                    // Not possible.
                    throw new RuntimeException(e);
                }
            }

            @Override
            public String toString() {
                return runnable.toString();
            }
        };
    }
}
#method_after
public final <T> Callable<T> wrap(final Callable<T> callable) {
    final Callable<T> wrapped = wrapImpl(new Callable<T>() {

        @Override
        public T call() throws Exception {
            RequestCleanup cleanup = scope.scope(Key.get(RequestCleanup.class), new Provider<RequestCleanup>() {

                @Override
                public RequestCleanup get() {
                    return new RequestCleanup();
                }
            }).get();
            try {
                return callable.call();
            } finally {
                cleanup.run();
            }
        }
    });
    return new Callable<T>() {

        @Override
        public T call() throws Exception {
            return wrapped.call();
        }

        @Override
        public String toString() {
            return callable.toString();
        }
    };
}
#end_block

#method_before
@Override
public Context get() {
    return getContext();
}
#method_after
@Override
public Context get() {
    return requireContext();
}
#end_block

#method_before
@Override
public SshSession get() {
    return getContext().getSession();
}
#method_after
@Override
public SshSession get() {
    return requireContext().getSession();
}
#end_block

#method_before
private void testGetGroup(String url, AccountGroup expectedGroup) throws IOException {
    RestResponse r = session.get(url);
    GroupInfo group = newGson().fromJson(r.getReader(), new TypeToken<GroupInfo>() {
    }.getType());
    assertGroupInfo(expectedGroup, group);
}
#method_after
private void testGetGroup(String url, AccountGroup expectedGroup) throws IOException {
    RestResponse r = session.get(url);
    GroupInfo group = newGson().fromJson(r.getReader(), GroupInfo.class);
    assertGroupInfo(expectedGroup, group);
}
#end_block

#method_before
@Test
public void messagesNotReturnedByDefault() throws GitAPIException, IOException {
    String changeId = createChange();
    postMessage(changeId, "Some nits need to be fixed.");
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChange(changeId);
    assertNull(c.messages);
}
#method_after
@Test
public void messagesNotReturnedByDefault() throws GitAPIException, IOException {
    String changeId = createChange();
    postMessage(changeId, "Some nits need to be fixed.");
    ChangeInfo c = getChange(changeId);
    assertNull(c.messages);
}
#end_block

#method_before
@Test
public void defaultMessage() throws GitAPIException, IOException {
    String changeId = createChange();
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(1, c.messages.size());
    assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message);
}
#method_after
@Test
public void defaultMessage() throws GitAPIException, IOException {
    String changeId = createChange();
    ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(1, c.messages.size());
    assertEquals("Uploaded patch set 1.", c.messages.iterator().next().message);
}
#end_block

#method_before
@Test
public void messagesReturnedInChronologicalOrder() throws GitAPIException, IOException {
    String changeId = createChange();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    com.google.gerrit.server.change.ChangeJson.ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(3, c.messages.size());
    Iterator<ChangeJson.ChangeMessageInfo> it = c.messages.iterator();
    assertEquals("Uploaded patch set 1.", it.next().message);
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#method_after
@Test
public void messagesReturnedInChronologicalOrder() throws GitAPIException, IOException {
    String changeId = createChange();
    String firstMessage = "Some nits need to be fixed.";
    postMessage(changeId, firstMessage);
    String secondMessage = "I like this feature.";
    postMessage(changeId, secondMessage);
    ChangeInfo c = getChangeWithMessages(changeId);
    assertNotNull(c.messages);
    assertEquals(3, c.messages.size());
    Iterator<ChangeMessageInfo> it = c.messages.iterator();
    assertEquals("Uploaded patch set 1.", it.next().message);
    assertMessage(firstMessage, it.next().message);
    assertMessage(secondMessage, it.next().message);
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if ((has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) && userProvider.get().isIdentifiedUser()) {
        actionJsonProvider.get().addChangeActions(out, cd);
        // todo: why do we need to treat followup specially here?
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in, cd.change().getProject(), has(WEB_LINKS));
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJsonProvider.get().addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in, cd.change().getProject(), has(WEB_LINKS));
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        actionJson.addRevisionActions(out, new RevisionResource(new ChangeResource(ctl), in));
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
public ChangeInfo addChangeActions(ChangeInfo to, ChangeData cd) throws OrmException {
    to.actions = toActionMap(cd);
    return to;
}
#method_after
public ChangeInfo addChangeActions(ChangeInfo to, ChangeControl ctl) {
    to.actions = toActionMap(ctl);
    return to;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (userProvider.get().isIdentifiedUser()) {
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(ChangeControl ctl) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (!ctl.getCurrentUser().isIdentifiedUser()) {
        return out;
    }
    Provider<CurrentUser> userProvider = Providers.of(ctl.getCurrentUser());
    for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
        out.put(d.getId(), new ActionInfo(d));
    }
    // TODO(sbeller): why do we need to treat followup specially here?
    if (ctl.getChange().getStatus().isOpen()) {
        UiAction.Description descr = new UiAction.Description();
        PrivateInternals_UiActionDescription.setId(descr, "followup");
        PrivateInternals_UiActionDescription.setMethod(descr, "POST");
        descr.setTitle("Create follow-up change");
        out.put(descr.getId(), new ActionInfo(descr));
    }
    return out;
}
#end_block

#method_before
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (userProvider.get().isIdentifiedUser()) {
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private Map<String, ActionInfo> toActionMap(RevisionResource rsrc) {
    Map<String, ActionInfo> out = new LinkedHashMap<>();
    if (rsrc.getControl().getCurrentUser().isIdentifiedUser()) {
        Provider<CurrentUser> userProvider = Providers.of(rsrc.getControl().getCurrentUser());
        for (UiAction.Description d : UiActions.from(revisions, rsrc, userProvider)) {
            out.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#end_block

#method_before
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(change.getId());
}
#method_after
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(getChangeId());
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Change change = getChange();
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    NoteMap noteMap = null;
    Iterator<Note> notes = null;
    if (ref != null) {
        RevCommit commit = walk.parseCommit(ref.getObjectId());
        noteMap = NoteMap.read(walk.getObjectReader(), commit);
        notes = noteMap.iterator();
    } else {
        return null;
    }
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#method_after
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    if (ref == null) {
        return null;
    }
    RevCommit commit = walk.parseCommit(ref.getObjectId());
    NoteMap noteMap = NoteMap.read(walk.getObjectReader(), commit);
    for (Note note : noteMap) {
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        result.commitIdA = content.commitIdA;
        result.commitIdB = content.commitIdB;
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.isBinary()) {
                result.binary = true;
            }
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
                result.metaA.commitId = content.commitIdA;
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
                result.metaB.commitId = content.commitIdB;
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    boolean intralineTimeout = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineTimeout = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    if (comments != null) {
        ensureCommentsVisible(comments);
    }
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    // Do nothing
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            hugeFile = true;
        }
        // In order to expand the skipped common lines or syntax highlight the
        // file properly we need to give the client the complete file contents.
        // So force our context temporarily to the complete file size.
        // 
        context = MAX_CONTEXT;
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, a.mimeType.toString(), b.mimeType.toString(), comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure, intralineTimeout, content.getPatchType() == Patch.PatchType.BINARY, aId.getName(), bId.getName());
}
#method_after
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    boolean intralineTimeout = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineTimeout = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    if (comments != null) {
        ensureCommentsVisible(comments);
    }
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    // Do nothing
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            hugeFile = true;
        }
        // In order to expand the skipped common lines or syntax highlight the
        // file properly we need to give the client the complete file contents.
        // So force our context temporarily to the complete file size.
        // 
        context = MAX_CONTEXT;
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, a.mimeType.toString(), b.mimeType.toString(), comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure, intralineTimeout, content.getPatchType() == Patch.PatchType.BINARY, aId == null ? null : aId.getName(), bId == null ? null : bId.getName());
}
#end_block

#method_before
protected ClassLoader getClassLoader() {
    return getClass().getClassLoader();
}
#method_after
@Override
protected ClassLoader getClassLoader() {
    return getClass().getClassLoader();
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        if (draftsHandling == DraftHandling.PUBLISH_FOR_ALL_REVISIONS) {
            drafts = scanDraftCommentsChange(rsrc);
        } else {
            drafts = scanDraftComments(rsrc);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_FOR_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(RevisionResource rsrc, ChangeUpdate update, Map<String, List<CommentInput>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        if (draftsHandling == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(rsrc);
        } else {
            drafts = patchSetDrafts(rsrc);
        }
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<CommentInput>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line != null ? c.line : 0, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(MoreObjects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
        case PUBLISH_ALL_REVISIONS:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                setCommentRevId(e, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
                ups.add(e);
            }
            break;
    }
    plcUtil.deleteComments(db.get(), update, del);
    plcUtil.upsertComments(db.get(), update, ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private void addLabelDelta(String name, short value) {
    labelDelta.add(new LabelVote(name, value).format());
}
#method_after
private void addLabelDelta(String name, short value) {
    labelDelta.add(LabelVote.create(name, value).format());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public RestView<RevisionResource> list() throws AuthException {
    checkIdentifiedUser();
    return list;
}
#method_after
@Override
public ListRevisionDrafts list() throws AuthException {
    checkIdentifiedUser();
    return list;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (pending) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.addPushCount(1);
        e.addState(ref, state);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        wrappedLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (pending) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                wrappedLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && GitRepositoryManager.REF_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                wrappedLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (pending) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount();
        e.addState(ref, state);
    }
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Override
public void run() {
    try {
        for (Project.NameKey nameKey : projectCache.all()) {
            replication.scheduleFullSync(nameKey, urlMatch, state);
        }
    } catch (Exception e) {
        wrappedLog.error("Cannot enumerate known projects", e, state);
    }
    state.allTaskScheduled();
}
#method_after
@Override
public void run() {
    try {
        for (Project.NameKey nameKey : projectCache.all()) {
            replication.scheduleFullSync(nameKey, urlMatch, state);
        }
    } catch (Exception e) {
        wrappedLog.error("Cannot enumerate known projects", e, state);
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean hasPushTask() {
    taskLock.lock();
    try {
        if (totalPushCount == 0) {
            return false;
        }
    } finally {
        taskLock.unlock();
    }
    return true;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushProcessing.onOneNodeReplicated(project, ref, uri, status);
    taskLock.lock();
    try {
        finishedPushCount++;
        if (!allScheduled) {
            return;
        }
        if (finishedPushCount < totalPushCount) {
            return;
        }
    } finally {
        taskLock.unlock();
    }
    pushProcessing.onAllNodesReplicated();
    if (type == ReplicationType.COMMAND) {
        allTaskFinished.countDown();
    }
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onOneNodeReplicated(project, ref, uri, status);
    countingLock.lock();
    try {
        finishedPushTasksCount++;
        if (!allScheduled) {
            return;
        }
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
public void waitForReplication() {
    taskLock.lock();
    try {
        if (finishedPushCount == totalPushCount) {
            return;
        }
    } finally {
        taskLock.unlock();
    }
    try {
        allTaskFinished.await();
    } catch (InterruptedException e) {
        log.error("It is interrupted while waiting replication to be completed");
        ;
    }
}
#method_after
public void waitForReplication() throws InterruptedException {
    allPushTasksFinished.await();
}
#end_block

#method_before
public void writeStdOut(final String message) {
    pushProcessing.writeStdOut(message);
}
#method_after
public void writeStdOut(final String message) {
    pushResultProcessing.writeStdOut(message);
}
#end_block

#method_before
public void writeStdErr(final String message) {
    pushProcessing.writeStdErr(message);
}
#method_after
public void writeStdErr(final String message) {
    pushResultProcessing.writeStdErr(message);
}
#end_block

#method_before
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && queue.replicateAllOnPluginStart) {
        ReplicationState state = new ReplicationState(ReplicationType.START_UP);
        pushAllFuture.set(pushAll.create(null, state).schedule(30, TimeUnit.SECONDS));
    }
}
#method_after
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && queue.replicateAllOnPluginStart) {
        ReplicationState state = new ReplicationState(ReplicationType.STARTUP);
        pushAllFuture.set(pushAll.create(null, state).schedule(30, TimeUnit.SECONDS));
    }
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(this, ReplicationType.COMMAND);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.allTaskScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                log.warn("Thread is interrupted while waiting for PushAll operation to finish", e);
            } catch (ExecutionException e) {
                log.warn("An excetion is thrown in PushAll operation", e);
            }
        }
        if (state.hasPushTask()) {
            state.waitForReplication();
        } else {
            writeStdOutSync("All things is up-to-date, no need to replicate!");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(ReplicationType.COMMAND, this);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.markAllPushTasksScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                wrappedLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
public void writeStdOutSync(final String message) {
    synchronized (stdout) {
        stdout.println(message);
        stdout.flush();
    }
}
#method_after
public void writeStdOutSync(final String message) {
    if (wait) {
        synchronized (stdout) {
            stdout.println(message);
            stdout.flush();
        }
    }
}
#end_block

#method_before
public void writeStdErrSync(final String message) {
    synchronized (stderr) {
        stderr.println(message);
        stderr.flush();
    }
}
#method_after
public void writeStdErrSync(final String message) {
    if (wait) {
        synchronized (stderr) {
            stderr.println(message);
            stderr.flush();
        }
    }
}
#end_block

#method_before
static String replaceName(String in, String name) {
    String key = "${name}";
    int n = in.indexOf(key);
    if (0 <= n) {
        return in.substring(0, n) + name + in.substring(n + key.length());
    }
    return null;
}
#method_after
static String replaceName(String in, String name, boolean keyIsOptional) {
    String key = "${name}";
    int n = in.indexOf(key);
    if (0 <= n) {
        return in.substring(0, n) + name + in.substring(n + key.length());
    }
    if (keyIsOptional) {
        return in;
    }
    return null;
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri, state);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs) {
            if (cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.allTaskScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs) {
            if (cfg.wouldPushProject(project) && cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
        } catch (NoRemoteRepositoryException e) {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        } catch (NotSupportedException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (RuntimeException e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } catch (Error e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
        } catch (RemoteRepositoryException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        } catch (NotSupportedException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
        } catch (RuntimeException e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } catch (Error e) {
            wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable.Section();
    incoming = new ChangeTable.Section();
    closed = new ChangeTable.Section();
    outgoing.setTitleWidget(new InlineHyperlink(Util.C.outgoingReviews(), PageLinks.toChangeQuery("is:open owner:self")));
    incoming.setTitleWidget(new InlineHyperlink(Util.C.incomingReviews(), PageLinks.toChangeQuery("is:open reviewer:self -owner:self")));
    incoming.setHighlightUnreviewed(mine);
    closed.setTitleWidget(new InlineHyperlink(Util.C.recentlyClosed(), PageLinks.toChangeQuery("is:closed (owner:self OR reviewer:self)")));
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new ChangeTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    table.addStyleName(Gerrit.RESOURCES.css().accountDashboard());
    outgoing = new ChangeTable.Section();
    incoming = new ChangeTable.Section();
    closed = new ChangeTable.Section();
    String who = mine ? "self" : ownerId.toString();
    outgoing.setTitleWidget(new InlineHyperlink(Util.C.outgoingReviews(), PageLinks.toChangeQuery(queryOutGoing(who))));
    incoming.setTitleWidget(new InlineHyperlink(Util.C.incomingReviews(), PageLinks.toChangeQuery(queryInComing(who))));
    incoming.setHighlightUnreviewed(mine);
    closed.setTitleWidget(new InlineHyperlink(Util.C.recentlyClosed(), PageLinks.toChangeQuery(queryClosed(who))));
    table.addSection(outgoing);
    table.addSection(incoming);
    table.addSection(closed);
    add(table);
    table.setSavePointerId("owner:" + ownerId);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    String who = mine ? "self" : ownerId.toString();
    ChangeList.query(new ScreenLoadCallback<JsArray<ChangeList>>(this) {

        @Override
        protected void preDisplay(JsArray<ChangeList> result) {
            display(result);
        }
    }, mine ? EnumSet.of(ListChangesOption.REVIEWED) : EnumSet.noneOf(ListChangesOption.class), "is:open owner:" + who, "is:open reviewer:" + who + " -owner:" + who, "is:closed (owner:" + who + " OR reviewer:" + who + ") -age:4w limit:10");
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    String who = mine ? "self" : ownerId.toString();
    ChangeList.query(new ScreenLoadCallback<JsArray<ChangeList>>(this) {

        @Override
        protected void preDisplay(JsArray<ChangeList> result) {
            display(result);
        }
    }, mine ? EnumSet.of(ListChangesOption.REVIEWED) : EnumSet.noneOf(ListChangesOption.class), queryOutGoing(who), queryInComing(who), queryClosed(who) + " -age:4w limit:10");
}
#end_block

#method_before
static void call(final Button b, final Change.Id id, final String revision, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new TextAreaActionDialog(Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            b.setEnabled(true);
        }
    }.center();
}
#method_after
static void call(final Button b, final Change.Id id, final String revision, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new TextAreaActionDialog(Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            super.onClose(event);
            b.setEnabled(true);
        }
    }.center();
}
#end_block

#method_before
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#method_after
public void update() throws SubmoduleException {
    try {
        schema = schemaFactory.open();
        updateSubmoduleSubscriptions();
        updateSuperProjects(destBranch, rw, mergeTip.getId().toObjectId(), null);
    } catch (OrmException | IOException e) {
        throw new SubmoduleException("Cannot open database", e);
    } finally {
        if (schema != null) {
            schema.close();
            schema = null;
        }
    }
}
#end_block

#method_before
private void updateSubmoduleSubscriptions() throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try {
        final TreeWalk tw = TreeWalk.forPath(db, GIT_MODULES, mergeTip.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, db, mergeTip, GIT_MODULES);
            final String thisServer = new URI(urlProvider.get()).getHost();
            final Branch.NameKey target = new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get());
            final Set<SubmoduleSubscription> oldSubscriptions = new HashSet<>(schema.submoduleSubscriptions().bySuperProject(destBranch).toList());
            final List<SubmoduleSubscription> newSubscriptions = new SubmoduleSectionParser(bbc, thisServer, target, repoManager).parseAllSections();
            final Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
            for (SubmoduleSubscription s : newSubscriptions) {
                if (oldSubscriptions.contains(s)) {
                    alreadySubscribeds.add(s);
                }
            }
            oldSubscriptions.removeAll(newSubscriptions);
            newSubscriptions.removeAll(alreadySubscribeds);
            if (!oldSubscriptions.isEmpty()) {
                schema.submoduleSubscriptions().delete(oldSubscriptions);
            }
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#method_after
private void updateSubmoduleSubscriptions() throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try {
        final TreeWalk tw = TreeWalk.forPath(db, GIT_MODULES, mergeTip.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, db, mergeTip, GIT_MODULES);
            final String thisServer = new URI(urlProvider.get()).getHost();
            final Branch.NameKey target = new Branch.NameKey(new Project.NameKey(destProject.getName()), destBranch.get());
            final Set<SubmoduleSubscription> oldSubscriptions = new HashSet<>(schema.submoduleSubscriptions().bySuperProject(destBranch).toList());
            List<SubmoduleSubscription> newSubscriptions = subSecParserFactory.create(bbc, thisServer, target).parseAllSections();
            final Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
            for (SubmoduleSubscription s : newSubscriptions) {
                if (oldSubscriptions.contains(s)) {
                    alreadySubscribeds.add(s);
                }
            }
            oldSubscriptions.removeAll(newSubscriptions);
            newSubscriptions.removeAll(alreadySubscribeds);
            if (!oldSubscriptions.isEmpty()) {
                schema.submoduleSubscriptions().delete(oldSubscriptions);
            }
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#end_block

#method_before
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        try {
                            sb.append("\n").append(c.getFullMessage());
                        } catch (NullPointerException e) {
                            sb.append("\n").append("NPE");
                        }
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
private void updateSuperProjects(final Branch.NameKey updatedBranch, RevWalk myRw, final ObjectId mergedCommit, final String msg) throws SubmoduleException, IOException {
    try {
        final List<SubmoduleSubscription> subscribers = schema.submoduleSubscriptions().bySubmodule(updatedBranch).toList();
        if (!subscribers.isEmpty()) {
            // Initialize the message buffer
            StringBuilder sb = new StringBuilder();
            if (msg != null) {
                sb.append(msg);
            } else {
                // The first updatedBranch on a cascade event of automatic
                // updates of repos is added to updatedSubscribers set so
                // if we face a situation having
                // submodule-a(master)-->super(master)-->submodule-a(master),
                // it will be detected we have a circular subscription
                // when updateSuperProjects is called having as updatedBranch
                // the super(master) value.
                updatedSubscribers.add(updatedBranch);
                for (final Change chg : submitted) {
                    final CodeReviewCommit c = commits.get(chg.getId());
                    if (c != null && (c.getStatusCode() == CommitMergeStatus.CLEAN_MERGE || c.getStatusCode() == CommitMergeStatus.CLEAN_PICK || c.getStatusCode() == CommitMergeStatus.CLEAN_REBASE)) {
                        myRw.parseBody(c);
                        sb.append("\n").append(c.getFullMessage());
                    }
                }
            }
            // update subscribers of this module
            List<SubmoduleSubscription> incorrectSubscriptions = Lists.newLinkedList();
            for (final SubmoduleSubscription s : subscribers) {
                try {
                    if (!updatedSubscribers.add(s.getSuperProject())) {
                        log.error("Possible circular subscription involving " + s);
                    } else {
                        Map<Branch.NameKey, ObjectId> modules = new HashMap<>(1);
                        modules.put(updatedBranch, mergedCommit);
                        Map<Branch.NameKey, String> paths = new HashMap<>(1);
                        paths.put(updatedBranch, s.getPath());
                        updateGitlinks(s.getSuperProject(), myRw, modules, paths, sb.toString());
                    }
                } catch (SubmoduleException e) {
                    log.warn("Cannot update gitlinks for " + s + " due to " + e.getMessage());
                    incorrectSubscriptions.add(s);
                } catch (Exception e) {
                    log.error("Cannot update gitlinks for " + s, e);
                }
            }
            if (!incorrectSubscriptions.isEmpty()) {
                try {
                    schema.submoduleSubscriptions().delete(incorrectSubscriptions);
                    log.info("Deleted incorrect submodule subscription(s) " + incorrectSubscriptions);
                } catch (OrmException e) {
                    log.error("Cannot delete submodule subscription(s) " + incorrectSubscriptions, e);
                }
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated " + subscriber.getParentKey().get());
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.release();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(final Branch.NameKey subscriber, RevWalk myRw, final Map<Branch.NameKey, ObjectId> modules, final Map<Branch.NameKey, String> paths, final String msg) throws SubmoduleException {
    PersonIdent author = null;
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append("Updated ").append(subscriber.getParentKey().get()).append('\n');
    Repository pdb = null;
    RevWalk recRw = null;
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            RevCommit c = myRw.parseCommit(me.getValue());
            if (c == null) {
                continue;
            }
            msgbuf.append("\nProject: ");
            msgbuf.append(me.getKey().getParentKey().get());
            msgbuf.append("  ").append(me.getValue().getName());
            msgbuf.append("\n");
            if (modules.size() == 1) {
                if (!Strings.isNullOrEmpty(msg)) {
                    msgbuf.append(msg);
                } else {
                    msgbuf.append("\n");
                    msgbuf.append(c.getFullMessage());
                }
            } else {
                msgbuf.append(c.getShortMessage());
            }
            msgbuf.append("\n");
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<Branch.NameKey, ObjectId> me : modules.entrySet()) {
            ed.add(new PathEdit(paths.get(me.getKey())) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ent.setObjectId(me.getValue().copy());
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(subscriber, recRw, commitId, msgbuf.toString());
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final RevWalk rw = new RevWalk(pdb);
    try {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    } finally {
        rw.release();
    }
}
#method_after
private static DirCache readTree(final Repository pdb, final Ref branch) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    try (RevWalk rw = new RevWalk(pdb)) {
        final DirCache dc = DirCache.newInCore();
        final DirCacheBuilder b = dc.builder();
        // no prefix path
        b.addTree(// no prefix path
        new byte[0], // standard stage
        DirCacheEntry.STAGE_0, pdb.newObjectReader(), rw.parseTree(branch.getObjectId()));
        b.finish();
        return dc;
    }
}
#end_block

#method_before
private static Predicate<ChangeData> topic(String topic) {
    return new TopicPredicate(schema(args.indexes), topic);
}
#method_after
private Predicate<ChangeData> topic(String topic) {
    return new TopicPredicate(schema(indexes), topic);
}
#end_block

#method_before
@Override
protected void run() throws OrmException, IOException, UnloggedFailure, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException {
    ImportProject.Input input = new ImportProject.Input();
    input.from = url;
    input.name = name;
    input.user = user;
    input.pass = readPassword();
    if (!Strings.isNullOrEmpty(parent)) {
        input.parent = parent;
    }
    try {
        ImportProject importer = importProjectFactory.create(new Project.NameKey(project));
        if (!quiet) {
            importer.setErr(stderr);
        }
        ImportStatistic stats = importer.apply(new ConfigResource(), input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#method_after
@Override
protected void run() throws OrmException, IOException, UnloggedFailure, ValidationException, GitAPIException, NoSuchChangeException, NoSuchAccountException {
    ImportProject.Input input = new ImportProject.Input();
    input.from = url;
    input.name = name;
    input.user = user;
    input.pass = PasswordUtil.readPassword(in, pass);
    if (!Strings.isNullOrEmpty(parent)) {
        input.parent = parent;
    }
    try {
        ImportProject importer = importProjectFactory.create(new Project.NameKey(project));
        if (!quiet) {
            importer.setErr(stderr);
        }
        ImportStatistic stats = importer.apply(new ConfigResource(), input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ImportProjectResource rsrc = projects.parse(project);
        if (!quiet) {
            resume.setErr(stderr);
        }
        ResumeProjectImport.Input input = new ResumeProjectImport.Input();
        input.user = user;
        input.pass = readPassword();
        input.force = force;
        ResumeImportStatistic stats = resume.apply(rsrc, input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
        stdout.print("Updated Changes: " + stats.numChangesUpdated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ImportProjectResource rsrc = projects.parse(project);
        if (!quiet) {
            resume.setErr(stderr);
        }
        ResumeProjectImport.Input input = new ResumeProjectImport.Input();
        input.user = user;
        input.pass = PasswordUtil.readPassword(in, pass);
        input.force = force;
        ResumeImportStatistic stats = resume.apply(rsrc, input);
        stdout.print("Created Changes: " + stats.numChangesCreated + "\n");
        stdout.print("Updated Changes: " + stats.numChangesUpdated + "\n");
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
private RevWalk verifyConnected(final Repository repo, final ObjectId revid) throws InvalidRevisionException {
    try {
        final ObjectWalk rw = new ObjectWalk(repo);
        try {
            rw.markStart(rw.parseCommit(revid));
        } catch (IncorrectObjectTypeException err) {
            throw new InvalidRevisionException();
        }
        RefDatabase refDb = repo.getRefDatabase();
        for (Ref r : Iterables.concat(refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values())) {
            try {
                rw.markUninteresting(rw.parseAny(r.getObjectId()));
            } catch (MissingObjectException err) {
                continue;
            }
        }
        rw.checkConnectivity();
        return rw;
    } catch (IncorrectObjectTypeException err) {
        throw new InvalidRevisionException();
    } catch (MissingObjectException err) {
        throw new InvalidRevisionException();
    } catch (IOException err) {
        log.error("Repository \"" + repo.getDirectory() + "\" may be corrupt; suggest running git fsck", err);
        throw new InvalidRevisionException();
    }
}
#method_after
private RevWalk verifyConnected(final Repository repo, final ObjectId revid) throws InvalidRevisionException {
    try {
        final ObjectWalk rw = new ObjectWalk(repo);
        try {
            rw.markStart(rw.parseCommit(revid));
        } catch (IncorrectObjectTypeException err) {
            throw new InvalidRevisionException();
        }
        RefDatabase refDb = repo.getRefDatabase();
        Iterable<Ref> refs = Iterables.concat(refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values());
        Ref rc = refDb.getRef(RefNames.REFS_CONFIG);
        if (rc != null) {
            refs = Iterables.concat(refs, Collections.singleton(rc));
        }
        for (Ref r : refs) {
            try {
                rw.markUninteresting(rw.parseAny(r.getObjectId()));
            } catch (MissingObjectException err) {
                continue;
            }
        }
        rw.checkConnectivity();
        return rw;
    } catch (IncorrectObjectTypeException err) {
        throw new InvalidRevisionException();
    } catch (MissingObjectException err) {
        throw new InvalidRevisionException();
    } catch (IOException err) {
        log.error("Repository \"" + repo.getDirectory() + "\" may be corrupt; suggest running git fsck", err);
        throw new InvalidRevisionException();
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
    boolean link = req.getParameter("link") != null;
    String id = Strings.nullToEmpty(req.getParameter("id")).trim();
    if (id.isEmpty()) {
        sendForm(req, res, link, null);
        return;
    }
    if (!id.startsWith("http://") && !id.startsWith("https://")) {
        id = "http://" + id;
    }
    if ((ssoUrl != null && !ssoUrl.equals(id)) || !impl.isAllowedOpenID(id)) {
        sendForm(req, res, link, "OpenID provider not permitted by site policy.");
        return;
    }
    boolean remember = "1".equals(req.getParameter("rememberme"));
    String token = LoginUrlToken.getToken(req);
    SignInMode mode;
    if (link) {
        mode = SignInMode.LINK_IDENTIY;
    } else if (PageLinks.REGISTER.equals(token)) {
        mode = SignInMode.REGISTER;
        token = PageLinks.MINE;
    } else {
        mode = SignInMode.SIGN_IN;
    }
    OAuthServiceProvider oauthProvider = lookupOAuthServiceProvider(id);
    if (oauthProvider == null) {
        discover(req, res, link, id, remember, token, mode);
    } else {
        OAuthSessionOverOpenID oauthSession = oauthSessionProvider.get();
        if ((isGerritLogin(req) || oauthSession.isOAuthFinal(req)) && !oauthSession.isLoggedIn()) {
            oauthSession.setServiceProvider(oauthProvider);
            oauthSession.login(req, res, oauthProvider);
        }
    }
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException {
    boolean link = req.getParameter("link") != null;
    String id = Strings.nullToEmpty(req.getParameter("id")).trim();
    if (id.isEmpty()) {
        sendForm(req, res, link, null);
        return;
    }
    if (!id.startsWith("http://") && !id.startsWith("https://")) {
        id = "http://" + id;
    }
    if ((ssoUrl != null && !ssoUrl.equals(id)) || !impl.isAllowedOpenID(id)) {
        sendForm(req, res, link, "OpenID provider not permitted by site policy.");
        return;
    }
    boolean remember = "1".equals(req.getParameter("rememberme"));
    String token = LoginUrlToken.getToken(req);
    SignInMode mode;
    if (link) {
        mode = SignInMode.LINK_IDENTIY;
    } else if (PageLinks.REGISTER.equals(token)) {
        mode = SignInMode.REGISTER;
        token = PageLinks.MINE;
    } else {
        mode = SignInMode.SIGN_IN;
    }
    OAuthServiceProvider oauthProvider = lookupOAuthServiceProvider(id);
    if (oauthProvider == null) {
        discover(req, res, link, id, remember, token, mode);
    } else {
        OAuthSessionOverOpenID oauthSession = oauthSessionProvider.get();
        if (!currentUserProvider.get().isIdentifiedUser() && oauthSession.isLoggedIn()) {
            oauthSession.logout();
        }
        if ((isGerritLogin(req) || oauthSession.isOAuthFinal(req)) && !oauthSession.isLoggedIn()) {
            oauthSession.setServiceProvider(oauthProvider);
            oauthSession.login(req, res, oauthProvider);
        }
    }
}
#end_block

#method_before
private void pickSSOServiceProvider() throws ServletException {
    SortedSet<String> plugins = oauthServiceProviders.plugins();
    if (plugins.isEmpty()) {
        throw new ServletException("OAuth service provider wasn't installed");
    }
    if (plugins.size() == 1) {
        SortedMap<String, Provider<OAuthServiceProvider>> services = oauthServiceProviders.byPlugin(Iterables.getOnlyElement(plugins));
        if (services.size() == 1) {
            ssoProvider = Iterables.getOnlyElement(services.values()).get();
        }
    }
}
#method_after
private void pickSSOServiceProvider() throws ServletException {
    SortedSet<String> plugins = oauthServiceProviders.plugins();
    if (plugins.size() == 1) {
        SortedMap<String, Provider<OAuthServiceProvider>> services = oauthServiceProviders.byPlugin(Iterables.getOnlyElement(plugins));
        if (services.size() == 1) {
            ssoProvider = Iterables.getOnlyElement(services.values()).get();
        }
    }
}
#end_block

#method_before
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(null, new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectUrl = request.getRequestURI();
        response.sendRedirect(oauth.getAuthorizationUrl(null) + "&state=" + state);
        return false;
    }
}
#method_after
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(request, response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectToken = LoginUrlToken.getToken(request);
        response.sendRedirect(oauth.getAuthorizationUrl() + "&state=" + state);
        return false;
    }
}
#end_block

#method_before
private void authenticateAndRedirect(HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                // Both link to the same account, that's what we expected.
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // 
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    String suffix = redirectUrl.substring(GERRIT_LOGIN.length() + 1);
    suffix = URLDecoder.decode(suffix, StandardCharsets.UTF_8.name());
    rsp.sendRedirect(suffix);
}
#method_after
private void authenticateAndRedirect(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    com.google.gerrit.server.account.AuthRequest areq = new com.google.gerrit.server.account.AuthRequest(user.getExternalId());
    AuthResult arsp = null;
    try {
        String claimedIdentifier = user.getClaimedIdentity();
        Account.Id actualId = accountManager.lookup(user.getExternalId());
        if (!Strings.isNullOrEmpty(claimedIdentifier)) {
            Account.Id claimedId = accountManager.lookup(claimedIdentifier);
            if (claimedId != null && actualId != null) {
                if (claimedId.equals(actualId)) {
                // Both link to the same account, that's what we expected.
                } else {
                    // This is (for now) a fatal error. There are two records
                    // for what might be the same user.
                    // 
                    log.error("OAuth accounts disagree over user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier + "\n" + "  Delgate ID: " + actualId + " is " + user.getExternalId());
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            } else if (claimedId != null && actualId == null) {
                // 
                try {
                    accountManager.link(claimedId, areq);
                } catch (OrmException e) {
                    log.error("Cannot link: " + user.getExternalId() + " to user identity:\n" + "  Claimed ID: " + claimedId + " is " + claimedIdentifier);
                    rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
                    return;
                }
            }
        }
        areq.setUserName(user.getUserName());
        areq.setEmailAddress(user.getEmailAddress());
        areq.setDisplayName(user.getDisplayName());
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    webSession.get().login(arsp, true);
    StringBuilder rdr = new StringBuilder(urlProvider.get(req));
    rdr.append(Url.decode(redirectToken));
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
void logout() {
    token = null;
    user = null;
    redirectUrl = null;
    serviceProvider = null;
}
#method_after
void logout() {
    token = null;
    user = null;
    redirectToken = null;
    serviceProvider = null;
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        String msg;
        if (rule == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (rule != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new StringReader(rule));
        }
    } catch (CompileException err) {
        String msg;
        if (rule == null && control.getProjectControl().isOwner()) {
            msg = String.format("Cannot load rules.pl for %s: %s", getProjectName(), err.getMessage());
        } else if (rule != null) {
            msg = err.getMessage();
        } else {
            msg = String.format("Cannot load rules.pl for %s", getProjectName());
        }
        throw new RuleEvalException(msg, err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(request, response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectToken = request.getRequestURI();
        // We are here in content of filter.
        // Due to this Jetty bug:
        // https://bz.apache.org/bugzilla/show_bug.cgi?id=28323
        // we cannot use LoginUrlToken.getToken() method,
        // because it relies on getPathInfo() and it is always null here.
        redirectToken = redirectToken.substring(request.getContextPath().length());
        response.sendRedirect(oauth.getAuthorizationUrl() + "&state=" + state);
        return false;
    }
}
#method_after
boolean login(HttpServletRequest request, HttpServletResponse response, OAuthServiceProvider oauth) throws IOException {
    if (isLoggedIn()) {
        return true;
    }
    log.debug("Login " + this);
    if (isOAuthFinal(request)) {
        if (!checkState(request)) {
            response.sendError(HttpServletResponse.SC_NOT_FOUND);
            return false;
        }
        log.debug("Login-Retrieve-User " + this);
        token = oauth.getAccessToken(new OAuthVerifier(request.getParameter("code")));
        user = oauth.getUserInfo(token);
        if (isLoggedIn()) {
            log.debug("Login-SUCCESS " + this);
            authenticateAndRedirect(request, response);
            return true;
        } else {
            response.sendError(SC_UNAUTHORIZED);
            return false;
        }
    } else {
        log.debug("Login-PHASE1 " + this);
        redirectToken = request.getRequestURI();
        // We are here in content of filter.
        // Due to this Jetty limitation:
        // https://bz.apache.org/bugzilla/show_bug.cgi?id=28323
        // we cannot use LoginUrlToken.getToken() method,
        // because it relies on getPathInfo() and it is always null here.
        redirectToken = redirectToken.substring(request.getContextPath().length());
        response.sendRedirect(oauth.getAuthorizationUrl() + "&state=" + state);
        return false;
    }
}
#end_block

#method_before
public TestAccount get(String username) {
    TestAccount account = accounts.get(username);
    checkArgument(account != null, "No TestAccount created for %s", username);
    return account;
}
#method_after
public TestAccount get(String username) {
    return checkNotNull(accounts.get(username), "No TestAccount created for %s", username);
}
#end_block

#method_before
@Override
public Boolean load(EntryKey key) throws NoSuchProjectException, MergeException, IOException {
    checkArgument(key.load != null, "Key cannot be loaded: %s", key);
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try {
        RefDatabase refDatabase = key.load.repo.getRefDatabase();
        Map<String, Ref> heads = refDatabase.getRefs(Constants.R_HEADS);
        Map<String, Ref> tags = refDatabase.getRefs(Constants.R_TAGS);
        RevWalk rw = CodeReviewCommit.newRevWalk(key.load.repo);
        try {
            RevFlag canMerge = rw.newFlag("CAN_MERGE");
            CodeReviewCommit rev = parse(rw, key.commit);
            rev.add(canMerge);
            CodeReviewCommit tip = parse(rw, key.into);
            Set<RevCommit> accepted = alreadyAccepted(rw, heads.values(), tags.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            return submitStrategyFactory.create(key.submitType, key.load.db, key.load.repo, rw, null, /*inserter*/
            canMerge, accepted, key.load.dest).dryRun(tip, rev);
        } finally {
            rw.release();
        }
    } finally {
        key.load = null;
    }
}
#method_after
@Override
public Boolean load(EntryKey key) throws NoSuchProjectException, MergeException, IOException {
    checkArgument(key.load != null, "Key cannot be loaded: %s", key);
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try {
        RefDatabase refDatabase = key.load.repo.getRefDatabase();
        Iterable<Ref> refs = Iterables.concat(refDatabase.getRefs(Constants.R_HEADS).values(), refDatabase.getRefs(Constants.R_TAGS).values());
        try (RevWalk rw = CodeReviewCommit.newRevWalk(key.load.repo)) {
            RevFlag canMerge = rw.newFlag("CAN_MERGE");
            CodeReviewCommit rev = parse(rw, key.commit);
            rev.add(canMerge);
            CodeReviewCommit tip = parse(rw, key.into);
            Set<RevCommit> accepted = alreadyAccepted(rw, refs);
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            return submitStrategyFactory.create(key.submitType, key.load.db, key.load.repo, rw, null, /*inserter*/
            canMerge, accepted, key.load.dest).dryRun(tip, rev);
        }
    } finally {
        key.load = null;
    }
}
#end_block

#method_before
private static Set<RevCommit> alreadyAccepted(RevWalk rw, Collection<Ref> heads, Collection<Ref> tags) throws MissingObjectException, IOException {
    Set<RevCommit> accepted = Sets.newHashSet();
    addAlreadyAccepted(rw, heads, accepted);
    addAlreadyAccepted(rw, tags, accepted);
    return accepted;
}
#method_after
private static Set<RevCommit> alreadyAccepted(RevWalk rw, Iterable<Ref> refs) throws MissingObjectException, IOException {
    Set<RevCommit> accepted = Sets.newHashSet();
    for (Ref r : refs) {
        try {
            accepted.add(rw.parseCommit(r.getObjectId()));
        } catch (IncorrectObjectTypeException nonCommit) {
        // Not a commit? Skip over it.
        }
    }
    return accepted;
}
#end_block

#method_before
@Override
public boolean getIfPresent(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy) {
    return cache.getIfPresent(new EntryKey(commit, toId(intoRef), submitType, mergeStrategy));
}
#method_after
@Override
public Boolean getIfPresent(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy) {
    return cache.getIfPresent(new EntryKey(commit, toId(intoRef), submitType, mergeStrategy));
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // so we do it here instead of in renderRevisionInfo.
    if (!info.status().isOpen() || !revision.equals(info.current_revision()) || info.revision(revision).is_edit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.current_revision()) || info.revision(revision).is_edit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
}
#end_block

#method_before
@Override
public void start() {
    try {
        ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(path);
        ds.setUsername(username);
        ds.setPassword(password);
        Connection conn = ds.getConnection();
        StringBuilder query = new StringBuilder();
        query.append(format("CREATE TABLE IF NOT EXISTS %s(", TABLE_NAME));
        if (ds.getDriverClassName().contains("postgresql")) {
            query.append(format("%s SERIAL PRIMARY KEY,", PRIMARY_ENTRY));
        } else {
            query.append(format("%s INT AUTO_INCREMENT PRIMARY KEY,", PRIMARY_ENTRY));
        }
        query.append(format("%s VARCHAR(255),", PROJECT_ENTRY));
        query.append(format("%s TIMESTAMP DEFAULT NOW(),", DATE_ENTRY));
        query.append(format("%s TEXT)", EVENT_ENTRY));
        Statement stat = conn.createStatement();
        try {
            stat.execute(query.toString());
        } finally {
            closeStatement(stat);
            closeConnection(conn);
        }
    } catch (SQLException e) {
        throw new RuntimeException("Cannot start the database", e);
    }
    removeOldEntries();
}
#method_after
@Override
public void start() {
    try {
        sqlClient.createDBIfNotCreated();
    } catch (SQLException e) {
        throw new RuntimeException("Cannot start the database", e);
    }
    removeOldEvents();
}
#end_block

#method_before
@Override
public void stop() {
    try {
        ds.close();
    } catch (SQLException e) {
        throw new RuntimeException("Cannot close datasource ", e);
    }
}
#method_after
@Override
public void stop() {
    try {
        sqlClient.close();
    } catch (SQLException e) {
        throw new RuntimeException("Cannot close datasource ", e);
    }
}
#end_block

#method_before
@Override
public List<String> queryChangeEvents(String query) throws MalformedQueryException {
    List<String> events = new ArrayList<>();
    Connection conn = null;
    Statement stat = null;
    ResultSet rs = null;
    try {
        conn = ds.getConnection();
        stat = conn.createStatement();
        try {
            Project.NameKey project = null;
            rs = stat.executeQuery(query);
            while (rs.next()) {
                try {
                    project = new Project.NameKey(rs.getString(PROJECT_ENTRY));
                    if (projectControlFactory.controlFor(project, userProvider.get()).isVisible()) {
                        events.add(rs.getString(EVENT_ENTRY));
                    }
                } catch (NoSuchProjectException e) {
                    log.warn("Database contains a non-existing project, " + project.get() + ", removing project from database", e);
                    removeProjectEntries(project.get());
                } catch (IOException e) {
                    log.warn("Cannot get project visibility info for " + project.get() + " from cache", e);
                }
            }
        } catch (SQLException e) {
            throw new MalformedQueryException(e);
        }
    } catch (SQLException e) {
        throw new RuntimeException("Cannot query database", e);
    } finally {
        closeResultSet(rs);
        closeStatement(stat);
        closeConnection(conn);
    }
    return events;
}
#method_after
@Override
public List<String> queryChangeEvents(String query) throws MalformedQueryException {
    List<String> events = new ArrayList<>();
    Project.NameKey project = null;
    for (Entry<String, Collection<String>> entry : sqlClient.getEvents(query).asMap().entrySet()) {
        try {
            project = new Project.NameKey(entry.getKey());
            if (projectControlFactory.controlFor(project, userProvider.get()).isVisible()) {
                events.addAll(entry.getValue());
            }
        } catch (NoSuchProjectException e) {
            log.warn("Database contains a non-existing project, " + project.get() + ", removing project from database", e);
            removeProjectEvents(project.get());
        } catch (IOException e) {
            log.warn("Cannot get project visibility info for " + project.get() + " from cache", e);
        }
    }
    return events;
}
#end_block

#method_before
@Override
public void storeEvent(ProjectEvent event) {
    Project.NameKey projectName = event.getProjectNameKey();
    if (projectName == null) {
        return;
    }
    String json = gson.toJson(event);
    int failedConnections = 0;
    boolean done = false;
    while (!done) {
        try {
            Connection conn = ds.getConnection();
            Statement stat = conn.createStatement();
            try {
                stat.execute(format("INSERT INTO %s(%s, %s, %s) ", TABLE_NAME, PROJECT_ENTRY, DATE_ENTRY, EVENT_ENTRY) + format("VALUES('%s', '%s', '%s')", projectName.get(), new Timestamp(event.eventCreatedOn * 1000L), json));
                done = true;
            } finally {
                closeStatement(stat);
                closeConnection(conn);
            }
        } catch (SQLException e) {
            log.warn("Cannot store ChangeEvent for: " + projectName.get() + "\n" + e.toString());
            if (e.getCause() instanceof ConnectException || e.toString().contains("terminating connection")) {
                if (failedConnections < maxTries) {
                    failedConnections++;
                    log.info("Retrying store event");
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException e1) {
                        continue;
                    }
                } else {
                    log.error("Failed to store event " + maxTries + " times");
                    done = true;
                }
            } else {
                done = true;
            }
        }
    }
}
#method_after
@Override
public void storeEvent(ProjectEvent event) {
    Project.NameKey projectName = event.getProjectNameKey();
    if (projectName == null) {
        return;
    }
    int failedConnections = 0;
    boolean done = false;
    while (!done) {
        done = true;
        try {
            sqlClient.storeEvent(event);
        } catch (SQLException e) {
            log.warn("Cannot store ChangeEvent for: " + projectName.get(), e);
            if (e.getCause() instanceof ConnectException || e.getMessage().contains("terminating connection")) {
                if (maxTries == 0) {
                } else if (failedConnections < maxTries - 1) {
                    failedConnections++;
                    done = false;
                    log.info("Retrying store event");
                    try {
                        Thread.sleep(waitTime);
                    } catch (InterruptedException e1) {
                        continue;
                    }
                } else {
                    log.error("Failed to store event " + maxTries + " times");
                }
            }
        }
    }
}
#end_block

#method_before
@Option(name = "--limit", aliases = { "-n" }, metaVar = "CNT", usage = "maximum number of reviewers to list")
public void setLimit(int l) {
    this.limit = l <= 0 ? MAX : Math.min(l, MAX);
}
#method_after
@Option(name = "--limit", aliases = { "-n" }, metaVar = "CNT", usage = "maximum number of reviewers to list")
public void setLimit(int l) {
    this.limit = l <= 0 ? maxSuggestedReviewers : Math.min(l, maxSuggestedReviewers);
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        reviewer.add(new SuggestedReviewerInfo(a));
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            reviewer.add(new SuggestedReviewerInfo(info));
        }
    }
    Collections.sort(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        reviewer.add(new SuggestedReviewerInfo(a));
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            reviewer.add(new SuggestedReviewerInfo(info));
        }
    }
    Collections.sort(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#end_block

#method_before
private String getSortValue() {
    return account != null ? Objects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
}
#method_after
private String getSortValue() {
    return account != null ? MoreObjects.firstNonNull(account.email, Strings.nullToEmpty(account.name)) : Strings.nullToEmpty(group.name);
}
#end_block

#method_before
@Override
public PatchList load(final PatchListKey key) throws Exception {
    final Repository repo = repoManager.openRepository(key.projectKey);
    try {
        return readPatchList(key, repo);
    } finally {
        repo.close();
    }
}
#method_after
@Override
public PatchList load(final PatchListKey key) throws IOException, PatchListNotAvailableException {
    final Repository repo = repoManager.openRepository(key.projectKey);
    try {
        return readPatchList(key, repo);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws Exception {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    final ObjectReader reader = repo.newObjectReader();
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, repo, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = key.getOldId() != null ? FluentIterable.from(patchListCache.get(new PatchListKey(key.projectKey, null, key.getNewId(), key.getWhitespace())).getPatches()).transform(new Function<PatchListEntry, String>() {

            @Override
            public String apply(PatchListEntry entry) {
                return entry.getNewName();
            }
        }).toSet() : null;
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(// 
        cmp, // 
        repo, // 
        reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                entries.add(newEntry(aTree, fh));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    } finally {
        reader.release();
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    final ObjectReader reader = repo.newObjectReader();
    try {
        final RevWalk rw = new RevWalk(reader);
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, repo, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = key.getOldId() != null ? FluentIterable.from(patchListCache.get(new PatchListKey(key.projectKey, null, key.getNewId(), key.getWhitespace())).getPatches()).transform(new Function<PatchListEntry, String>() {

            @Override
            public String apply(PatchListEntry entry) {
                return entry.getNewName();
            }
        }).toSet() : null;
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(// 
        cmp, // 
        repo, // 
        reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                entries.add(newEntry(aTree, fh));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    } finally {
        reader.release();
    }
}
#end_block

#method_before
private FileHeader toFileHeader(PatchListKey key, DiffFormatter diffFormatter, DiffEntry diffEntry) throws Exception {
    DiffWorkerPool.Worker worker = workerPool.acquire();
    DiffWorkerPool.Worker.Result r;
    r = worker.toFileHeaderWithTimeout(key, diffFormatter, diffEntry, timeoutMillis);
    if (r == DiffWorkerPool.Worker.Result.TIMEOUT) {
        // Don't keep this thread. We have to murder it unsafely, which
        // means its unable to be reused in the future. Return a result produced
        // by HistogramDiff without the usage of MyersDiff.
        // 
        HistogramDiff histogramDiff = new HistogramDiff();
        histogramDiff.setFallbackAlgorithm(null);
        diffFormatter.setDiffAlgorithm(histogramDiff);
        return diffFormatter.toFileHeader(diffEntry);
    }
    workerPool.release(worker);
    if (r.error != null) {
        // 
        throw r.error;
    }
    return r.fileHeader;
}
#method_after
private FileHeader toFileHeader(PatchListKey key, final DiffFormatter diffFormatter, final DiffEntry diffEntry) throws IOException {
    Future<FileHeader> result = diffExecutor.submit(new Callable<FileHeader>() {

        @Override
        public FileHeader call() throws IOException {
            return diffFormatter.toFileHeader(diffEntry);
        }
    });
    try {
        return result.get(timeoutMillis, TimeUnit.MILLISECONDS);
    } catch (InterruptedException | TimeoutException e) {
        log.warn(timeoutMillis + " ms timeout reached for Diff loader" + " in project " + key.projectKey.get() + " on commit " + key.getNewId().name() + " on path " + diffEntry.getNewPath() + " comparing " + diffEntry.getOldId().name() + ".." + diffEntry.getNewId().name());
        result.cancel(true);
        return toFileHeaderWithoutMyersDiff(diffFormatter, diffEntry);
    } catch (ExecutionException e) {
        // If there was an error computing the result, carry it
        // up to the caller so the cache knows this key is invalid.
        Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
        throw new IOException(e.getMessage(), e.getCause());
    }
}
#end_block

#method_before
private static RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#method_after
private RevObject aFor(final PatchListKey key, final Repository repo, final RevWalk rw, final RevCommit b) throws IOException {
    if (key.getOldId() != null) {
        return rw.parseAny(key.getOldId());
    }
    switch(b.getParentCount()) {
        case 0:
            return rw.parseAny(emptyTree(repo));
        case 1:
            {
                RevCommit r = b.getParent(0);
                rw.parseBody(r);
                return r;
            }
        case 2:
            return automerge(repo, rw, b, mergeStrategy);
        default:
            // TODO(sop) handle an octopus merge.
            return null;
    }
}
#end_block

#method_before
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, boolean save) throws IOException {
    String hash = b.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ObjectId treeId;
    ResolveMerger m = (ResolveMerger) MergeStrategy.RESOLVE.newMerger(repo, true);
    final ObjectInserter ins = repo.newObjectInserter();
    try {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void release() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(b.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = b.getParent(0);
            RevCommit theirs = b.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                TemporaryBuffer buf = new TemporaryBuffer.LocalFile(10 * 1024 * 1024);
                try {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8");
                    buf.close();
                    InputStream in = buf.openInputStream();
                    try {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    } finally {
                        in.close();
                    }
                } finally {
                    buf.destroy();
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
    } finally {
        ins.release();
    }
    if (save) {
        RefUpdate update = repo.updateRef(refName);
        update.setNewObjectId(treeId);
        update.disableRefLog();
        update.forceUpdate();
    }
    return rw.parseTree(treeId);
}
#method_after
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy) throws IOException {
    return automerge(repo, rw, b, mergeStrategy, true);
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    for (ChangeMessage m : cd.messages()) {
        if (m.getAuthor().equals(id)) {
            return true;
        }
    }
    for (PatchLineComment c : cd.publishedComments()) {
        if (c.getAuthor().equals(id)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    for (ChangeMessage m : cd.messages()) {
        if (Objects.equals(m.getAuthor(), id)) {
            return true;
        }
    }
    for (PatchLineComment c : cd.publishedComments()) {
        if (Objects.equals(c.getAuthor(), id)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return val.hashCode();
}
#method_after
@Override
public int hashCode() {
    return System.identityHashCode(this);
}
#end_block

#method_before
private TreeSet<Entry<String, Path>> jarsFirstSortedPluginsSet(Map<String, Path> activePlugins) {
    final PathMatcher jarMatcher = FileSystems.getDefault().getPathMatcher("glob:*.jar");
    TreeSet<Entry<String, Path>> sortedPlugins = Sets.newTreeSet(new Comparator<Entry<String, Path>>() {

        @Override
        public int compare(Entry<String, Path> e1, Entry<String, Path> e2) {
            Path n1 = e1.getValue().getFileName();
            Path n2 = e2.getValue().getFileName();
            return ComparisonChain.start().compareTrueFirst(jarMatcher.matches(n1), jarMatcher.matches(n2)).compare(n1, n2).result();
        }
    });
    addAllEntries(activePlugins, sortedPlugins);
    return sortedPlugins;
}
#method_after
private TreeSet<Entry<String, Path>> jarsFirstSortedPluginsSet(Map<String, Path> activePlugins) {
    TreeSet<Entry<String, Path>> sortedPlugins = Sets.newTreeSet(new Comparator<Entry<String, Path>>() {

        @Override
        public int compare(Entry<String, Path> e1, Entry<String, Path> e2) {
            Path n1 = e1.getValue().getFileName();
            Path n2 = e2.getValue().getFileName();
            return ComparisonChain.start().compareTrueFirst(isJar(n1), isJar(n2)).compare(n1, n2).result();
        }

        private boolean isJar(Path n1) {
            return n1.toString().endsWith(".jar");
        }
    });
    addAllEntries(activePlugins, sortedPlugins);
    return sortedPlugins;
}
#end_block

#method_before
private void load(List<String> pluginUrls) {
    for (String url : pluginUrls) {
        Plugin plugin = Plugin.create(url);
        plugins().put(url, plugin);
        ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new LoadCallback(plugin)).inject();
    }
}
#method_after
public static void load(List<String> plugins, int loadTimeout, AsyncCallback<VoidResult> callback) {
    if (plugins == null || plugins.isEmpty()) {
        callback.onSuccess(VoidResult.create());
    } else {
        self = new PluginLoader(loadTimeout, callback);
        self.load(plugins);
        self.startTimers();
        self.center();
    }
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar(false);
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    CallbackGroup cbg = new CallbackGroup();
    if (isSignedIn()) {
        AccountApi.self().view("preferences").get(cbg.add(createMyMenuBarCallback()));
    }
    PluginLoader.load(hpd.plugins, cbg.addFinal(new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    }), hpd.pluginsLoadTimeout);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar(false);
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    CallbackGroup cbg = new CallbackGroup();
    if (isSignedIn()) {
        AccountApi.self().view("preferences").get(cbg.add(createMyMenuBarCallback()));
    }
    PluginLoader.load(hpd.plugins, hpd.pluginsLoadTimeout, cbg.addFinal(new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    }));
}
#end_block

#method_before
private int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", 5000, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#method_after
private static int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#end_block

#method_before
public void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#method_after
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#end_block

#method_before
@Test
public void forcePushNotAllowed() throws GitAPIException, IOException {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertStatus(Status.REJECTED_OTHER_REASON, "non-fast forward");
}
#method_after
@Test
public void forcePushNotAllowed() throws Exception {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertErrorStatus("non-fast forward");
}
#end_block

#method_before
@Test
public void forcePushAllowed() throws GitAPIException, IOException, ConfigInvalidException {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    grant(Permission.PUSH, project, "refs/*", true);
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertOkStatus();
}
#method_after
@Test
public void forcePushAllowed() throws Exception {
    ObjectId initial = git.getRepository().getRef(HEAD).getLeaf().getObjectId();
    grant(Permission.PUSH, project, "refs/*", true);
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), "change1", "a.txt", "content");
    PushOneCommit.Result r1 = push1.to(git, "refs/heads/master");
    r1.assertOkStatus();
    // Reset HEAD to initial so the new change is a non-fast forward
    RefUpdate ru = git.getRepository().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), "change2", "b.txt", "content");
    push2.setForce(true);
    PushOneCommit.Result r2 = push2.to(git, "refs/heads/master");
    r2.assertOkStatus();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setUseAutoBase(getEnum(rc, RECEIVE, null, KEY_USE_AUTO_BASE, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_AUTO_BASE, p.getUseAutoBase(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    savePluginSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    savePluginSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.useAutoBase != null) {
            p.setUseAutoBase(input.useAutoBase);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(rsrc.getControl().getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.createNewChangeForAllNotInTarget != null) {
            p.setCreateNewChangeForAllNotInTarget(input.createNewChangeForAllNotInTarget);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        if (input.pluginConfigValues != null) {
            setPluginConfigValues(rsrc.getControl().getProjectState(), projectConfig, input.pluginConfigValues);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, RefNames.REFS_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            projectCache.evict(projectConfig.getProject());
            gitMgr.setProjectDescription(projectName, p.getDescription());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, pluginConfigEntries, cfgFactory, allProjects, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (useAutoBase) {
        String magicBranchRef = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(magicBranchRef).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), magicBranchRef), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (useAutoBase && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "You can't push merges with auto base on");
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean useAutoBase, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setUseAutoBase(useAutoBase);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#method_after
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean createNewChangeForAllNotInTarget, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setCreateNewChangeForAllNotInTarget(createNewChangeForAllNotInTarget);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.autoBase = MoreObjects.firstNonNull(input.useAutoBase, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = MoreObjects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = MoreObjects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : MoreObjects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.newChangeForAllNotInTarget = MoreObjects.firstNonNull(input.createNewChangeForAllNotInTarget, InheritableBoolean.INHERIT);
    args.changeIdRequired = MoreObjects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
    useAutoBase = update.useAutoBase;
}
#method_after
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
    createNewChangeForAllNotInTarget = update.createNewChangeForAllNotInTarget;
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setUseAutoBase(createProjectArgs.autoBase);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(MoreObjects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setCreateNewChangeForAllNotInTarget(createProjectArgs.newChangeForAllNotInTarget);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    autoBase.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    newChangeForAllNotInTarget.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    autoBase = newInheritedBooleanBox();
    saveEnabler.listenTo(autoBase);
    grid.add(Util.C.useAutoBase(), autoBase);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    newChangeForAllNotInTarget = newInheritedBooleanBox();
    saveEnabler.listenTo(newChangeForAllNotInTarget);
    grid.add(Util.C.createNewChangeForAllNotInTarget(), newChangeForAllNotInTarget);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(autoBase, result.use_auto_base());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(newChangeForAllNotInTarget, result.create_new_change_for_all_not_in_target());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(autoBase), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(newChangeForAllNotInTarget), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public String getSchemeRest() {
    String id = getExternalId();
    int c = id.indexOf(':');
    return 0 < c ? id.substring(c + 1) : null;
}
#method_after
public String getSchemeRest() {
    String scheme = key.getScheme();
    return null != scheme ? getExternalId().substring(scheme.length() + 1) : null;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = LoginUrlToken.getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    areq.setDisplayName(authFilter.getRemoteDisplayname(req));
    areq.setEmailAddress(authFilter.getRemoteEmail(req));
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    String remoteExternalId = authFilter.getRemoteExternalIdToken(req);
    if (remoteExternalId != null) {
        try {
            linkRemoteExternalId(arsp, remoteExternalId);
        } catch (AccountException | OrmException e) {
            log.error("Unable to associated external identity \"" + remoteExternalId + "\" to user \"" + user + "\"", e);
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    final StringBuilder rdr = new StringBuilder();
    if (arsp.isNew() && authConfig.getRegisterPageUrl() != null) {
        rdr.append(authConfig.getRegisterPageUrl());
    } else {
        rdr.append(urlProvider.get(req));
        rdr.append('#');
        if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
            rdr.append(PageLinks.REGISTER);
        }
        rdr.append(token);
    }
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = LoginUrlToken.getToken(req);
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    areq.setDisplayName(authFilter.getRemoteDisplayname(req));
    areq.setEmailAddress(authFilter.getRemoteEmail(req));
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    String remoteExternalId = authFilter.getRemoteExternalIdToken(req);
    if (remoteExternalId != null) {
        try {
            log.debug("Associating external identity \"{}\" to user \"{}\"", remoteExternalId, user);
            updateRemoteExternalId(arsp, remoteExternalId);
        } catch (AccountException | OrmException e) {
            log.error("Unable to associate external identity \"" + remoteExternalId + "\" to user \"" + user + "\"", e);
            rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
    }
    final StringBuilder rdr = new StringBuilder();
    if (arsp.isNew() && authConfig.getRegisterPageUrl() != null) {
        rdr.append(authConfig.getRegisterPageUrl());
    } else {
        rdr.append(urlProvider.get(req));
        if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
            rdr.append('#' + PageLinks.REGISTER);
        }
        rdr.append(token);
    }
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
private static AuthType toType(final Config cfg) {
    return ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
}
#method_after
private static AuthType toType(final Config cfg) {
    return cfg.getEnum("auth", null, "type", AuthType.OPENID);
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> submittedChanges = submit(rsrc, caller, false);
    if (input.waitForMerge) {
        for (Change c : submittedChanges) {
            mergeQueue.merge(c.getDest());
        }
        change = dbProvider.get().changes().get(change.getId());
    } else {
        for (Change c : submittedChanges) {
            mergeQueue.schedule(c.getDest());
        }
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> submittedChanges = submit(rsrc, caller, false);
    if (input.waitForMerge) {
        for (Change c : submittedChanges) {
            // TODO(sbeller): We should make schedule return a Future, then we
            // could do these all in parallel and still block until they're done.
            mergeQueue.merge(c.getDest());
        }
        change = dbProvider.get().changes().get(change.getId());
    } else {
        for (Change c : submittedChanges) {
            mergeQueue.schedule(c.getDest());
        }
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } catch (ResourceConflictException e) {
        throw e;
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
private Change submitThisChange(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change.getId(), timestamp);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } catch (ResourceConflictException e) {
        throw e;
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#method_after
private List<Change> submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            submitToDatabase(db, c.getId(), timestamp);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    List<Change> ret = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
        ret.add(c.change());
    }
    indexer.indexAsync(ids).checkedGet();
    return ret;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
            loadRevisionInfo();
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            // Revision loading may be slower than the rest, so do it
            // asynchronous to have the rest fast.
            loadConfigInfo(info, base);
            loadRevisionInfo();
        }
    }));
}
#end_block

#method_before
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(changeId.get(), revision);
    call.background();
    call.get(new AsyncCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(NativeMap<ActionInfo> result) {
            renderRevisionInfo(changeInfo, result);
        }
    });
}
#method_after
void loadRevisionInfo() {
    RestApi call = ChangeApi.actions(changeId.get(), revision);
    call.background();
    call.get(new GerritCallback<NativeMap<ActionInfo>>() {

        @Override
        public void onSuccess(NativeMap<ActionInfo> actionMap) {
            actionMap.copyKeysIntoChildren("id");
            renderRevisionInfo(changeInfo, actionMap);
        }
    });
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info, NativeMap<ActionInfo> actions) {
    if (info.status() == Status.DRAFT) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    renameFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    renameFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled();
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    renderRevisionInfo(info, NativeMap.<ActionInfo>create());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    renderRevisionInfo(changeInfo, NativeMap.<ActionInfo>create());
}
#end_block

#method_before
void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initChangeAction(info, actionMap);
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    actions.reloadRevisionActions(actionMap);
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info, NativeMap<ActionInfo> actions) {
    if (info.status() == Status.DRAFT) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    reviewMode.setVisible(true);
}
#method_after
@UiHandler("editMode")
void onEditMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.EDIT;
    refreshFileTable();
    editMode.setVisible(false);
    addFile.setVisible(true);
    deleteFile.setVisible(true);
    renameFile.setVisible(true);
    reviewMode.setVisible(true);
}
#end_block

#method_before
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    reviewMode.setVisible(false);
}
#method_after
@UiHandler("reviewMode")
void onReviewMode(@SuppressWarnings("unused") ClickEvent e) {
    fileTableMode = FileTable.Mode.REVIEW;
    refreshFileTable();
    editMode.setVisible(true);
    addFile.setVisible(false);
    deleteFile.setVisible(false);
    renameFile.setVisible(false);
    reviewMode.setVisible(false);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    loadFileList(base, rev, myLastReply, group, comments, drafts);
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    renderRevisionInfo(info, NativeMap.<ActionInfo>create());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    RevisionInfo revInfo = info.revision(revision);
    NativeMap<ActionInfo> actionMap = revInfo.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actionMap.copyKeysIntoChildren("id");
    renderRevisionInfo(info, actionMap);
}
#end_block

#method_before
void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initChangeAction(info, actionMap);
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = areChangesSubmittable(changesByTopic, resource.getUser());
        if (!Strings.isNullOrEmpty(topicProblems)) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    if (problemsForSubmittingChanges(Arrays.asList(cd), resource.getUser()) != null) {
        visible = false;
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private Change submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            if (submitToDatabase(db, c.getId(), timestamp) == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
    }
    indexer.indexAsync(ids).checkedGet();
    return change;
}
#method_after
private Change submitWholeTopic(RevisionResource rsrc, IdentifiedUser caller, boolean force, String topic) throws ResourceConflictException, OrmException, IOException {
    Preconditions.checkNotNull(topic);
    final Timestamp timestamp = TimeUtil.nowTs();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, rsrc.getControl());
    List<ChangeData> changesByTopic = queryProvider.get().byTopicOpen(topic);
    String problems = problemsForSubmittingChanges(changesByTopic, caller);
    if (problems != null) {
        throw new ResourceConflictException(problems);
    }
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    List<SubmitRecord> submitRecords = checkSubmitRule(cd, rsrc.getPatchSet(), force);
    update.submit(submitRecords);
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        for (ChangeData c : changesByTopic) {
            if (submitToDatabase(db, c.getId(), timestamp) == null) {
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    List<Change.Id> ids = new ArrayList<>(changesByTopic.size());
    for (ChangeData c : changesByTopic) {
        ids.add(c.getId());
    }
    indexer.indexAsync(ids).checkedGet();
    return change;
}
#end_block

#method_before
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    BatchMetaDataUpdate batch = update1.openUpdateInBatch(bru);
    PatchLineComment comment1 = newPublishedPatchLineComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update1.setPatchSetId(psId);
    update1.upsertComment(comment1);
    update1.writeCommit(batch);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    update2.putApproval("Code-Review", (short) 2);
    batch.write(update2, new CommitBuilder());
    try {
        batch.commit();
    } finally {
        batch.close();
    }
    RevWalk rw = new RevWalk(repo);
    try {
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } finally {
        rw.release();
    }
    ChangeNotes notes = newNotes(c);
    List<PatchSetApproval> psas = notes.getApprovals().get(c.currentPatchSetId());
    assertEquals(1, psas.size());
    assertTrue(notes.getBaseComments().size() == 0);
}
#method_after
@Test
public void multipleUpdatesIncludingComments() throws Exception {
    Change c = newChange();
    ChangeUpdate update1 = newUpdate(c, otherUser);
    String uuid1 = "uuid1";
    String message1 = "comment 1";
    CommentRange range1 = new CommentRange(1, 1, 2, 1);
    Timestamp time1 = TimeUtil.nowTs();
    PatchSet.Id psId = c.currentPatchSetId();
    BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
    BatchMetaDataUpdate batch = update1.openUpdateInBatch(bru);
    PatchLineComment comment1 = newPublishedPatchLineComment(psId, "file1", uuid1, range1, range1.getEndLine(), otherUser, null, time1, message1, (short) 0, "abcd1234abcd1234abcd1234abcd1234abcd1234");
    update1.setPatchSetId(psId);
    update1.upsertComment(comment1);
    update1.writeCommit(batch);
    ChangeUpdate update2 = newUpdate(c, otherUser);
    update2.putApproval("Code-Review", (short) 2);
    update2.writeCommit(batch);
    RevWalk rw = new RevWalk(repo);
    try {
        batch.commit();
        bru.execute(rw, NullProgressMonitor.INSTANCE);
        ChangeNotes notes = newNotes(c);
        ObjectId tip = notes.getRevision();
        RevCommit commitWithApprovals = rw.parseCommit(tip);
        assertNotNull(commitWithApprovals);
        RevCommit commitWithComments = commitWithApprovals.getParent(0);
        assertNotNull(commitWithComments);
        ChangeNotesParser notesWithComments = new ChangeNotesParser(c, commitWithComments.copy(), rw, repoManager);
        notesWithComments.parseAll();
        ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals1 = notesWithComments.buildApprovals();
        assertEquals(0, approvals1.size());
        assertEquals(1, notesWithComments.commentsForBase.size());
        notesWithComments.close();
        ChangeNotesParser notesWithApprovals = new ChangeNotesParser(c, commitWithApprovals.copy(), rw, repoManager);
        notesWithApprovals.parseAll();
        ImmutableListMultimap<PatchSet.Id, PatchSetApproval> approvals2 = notesWithApprovals.buildApprovals();
        assertEquals(1, approvals2.size());
        assertEquals(1, notesWithApprovals.commentsForBase.size());
        notesWithApprovals.close();
    } finally {
        batch.close();
        rw.release();
    }
}
#end_block

#method_before
public GroupControl controlFor(final CurrentUser who, final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(who, group);
}
#method_after
public GroupControl controlFor(final CurrentUser who, final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(who, group, groupBackend);
}
#end_block

#method_before
public GroupControl controlFor(GroupDescription.Basic group) {
    return new GroupControl(user.get(), group);
}
#method_after
public GroupControl controlFor(GroupDescription.Basic group) {
    return new GroupControl(user.get(), group, groupBackend);
}
#end_block

#method_before
public boolean isVisible() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    /* Check for canAdministrateServer may seem redundant, but allows
     * for visibility of all groups that are not an internal group to
     * server administrators.
     */
    return (accountGroup != null && accountGroup.isVisibleToAll()) || user instanceof InternalUser || user.getEffectiveGroups().contains(group.getGroupUUID()) || isOwner() || group.getName().startsWith("ldap/") ? true : user.getCapabilities().canAdministrateServer();
}
#method_after
public boolean isVisible() {
    /* Check for canAdministrateServer may seem redundant, but allows
     * for visibility of all groups that are not an internal group to
     * server administrators.
     */
    return user instanceof InternalUser || user.memberOf(group.getGroupUUID()) || isOwner() || user.getCapabilities().canAdministrateServer() || groupBackend.isVisibleToAll(group.getGroupUUID());
}
#end_block

#method_before
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#method_after
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().memberOf(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#end_block

#method_before
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), uploader);
    PatchSetInserter patchSetInserter = patchSetInserterFactory.create(git, revWalk, changeControl, rebasedCommit).setCopyLabels(true).setValidatePolicy(validate).setDraft(originalPatchSet.isDraft()).setSendMail(sendMail).setRunHooks(runHooks);
    final PatchSet.Id newPatchSetId = patchSetInserter.getPatchSetId();
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader.getAccountId(), TimeUtil.nowTs(), patchSetId);
    cmsg.setMessage("Patch Set " + newPatchSetId.get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetInserter.setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#method_after
public void rebase(Change change, PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(change, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, ValidatePolicy.GERRIT);
    } catch (MergeConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
private static String findBaseRevision(final PatchSet.Id patchSetId, final ReviewDb db, final Branch.NameKey destBranch, final Repository git, List<PatchSetAncestor> patchSetAncestors, List<PatchSet> depPatchSetList, List<Change> depChangeList) throws IOException, OrmException {
    String baseRev = null;
    if (patchSetAncestors == null) {
        patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
    }
    if (patchSetAncestors.size() > 1) {
        throw new IOException("Cannot rebase a change with multiple parents. Parents commits: " + patchSetAncestors.toString());
    }
    if (patchSetAncestors.size() == 0) {
        throw new IOException("Cannot rebase a change without any parents (is this the initial commit?).");
    }
    RevId ancestorRev = patchSetAncestors.get(0).getAncestorRevision();
    if (depPatchSetList == null || depPatchSetList.size() != 1 || !depPatchSetList.get(0).getRevision().equals(ancestorRev)) {
        depPatchSetList = db.patchSets().byRevision(ancestorRev).toList();
    }
    for (PatchSet depPatchSet : depPatchSetList) {
        Change.Id depChangeId = depPatchSet.getId().getParentKey();
        Change depChange;
        if (depChangeList == null || depChangeList.size() != 1 || !depChangeList.get(0).getId().equals(depChangeId)) {
            depChange = db.changes().get(depChangeId);
        } else {
            depChange = depChangeList.get(0);
        }
        if (!depChange.getDest().equals(destBranch)) {
            continue;
        }
        if (depChange.getStatus() == Status.ABANDONED) {
            throw new IOException("Cannot rebase a change with an abandoned parent: " + depChange.getKey().toString());
        }
        if (depChange.getStatus().isOpen()) {
            if (depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                throw new IOException("Change is already based on the latest patch set of the dependent change.");
            }
            PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
            baseRev = latestDepPatchSet.getRevision().get();
        }
        break;
    }
    if (baseRev == null) {
        // We are dependent on a merged PatchSet or have no PatchSet
        // dependencies at all.
        Ref destRef = git.getRef(destBranch.get());
        if (destRef == null) {
            throw new IOException("The destination branch does not exist: " + destBranch.get());
        }
        baseRev = destRef.getObjectId().getName();
        if (baseRev.equals(ancestorRev.get())) {
            throw new IOException("Change is already up to date.");
        }
    }
    return baseRev;
}
#method_after
private static String findBaseRevision(final PatchSet.Id patchSetId, final ReviewDb db, final Branch.NameKey destBranch, final Repository git, List<PatchSetAncestor> patchSetAncestors, List<PatchSet> depPatchSetList, List<Change> depChangeList) throws IOException, OrmException {
    String baseRev = null;
    if (patchSetAncestors == null) {
        patchSetAncestors = db.patchSetAncestors().ancestorsOf(patchSetId).toList();
    }
    if (patchSetAncestors.size() > 1) {
        throw new IOException("Cannot rebase a change with multiple parents. Parent commits: " + patchSetAncestors.toString());
    }
    if (patchSetAncestors.size() == 0) {
        throw new IOException("Cannot rebase a change without any parents (is this the initial commit?).");
    }
    RevId ancestorRev = patchSetAncestors.get(0).getAncestorRevision();
    if (depPatchSetList == null || depPatchSetList.size() != 1 || !depPatchSetList.get(0).getRevision().equals(ancestorRev)) {
        depPatchSetList = db.patchSets().byRevision(ancestorRev).toList();
    }
    for (PatchSet depPatchSet : depPatchSetList) {
        Change.Id depChangeId = depPatchSet.getId().getParentKey();
        Change depChange;
        if (depChangeList == null || depChangeList.size() != 1 || !depChangeList.get(0).getId().equals(depChangeId)) {
            depChange = db.changes().get(depChangeId);
        } else {
            depChange = depChangeList.get(0);
        }
        if (!depChange.getDest().equals(destBranch)) {
            continue;
        }
        if (depChange.getStatus() == Status.ABANDONED) {
            throw new IOException("Cannot rebase a change with an abandoned parent: " + depChange.getKey().toString());
        }
        if (depChange.getStatus().isOpen()) {
            if (depPatchSet.getId().equals(depChange.currentPatchSetId())) {
                throw new IOException("Change is already based on the latest patch set of the dependent change.");
            }
            PatchSet latestDepPatchSet = db.patchSets().get(depChange.currentPatchSetId());
            baseRev = latestDepPatchSet.getRevision().get();
        }
        break;
    }
    if (baseRev == null) {
        // We are dependent on a merged PatchSet or have no PatchSet
        // dependencies at all.
        Ref destRef = git.getRef(destBranch.get());
        if (destRef == null) {
            throw new IOException("The destination branch does not exist: " + destBranch.get());
        }
        baseRev = destRef.getObjectId().getName();
        if (baseRev.equals(ancestorRev.get())) {
            throw new IOException("Change is already up to date.");
        }
    }
    return baseRev;
}
#end_block

#method_before
private ObjectId rebaseCommit(final Repository git, final ObjectInserter inserter, final RevCommit original, final RevCommit base, final MergeUtil mergeUtil, final PersonIdent committerIdent) throws IOException, PathConflictException {
    final RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new IOException("Change is already up to date.");
    }
    final ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, inserter);
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new PathConflictException("The change could not be rebased due to a path conflict during merge.");
    }
    final CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    cb.setCommitter(committerIdent);
    final ObjectId objectId = inserter.insert(cb);
    inserter.flush();
    return objectId;
}
#method_after
private ObjectId rebaseCommit(Repository git, ObjectInserter inserter, RevCommit original, RevCommit base, MergeUtil mergeUtil, PersonIdent committerIdent) throws MergeConflictException, IOException {
    RevCommit parentCommit = original.getParent(0);
    if (base.equals(parentCommit)) {
        throw new IOException("Change is already up to date.");
    }
    ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, inserter);
    merger.setBase(parentCommit);
    merger.merge(original, base);
    if (merger.getResultTreeId() == null) {
        throw new MergeConflictException("The change could not be rebased due to a conflict during merge.");
    }
    CommitBuilder cb = new CommitBuilder();
    cb.setTreeId(merger.getResultTreeId());
    cb.setParentId(base);
    cb.setAuthor(original.getAuthorIdent());
    cb.setMessage(original.getFullMessage());
    cb.setCommitter(committerIdent);
    ObjectId objectId = inserter.insert(cb);
    inserter.flush();
    return objectId;
}
#end_block

#method_before
public boolean canRebase(RevisionResource r) {
    Repository git;
    try {
        git = gitManager.openRepository(r.getChange().getProject());
    } catch (RepositoryNotFoundException err) {
        return false;
    } catch (IOException err) {
        return false;
    }
    try {
        findBaseRevision(r.getPatchSet().getId(), db, r.getChange().getDest(), git, null, null, null);
        return true;
    } catch (IOException e) {
        return false;
    } catch (OrmException e) {
        return false;
    } finally {
        git.close();
    }
}
#method_after
public boolean canRebase(RevisionResource r) {
    Repository git;
    try {
        git = gitManager.openRepository(r.getChange().getProject());
    } catch (RepositoryNotFoundException err) {
        return false;
    } catch (IOException err) {
        return false;
    }
    try {
        findBaseRevision(r.getPatchSet().getId(), db.get(), r.getChange().getDest(), git, null, null, null);
        return true;
    } catch (IOException e) {
        return false;
    } catch (OrmException e) {
        return false;
    } finally {
        git.close();
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId());
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#method_after
private static String formatChangeUrl(String url, Change change) {
    StringBuilder m = new StringBuilder().append("  ").append(url).append(change.getChangeId()).append(" ").append(ChangeUtil.cropSubject(change.getSubject()));
    if (change.getStatus() == Change.Status.DRAFT) {
        m.append(" [DRAFT]");
    }
    return m.toString();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    rp.getRevWalk().reset();
    if (ctl.canCreate(db, rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
@Option(name = "-r", metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#method_after
@Option(name = "--reviewer", aliases = { "-r" }, metaVar = "EMAIL", usage = "add reviewer to changes")
void reviewer(Account.Id id) {
    reviewer.add(id);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
CheckedFuture<Void, OrmException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<Void, InsertException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error("Cannot read database before replacement", err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error("Cannot read repository before replacement", err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (changeKind == ChangeKind.REWORK) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private List<Ref> refs(Change.Id changeId) {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null && PatchSet.isRef(ref.getName())) {
                refsByChange.put(Change.Id.fromRef(ref.getName()), ref);
            }
        }
    }
    return refsByChange.get(changeId);
}
#method_after
private List<Ref> refs(Change.Id changeId) {
    return refsByChange().get(changeId);
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) {
    if (validCommits.contains(c)) {
        return true;
    }
    CommitReceivedEvent receiveEvent = new CommitReceivedEvent(cmd, project, ctl.getRefName(), c, currentUser);
    CommitValidators commitValidators = commitValidatorsFactory.create(ctl, sshInfo, repo);
    try {
        messages.addAll(commitValidators.validateForReceiveCommits(receiveEvent, rejectCommits));
    } catch (CommitValidationException e) {
        messages.addAll(e.getMessages());
        reject(cmd, e.getMessage());
        return false;
    }
    validCommits.add(c);
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException, IOException {
    Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    indexer.index(db, change);
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopicOpen(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(true);
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMap();
    for (PatchSetApproval psa : approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getControl(), psId)) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || !submit.getAccountId().equals(caller.getAccountId())) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.deleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
private List<SubmitRecord> checkSubmitRule(ChangeData cd, PatchSet patchSet, boolean force) throws ResourceConflictException, OrmException {
    List<SubmitRecord> results = new SubmitRuleEvaluator(cd).setPatchSet(patchSet).canSubmit();
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0) {
                                msg.append("; ");
                            }
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), patchSet.getId(), cd.change().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#method_after
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (!hasUser || Gerrit.getUserAccount().getGeneralPreferences().isMuteCommonPathPrefixes()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && !ChangeType.DELETED.matches(info.status())) {
        if (ChangeType.ADDED.matches(info.status())) {
            sb.append(info.lines_inserted()).append(" lines");
        } else {
            sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.lines_inserted() + info.lines_deleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.lines_inserted()).append(" lines");
            } else {
                sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
            }
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta2(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn2());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && (info.lines_inserted() != 0 || info.lines_deleted() != 0)) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(5, (int) (((double) w) * info.lines_inserted() / t));
        int d = Math.max(5, (int) (((double) w) * info.lines_deleted() / t));
        sb.setAttribute("title", Util.M.patchTableSize_LongModify(info.lines_inserted(), info.lines_deleted()));
        if (0 < info.lines_inserted()) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < info.lines_deleted()) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta2(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn2());
    if (showChangeSizeBars && !Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && (info.lines_inserted() != 0 || info.lines_deleted() != 0)) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(5, (int) (((double) w) * info.lines_inserted() / t));
        int d = Math.max(5, (int) (((double) w) * info.lines_deleted() / t));
        sb.setAttribute("title", Util.M.patchTableSize_LongModify(info.lines_inserted(), info.lines_deleted()));
        if (0 < info.lines_inserted()) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < info.lines_deleted()) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void footer(SafeHtmlBuilder sb) {
    sb.openTr().setStyleName(R.css().nohover());
    sb.openTh().setStyleName(R.css().pointer()).closeTh();
    if (mode == Mode.REVIEW) {
        sb.openTh().setStyleName(R.css().reviewed()).closeTh();
    } else {
        sb.openTh().setStyleName(R.css().removeButton()).closeTh();
    }
    sb.openTh().setStyleName(R.css().status()).closeTh();
    // path
    sb.openTd().closeTd();
    // comments
    sb.openTd().setAttribute("colspan", 3).closeTd();
    // delta1
    sb.openTh().setStyleName(R.css().deltaColumn1()).append(Util.M.patchTableSize_Modify(inserted, deleted)).closeTh();
    // delta2
    sb.openTh().setStyleName(R.css().deltaColumn2());
    int w = 80;
    int t = inserted + deleted;
    int i = Math.max(1, (int) (((double) w) * inserted / t));
    int d = Math.max(1, (int) (((double) w) * deleted / t));
    if (i + d > w && i > d) {
        i = w - d;
    } else if (i + d > w && d > i) {
        d = w - i;
    }
    if (0 < inserted) {
        sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
    }
    if (0 < deleted) {
        sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
    }
    sb.closeTh();
    sb.closeTr();
}
#method_after
private void footer(SafeHtmlBuilder sb) {
    sb.openTr().setStyleName(R.css().nohover());
    sb.openTh().setStyleName(R.css().pointer()).closeTh();
    if (mode == Mode.REVIEW) {
        sb.openTh().setStyleName(R.css().reviewed()).closeTh();
    } else {
        sb.openTh().setStyleName(R.css().removeButton()).closeTh();
    }
    sb.openTh().setStyleName(R.css().status()).closeTh();
    // path
    sb.openTd().closeTd();
    // comments
    sb.openTd().setAttribute("colspan", 3).closeTd();
    // delta1
    sb.openTh().setStyleName(R.css().deltaColumn1()).append(Util.M.patchTableSize_Modify(inserted, deleted)).closeTh();
    // delta2
    sb.openTh().setStyleName(R.css().deltaColumn2());
    if (showChangeSizeBars) {
        int w = 80;
        int t = inserted + deleted;
        int i = Math.max(1, (int) (((double) w) * inserted / t));
        int d = Math.max(1, (int) (((double) w) * deleted / t));
        if (i + d > w && i > d) {
            i = w - d;
        } else if (i + d > w && d > i) {
            d = w - i;
        }
        if (0 < inserted) {
            sb.openDiv().setStyleName(R.css().inserted()).setAttribute("style", "width:" + i + "px").closeDiv();
        }
        if (0 < deleted) {
            sb.openDiv().setStyleName(R.css().deleted()).setAttribute("style", "width:" + d + "px").closeDiv();
        }
    }
    sb.closeTh();
    sb.closeTr();
}
#end_block

#method_before
static void call(final Button b, final String project) {
    b.setEnabled(false);
    ChangeApi.createDraftChange(project, "refs/meta/config", Util.C.editConfigMessage(), null, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(result.legacy_id(), 1), "project.config"));
        }

        @Override
        public void onFailure(Throwable caught) {
            b.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
static void call(final Button b, final String project) {
    b.setEnabled(false);
    ChangeApi.createChange(project, RefNames.REFS_CONFIG, Util.C.editConfigMessage(), null, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(result.legacy_id(), 1), "project.config"));
        }

        @Override
        public void onFailure(Throwable caught) {
            b.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2.getBytes("UTF-8"));
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#method_after
@Test
public void rebaseEdit() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    modifier.rebaseEdit(edit, current);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(beforeRebase.equals(afterRebase)).isFalse();
}
#end_block

#method_before
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2.getBytes("UTF-8"));
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(afterRebase).isNotEqualTo(beforeRebase);
}
#method_after
@Test
public void rebaseEditRest() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    assertThat(modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    ChangeEdit edit = editUtil.byChange(change).get();
    PatchSet current = getCurrentPatchSet(changeId);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId() - 1);
    Date beforeRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    RestResponse r = adminSession.post(urlRebase());
    assertThat(r.getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change).get();
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.getChange().getProject()), ObjectId.fromString(edit.getRevision().get()), FILE_NAME2), CONTENT_NEW2);
    assertThat(edit.getBasePatchSet().getPatchSetId()).isEqualTo(current.getPatchSetId());
    Date afterRebase = edit.getEditCommit().getCommitterIdent().getWhen();
    assertThat(afterRebase).isNotEqualTo(beforeRebase);
}
#end_block

#method_before
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2 + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#method_after
@Test
public void updateMessageRest() throws Exception {
    assertThat(adminSession.get(urlEditMessage()).getStatusCode()).isEqualTo(SC_NOT_FOUND);
    EditMessage.Input in = new EditMessage.Input();
    in.message = String.format("New commit message\n\n" + CONTENT_NEW2_STR + "\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    RestResponse r = adminSession.getJsonAccept(urlEditMessage());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(in.message);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
    in.message = String.format("New commit message2\n\nChange-Id: %s", change.getKey());
    assertThat(adminSession.put(urlEditMessage(), in).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(in.message);
}
#end_block

#method_before
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2.getBytes("UTF-8"));
}
#method_after
@Test
public void amendExistingFile() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2.getBytes("UTF-8"));
}
#method_after
@Test
public void createAndChangeEditInOneRequestRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW);
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME), CONTENT_NEW2);
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.getJsonAccept(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2.getBytes("UTF-8")));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertThat(adminSession.putRaw(urlEditFile(), in.content).getStatusCode()).isEqualTo(SC_NO_CONTENT);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    RestResponse r = adminSession.getJsonAccept(urlEditFile());
    assertThat(r.getStatusCode()).isEqualTo(SC_OK);
    assertThat(readContentFromJson(r)).isEqualTo(StringUtils.newStringUtf8(CONTENT_NEW2));
}
#end_block

#method_before
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW2.getBytes("UTF-8"));
}
#method_after
@Test
public void addNewFileAndAmend() throws Exception {
    assertThat(modifier.createEdit(change, ps)).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW);
    assertThat(modifier.modifyFile(edit.get(), FILE_NAME2, RestSession.newRawInput(CONTENT_NEW2))).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertByteArray(fileUtil.getContent(projectCache.get(edit.get().getChange().getProject()), ObjectId.fromString(edit.get().getRevision().get()), FILE_NAME2), CONTENT_NEW2);
}
#end_block

#method_before
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { toc(), note() };
}
#method_after
@Override
public Rule[] blockPluginRules() {
    return new Rule[] { note(), toc() };
}
#end_block

#method_before
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), whitespace(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode((DivNode.Style) pop(), parse(body).getChildren())));
}
#method_after
public Rule note() {
    StringBuilderVar body = new StringBuilderVar();
    return NodeSequence(string("***"), Sp(), typeOfNote(), Newline(), oneOrMore(testNot(string("***"), Newline()), Line(body)), string("***"), Newline(), push(new DivNode(popAsString(), parse(body))));
}
#end_block

#method_before
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(DivNode.Style.NOTE)), sequence(string("promo"), push(DivNode.Style.PROMO)), sequence(string("aside"), push(DivNode.Style.ASIDE)));
}
#method_after
public Rule typeOfNote() {
    return firstOf(sequence(string("note"), push(match())), sequence(string("promo"), push(match())), sequence(string("aside"), push(match())));
}
#end_block

#method_before
public RootNode parse(StringBuilderVar body) {
    // parsing within a block.
    return parser.parseMarkdown(body.getChars());
}
#method_after
public List<Node> parse(StringBuilderVar body) {
    // parsing within a block.
    if (parser == null) {
        parser = newParser();
    }
    return parser.parseMarkdown(body.getChars()).getChildren();
}
#end_block

#method_before
String getStyleName() {
    return style.name().toLowerCase(Locale.US);
}
#method_after
public String getStyleName() {
    return style;
}
#end_block

#method_before
@Override
public void accept(Visitor visitor) {
    visitor.visit(this);
}
#method_after
@Override
public void accept(org.pegdown.ast.Visitor visitor) {
    ((Visitor) visitor).visit(this);
}
#end_block

#method_before
String getTitle(Node root) {
    if (root instanceof HeaderNode) {
        HeaderNode h = (HeaderNode) root;
        if (h.getLevel() == 1) {
            return TocSerializer.getText(h);
        }
    }
    List<Node> ch = root.getChildren();
    if (ch != null) {
        for (Node n : ch) {
            String title = getTitle(n);
            if (title != null) {
                return title;
            }
        }
    }
    return null;
}
#method_after
static String getTitle(Node node) {
    if (node instanceof HeaderNode) {
        if (((HeaderNode) node).getLevel() == 1) {
            return getInnerText(node);
        }
        return null;
    }
    for (Node child : node.getChildren()) {
        String title = getTitle(child);
        if (title != null) {
            return title;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        if (Strings.isNullOrEmpty(path)) {
            path = INDEX_MD;
        } else if (path.endsWith("/")) {
            path += INDEX_MD;
        }
        if (!path.endsWith(".md")) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        RevTree root = getRoot(view, rw);
        if (root == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        String srcmd = readFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        MarkdownHelper fmt = new MarkdownHelper(view);
        RootNode doc = parseFile(view, path, fmt, srcmd);
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        String navmd = readFile(rw, root, "navbar.md");
        RootNode nav = navmd != null ? parseFile(view, "navbar.md", fmt, navmd) : null;
        showDoc(req, res, fmt, nav, doc);
    } finally {
        rw.release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Config cfg = getAccess(req).getConfig();
    if (!cfg.getBoolean("markdown", "render", true)) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        RevTree root;
        try {
            root = rw.parseTree(view.getRevision().getId());
        } catch (IncorrectObjectTypeException e) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile navmd = findFile(rw, root, NAVBAR_MD);
        String reqEtag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        String curEtag = etag(srcmd, navmd);
        if (reqEtag != null && reqEtag.equals(curEtag)) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        int inputLimit = cfg.getInt("markdown", "inputLimit", 5 << 20);
        RootNode doc = GitilesMarkdown.parseFile(view, srcmd.path, srcmd.read(rw.getObjectReader(), inputLimit));
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        RootNode nav = null;
        if (navmd != null) {
            nav = GitilesMarkdown.parseFile(view, navmd.path, navmd.read(rw.getObjectReader(), inputLimit));
            if (nav == null) {
                res.setStatus(SC_INTERNAL_SERVER_ERROR);
                return;
            }
        }
        res.setHeader(HttpHeaders.ETAG, curEtag);
        showDoc(req, res, view, nav, doc);
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, MarkdownHelper fmt, RootNode nav, RootNode doc) throws IOException {
    String title = MoreObjects.firstNonNull(Strings.emptyToNull(fmt.getTitle(doc)), ViewFilter.getView(req).getPathPart());
    Map<String, Object> data = new HashMap<>();
    data.put("breadcrumbs", null);
    data.put("repositoryName", null);
    data.put("title", title);
    data.put("navbarHtml", fmt.renderHTML(nav));
    data.put("bodyHtml", fmt.renderHTML(doc));
    renderHtml(req, res, "gitiles.markdownDoc", data);
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, RootNode nav, RootNode doc) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.put("pageTitle", MoreObjects.firstNonNull(MarkdownHelper.getTitle(doc), view.getPathPart()));
    data.put("sourceUrl", GitilesView.path().copyFrom(view).toUrl());
    data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
    data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    data.put("navbarHtml", new MarkdownToHtml(view).toSoyHtml(nav));
    data.put("bodyHtml", new MarkdownToHtml(view).toSoyHtml(doc));
    String page = renderer.render(SOY_TEMPLATE, data);
    byte[] raw = page.getBytes(UTF_8);
    res.setContentType(FormatType.HTML.getMimeType());
    res.setCharacterEncoding(UTF_8.name());
    setCacheHeaders(res);
    if (acceptsGzipEncoding(req)) {
        res.setHeader(HttpHeaders.CONTENT_ENCODING, "gzip");
        raw = gzip(raw);
    }
    res.setContentLength(raw.length);
    res.setStatus(HttpServletResponse.SC_OK);
    res.getOutputStream().write(raw);
}
#end_block

#method_before
void render(HttpServletResponse res, String templateName, Map<String, ?> soyData) throws IOException {
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    byte[] data = newRenderer(templateName).setData(soyData).render().getBytes(UTF_8);
    res.setContentLength(data.length);
    res.getOutputStream().write(data);
}
#method_after
public String render(String templateName, Map<String, ?> soyData) {
    return newRenderer(templateName).setData(soyData).render();
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!getAccess(req).getConfig().getBoolean("gitiles", "renderMarkdown", true)) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        RevTree root = getRoot(view, rw);
        if (root == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile navmd = findFile(rw, root, "navbar.md");
        String etag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        if (etag != null && etag.equals(etag(srcmd, navmd))) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        srcmd.read(rw.getObjectReader());
        if (navmd != null) {
            navmd.read(rw.getObjectReader());
        }
        MarkdownHelper fmt = new MarkdownHelper(view);
        RootNode doc = parseFile(view, fmt, srcmd);
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        RootNode nav = navmd != null ? parseFile(view, fmt, navmd) : null;
        res.setHeader(HttpHeaders.ETAG, etag(srcmd, navmd));
        showDoc(req, res, view, fmt, nav, doc);
    } finally {
        rw.release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Config cfg = getAccess(req).getConfig();
    if (!cfg.getBoolean("markdown", "render", true)) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk rw = new RevWalk(repo);
    try {
        String path = view.getPathPart();
        RevTree root;
        try {
            root = rw.parseTree(view.getRevision().getId());
        } catch (IncorrectObjectTypeException e) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile srcmd = findFile(rw, root, path);
        if (srcmd == null) {
            res.setStatus(SC_NOT_FOUND);
            return;
        }
        SourceFile navmd = findFile(rw, root, NAVBAR_MD);
        String reqEtag = req.getHeader(HttpHeaders.IF_NONE_MATCH);
        String curEtag = etag(srcmd, navmd);
        if (reqEtag != null && reqEtag.equals(curEtag)) {
            res.setStatus(SC_NOT_MODIFIED);
            return;
        }
        view = view.toBuilder().setPathPart(srcmd.path).build();
        int inputLimit = cfg.getInt("markdown", "inputLimit", 5 << 20);
        RootNode doc = GitilesMarkdown.parseFile(view, srcmd.path, srcmd.read(rw.getObjectReader(), inputLimit));
        if (doc == null) {
            res.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
        RootNode nav = null;
        if (navmd != null) {
            nav = GitilesMarkdown.parseFile(view, navmd.path, navmd.read(rw.getObjectReader(), inputLimit));
            if (nav == null) {
                res.setStatus(SC_INTERNAL_SERVER_ERROR);
                return;
            }
        }
        res.setHeader(HttpHeaders.ETAG, curEtag);
        showDoc(req, res, view, nav, doc);
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private static String etag(SourceFile srcmd, SourceFile navmd) {
    List<String> p = new ArrayList<>(3);
    p.add(GEN);
    p.add(srcmd.id.name());
    if (navmd != null) {
        p.add(navmd.id.name());
    }
    return Joiner.on('-').join(p);
}
#method_after
private String etag(SourceFile srcmd, SourceFile navmd) {
    byte[] b = new byte[Constants.OBJECT_ID_LENGTH];
    Hasher h = Hashing.sha1().newHasher();
    h.putInt(ETAG_GEN);
    renderer.getTemplateHash(SOY_FILE).writeBytesTo(b, 0, b.length);
    h.putBytes(b);
    if (navmd != null) {
        navmd.id.copyRawTo(b, 0);
        h.putBytes(b);
    }
    srcmd.id.copyRawTo(b, 0);
    h.putBytes(b);
    return h.hash().toString();
}
#end_block

#method_before
@Override
protected void setCacheHeaders(HttpServletResponse res) {
    long now = System.currentTimeMillis();
    res.setDateHeader("Expires", now);
    res.setDateHeader("Date", now);
    res.setHeader("Cache-Control", "private, max-age=0, must-revalidate");
}
#method_after
@Override
protected void setCacheHeaders(HttpServletResponse res) {
    long now = System.currentTimeMillis();
    res.setDateHeader(HttpHeaders.EXPIRES, now);
    res.setDateHeader(HttpHeaders.DATE, now);
    res.setHeader(HttpHeaders.CACHE_CONTROL, "private, max-age=0, must-revalidate");
}
#end_block

#method_before
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, MarkdownHelper fmt, RootNode nav, RootNode doc) throws IOException {
    String title = MoreObjects.firstNonNull(Strings.emptyToNull(fmt.getTitle(doc)), view.getPathPart());
    Map<String, Object> data = new HashMap<>();
    fmt.populateBanner(data, nav);
    data.put("breadcrumbs", null);
    data.put("repositoryName", null);
    data.put("title", title);
    data.put("navbarHtml", fmt.renderHTML(nav));
    data.put("bodyHtml", fmt.renderHTML(doc));
    data.put("sourceUrl", GitilesView.path().copyFrom(view).setRevision(view.getRevision().getId().getName()).toUrl());
    data.put("logUrl", GitilesView.log().copyFrom(view).setRevision(view.getRevision().getId().getName()).toUrl());
    data.put("blameUrl", GitilesView.blame().copyFrom(view).setRevision(view.getRevision().getId().getName()).toUrl());
    renderHtml(req, res, "gitiles.markdownDoc", data);
}
#method_after
private void showDoc(HttpServletRequest req, HttpServletResponse res, GitilesView view, RootNode nav, RootNode doc) throws IOException {
    Map<String, Object> data = new HashMap<>();
    data.putAll(Navbar.bannerSoyData(view, nav));
    data.put("pageTitle", MoreObjects.firstNonNull(MarkdownHelper.getTitle(doc), view.getPathPart()));
    data.put("sourceUrl", GitilesView.path().copyFrom(view).toUrl());
    data.put("logUrl", GitilesView.log().copyFrom(view).toUrl());
    data.put("blameUrl", GitilesView.blame().copyFrom(view).toUrl());
    data.put("navbarHtml", new MarkdownToHtml(view).toSoyHtml(nav));
    data.put("bodyHtml", new MarkdownToHtml(view).toSoyHtml(doc));
    String page = renderer.render(SOY_TEMPLATE, data);
    byte[] raw = page.getBytes(UTF_8);
    res.setContentType(FormatType.HTML.getMimeType());
    res.setCharacterEncoding(UTF_8.name());
    setCacheHeaders(res);
    if (acceptsGzipEncoding(req)) {
        res.setHeader(HttpHeaders.CONTENT_ENCODING, "gzip");
        raw = gzip(raw);
    }
    res.setContentLength(raw.length);
    res.setStatus(HttpServletResponse.SC_OK);
    res.getOutputStream().write(raw);
}
#end_block

#method_before
void read(ObjectReader reader) throws IOException {
    ObjectLoader obj = reader.open(id, OBJ_BLOB);
    byte[] raw = obj.getCachedBytes(MAX_MD_BYTES);
    text = RawParseUtils.decode(raw);
}
#method_after
String read(ObjectReader reader, int inputLimit) throws IOException {
    ObjectLoader obj = reader.open(id, OBJ_BLOB);
    byte[] raw = obj.getCachedBytes(inputLimit);
    return RawParseUtils.decode(raw);
}
#end_block

#method_before
public static String getInnerText(Node h) {
    List<Node> ch = h.getChildren();
    if (ch == null || ch.isEmpty()) {
        return null;
    }
    StringBuilder b = new StringBuilder();
    for (Node n : ch) {
        if (n instanceof TextNode) {
            b.append(((TextNode) n).getText());
        }
    }
    return Strings.emptyToNull(b.toString().trim());
}
#method_after
public static String getInnerText(Node node) {
    if (node == null || node.getChildren().isEmpty()) {
        return null;
    }
    StringBuilder b = new StringBuilder();
    appendTextFromChildren(b, node);
    return Strings.emptyToNull(b.toString().trim());
}
#end_block

#method_before
@Override
public void accept(Visitor visitor) {
    visitor.visit(this);
}
#method_after
@Override
public void accept(org.pegdown.ast.Visitor visitor) {
    ((Visitor) visitor).visit(this);
}
#end_block

#method_before
@Override
public List<Node> getChildren() {
    return null;
}
#method_after
@Override
public List<Node> getChildren() {
    return Collections.emptyList();
}
#end_block

#method_before
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    ChangeInfo cherryInfo = cherry.get();
    assertThat((Iterable<?>) cherryInfo.messages).hasSize(1);
    Iterator<ChangeMessageInfo> it = cherryInfo.messages.iterator();
    assertThat(it.next().message).isEqualTo("Cherry picked as patch set 1.");
    assertThat(cherryInfo.subject).contains(in.message);
    assertThat(cherryInfo.topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    String cherryPickedRevision = cherry.get().currentRevision;
    String expectedMessage = String.format("Patch Set 1: Cherry Picked\n\n" + "This patchset was cherry picked to branch %s as commit %s", in.destination, cherryPickedRevision);
    Iterator<ChangeMessageInfo> origIt = orig.get().messages.iterator();
    origIt.next();
    assertThat(origIt.next().message).isEqualTo(expectedMessage);
    assertThat((Iterable<?>) cherry.get().messages).hasSize(1);
    Iterator<ChangeMessageInfo> cherryIt = cherry.get().messages.iterator();
    expectedMessage = "Patch Set 1: Cherry Picked from branch master.";
    assertThat(cherryIt.next().message).isEqualTo(expectedMessage);
    assertThat(cherry.get().subject).contains(in.message);
    assertThat(cherry.get().topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
public static void registerClass(Event event) {
    typesByString.put(event.getType(), event.getClass());
}
#method_after
public static void registerClass(Event event) {
    String type = event.getType();
    if (typesByString.containsKey(type)) {
        throw new IllegalArgumentException("Event type already registered: " + type);
    }
    typesByString.put(type, event.getClass());
}
#end_block

#method_before
public static Class getClass(String type) {
    return typesByString.get(type);
}
#method_after
public static Class<?> getClass(String type) {
    return typesByString.get(type);
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, final Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(new HttpResponse<T>(res, null, null));
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        long start = System.currentTimeMillis();
        final T data;
        final String type;
        if (isJsonBody(res)) {
            try {
                // javac generics bug
                data = RestApi.<T>cast(parseJson(res));
                type = JSON_TYPE;
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else if (isEncodedBase64(res)) {
            data = NativeString.wrap(decodeBase64(res.getText())).cast();
            type = simpleType(res.getHeader("X-FYI-Content-Type"));
        } else if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            type = TEXT_TYPE;
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        Scheduler.ScheduledCommand cmd = new Scheduler.ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    cb.onSuccess(new HttpResponse<>(res, type, data));
                } finally {
                    if (!background) {
                        RpcStatus.INSTANCE.onRpcComplete();
                    }
                }
            }
        };
        // Defer handling the response if the parse took a while.
        if ((System.currentTimeMillis() - start) > 75) {
            Scheduler.get().scheduleDeferred(cmd);
        } else {
            cmd.execute();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#method_after
@Override
public void onResponseReceived(Request req, final Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(new HttpResponse<T>(res, null, null));
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        long start = System.currentTimeMillis();
        final T data;
        final String type;
        if (isJsonBody(res)) {
            try {
                JSONValue val = parseJson(res);
                if (isJsonEncoded(res) && val.isString() != null) {
                    data = NativeString.wrap(val.isString().stringValue()).cast();
                    type = simpleType(res.getHeader("X-FYI-Content-Type"));
                } else {
                    data = RestApi.<T>cast(val);
                    type = JSON_TYPE;
                }
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            type = TEXT_TYPE;
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        Scheduler.ScheduledCommand cmd = new Scheduler.ScheduledCommand() {

            @Override
            public void execute() {
                try {
                    cb.onSuccess(new HttpResponse<>(res, type, data));
                } finally {
                    if (!background) {
                        RpcStatus.INSTANCE.onRpcComplete();
                    }
                }
            }
        };
        // Defer handling the response if the parse took a while.
        if ((System.currentTimeMillis() - start) > 75) {
            Scheduler.get().scheduleDeferred(cmd);
        } else {
            cmd.execute();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
public <T extends JavaScriptObject> void post(String content, HttpCallback<T> cb) {
    sendRaw(POST, content, cb);
}
#method_after
public <T extends JavaScriptObject> void post(String content, HttpCallback<T> cb) {
    sendText(POST, content, cb);
}
#end_block

#method_before
public <T extends JavaScriptObject> void put(String content, HttpCallback<T> cb) {
    sendRaw(PUT, content, cb);
}
#method_after
public <T extends JavaScriptObject> void put(String content, HttpCallback<T> cb) {
    sendText(PUT, content, cb);
}
#end_block

#method_before
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#method_after
private void appendAndLogErrorMessage(StringBuilder errorMessages, ReceiveCommand cmd) {
    String msg = null;
    switch(cmd.getResult()) {
        case REJECTED_CURRENT_BRANCH:
            msg = format("Cannot delete %s: it is the current branch", cmd.getRefName());
            break;
        case REJECTED_OTHER_REASON:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getMessage());
            break;
        default:
            msg = format("Cannot delete %s: %s", cmd.getRefName(), cmd.getResult());
            break;
    }
    log.error(msg);
    errorMessages.append(msg);
    errorMessages.append("\n");
}
#end_block

#method_before
private static BinaryResult stackBase64(HttpServletResponse res, final BinaryResult src) throws IOException {
    BinaryResult b64;
    long len = src.getContentLength();
    if (0 <= len && len <= (7 << 20)) {
        b64 = base64(src);
    } else {
        b64 = new BinaryResult() {

            @Override
            public void writeTo(final OutputStream out) throws IOException {
                try (OutputStreamWriter w = new OutputStreamWriter(new OutputStream() {

                    @Override
                    public void write(int b) throws IOException {
                        out.write(b);
                    }

                    @Override
                    public void close() {
                    // do not close `out`, but only `w` and `e`
                    }
                }, ISO_8859_1);
                    OutputStream e = BaseEncoding.base64().encodingStream(w)) {
                    src.writeTo(e);
                    e.flush();
                }
            }
        };
    }
    res.setHeader("X-FYI-Content-Encoding", "base64");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1");
}
#method_after
private static BinaryResult stackBase64(HttpServletResponse res, final BinaryResult src) throws IOException {
    BinaryResult b64;
    long len = src.getContentLength();
    if (0 <= len && len <= (7 << 20)) {
        b64 = base64(src);
    } else {
        b64 = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try (OutputStreamWriter w = new OutputStreamWriter(new FilterOutputStream(out) {

                    @Override
                    public void close() {
                    // Do not close out, but only w and e.
                    }
                }, ISO_8859_1);
                    OutputStream e = BaseEncoding.base64().encodingStream(w)) {
                    src.writeTo(e);
                }
            }
        };
    }
    res.setHeader("X-FYI-Content-Encoding", "base64");
    res.setHeader("X-FYI-Content-Type", src.getContentType());
    return b64.setContentType("text/plain").setCharacterEncoding("ISO-8859-1");
}
#end_block

#method_before
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (Gerrit.getConfig().getMuteCommonPathsInFileTable()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#method_after
private void columnPath(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().pathColumn()).openAnchor();
    String path = info.path();
    if (mode == Mode.EDIT && !isEditable(info)) {
        sb.setAttribute("onclick", RESTORE + "(event," + info._row() + ")");
    } else {
        sb.setAttribute("href", "#" + url(info)).setAttribute("onclick", OPEN + "(event," + info._row() + ")");
    }
    if (Patch.COMMIT_MSG.equals(path)) {
        sb.append(Util.C.commitMessage());
    } else if (!hasUser || Gerrit.getUserAccount().getGeneralPreferences().isMuteCommonPathPrefixes()) {
        int commonPrefixLen = commonPrefix(path);
        if (commonPrefixLen > 0) {
            sb.openSpan().setStyleName(R.css().commonPrefix()).append(path.substring(0, commonPrefixLen)).closeSpan();
        }
        sb.append(path.substring(commonPrefixLen));
        lastPath = path;
    } else {
        sb.append(path);
    }
    sb.closeAnchor();
    if (info.old_path() != null) {
        sb.br();
        sb.openSpan().setStyleName(R.css().renameCopySource()).append(info.old_path()).closeSpan();
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary() && !ChangeType.DELETED.matches(info.status())) {
        if (ChangeType.ADDED.matches(info.status())) {
            sb.append(info.lines_inserted()).append(" lines");
        } else {
            sb.append("+").append(info.lines_inserted()).append(", -").append(info.lines_deleted());
        }
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        sb.append(info.lines_inserted() + info.lines_deleted());
    }
    sb.closeTd();
}
#end_block

#method_before
private Injector newRootInjector(final PluginGuiceEnvironment env) {
    List<Module> modules = Lists.newArrayListWithCapacity(4);
    if (getApiType() == ApiType.PLUGIN) {
        modules.add(env.getSysModule());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(PluginUser.class).toInstance(getPluginUser());
            bind(String.class).annotatedWith(PluginName.class).toInstance(getName());
            bind(String.class).annotatedWith(PluginCanonicalWebUrl.class).toInstance(pluginCanonicalWebUrl);
            bind(File.class).annotatedWith(PluginData.class).toProvider(new Provider<File>() {

                private volatile boolean ready;

                @Override
                public File get() {
                    synchronized (dataDir) {
                        if (!ready) {
                            if (!dataDir.exists() && !dataDir.mkdirs()) {
                                throw new ProvisionException(String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName()));
                            }
                            ready = true;
                        }
                    }
                    return dataDir;
                }
            });
        }
    });
    return Guice.createInjector(modules);
}
#method_after
private Injector newRootInjector(final PluginGuiceEnvironment env) {
    List<Module> modules = Lists.newArrayListWithCapacity(4);
    if (getApiType() == ApiType.PLUGIN) {
        modules.add(env.getSysModule());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(PluginUser.class).toInstance(getPluginUser());
            bind(String.class).annotatedWith(PluginName.class).toInstance(getName());
            bind(String.class).annotatedWith(PluginCanonicalWebUrl.class).toInstance(pluginCanonicalWebUrl);
            bind(File.class).annotatedWith(PluginData.class).toProvider(new Provider<File>() {

                private volatile boolean ready;

                @Override
                public File get() {
                    if (!ready) {
                        synchronized (dataDir) {
                            if (!ready) {
                                if (!dataDir.exists() && !dataDir.mkdirs()) {
                                    throw new ProvisionException(String.format("Cannot create %s for plugin %s", dataDir.getAbsolutePath(), getName()));
                                }
                                ready = true;
                            }
                        }
                    }
                    return dataDir;
                }
            });
        }
    });
    return Guice.createInjector(modules);
}
#end_block

#method_before
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result).hasSize(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void createDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        addDraft(changeId, revId, comment);
        Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
        assertThat(result).hasSize(1);
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Side.REVISION, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void postComment() throws Exception {
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
        PushOneCommit.Result r = push.to(git, "refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        ReviewInput.CommentInput comment = newCommentInfo(file, Side.REVISION, line, "comment 1");
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void putDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
    String uuid = actual.id;
    comment.message = "updated comment 1";
    updateDraft(changeId, revId, comment, uuid);
    result = getDraftComments(changeId, revId);
    actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void putDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        addDraft(changeId, revId, comment);
        Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
        String uuid = actual.id;
        comment.message = "updated comment 1";
        updateDraft(changeId, revId, comment, uuid);
        result = getDraftComments(changeId, revId);
        actual = Iterables.getOnlyElement(result.get(comment.path));
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void getDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    CommentInfo actual = getDraftComment(changeId, revId, returned.id);
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void getDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        CommentInfo returned = addDraft(changeId, revId, comment);
        CommentInfo actual = getDraftComment(changeId, revId, returned.id);
        assertCommentInfo(comment, actual);
    }
}
#end_block

#method_before
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts).isEmpty();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    for (Integer line : lines) {
        PushOneCommit.Result r = createChange();
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput.CommentInput comment = newCommentInfo("file1", Side.REVISION, line, "comment 1");
        CommentInfo returned = addDraft(changeId, revId, comment);
        deleteDraft(changeId, revId, returned.id);
        Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
        assertThat(drafts).isEmpty();
    }
}
#end_block

#method_before
private ReviewInput.CommentInput newCommentInfo(String path, Side side, String message) {
    ReviewInput.CommentInput input = new ReviewInput.CommentInput();
    input.path = path;
    input.side = side;
    input.line = 1;
    input.message = message;
    Comment.Range range = new Comment.Range();
    range.startLine = 1;
    range.startCharacter = 1;
    range.endLine = 1;
    range.endCharacter = 5;
    input.range = range;
    return input;
}
#method_after
private ReviewInput.CommentInput newCommentInfo(String path, Side side, int line, String message) {
    ReviewInput.CommentInput input = new ReviewInput.CommentInput();
    input.path = path;
    input.side = side;
    input.line = line != 0 ? line : null;
    input.message = message;
    if (line != 0) {
        Comment.Range range = new Comment.Range();
        range.startLine = 1;
        range.startCharacter = 1;
        range.endLine = 1;
        range.endCharacter = 5;
        input.range = range;
    }
    return input;
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new BadRequestException("cannot upload drafts");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.size() != 1) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                if (!rsrc.getControl().controlFor(change).isVisible(db.get())) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("cannot upload drafts");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.size() != 1) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                if (!rsrc.getControl().controlFor(change).isVisible(db.get())) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Test
public void createDraftChangeNotAllowed() throws Exception {
    assume().that(isAllowDrafts()).isFalse();
    ChangeInfo ci = newChangeInfo(ChangeStatus.DRAFT);
    RestResponse r = adminSession.post("/changes/", ci);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_BAD_REQUEST);
    assertThat(r.getEntityContent()).contains("cannot upload drafts");
}
#method_after
@Test
public void createDraftChangeNotAllowed() throws Exception {
    assume().that(isAllowDrafts()).isFalse();
    ChangeInfo ci = newChangeInfo(ChangeStatus.DRAFT);
    RestResponse r = adminSession.post("/changes/", ci);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_METHOD_NOT_ALLOWED);
    assertThat(r.getEntityContent()).contains("cannot upload drafts");
}
#end_block

#method_before
@Override
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        @Override
        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    queryBuilder.create(currentUser).parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#method_after
@Override
public void addProjectWatch(final String projectName, final String filter, final AsyncCallback<AccountProjectWatchInfo> callback) {
    run(callback, new Action<AccountProjectWatchInfo>() {

        @Override
        public AccountProjectWatchInfo run(ReviewDb db) throws OrmException, NoSuchProjectException, InvalidQueryException {
            final Project.NameKey nameKey = new Project.NameKey(projectName);
            final ProjectControl ctl = projectControlFactory.validateFor(nameKey);
            if (filter != null) {
                try {
                    queryBuilder.parse(filter);
                } catch (QueryParseException badFilter) {
                    throw new InvalidQueryException(badFilter.getMessage(), filter);
                }
            }
            AccountProjectWatch watch = new AccountProjectWatch(new AccountProjectWatch.Key(((IdentifiedUser) ctl.getCurrentUser()).getAccountId(), nameKey, filter));
            try {
                db.accountProjectWatches().insert(Collections.singleton(watch));
            } catch (OrmDuplicateKeyException alreadyHave) {
                watch = db.accountProjectWatches().get(watch.getKey());
            }
            return new AccountProjectWatchInfo(watch, ctl.getProject());
        }
    });
}
#end_block

#method_before
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb;
    Predicate<ChangeData> p = null;
    if (user == null) {
        qb = args.queryBuilder.create(Providers.of(args.anonymousUser));
    } else {
        qb = args.queryBuilder.create(Providers.of(user));
        p = qb.is_visible();
    }
    if (filter != null) {
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
    }
    return p == null || p.match(changeData);
}
#method_after
private boolean filterMatch(CurrentUser user, String filter) throws OrmException, QueryParseException {
    ChangeQueryBuilder qb;
    Predicate<ChangeData> p = null;
    if (user == null) {
        qb = args.queryBuilder.asUser(args.anonymousUser);
    } else {
        qb = args.queryBuilder.asUser(user);
        p = qb.is_visible();
    }
    if (filter != null) {
        Predicate<ChangeData> filterPredicate = qb.parse(filter);
        if (p == null) {
            p = filterPredicate;
        } else {
            p = Predicate.and(filterPredicate, p);
        }
    }
    return p == null || p.match(changeData);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> has(String value) {
    if ("star".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, userProvider.get());
    }
    if ("draft".equalsIgnoreCase(value)) {
        return new HasDraftByPredicate(args, self());
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("draft".equalsIgnoreCase(value)) {
        return new HasDraftByPredicate(args, self());
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, userProvider.get());
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, userProvider.get(), false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, userProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return new IsStarredByPredicate(args, userProvider.get());
    }
    Set<Account.Id> m = parseAccount(who);
    List<IsStarredByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(new IsStarredByPredicate(args, args.userFactory.create(args.db, id)));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> starredby(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return new IsStarredByPredicate(args);
    }
    Set<Account.Id> m = parseAccount(who);
    List<IsStarredByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(new IsStarredByPredicate(args.asUser(id)));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        CurrentUser user = userProvider.get();
        if (user.isIdentifiedUser() && id.equals(((IdentifiedUser) user).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, user, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.db, id), true));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    Account.Id callerId;
    try {
        CurrentUser caller = args.self.get();
        if (caller.isIdentifiedUser()) {
            callerId = ((IdentifiedUser) caller).getAccountId();
        } else {
            callerId = null;
        }
    } catch (ProvisionException e) {
        callerId = null;
    }
    for (Account.Id id : m) {
        // Each child IsWatchedByPredicate includes a visibility filter for the
        // corresponding user, to ensure that predicate subtree only returns
        // changes visible to that user. The exception is if one of the users is
        // the caller of this method, in which case visibility is already being
        // checked at the top level.
        p.add(new IsWatchedByPredicate(args.asUser(id), !id.equals(callerId)));
    }
    return Predicate.or(p);
}
#end_block

#method_before
public Predicate<ChangeData> is_visible() {
    return visibleto(userProvider.get());
}
#method_after
public Predicate<ChangeData> is_visible() throws QueryParseException {
    return visibleto(args.getCurrentUser());
}
#end_block

#method_before
private Account.Id self() {
    CurrentUser user = userProvider.get();
    if (user.isIdentifiedUser()) {
        return ((IdentifiedUser) user).getAccountId();
    }
    throw new IllegalArgumentException();
}
#method_after
private Account.Id self() throws QueryParseException {
    return args.getIdentifiedUser().getAccountId();
}
#end_block

#method_before
boolean isDisabled() {
    return getPermittedLimit() <= 0;
}
#method_after
boolean isDisabled() {
    return permittedLimit <= 0;
}
#end_block

#method_before
private int getEffectiveLimit(Predicate<ChangeData> p) {
    List<Integer> possibleLimits = new ArrayList<>(3);
    possibleLimits.add(getPermittedLimit());
    if (limitFromCaller > 0) {
        possibleLimits.add(limitFromCaller);
    }
    Integer limitFromPredicate = LimitPredicate.getLimit(p);
    if (limitFromPredicate != null) {
        possibleLimits.add(limitFromPredicate);
    }
    return Ordering.natural().min(possibleLimits);
}
#method_after
private int getEffectiveLimit(Predicate<ChangeData> p) {
    List<Integer> possibleLimits = new ArrayList<>(3);
    possibleLimits.add(permittedLimit);
    if (limitFromCaller > 0) {
        possibleLimits.add(limitFromCaller);
    }
    Integer limitFromPredicate = LimitPredicate.getLimit(p);
    if (limitFromPredicate != null) {
        possibleLimits.add(limitFromPredicate);
    }
    return Ordering.natural().min(possibleLimits);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db, String mergeResultRev) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
private void fireEventForUnrestrictedListeners(final Event event) {
    for (ChangeListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#method_after
private void fireEventForUnrestrictedListeners(final Event event) {
    for (EventListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#end_block

#method_before
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(Branch.NameKey branchName, final Event event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) {
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    hooks.addChangeListener(listener, currentUser);
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes("UTF-8"));
        err.flush();
        onExit(1);
        return;
    }
    stdout = toPrintWriter(out);
    hooks.addEventListener(listener, currentUser);
}
#end_block

#method_before
@Override
protected void onExit(final int rc) {
    hooks.removeChangeListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#method_after
@Override
protected void onExit(final int rc) {
    hooks.removeEventListener(listener);
    synchronized (taskLock) {
        done = true;
    }
    super.onExit(rc);
}
#end_block

#method_before
@Override
public void destroy() {
    hooks.removeChangeListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#method_after
@Override
public void destroy() {
    hooks.removeEventListener(listener);
    final boolean exit;
    synchronized (taskLock) {
        if (task != null) {
            task.cancel(true);
            // onExit will be invoked by the task cancellation.
            exit = false;
        } else {
            exit = !done;
        }
        done = true;
    }
    if (exit) {
        onExit(0);
    }
}
#end_block

#method_before
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            hooks.removeChangeListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#method_after
private void writeEvents() {
    int processed = 0;
    while (processed < BATCH_SIZE) {
        if (Thread.interrupted() || stdout.checkError()) {
            // The other side either requested a shutdown by calling our
            // destroy() above, or it closed the stream and is no longer
            // accepting output. Either way terminate this instance.
            // 
            hooks.removeEventListener(listener);
            flush();
            onExit(0);
            return;
        }
        if (dropped) {
            write(droppedOutputEvent);
            dropped = false;
        }
        final Event event = poll();
        if (event == null) {
            break;
        }
        write(event);
        processed++;
    }
    flush();
    if (BATCH_SIZE <= processed) {
        // 
        synchronized (taskLock) {
            task = pool.submit(writer);
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    boolean useTopicSubmit = submitWholeTopic && !resource.getChange().getTopic().isEmpty();
    return new UiAction.Description().setLabel(useTopicSubmit ? labelSubmitTopic : label).setTitle(useTopicSubmit ? titlePatternSubmitTopic : Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = submitToDatabase(db, change, timestamp);
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
@Override
public int hashCode() {
    return computedHashCode();
}
#method_after
@Override
public int hashCode() {
    return cachedHashCode();
}
#end_block

#method_before
private void setUpChange() throws Exception {
    change = new Change(new Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new Change.Id(1), userId, new Branch.NameKey(allProjects, "refs/heads/master"), TimeUtil.nowTs());
    ChangeUtil.computeSortKey(change);
    PatchSetInfo ps = new PatchSetInfo(new PatchSet.Id(change.getId(), 1));
    ps.setSubject("Test change");
    change.setCurrentPatchSet(ps);
    db.changes().insert(ImmutableList.of(change));
}
#method_after
private void setUpChange() throws Exception {
    change = new Change(new Change.Key("Iabcd1234abcd1234abcd1234abcd1234abcd1234"), new Change.Id(1), userId, new Branch.NameKey(allProjects, "refs/heads/master"), TimeUtil.nowTs());
    PatchSetInfo ps = new PatchSetInfo(new PatchSet.Id(change.getId(), 1));
    ps.setSubject("Test change");
    change.setCurrentPatchSet(ps);
    db.changes().insert(ImmutableList.of(change));
}
#end_block

#method_before
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        patchSets.add(parsePatchSet(token));
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#method_after
@Argument(index = 0, required = true, multiValued = true, metaVar = "{COMMIT | CHANGE,PATCHSET}", usage = "list of commits or patch sets to review")
void addPatchSetId(final String token) {
    try {
        PatchSet ps = CommandUtils.parsePatchSet(token, db, projectControl, branch);
        patchSets.add(ps);
    } catch (UnloggedFailure e) {
        throw new IllegalArgumentException(e.getMessage(), e);
    } catch (OrmException e) {
        throw new IllegalArgumentException("database error", e);
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        ins.setHashtags(magicBranch.getHashtags());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private ListMultimap<Change.Id, Ref> refsByChange() {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange;
}
#method_after
private ListMultimap<Change.Id, Ref> refsByChange() {
    initChangeRefMaps();
    return refsByChange;
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.hasEmailAddress(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByKey(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByBranch(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByBranch(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, UnprocessableEntityException, OrmException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change.getId());
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    indexWrite.checkedGet();
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<CommentInput>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<CommentInput>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getControl()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<CommentInput>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, revision.getChange().currentPatchSetId()));
        }
        List<CommentInput> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<CommentInput> listItr = list.iterator();
        while (listItr.hasNext()) {
            CommentInput c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line != null && c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.nullToEmpty(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    if (submitWholeTopic && !topic.isEmpty()) {
        List<ChangeData> changesByTopic = null;
        try {
            changesByTopic = queryProvider.get().byTopic(topic);
        } catch (OrmException e) {
            throw new OrmRuntimeException(e);
        }
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        // tooltip. Caution: Check access control for those changes.
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(areChangesSubmittable(changesByTopic, resource.getUser()));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true);
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    ChangeUtil.computeSortKey(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    if (submitWholeTopic) {
        return submitWholeTopic(rsrc, caller, force);
    } else {
        return submitThisChange(rsrc, caller, force);
    }
}
#end_block

#method_before
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, Collection<String> usernames) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    boolean hasUsernames = usernames != null && !usernames.isEmpty();
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (hasUsernames) {
            if (!perUser && sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
                perUser = ((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref);
            }
            for (String username : usernames) {
                if (sm.match(ref, username)) {
                    sectionToProject.put(sm.section, sm.project);
                    break;
                }
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                if (addRule) {
                    List<PermissionRule> r = permissions.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        permissions.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, ruleProps, perUser);
}
#method_after
PermissionCollection filter(Iterable<SectionMatcher> matcherList, String ref, Provider<? extends Collection<String>> usernameProvider) {
    if (isRE(ref)) {
        ref = RefControl.shortestExample(ref);
    } else if (ref.endsWith("/*")) {
        ref = ref.substring(0, ref.length() - 1);
    }
    Collection<String> usernames = null;
    boolean perUser = false;
    Map<AccessSection, Project.NameKey> sectionToProject = Maps.newLinkedHashMap();
    for (SectionMatcher sm : matcherList) {
        // 
        if (sm.matcher instanceof RefPatternMatcher.ExpandParameters) {
            if (!((RefPatternMatcher.ExpandParameters) sm.matcher).matchPrefix(ref)) {
                continue;
            }
            perUser = true;
            if (usernames == null) {
                usernames = usernameProvider.get();
            }
            for (String username : usernames) {
                if (sm.match(ref, username)) {
                    sectionToProject.put(sm.section, sm.project);
                    break;
                }
            }
        } else if (sm.match(ref, null)) {
            sectionToProject.put(sm.section, sm.project);
        }
    }
    List<AccessSection> sections = Lists.newArrayList(sectionToProject.keySet());
    sorter.sort(ref, sections);
    Set<SeenRule> seen = new HashSet<>();
    Set<String> exclusiveGroupPermissions = new HashSet<>();
    HashMap<String, List<PermissionRule>> permissions = new HashMap<>();
    HashMap<String, List<PermissionRule>> overridden = new HashMap<>();
    Map<PermissionRule, ProjectRef> ruleProps = Maps.newIdentityHashMap();
    for (AccessSection section : sections) {
        Project.NameKey project = sectionToProject.get(section);
        for (Permission permission : section.getPermissions()) {
            boolean exclusivePermissionExists = exclusiveGroupPermissions.contains(permission.getName());
            for (PermissionRule rule : permission.getRules()) {
                SeenRule s = SeenRule.create(section, permission, rule);
                boolean addRule;
                if (rule.isBlock()) {
                    addRule = true;
                } else {
                    addRule = seen.add(s) && !rule.isDeny() && !exclusivePermissionExists;
                }
                HashMap<String, List<PermissionRule>> p = null;
                if (addRule) {
                    p = permissions;
                } else if (!rule.isDeny() && !exclusivePermissionExists) {
                    p = overridden;
                }
                if (p != null) {
                    List<PermissionRule> r = p.get(permission.getName());
                    if (r == null) {
                        r = new ArrayList<>(2);
                        p.put(permission.getName(), r);
                    }
                    r.add(rule);
                    ruleProps.put(rule, ProjectRef.create(project, section.getName()));
                }
            }
            if (permission.getExclusiveGroup()) {
                exclusiveGroupPermissions.add(permission.getName());
            }
        }
    }
    return new PermissionCollection(permissions, overridden, ruleProps, perUser);
}
#end_block

#method_before
static SeenRule create(AccessSection section, Permission permission, PermissionRule rule) {
    return new AutoValue_PermissionCollection_SeenRule(section.getName(), permission.getName(), rule.getGroup().getUUID());
}
#method_after
static SeenRule create(AccessSection section, Permission permission, @Nullable PermissionRule rule) {
    AccountGroup.UUID group = rule != null && rule.getGroup() != null ? rule.getGroup().getUUID() : null;
    return new AutoValue_PermissionCollection_SeenRule(section.getName(), permission.getName(), group);
}
#end_block

#method_before
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username = lowerCaseUsername ? req.getUsername().toLowerCase(Locale.US) : req.getUsername();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword());
            }
            return new AuthUser(AuthUser.UUID.create(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#method_after
@Override
public AuthUser authenticate(AuthRequest req) throws MissingCredentialsException, InvalidCredentialsException, UnknownUserException, UserNotAllowedException, AuthException {
    if (req.getUsername() == null) {
        throw new MissingCredentialsException();
    }
    final String username = lowerCaseUsername ? req.getUsername().toLowerCase(Locale.US) : req.getUsername();
    try {
        final DirContext ctx;
        if (authConfig.getAuthType() == AuthType.LDAP_BIND) {
            ctx = helper.authenticate(username, req.getPassword());
        } else {
            ctx = helper.open();
        }
        try {
            final Helper.LdapSchema schema = helper.getSchema(ctx);
            final LdapQuery.Result m = helper.findAccount(schema, ctx, username);
            if (authConfig.getAuthType() == AuthType.LDAP) {
                // We found the user account, but we need to verify
                // the password matches it before we can continue.
                // 
                helper.authenticate(m.getDN(), req.getPassword()).close();
            }
            return new AuthUser(AuthUser.UUID.create(username), username);
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (AccountException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new InvalidCredentialsException("Cannot query LDAP for account", e);
    } catch (NamingException e) {
        log.error("Cannot query LDAP to authenticate user", e);
        throw new AuthException("Cannot query LDAP for account", e);
    } catch (LoginException e) {
        log.error("Cannot authenticate server via JAAS", e);
        throw new AuthException("Cannot query LDAP for account", e);
    }
}
#end_block

#method_before
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, getDestinationBranch(), message.getText(), null, true, new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createDraftChange(project, getDestinationBranch(), message.getText(), null, new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    IoAcceptor acceptor = sshDaemon.getIoAcceptor();
    if (acceptor == null) {
        throw new Failure(1, "fatal: sshd no longer running");
    }
    for (String sessionId : sessionIds) {
        boolean connectionFound = false;
        int id = (int) Long.parseLong(sessionId, 16);
        for (final IoSession io : acceptor.getManagedSessions().values()) {
            ServerSession serverSession = (ServerSession) ServerSession.getSession(io, true);
            SshSession sshSession = serverSession != null ? serverSession.getAttribute(SshSession.KEY) : null;
            if (sshSession.getSessionId() == id) {
                connectionFound = true;
                stdout.println("closing connection " + sessionId + "...");
                io.close(true);
                break;
            }
        }
        if (!connectionFound) {
            stderr.print("close connection " + id + ": no such connection\n");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    IoAcceptor acceptor = sshDaemon.getIoAcceptor();
    if (acceptor == null) {
        throw new Failure(1, "fatal: sshd no longer running");
    }
    for (String sessionId : sessionIds) {
        boolean connectionFound = false;
        int id = (int) Long.parseLong(sessionId, 16);
        for (IoSession io : acceptor.getManagedSessions().values()) {
            ServerSession serverSession = (ServerSession) ServerSession.getSession(io, true);
            SshSession sshSession = serverSession != null ? serverSession.getAttribute(SshSession.KEY) : null;
            if (sshSession != null && sshSession.getSessionId() == id) {
                connectionFound = true;
                stdout.println("closing connection " + sessionId + "...");
                IoCloseFuture future = io.close(true);
                if (wait) {
                    try {
                        future.await();
                        stdout.println("closed connection " + sessionId);
                    } catch (InterruptedException e) {
                        log.warn("Wait for connection to close interrupted: " + e.getMessage());
                    }
                }
                break;
            }
        }
        if (!connectionFound) {
            stderr.print("close connection " + sessionId + ": no such connection\n");
        }
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            NativeMap<ActionInfo> actions = info.edit().has_actions() ? info.edit().actions() : NativeMap.<ActionInfo>create();
            actions.copyKeysIntoChildren("id");
            if (actions.containsKey("publish")) {
                publishEdit.setVisible(true);
                publishEdit.setTitle(actions.get("publish").title());
            }
            if (actions.containsKey("rebase")) {
                rebaseEdit.setVisible(true);
                rebaseEdit.setTitle(actions.get("rebase").title());
            }
            if (actions.containsKey("/")) {
                deleteEdit.setVisible(true);
                deleteEdit.setTitle(actions.get("/").title());
            }
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    ChangeGlue.fireShowChange(changeInfo, changeInfo.revision(revision));
    CodeMirror.preload();
    startPoller();
    if (NewChangeScreenBar.show()) {
        add(new NewChangeScreenBar(changeId));
    }
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    ChangeGlue.fireShowChange(changeInfo, changeInfo.revision(revision));
    CodeMirror.preload();
    startPoller();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, reply, fileTableMode, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.get().apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query, int limit) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(query);
        mySuggestReviewers.setLimit(limit);
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    return new SuggestedReviewersRequest() {

        @Override
        public List<SuggestedReviewerInfo> get() throws RestApiException {
            return ChangeApiImpl.this.suggestReviewers(this);
        }
    };
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(query);
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    return suggestReviewers().withQuery(query);
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return ChangeInfoMapper.INSTANCE.apply(changeJson.get().addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.get().addOptions(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.allOf(ListChangesOption.class));
}
#method_after
@Override
public ChangeInfo get() throws RestApiException {
    return get(EnumSet.complementOf(EnumSet.of(ListChangesOption.CHECK)));
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.accounts", value = "false")
public void suggestReviewersNoResult1() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfig(name = "suggest.accounts", value = "false")
public void suggestReviewersNoResult1() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.accounts", value = "true"), @GerritConfig(name = "suggest.from", value = "1"), @GerritConfig(name = "accounts.visibility", value = "NONE") })
public void suggestReviewersNoResult2() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.accounts", value = "true"), @GerritConfig(name = "suggest.from", value = "1"), @GerritConfig(name = "accounts.visibility", value = "NONE") })
public void suggestReviewersNoResult2() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.from", value = "2")
public void suggestReviewersNoResult3() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 0);
}
#method_after
@Test
@GerritConfig(name = "suggest.from", value = "2")
public void suggestReviewersNoResult3() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).isEmpty();
}
#end_block

#method_before
@Test
public void suggestReviewersChange() throws GitAPIException, IOException, Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertEquals(reviewers.size(), 6);
    reviewers = suggestReviewers(changeId, "u", 5);
    assertEquals(reviewers.size(), 5);
    reviewers = suggestReviewers(changeId, "users3", 10);
    assertEquals(reviewers.size(), 1);
}
#method_after
@Test
public void suggestReviewersChange() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "u", 6);
    assertThat(reviewers).hasSize(6);
    reviewers = suggestReviewers(changeId, "u", 5);
    assertThat(reviewers).hasSize(5);
    reviewers = suggestReviewers(changeId, "users3", 10);
    assertThat(reviewers).hasSize(1);
}
#end_block

#method_before
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersSameGroupVisibility() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertTrue(reviewers.isEmpty());
    reviewers = suggestReviewers(new RestSession(server, user2), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
    reviewers = suggestReviewers(new RestSession(server, user3), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
}
#method_after
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersSameGroupVisibility() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).isEmpty();
    reviewers = suggestReviewers(new RestSession(server, user2), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
    reviewers = suggestReviewers(new RestSession(server, user3), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
}
#end_block

#method_before
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersViewAllAccounts() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertTrue(reviewers.isEmpty());
    grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertEquals(1, reviewers.size());
    assertEquals("User2", Iterables.getOnlyElement(reviewers).account.name);
}
#method_after
@Test
@GerritConfig(name = "accounts.visibility", value = "SAME_GROUP")
public void suggestReviewersViewAllAccounts() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers;
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).isEmpty();
    grantCapability(GlobalCapability.VIEW_ALL_ACCOUNTS, group1);
    reviewers = suggestReviewers(new RestSession(server, user1), changeId, "user2", 2);
    assertThat(reviewers).hasSize(1);
    assertThat(Iterables.getOnlyElement(reviewers).account.name).isEqualTo("User2");
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2")
public void suggestReviewersMaxNbrSuggestions() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5);
    assertEquals(2, reviewers.size());
}
#method_after
@Test
@GerritConfig(name = "suggest.maxSuggestedReviewers", value = "2")
public void suggestReviewersMaxNbrSuggestions() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "user", 5);
    assertThat(reviewers).hasSize(2);
}
#end_block

#method_before
@Test
@GerritConfig(name = "suggest.fullTextSearch", value = "true")
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5);
    assertEquals(4, reviewers.size());
}
#method_after
@Test
@GerritConfig(name = "suggest.fullTextSearch", value = "true")
public void suggestReviewersFullTextSearch() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 5);
    assertThat(reviewers).hasSize(4);
}
#end_block

#method_before
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.fulltextsearch", value = "true"), @GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") })
public void suggestReviewersFullTextSearchLimitMaxMatches() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3);
    assertEquals(2, reviewers.size());
}
#method_after
@Test
@GerritConfigs({ @GerritConfig(name = "suggest.fulltextsearch", value = "true"), @GerritConfig(name = "suggest.fullTextSearchMaxMatches", value = "2") })
public void suggestReviewersFullTextSearchLimitMaxMatches() throws Exception {
    String changeId = createChange().getChangeId();
    List<SuggestedReviewerInfo> reviewers = suggestReviewers(changeId, "ser", 3);
    assertThat(reviewers).hasSize(2);
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query, int limit) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public SuggestedReviewersRequest suggestReviewers(String query) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    accountLoaderFactory.create(true).fill(suggestedAccounts);
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = SUGGESTED_REVIEWER_INFO_ORDERING.sortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#method_after
@Override
public List<SuggestedReviewerInfo> apply(ChangeResource rsrc) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(query)) {
        throw new BadRequestException("missing query field");
    }
    if (!suggestAccounts || query.length() < suggestFrom) {
        return Collections.emptyList();
    }
    VisibilityControl visibilityControl = getVisibility(rsrc);
    List<AccountInfo> suggestedAccounts;
    if (useFullTextSearch) {
        suggestedAccounts = suggestAccountFullTextSearch(visibilityControl);
    } else {
        suggestedAccounts = suggestAccount(visibilityControl);
    }
    List<SuggestedReviewerInfo> reviewer = Lists.newArrayList();
    for (AccountInfo a : suggestedAccounts) {
        SuggestedReviewerInfo info = new SuggestedReviewerInfo();
        info.account = a;
        reviewer.add(info);
    }
    Project p = rsrc.getControl().getProject();
    for (GroupReference g : suggestAccountGroup(rsrc.getControl().getProjectControl())) {
        if (suggestGroupAsReviewer(p, g, visibilityControl)) {
            GroupBaseInfo info = new GroupBaseInfo();
            info.id = Url.encode(g.getUUID().get());
            info.name = g.getName();
            SuggestedReviewerInfo suggestedReviewerInfo = new SuggestedReviewerInfo();
            suggestedReviewerInfo.group = info;
            reviewer.add(suggestedReviewerInfo);
        }
    }
    reviewer = ORDERING.immutableSortedCopy(reviewer);
    if (reviewer.size() <= limit) {
        return reviewer;
    } else {
        return reviewer.subList(0, limit);
    }
}
#end_block

#method_before
private VisibilityControl getVisibility(final ChangeResource rsrc) {
    if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account account) throws OrmException {
                return true;
            }
        };
    } else {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account account) throws OrmException {
                IdentifiedUser who = identifiedUserFactory.create(dbProvider, account.getId());
                // to drafts
                return rsrc.getControl().forUser(who).isRefVisible();
            }
        };
    }
}
#method_after
private VisibilityControl getVisibility(final ChangeResource rsrc) {
    if (rsrc.getControl().getRefControl().isVisibleByRegisteredUsers()) {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account.Id account) throws OrmException {
                return true;
            }
        };
    } else {
        return new VisibilityControl() {

            @Override
            public boolean isVisibleTo(Account.Id account) throws OrmException {
                IdentifiedUser who = identifiedUserFactory.create(dbProvider, account);
                // to drafts
                return rsrc.getControl().forUser(who).isRefVisible();
            }
        };
    }
}
#end_block

#method_before
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    LinkedHashMap<Account.Id, AccountInfo> r = Maps.newLinkedHashMap();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl);
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            addSuggestion(r, p, new AccountInfo(p.getId()), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                AccountInfo info = new AccountInfo(p.getId());
                addSuggestion(r, p, info, visibilityControl);
            }
        }
    }
    return Lists.newArrayList(r.values());
}
#method_after
private List<AccountInfo> suggestAccount(VisibilityControl visibilityControl) throws OrmException {
    String a = query;
    String b = a + MAX_SUFFIX;
    Map<Account.Id, AccountInfo> r = new LinkedHashMap<>();
    Map<Account.Id, String> queryEmail = new HashMap<>();
    for (Account p : dbProvider.get().accounts().suggestByFullName(a, b, limit)) {
        if (p.isActive()) {
            addSuggestion(r, p.getId(), visibilityControl);
        }
    }
    if (r.size() < limit) {
        for (Account p : dbProvider.get().accounts().suggestByPreferredEmail(a, b, limit - r.size())) {
            if (p.isActive()) {
                addSuggestion(r, p.getId(), visibilityControl);
            }
        }
    }
    if (r.size() < limit) {
        for (AccountExternalId e : dbProvider.get().accountExternalIds().suggestByEmailAddress(a, b, limit - r.size())) {
            if (!r.containsKey(e.getAccountId())) {
                Account p = accountCache.get(e.getAccountId()).getAccount();
                if (p.isActive()) {
                    if (addSuggestion(r, p.getId(), visibilityControl)) {
                        queryEmail.put(e.getAccountId(), e.getEmailAddress());
                    }
                }
            }
        }
    }
    accountLoader.fill();
    for (Map.Entry<Account.Id, String> p : queryEmail.entrySet()) {
        AccountInfo info = r.get(p.getKey());
        if (info != null) {
            info.email = p.getValue();
        }
    }
    return new ArrayList<>(r.values());
}
#end_block

#method_before
private List<AccountInfo> suggestAccountFullTextSearch(VisibilityControl visibilityControl) throws OrmException {
    String str = query.toLowerCase();
    LinkedHashMap<Account.Id, AccountInfo> accountMap = Maps.newLinkedHashMap();
    List<Account> fullNameMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches);
    List<Account> emailMatches = Lists.newArrayListWithCapacity(fullTextMaxMatches);
    for (Account a : reviewerSuggestionCache.get()) {
        if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) {
            fullNameMatches.add(a);
        } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) {
            emailMatches.add(a);
        }
        if (fullNameMatches.size() >= fullTextMaxMatches) {
            break;
        }
    }
    for (Account a : fullNameMatches) {
        addSuggestion(accountMap, a, new AccountInfo(a.getId()), visibilityControl);
        if (accountMap.size() >= limit) {
            break;
        }
    }
    if (accountMap.size() < limit) {
        for (Account a : emailMatches) {
            addSuggestion(accountMap, a, new AccountInfo(a.getId()), visibilityControl);
            if (accountMap.size() >= limit) {
                break;
            }
        }
    }
    return Lists.newArrayList(accountMap.values());
}
#method_after
private List<AccountInfo> suggestAccountFullTextSearch(VisibilityControl visibilityControl) throws OrmException {
    String str = query.toLowerCase();
    Map<Account.Id, AccountInfo> accountMap = new LinkedHashMap<>();
    List<Account> fullNameMatches = new ArrayList<>(fullTextMaxMatches);
    List<Account> emailMatches = new ArrayList<>(fullTextMaxMatches);
    for (Account a : reviewerSuggestionCache.get()) {
        if (a.getFullName() != null && a.getFullName().toLowerCase().contains(str)) {
            fullNameMatches.add(a);
        } else if (a.getPreferredEmail() != null && emailMatches.size() < fullTextMaxMatches && a.getPreferredEmail().toLowerCase().contains(str)) {
            emailMatches.add(a);
        }
        if (fullNameMatches.size() >= fullTextMaxMatches) {
            break;
        }
    }
    for (Account a : fullNameMatches) {
        addSuggestion(accountMap, a.getId(), visibilityControl);
        if (accountMap.size() >= limit) {
            break;
        }
    }
    if (accountMap.size() < limit) {
        for (Account a : emailMatches) {
            addSuggestion(accountMap, a.getId(), visibilityControl);
            if (accountMap.size() >= limit) {
                break;
            }
        }
    }
    accountLoader.fill();
    return Lists.newArrayList(accountMap.values());
}
#end_block

#method_before
private void addSuggestion(Map<Account.Id, AccountInfo> map, Account account, AccountInfo info, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account.getId()) && account.isActive() && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControlFactory.get().canSee(account)) {
        map.put(account.getId(), info);
    }
}
#method_after
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account.Id account, VisibilityControl visibilityControl) throws OrmException {
    if (!map.containsKey(account) && // Can the suggestion see the change?
    visibilityControl.isVisibleTo(account) && // Can the account see the current user?
    accountControl.canSee(account)) {
        map.put(account, accountLoader.get(account));
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account)) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#method_after
private boolean suggestGroupAsReviewer(Project project, GroupReference group, VisibilityControl visibilityControl) throws OrmException, IOException {
    if (!PostReviewers.isLegalReviewerGroup(group.getUUID())) {
        return false;
    }
    try {
        Set<Account> members = groupMembersFactory.create(currentUser.get()).listAccounts(group.getUUID(), project.getNameKey());
        if (members.isEmpty()) {
            return false;
        }
        if (maxAllowed > 0 && members.size() > maxAllowed) {
            return false;
        }
        // require that at least one member in the group can see the change
        for (Account account : members) {
            if (visibilityControl.isVisibleTo(account.getId())) {
                return true;
            }
        }
    } catch (NoSuchGroupException e) {
        return false;
    } catch (NoSuchProjectException e) {
        return false;
    }
    return false;
}
#end_block

#method_before
static int optional(final Config config, final String name, int defaultValue) {
    return config.getInt("ldap", name, defaultValue);
}
#method_after
static int optional(Config config, String name, int defaultValue) {
    return config.getInt("ldap", name, defaultValue);
}
#end_block

#method_before
static String optional(final Config config, final String name, final String defaultValue) {
    final String v = optional(config, name);
    if (v == null || "".equals(v)) {
        return defaultValue;
    }
    return v;
}
#method_after
static String optional(Config config, String name, String defaultValue) {
    final String v = optional(config, name);
    if (Strings.isNullOrEmpty(v)) {
        return defaultValue;
    }
    return v;
}
#end_block

#method_before
static boolean optional(final Config config, final String name, final boolean defaultValue) {
    return config.getBoolean("ldap", name, defaultValue);
}
#method_after
static boolean optional(Config config, String name, boolean defaultValue) {
    return config.getBoolean("ldap", name, defaultValue);
}
#end_block

#method_before
DirContext open() throws NamingException, LoginException {
    final Properties env = createContextProperties();
    if (useConnectionPooling) {
        env.put("com.sun.jndi.ldap.connect.pool", String.valueOf(useConnectionPooling));
        if (connectTimeOutMillis != null) {
            env.put("com.sun.jndi.ldap.connect.timeout", connectTimeOutMillis);
        }
        env.put("com.sun.jndi.ldap.connect.pool.authentication", poolAuthentication);
        if (poolDebug != null) {
            env.put("com.sun.jndi.ldap.connect.pool.debug", poolDebug);
        }
        env.put("com.sun.jndi.ldap.connect.pool.initsize", poolInitsize);
        env.put("com.sun.jndi.ldap.connect.pool.maxsize", poolMaxsize);
        env.put("com.sun.jndi.ldap.connect.pool.prefsize", poolPrefsize);
        env.put("com.sun.jndi.ldap.connect.pool.protocol", poolProtocol);
        if (poolTimeoutMillis != null) {
            env.put("com.sun.jndi.ldap.connect.pool.timeout", poolTimeoutMillis);
        }
    }
    env.put(Context.SECURITY_AUTHENTICATION, authentication);
    env.put(Context.REFERRAL, referral);
    if ("GSSAPI".equals(authentication)) {
        return kerberosOpen(env);
    } else {
        if (username != null) {
            env.put(Context.SECURITY_PRINCIPAL, username);
            env.put(Context.SECURITY_CREDENTIALS, password);
        }
        return new InitialDirContext(env);
    }
}
#method_after
DirContext open() throws NamingException, LoginException {
    final Properties env = createContextProperties();
    if (connectionPoolConfig != null) {
        env.putAll(connectionPoolConfig);
    }
    env.put(Context.SECURITY_AUTHENTICATION, authentication);
    env.put(Context.REFERRAL, referral);
    if ("GSSAPI".equals(authentication)) {
        return kerberosOpen(env);
    } else {
        if (username != null) {
            env.put(Context.SECURITY_PRINCIPAL, username);
            env.put(Context.SECURITY_CREDENTIALS, password);
        }
        return new InitialDirContext(env);
    }
}
#end_block

#method_before
public Result rm(Git git, String ref) throws GitAPIException, IOException {
    GitUtil.rm(git, fileName);
    return execute(git, ref);
}
#method_after
public Result rm(Git git, String ref) throws GitAPIException {
    GitUtil.rm(git, fileName);
    return execute(git, ref);
}
#end_block

#method_before
private Result execute(Git git, String ref) throws GitAPIException, IOException, ConcurrentRefUpdateException, InvalidTagNameException, NoHeadException {
    Commit c;
    if (changeId != null) {
        c = amendCommit(git, i, subject, changeId);
    } else {
        c = createCommit(git, i, subject);
        changeId = c.getChangeId();
    }
    if (tagName != null) {
        git.tag().setName(tagName).setAnnotated(false).call();
    }
    return new Result(ref, pushHead(git, ref, tagName != null), c, subject);
}
#method_after
private Result execute(Git git, String ref) throws GitAPIException, ConcurrentRefUpdateException, InvalidTagNameException, NoHeadException {
    Commit c;
    if (changeId != null) {
        c = amendCommit(git, i, subject, changeId);
    } else {
        c = createCommit(git, i, subject);
        changeId = c.getChangeId();
    }
    if (tag != null) {
        TagCommand tagCommand = git.tag().setName(tag.name);
        if (tag instanceof AnnotatedTag) {
            AnnotatedTag annotatedTag = (AnnotatedTag) tag;
            tagCommand.setAnnotated(true).setMessage(annotatedTag.message).setTagger(annotatedTag.tagger);
        } else {
            tagCommand.setAnnotated(false);
        }
        tagCommand.call();
    }
    return new Result(ref, pushHead(git, ref, tag != null), c, subject);
}
#end_block

#method_before
public void setTag(final String tagName) {
    this.tagName = tagName;
}
#method_after
public void setTag(final Tag tag) {
    this.tag = tag;
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertEquals(subject, c.getSubject());
    assertEquals(expectedStatus, c.getStatus());
    assertEquals(expectedTopic, Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertThat(resSubj).isEqualTo(c.getSubject());
    assertThat(expectedStatus).isEqualTo(c.getStatus());
    assertThat(expectedTopic).isEqualTo(Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Set<Account.Id> expectedReviewerIds = Sets.newHashSet(Lists.transform(Arrays.asList(expectedReviewers), new Function<TestAccount, Account.Id>() {

        @Override
        public Account.Id apply(TestAccount a) {
            return a.id;
        }
    }));
    for (Account.Id accountId : approvalsUtil.getReviewers(db, notesFactory.create(c)).values()) {
        assertTrue("unexpected reviewer " + accountId, expectedReviewerIds.remove(accountId));
    }
    assertTrue("missing reviewers: " + expectedReviewerIds, expectedReviewerIds.isEmpty());
}
#method_after
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Set<Account.Id> expectedReviewerIds = Sets.newHashSet(Lists.transform(Arrays.asList(expectedReviewers), new Function<TestAccount, Account.Id>() {

        @Override
        public Account.Id apply(TestAccount a) {
            return a.id;
        }
    }));
    for (Account.Id accountId : approvalsUtil.getReviewers(db, notesFactory.create(c)).values()) {
        assertThat(expectedReviewerIds.remove(accountId)).named("unexpected reviewer " + accountId).isTrue();
    }
    assertThat(expectedReviewerIds.isEmpty()).named("missing reviewers: " + expectedReviewerIds).isTrue();
}
#end_block

#method_before
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertEquals(message(refUpdate), expectedStatus, refUpdate.getStatus());
    assertEquals(expectedMessage, refUpdate.getMessage());
}
#method_after
private void assertStatus(Status expectedStatus, String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(expectedStatus).named(message(refUpdate)).isEqualTo(refUpdate.getStatus());
    assertThat(expectedMessage).isEqualTo(refUpdate.getMessage());
}
#end_block

#method_before
public void assertMessage(String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertTrue(message(refUpdate), message(refUpdate).toLowerCase().contains(expectedMessage.toLowerCase()));
}
#method_after
public void assertMessage(String expectedMessage) {
    RemoteRefUpdate refUpdate = result.getRemoteUpdate(ref);
    assertThat(message(refUpdate).toLowerCase()).named(message(refUpdate)).contains(expectedMessage.toLowerCase());
}
#end_block

#method_before
@Override
public String content() throws RestApiException {
    try {
        BinaryResult bin = getContent.apply(file);
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        bin.writeTo(os);
        return new String(os.toByteArray(), Charsets.UTF_8);
    } catch (IOException e) {
        throw new RestApiException("Cannot retrieve file content", e);
    }
}
#method_after
@Override
public BinaryResult content() throws RestApiException {
    try {
        return getContent.apply(file);
    } catch (NoSuchChangeException | IOException | OrmException e) {
        throw new RestApiException("Cannot retrieve file content", e);
    }
}
#end_block

#method_before
@Override
public DiffInfo diff() throws RestApiException {
    try {
        return gtDiff.get().apply(file).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#method_after
@Override
public DiffInfo diff() throws RestApiException {
    try {
        return getDiff.get().apply(file).value();
    } catch (IOException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#end_block

#method_before
@Override
public DiffInfo diff(String base) throws RestApiException {
    try {
        return gtDiff.get().setBase(base).apply(file).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#method_after
@Override
public DiffInfo diff(String base) throws RestApiException {
    try {
        return getDiff.get().setBase(base).apply(file).value();
    } catch (IOException | InvalidChangeOperationException | OrmException e) {
        throw new RestApiException("Cannot retrieve diff", e);
    }
}
#end_block

#method_before
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException {
    PatchSet.Id basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet().getId();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = Objects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<DiffInfo> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %s; want %s", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %s; want %s", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        DiffInfo result = new DiffInfo();
        // TODO referring to the parent commit by refs/changes/12/60012/1^1
        // will likely not work for inline edits
        String revA = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
        String revB = resource.getRevision().getEdit().isPresent() ? resource.getRevision().getEdit().get().getRefName() : resource.getRevision().getPatchSet().getRefName();
        FluentIterable<DiffWebLinkInfo> links = webLinks.getDiffLinks(state.getProject().getName(), resource.getPatchKey().getParentKey().getParentKey().get(), basePatchSet != null ? basePatchSet.getId().get() : null, revA, MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName()), resource.getPatchKey().getParentKey().get(), revB, ps.getNewName());
        result.webLinks = links.isEmpty() ? null : links.toList();
        if (!webLinksOnly) {
            if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
                result.metaA = new FileMeta();
                result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
                result.metaA.contentType = FileContentUtil.resolveContentType(state, result.metaA.name, ps.getFileModeA(), ps.getMimeTypeA());
                result.metaA.lines = ps.getA().size();
                result.metaA.webLinks = getFileWebLinks(state.getProject(), revA, result.metaA.name);
            }
            if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
                result.metaB = new FileMeta();
                result.metaB.name = ps.getNewName();
                result.metaB.contentType = FileContentUtil.resolveContentType(state, result.metaB.name, ps.getFileModeB(), ps.getMimeTypeB());
                result.metaB.lines = ps.getB().size();
                result.metaB.webLinks = getFileWebLinks(state.getProject(), revB, result.metaB.name);
            }
            if (intraline) {
                if (ps.hasIntralineTimeout()) {
                    result.intralineStatus = IntraLineStatus.TIMEOUT;
                } else if (ps.hasIntralineFailure()) {
                    result.intralineStatus = IntraLineStatus.FAILURE;
                } else {
                    result.intralineStatus = IntraLineStatus.OK;
                }
            }
            result.changeType = CHANGE_TYPE.get(ps.getChangeType());
            if (result.changeType == null) {
                throw new IllegalStateException("unknown change type: " + ps.getChangeType());
            }
            if (ps.getPatchHeader().size() > 0) {
                result.diffHeader = ps.getPatchHeader();
            }
            result.content = content.lines;
        }
        Response<DiffInfo> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Test
public void reviewTriplet() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
}
#method_after
@Test
public void reviewTriplet() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void reviewCurrent() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
}
#method_after
@Test
public void reviewCurrent() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void reviewNumber() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(1).review(ReviewInput.approve());
    r = updateChange(r, "new content");
    gApi.changes().id(r.getChangeId()).revision(2).review(ReviewInput.approve());
}
#method_after
@Test
public void reviewNumber() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(1).review(ReviewInput.approve());
    r = updateChange(r, "new content");
    gApi.changes().id(r.getChangeId()).revision(2).review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#method_after
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#end_block

#method_before
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#end_block

#method_before
@Test
public void deleteDraft() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createDraft();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createDraft();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete();
}
#end_block

#method_before
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in);
    cApi.current().review(ReviewInput.approve());
    cApi.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    assertThat(cherry.get().subject).contains(in.message);
    assertThat(cherry.get().topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
@Test
public void canRebase() throws GitAPIException, IOException, RestApiException, Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r1 = push.to(git, "refs/for/master");
    merge(r1);
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r2 = push.to(git, "refs/for/master");
    assertFalse(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).canRebase());
    merge(r2);
    git.checkout().setName(r1.getCommit().name()).call();
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r3 = push.to(git, "refs/for/master");
    assertTrue(gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).canRebase());
}
#method_after
@Test
public void canRebase() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r1 = push.to(git, "refs/for/master");
    merge(r1);
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r2 = push.to(git, "refs/for/master");
    boolean canRebase = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).canRebase();
    assertThat(canRebase).isFalse();
    merge(r2);
    git.checkout().setName(r1.getCommit().name()).call();
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r3 = push.to(git, "refs/for/master");
    canRebase = gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).canRebase();
    assertThat(canRebase).isTrue();
}
#end_block

#method_before
@Test
public void files() throws Exception {
    PushOneCommit.Result r = createChange();
    assertTrue(Iterables.all(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet(), new Predicate<String>() {

        @Override
        public boolean apply(String file) {
            return file.matches(FILE_NAME + '|' + Patch.COMMIT_MSG);
        }
    }));
}
#method_after
@Test
public void files() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.all(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet(), new Predicate<String>() {

        @Override
        public boolean apply(String file) {
            return file.matches(FILE_NAME + '|' + Patch.COMMIT_MSG);
        }
    })).isTrue();
}
#end_block

#method_before
@Test
public void diff() throws Exception {
    PushOneCommit.Result r = createChange();
    DiffInfo diff = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).diff();
    assertNull(diff.metaA);
    assertTrue(diff.metaB.lines == 1);
}
#method_after
@Test
public void diff() throws Exception {
    PushOneCommit.Result r = createChange();
    DiffInfo diff = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).diff();
    assertThat(diff.metaA).isNull();
    assertThat(diff.metaB.lines).isEqualTo(1);
}
#end_block

#method_before
@Test
public void content() throws Exception {
    PushOneCommit.Result r = createChange();
    assertEquals(FILE_CONTENT, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).content());
}
#method_after
@Test
public void content() throws Exception {
    PushOneCommit.Result r = createChange();
    BinaryResult bin = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).content();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), StandardCharsets.UTF_8);
    assertThat(res).isEqualTo(FILE_CONTENT);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().apply(revision).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().setBase(base).apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().setBase(base).apply(revision).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
public FileApi file(String path) throws RestApiException {
    try {
        return fileApi.create(files.get().parse(revision, IdString.fromDecoded(path)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#method_after
@Override
public FileApi file(String path) {
    return fileApi.create(files.get().parse(revision, IdString.fromDecoded(path)));
}
#end_block

#method_before
@Override
public FileResource parse(RevisionResource rev, IdString id) throws ResourceNotFoundException, OrmException, AuthException {
    return new FileResource(rev, id.get());
}
#method_after
@Override
public FileResource parse(RevisionResource rev, IdString id) {
    return new FileResource(rev, id.get());
}
#end_block

#method_before
@Override
public Response<?> apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceNotFoundException, OrmException {
    if (base != null && reviewed) {
        throw new BadRequestException("cannot combine base and reviewed");
    } else if (reviewed) {
        return Response.ok(reviewed(resource));
    }
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    try {
        Response<Map<String, FileInfo>> r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet(), basePatchSet));
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (PatchListNotAvailableException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
@Override
public Response<?> apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceNotFoundException, OrmException, RepositoryNotFoundException, IOException {
    checkOptions();
    if (reviewed) {
        return Response.ok(reviewed(resource));
    } else if (query != null) {
        return Response.ok(query(resource));
    }
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    try {
        Response<Map<String, FileInfo>> r = Response.ok(fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet().getRevision(), basePatchSet));
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (PatchListNotAvailableException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public String content() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public BinaryResult content() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public DiffInfo diff(String diffBaseRevisionId) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public DiffInfo diff(String base) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Map<String, FileInfo> files() {
    throw new NotImplementedException();
}
#method_after
@Override
public Map<String, FileInfo> files() throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public FileApi file(String filePath) {
    throw new NotImplementedException();
}
#method_after
@Override
public FileApi file(String path) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(DraftResource rsrc, Input input) throws OrmException {
    db.get().patchComments().delete(Collections.singleton(rsrc.getComment()));
    return Response.none();
}
#method_after
@Override
public Response<CommentInfo> apply(DraftResource rsrc, Input input) throws OrmException, IOException {
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    PatchLineComment c = rsrc.getComment();
    setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
    plcUtil.deleteComments(db.get(), update, Collections.singleton(c));
    update.commit();
    return Response.none();
}
#end_block

#method_before
@Override
public CommentInfo apply(DraftResource rsrc) throws OrmException {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#method_after
@Override
public CommentInfo apply(DraftResource rsrc) throws OrmException {
    return commentJson.format(rsrc.getComment());
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files() throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().apply(revision).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().setBase(base).apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<String, FileInfo> files(String base) throws RestApiException {
    try {
        return (Map<String, FileInfo>) listFiles.get().setBase(base).apply(revision).value();
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve files", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return Maps.transformEntries(listComments.apply(revision), new Maps.EntryTransformer<String, List<com.google.gerrit.server.change.CommentInfo>, List<CommentInfo>>() {

            @Override
            public List<CommentInfo> transformEntry(String key, List<com.google.gerrit.server.change.CommentInfo> c) {
                return Lists.transform(c, CommentInfoMapper.INSTANCE);
            }
        });
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> comments() throws RestApiException {
    try {
        return listComments.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comments", e);
    }
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return Maps.transformEntries(listDrafts.apply(revision), new Maps.EntryTransformer<String, List<com.google.gerrit.server.change.CommentInfo>, List<CommentInfo>>() {

            @Override
            public List<CommentInfo> transformEntry(String key, List<com.google.gerrit.server.change.CommentInfo> d) {
                return Lists.transform(d, CommentInfoMapper.INSTANCE);
            }
        });
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#method_after
@Override
public Map<String, List<CommentInfo>> drafts() throws RestApiException {
    try {
        return listDrafts.apply(revision);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve drafts", e);
    }
}
#end_block

#method_before
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        return draft(createDraft.apply(revision, in).value().id);
    } catch (OrmException e) {
        throw new RestApiException("Cannot create draft", e);
    }
}
#method_after
@Override
public DraftApi createDraft(DraftInput in) throws RestApiException {
    try {
        return draft(createDraft.apply(revision, in).value().id);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot create draft", e);
    }
}
#end_block

#method_before
@Override
public CommentInfo apply(CommentResource rsrc) throws OrmException {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#method_after
@Override
public CommentInfo apply(CommentResource rsrc) throws OrmException {
    return commentJson.format(rsrc.getComment());
}
#end_block

#method_before
@Test
public void reviewTriplet() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
}
#method_after
@Test
public void reviewTriplet() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void reviewCurrent() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
}
#method_after
@Test
public void reviewCurrent() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void reviewNumber() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(1).review(ReviewInput.approve());
    r = updateChange(r, "new content");
    gApi.changes().id(r.getChangeId()).revision(2).review(ReviewInput.approve());
}
#method_after
@Test
public void reviewNumber() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(1).review(ReviewInput.approve());
    r = updateChange(r, "new content");
    gApi.changes().id(r.getChangeId()).revision(2).review(ReviewInput.approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#method_after
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#end_block

#method_before
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#end_block

#method_before
@Test
public void deleteDraft() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createDraft();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createDraft();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).delete();
}
#end_block

#method_before
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in);
    cApi.current().review(ReviewInput.approve());
    cApi.current().submit();
}
#method_after
@Test
public void cherryPick() throws Exception {
    PushOneCommit.Result r = pushTo("refs/for/master%topic=someTopic");
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi orig = gApi.changes().id("p~master~" + r.getChangeId());
    assertThat((Iterable<?>) orig.get().messages).hasSize(1);
    ChangeApi cherry = orig.revision(r.getCommit().name()).cherryPick(in);
    assertThat((Iterable<?>) orig.get().messages).hasSize(2);
    assertThat(cherry.get().subject).contains(in.message);
    assertThat(cherry.get().topic).isEqualTo("someTopic");
    cherry.current().review(ReviewInput.approve());
    cherry.current().submit();
}
#end_block

#method_before
@Test
public void canRebase() throws GitAPIException, IOException, RestApiException, Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r1 = push.to(git, "refs/for/master");
    merge(r1);
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r2 = push.to(git, "refs/for/master");
    assertFalse(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).canRebase());
    merge(r2);
    git.checkout().setName(r1.getCommit().name()).call();
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r3 = push.to(git, "refs/for/master");
    assertTrue(gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).canRebase());
}
#method_after
@Test
public void canRebase() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r1 = push.to(git, "refs/for/master");
    merge(r1);
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r2 = push.to(git, "refs/for/master");
    boolean canRebase = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).canRebase();
    assertThat(canRebase).isFalse();
    merge(r2);
    git.checkout().setName(r1.getCommit().name()).call();
    push = pushFactory.create(db, admin.getIdent());
    PushOneCommit.Result r3 = push.to(git, "refs/for/master");
    canRebase = gApi.changes().id(r3.getChangeId()).revision(r3.getCommit().name()).canRebase();
    assertThat(canRebase).isTrue();
}
#end_block

#method_before
@Test
public void files() throws Exception {
    PushOneCommit.Result r = createChange();
    assertTrue(Iterables.all(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet(), new Predicate<String>() {

        @Override
        public boolean apply(String file) {
            return file.matches(FILE_NAME + '|' + Patch.COMMIT_MSG);
        }
    }));
}
#method_after
@Test
public void files() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.all(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).files().keySet(), new Predicate<String>() {

        @Override
        public boolean apply(String file) {
            return file.matches(FILE_NAME + '|' + Patch.COMMIT_MSG);
        }
    })).isTrue();
}
#end_block

#method_before
@Test
public void diff() throws Exception {
    PushOneCommit.Result r = createChange();
    DiffInfo diff = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).diff();
    assertNull(diff.metaA);
    assertEquals(1, diff.metaB.lines.intValue());
}
#method_after
@Test
public void diff() throws Exception {
    PushOneCommit.Result r = createChange();
    DiffInfo diff = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).diff();
    assertThat(diff.metaA).isNull();
    assertThat(diff.metaB.lines).isEqualTo(1);
}
#end_block

#method_before
@Test
public void content() throws Exception {
    PushOneCommit.Result r = createChange();
    assertEquals(FILE_CONTENT, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).content());
}
#method_after
@Test
public void content() throws Exception {
    PushOneCommit.Result r = createChange();
    BinaryResult bin = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).file(FILE_NAME).content();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), StandardCharsets.UTF_8);
    assertThat(res).isEqualTo(FILE_CONTENT);
}
#end_block

#method_before
@Test
public void drafts() throws Exception {
    PushOneCommit.Result r = createChange();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing hitespace";
    in.path = FILE_NAME;
    DraftApi draftApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).createDraft(in);
    assertEquals(in.message, draftApi.get().message);
    assertEquals(in.message, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).draft(draftApi.get().id).get().message);
    assertEquals(1, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).drafts().size());
    in.message = "good catch!";
    assertEquals(in.message, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).draft(draftApi.get().id).update(in).message);
    CommentInfo comment = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).draft(draftApi.get().id).get();
    assertEquals(admin.email, comment.author.email);
    draftApi.delete();
    assertEquals(0, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).drafts().size());
}
#method_after
@Test
public void drafts() throws Exception {
    PushOneCommit.Result r = createChange();
    DraftInput in = new DraftInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = FILE_NAME;
    DraftApi draftApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).createDraft(in);
    assertThat(draftApi.get().message).isEqualTo(in.message);
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).draft(draftApi.get().id).get().message).isEqualTo(in.message);
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).drafts()).hasSize(1);
    in.message = "good catch!";
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).draft(draftApi.get().id).update(in).message).isEqualTo(in.message);
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).draft(draftApi.get().id).get().author.email).isEqualTo(admin.email);
    draftApi.delete();
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).drafts()).isEmpty();
}
#end_block

#method_before
@Test
public void comments() throws Exception {
    PushOneCommit.Result r = createChange();
    CommentInput in = new CommentInput();
    in.line = 1;
    in.message = "nit: trailing hitespace";
    in.path = FILE_NAME;
    ReviewInput reviewInput = new ReviewInput();
    Map<String, List<CommentInput>> comments = new HashMap<>();
    comments.put(FILE_NAME, Collections.singletonList(in));
    reviewInput.comments = comments;
    reviewInput.message = "comment test";
    gApi.changes().id(r.getChangeId()).current().review(reviewInput);
    Map<String, List<CommentInfo>> out = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comments();
    assertEquals(1, out.size());
    CommentInfo comment = Iterables.getOnlyElement(out.get(FILE_NAME));
    assertEquals(in.message, comment.message);
    assertEquals(admin.email, comment.author.email);
    assertEquals(in.message, gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comment(comment.id).get().message);
}
#method_after
@Test
public void comments() throws Exception {
    PushOneCommit.Result r = createChange();
    CommentInput in = new CommentInput();
    in.line = 1;
    in.message = "nit: trailing whitespace";
    in.path = FILE_NAME;
    ReviewInput reviewInput = new ReviewInput();
    Map<String, List<CommentInput>> comments = new HashMap<>();
    comments.put(FILE_NAME, Collections.singletonList(in));
    reviewInput.comments = comments;
    reviewInput.message = "comment test";
    gApi.changes().id(r.getChangeId()).current().review(reviewInput);
    Map<String, List<CommentInfo>> out = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comments();
    assertThat(out).hasSize(1);
    CommentInfo comment = Iterables.getOnlyElement(out.get(FILE_NAME));
    assertThat(comment.message).isEqualTo(in.message);
    assertThat(comment.author.email).isEqualTo(admin.email);
    assertThat(gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).comment(comment.id).get().message).isEqualTo(in.message);
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(DraftResource rsrc, DraftInput in) throws BadRequestException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.apply(rsrc, null);
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid(), TimeUtil.nowTs());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return Response.ok(new CommentInfo(c, null));
}
#method_after
@Override
public Response<CommentInfo> apply(DraftResource rsrc, DraftInput in) throws BadRequestException, OrmException, IOException {
    PatchLineComment c = rsrc.getComment();
    ChangeUpdate update = updateFactory.create(rsrc.getControl());
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.apply(rsrc, null);
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        plcUtil.deleteComments(db.get(), update, Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid(), TimeUtil.nowTs());
        setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
        plcUtil.insertComments(db.get(), update, Collections.singleton(update(c, in)));
    } else {
        if (c.getRevId() == null) {
            setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
        }
        plcUtil.updateComments(db.get(), update, Collections.singleton(update(c, in)));
    }
    update.commit();
    return Response.ok(commentJson.format(c, false));
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, DraftInput in) throws BadRequestException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.endLine : 0;
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), line, rsrc.getAccountId(), Url.decode(in.inReplyTo), TimeUtil.nowTs());
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.fromRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#method_after
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, DraftInput in) throws BadRequestException, OrmException, IOException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    } else if (in.line != null && in.range != null && in.line != in.range.endLine) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.endLine : 0;
    Timestamp now = TimeUtil.nowTs();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), now);
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), line, rsrc.getAccountId(), Url.decode(in.inReplyTo), now);
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.fromRange(in.range);
    setCommentRevId(c, patchListCache, rsrc.getChange(), rsrc.getPatchSet());
    plcUtil.insertComments(db.get(), update, Collections.singleton(c));
    update.commit();
    return Response.created(commentJson.format(c, false));
}
#end_block

#method_before
@Override
public DraftResource parse(RevisionResource rev, IdString id) throws ResourceNotFoundException, OrmException, AuthException {
    checkIdentifiedUser();
    String uuid = id.get();
    for (PatchLineComment c : dbProvider.get().patchComments().draftByPatchSetAuthor(rev.getPatchSet().getId(), rev.getAccountId())) {
        if (uuid.equals(c.getKey().get())) {
            return new DraftResource(rev, c);
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public DraftResource parse(RevisionResource rev, IdString id) throws ResourceNotFoundException, OrmException, AuthException {
    checkIdentifiedUser();
    String uuid = id.get();
    for (PatchLineComment c : plcUtil.draftByPatchSetAuthor(dbProvider.get(), rev.getPatchSet().getId(), rev.getAccountId(), rev.getNotes())) {
        if (uuid.equals(c.getKey().get())) {
            return new DraftResource(rev, c);
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public CommentResource parse(RevisionResource rev, IdString id) throws ResourceNotFoundException, OrmException {
    String uuid = id.get();
    for (PatchLineComment c : dbProvider.get().patchComments().publishedByPatchSet(rev.getPatchSet().getId())) {
        if (uuid.equals(c.getKey().get())) {
            return new CommentResource(rev, c);
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
@Override
public CommentResource parse(RevisionResource rev, IdString id) throws ResourceNotFoundException, OrmException {
    String uuid = id.get();
    ChangeNotes notes = rev.getNotes();
    for (PatchLineComment c : plcUtil.publishedByPatchSet(dbProvider.get(), notes, rev.getPatchSet().getId())) {
        if (uuid.equals(c.getKey().get())) {
            return new CommentResource(rev, c);
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
protected Iterable<PatchLineComment> listComments(RevisionResource rsrc) throws OrmException {
    return db.get().patchComments().publishedByPatchSet(rsrc.getPatchSet().getId());
}
#method_after
@Override
protected Iterable<PatchLineComment> listComments(RevisionResource rsrc) throws OrmException {
    ChangeNotes notes = rsrc.getNotes();
    return plcUtil.publishedByPatchSet(db.get(), notes, rsrc.getPatchSet().getId());
}
#end_block

#method_before
@Override
public CommentInfo get() throws RestApiException {
    try {
        return CommentInfoMapper.INSTANCE.apply(getDraft.apply(draft));
    } catch (OrmException e) {
        throw new RestApiException("Cannot update draft", e);
    }
}
#method_after
@Override
public CommentInfo get() throws RestApiException {
    try {
        return getDraft.apply(draft);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve draft", e);
    }
}
#end_block

#method_before
@Override
public CommentInfo update(DraftInput in) throws RestApiException {
    try {
        return CommentInfoMapper.INSTANCE.apply(putDraft.apply(draft, in).value());
    } catch (OrmException e) {
        throw new RestApiException("Cannot update draft", e);
    }
}
#method_after
@Override
public CommentInfo update(DraftInput in) throws RestApiException {
    try {
        return putDraft.apply(draft, in).value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot update draft", e);
    }
}
#end_block

#method_before
@Override
public void delete() throws RestApiException {
    try {
        deleteDraft.apply(draft, null);
    } catch (OrmException e) {
        throw new RestApiException("Cannot delete draft", e);
    }
}
#method_after
@Override
public void delete() throws RestApiException {
    try {
        deleteDraft.apply(draft, null);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot delete draft", e);
    }
}
#end_block

#method_before
protected Iterable<PatchLineComment> listComments(RevisionResource rsrc) throws OrmException {
    return db.get().patchComments().draftByPatchSetAuthor(rsrc.getPatchSet().getId(), rsrc.getAccountId());
}
#method_after
protected Iterable<PatchLineComment> listComments(RevisionResource rsrc) throws OrmException {
    return plcUtil.draftByPatchSetAuthor(db.get(), rsrc.getPatchSet().getId(), rsrc.getAccountId(), rsrc.getNotes());
}
#end_block

#method_before
@Override
public Map<String, List<CommentInfo>> apply(RevisionResource rsrc) throws OrmException {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = includeAuthorInfo() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#method_after
@Override
public Map<String, List<CommentInfo>> apply(RevisionResource rsrc) throws OrmException {
    return commentJson.format(listComments(rsrc), includeAuthorInfo());
}
#end_block

#method_before
@Override
public CommentInfo get() throws RestApiException {
    try {
        return CommentInfoMapper.INSTANCE.apply(getComment.apply(comment));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comment", e);
    }
}
#method_after
@Override
public CommentInfo get() throws RestApiException {
    try {
        return getComment.apply(comment);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve comment", e);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeEditApi.get(revision, path, new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group2.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    });
    group2.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            content = null;
        }
    });
    group1.done();
    group2.done();
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            content = null;
        }
    });
    group1.done();
    group2.done();
    group3.done();
}
#end_block

#method_before
public void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (addBox == null) {
        addBox = new AddFileBox(changeId, revision);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(addButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(addBox);
    p.showRelativeTo(addButton);
    GlobalKey.dialog(p);
    addBox.setFocus(true);
    popup = p;
}
#method_after
public void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (addBox == null) {
        addBox = new AddFileBox(changeId, revision);
    }
    addBox.clearPath();
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(addButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(addBox);
    p.showRelativeTo(addButton);
    GlobalKey.dialog(p);
    addBox.setFocus(true);
    popup = p;
}
#end_block

#method_before
@UiHandler("open")
void onOpen(@SuppressWarnings("unused") ClickEvent e) {
    hide();
    Gerrit.display(Dispatcher.toEditScreen(new PatchSet.Id(changeId, revision._number()), path.getText()));
}
#method_after
@UiHandler("open")
void onOpen(@SuppressWarnings("unused") ClickEvent e) {
    open(path.getText());
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    path.setText("");
    hide();
}
#method_after
@UiHandler("cancel")
void onCancel(@SuppressWarnings("unused") ClickEvent e) {
    hide();
}
#end_block

#method_before
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.setOption("keyMap", "vim_ro");
    cm.focus();
}
#method_after
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    CallbackGroup group = new CallbackGroup();
    if (prefs.syntaxHighlighting() && !Patch.COMMIT_MSG.equals(path)) {
        final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
        ChangeFileApi.getContentType(revision, path, cmGroup.add(new GerritCallback<String>() {

            @Override
            public void onSuccess(String result) {
                type = result;
                injectMode(result, modeInjectorCb);
            }
        }));
    }
    cmGroup.done();
    ChangeApi.detail(revision.getParentKey().get(), group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }
    }));
    ChangeFileApi.getContentOrMessage(revision, path, group.addFinal(new ScreenLoadCallback<String>(this) {

        @Override
        protected void preDisplay(String content) {
            setShowTabs(prefs.showTabs());
            initEditor(content);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    final CallbackGroup group = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (prefs.syntaxHighlighting() && !Patch.COMMIT_MSG.equals(path)) {
        final AsyncCallback<Void> modeInjectorCb = group.addEmpty();
        ChangeFileApi.getContentType(revision, path, cmGroup.add(new GerritCallback<String>() {

            @Override
            public void onSuccess(String result) {
                ModeInfo mode = ModeInfo.findMode(result, path);
                type = mode != null ? mode.mime() : null;
                injectMode(result, modeInjectorCb);
            }
        }));
    }
    cmGroup.done();
    ChangeApi.detail(revision.getParentKey().get(), group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }
    }));
    ChangeFileApi.getContentOrMessage(revision, path, group.addFinal(new ScreenLoadCallback<String>(this) {

        @Override
        protected void preDisplay(String content) {
            initEditor(content);
        }
    }));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            adjustCodeMirrorHeight();
        }
    });
    closeHandler = Window.addWindowClosingHandler(new ClosingHandler() {

        @Override
        public void onWindowClosing(ClosingEvent event) {
            if (!cm.isClean(generation)) {
                event.setMessage(EditConstants.I.closeUnsavedChanges());
            }
        }
    });
    generation = cm.changeGeneration(true);
    save.setEnabled(false);
    cm.on(new ChangesHandler() {

        @Override
        public void handle(CodeMirror cm) {
            save.setEnabled(!cm.isClean(generation));
        }
    });
    adjustCodeMirrorHeight();
    setLineLength(prefs.lineLength());
    cm.refresh();
    cm.focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            cm.adjustHeight(header.getOffsetHeight());
        }
    });
    closeHandler = Window.addWindowClosingHandler(new ClosingHandler() {

        @Override
        public void onWindowClosing(ClosingEvent event) {
            if (!cm.isClean(generation)) {
                event.setMessage(EditConstants.I.closeUnsavedChanges());
            }
        }
    });
    generation = cm.changeGeneration(true);
    save.setEnabled(false);
    cm.on(new ChangesHandler() {

        @Override
        public void handle(CodeMirror cm) {
            save.setEnabled(!cm.isClean(generation));
        }
    });
    cm.adjustHeight(header.getOffsetHeight());
    cm.on("cursorActivity", updateCursorPosition());
    cm.extras().showTabs(prefs.showTabs());
    cm.extras().lineLength(prefs.lineLength());
    cm.refresh();
    cm.focus();
    updateActiveLine();
}
#end_block

#method_before
@UiHandler("save")
void onSave(@SuppressWarnings("unused") ClickEvent e) {
    if (cm.isClean(generation)) {
        upToChange();
        return;
    }
    ChangeFileApi.putContentOrMessage(revision, path, cm.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            upToChange();
        }
    });
}
#method_after
@UiHandler("save")
void onSave(@SuppressWarnings("unused") ClickEvent e) {
    save().run();
}
#end_block

#method_before
private void initEditor(String content) {
    String mode = prefs.syntaxHighlighting() ? ModeInjector.getContentType(type) : null;
    cm = CodeMirror.create(editor, Configuration.create().set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", mode));
    cm.addKeyMap(KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save()));
    cm.setValue(content);
    columnMargin = DOM.createDiv();
    columnMargin.setClassName(style.columnMargin());
    cm.mover().appendChild(columnMargin);
}
#method_after
private void initEditor(String content) {
    ModeInfo mode = prefs.syntaxHighlighting() ? ModeInfo.findMode(type, path) : null;
    cm = CodeMirror.create(editor, Configuration.create().set("value", content).set("readOnly", false).set("cursorBlinkRate", 0).set("cursorHeight", 0.85).set("lineNumbers", true).set("tabSize", prefs.tabSize()).set("lineWrapping", false).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "default").set("theme", prefs.theme().name().toLowerCase()).set("mode", mode != null ? mode.mode() : null));
    cm.addKeyMap(KeyMap.create().on("Cmd-S", save()).on("Ctrl-S", save()));
}
#end_block

#method_before
public final Change.Status status() {
    return Change.Status.valueOf(statusRaw());
}
#method_after
public final Change.Status status() {
    String s = statusRaw();
    return s != null ? Change.Status.valueOf(s) : null;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
    }
}
#end_block

#method_before
boolean wouldPushProject(final Project.NameKey project) {
    try {
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            return false;
        }
    } catch (Exception e) {
        log.warn(String.format("Could not determine visibility for project '%s'!", project));
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#method_after
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
public static String cleanupHashtag(String hashtag) {
    hashtag = LEADER.trimLeadingFrom(hashtag);
    hashtag = WHITESPACE.trimTrailingFrom(hashtag);
    return hashtag.toLowerCase();
}
#method_after
public static String cleanupHashtag(String hashtag) {
    hashtag = LEADER.trimLeadingFrom(hashtag);
    hashtag = WHITESPACE.trimTrailingFrom(hashtag);
    return hashtag;
}
#end_block

#method_before
public static Set<String> extractTags(String input) {
    if (Strings.isNullOrEmpty(input)) {
        return Collections.emptySet();
    } else {
        HashSet<String> result = new HashSet<>();
        Pattern pattern = Pattern.compile("#[A-Za-z0-9]+");
        Matcher matcher = pattern.matcher(input);
        while (matcher.find()) {
            result.add(matcher.group());
        }
        return result;
    }
}
#method_after
public static Set<String> extractTags(String input) {
    Set<String> result = new HashSet<>();
    if (!Strings.isNullOrEmpty(input)) {
        Matcher matcher = Pattern.compile(PATTERN).matcher(input);
        while (matcher.find()) {
            result.add(cleanupHashtag(matcher.group()));
        }
    }
    return result;
}
#end_block

#method_before
@Test
public void emptyCommitMessage() {
    assertThat(HashtagsUtil.extractTags("")).isEmpty();
}
#method_after
@Test
public void emptyCommitMessage() throws Exception {
    assertThat(HashtagsUtil.extractTags("")).isEmpty();
}
#end_block

#method_before
@Test
public void nullCommitMessage() {
    assertThat(HashtagsUtil.extractTags(null)).isEmpty();
}
#method_after
@Test
public void nullCommitMessage() throws Exception {
    assertThat(HashtagsUtil.extractTags(null)).isEmpty();
}
#end_block

#method_before
@Test
public void noHashtags() {
    String commitMessage = "Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).isEmpty();
}
#method_after
@Test
public void noHashtags() throws Exception {
    String commitMessage = "Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).isEmpty();
}
#end_block

#method_before
@Test
public void singleHashtag() {
    String commitMessage = "#Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("#Subject"));
}
#method_after
@Test
public void singleHashtag() throws Exception {
    String commitMessage = "#Subject\n\nLine 1\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("Subject"));
}
#end_block

#method_before
@Test
public void multipleHashtags() {
    String commitMessage = "#Subject\n\n#Hashtag\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("#Subject", "#Hashtag"));
}
#method_after
@Test
public void multipleHashtags() throws Exception {
    String commitMessage = "#Subject\n\n#Hashtag\n\nLine 2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("Subject", "Hashtag"));
}
#end_block

#method_before
@Test
public void multipleHashtagsNoSpaces() {
    String commitMessage = "Subject\n\n#Hashtag1#Hashtag2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("#Hashtag1", "#Hashtag2"));
}
#method_after
@Test
public void multipleHashtagsNoSpaces() throws Exception {
    String commitMessage = "Subject\n\n#Hashtag1#Hashtag2";
    assertThat(HashtagsUtil.extractTags(commitMessage)).containsExactlyElementsIn(Sets.newHashSet("Hashtag1"));
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db.get(), gerritServerConfig, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db.get(), rsrc.getChange()), false, "locate_submit_rule", "can_submit", "locate_submit_filter", "filter_submit_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = eval(evaluator);
    } catch (RuleEvalException | RuleEvalTimeoutException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<SubmitRecord> records = evaluator.setPatchSet(rsrc.getPatchSet()).setLogErrors(false).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).canSubmit();
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountLoader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    if (!out.isEmpty()) {
        out.get(0).prologReductionCount = evaluator.getReductionsConsumed();
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
private List<Term> evaluateImpl() throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProjectName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName, CurrentUser user) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment(user);
    try {
        Term sr = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, sr, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), getProjectName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", sr, cd.getId().get(), getProjectName()), err);
        } finally {
            reductionsConsumed = env.getReductions();
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        List<Term> r;
        if (resultsTerm.isList()) {
            r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
        } else {
            r = Collections.emptyList();
        }
        submitRule = sr;
        return r;
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    ProjectState projectState = projectControl.getProjectState();
    PrologEnvironment env;
    try {
        if (rulesInputStream == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", rulesInputStream);
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, db);
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, changeControl);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment(CurrentUser user) throws RuleEvalException {
    checkState(patchSet != null, "getPrologEnvironment() called before initPatchSet()");
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    if (user != null) {
        env.set(StoredValues.CURRENT_USER, user);
    }
    return env;
}
#end_block

#method_before
private Term runSubmitFilters(Term results, PrologEnvironment env) throws RuleEvalException {
    ProjectState projectState = projectControl.getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (fastEvalLabels) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
        }
        childEnv = parentEnv;
    }
    return results;
}
#method_after
private Term runSubmitFilters(Term results, PrologEnvironment env, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment childEnv = env;
    for (ProjectState parentState : projectState.parents()) {
        PrologEnvironment parentEnv;
        try {
            parentEnv = parentState.newPrologEnvironment();
        } catch (CompileException err) {
            throw new RuleEvalException("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
        }
        parentEnv.copyStoredValues(childEnv);
        Term filterRule = parentEnv.once("gerrit", filterRuleLocatorName, new VariableTerm());
        try {
            if (fastEvalLabels) {
                env.once("gerrit", "assume_range_from_label");
            }
            Term[] template = parentEnv.once("gerrit", filterRuleWrapperName, filterRule, results, new VariableTerm());
            results = template[2];
        } catch (ReductionLimitException err) {
            throw new RuleEvalException(String.format("%s on change %d of %s", err.getMessage(), cd.getId().get(), parentState.getProject().getName()));
        } catch (RuntimeException err) {
            throw new RuleEvalException(String.format("Exception calling %s on change %d of %s", filterRule, cd.getId().get(), parentState.getProject().getName()), err);
        } finally {
            reductionsConsumed += env.getReductions();
        }
        childEnv = parentEnv;
    }
    return results;
}
#end_block

#method_before
public Term getSubmitRule() {
    return submitRule;
}
#method_after
public Term getSubmitRule() {
    checkState(submitRule != null, "getSubmitRule() invalid before evaluation");
    return submitRule;
}
#end_block

#method_before
private String getProjectName() {
    if (projectName == null) {
        projectName = projectControl.getProjectState().getProject().getName();
    }
    return projectName;
}
#method_after
private String getProjectName() {
    return control.getProjectControl().getProjectState().getProject().getName();
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    if (replaceByCommit.containsKey(req.newCommit)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    replaceByCommit.put(req.newCommit, req);
    return true;
}
#method_after
private boolean requestReplace(final ReceiveCommand cmd, final boolean checkMergedInto, final Change change, final RevCommit newCommit) {
    if (change.getStatus().isClosed()) {
        reject(cmd, "change " + change.getId() + " closed");
        return false;
    }
    final ReplaceRequest req = new ReplaceRequest(change.getId(), newCommit, cmd, checkMergedInto);
    if (replaceByChange.containsKey(req.ontoChange)) {
        reject(cmd, "duplicate request");
        return false;
    }
    replaceByChange.put(req.ontoChange, req);
    return true;
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith(REFS_CHANGES)) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (forRef != null && forRef.equals(ref.getName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(RevWalk rw, @Nullable String forRef) {
    for (Ref ref : allRefs.values()) {
        if ((ref.getName().startsWith(R_HEADS) || ref.getName().equals(forRef)) && ref.getObjectId() != null) {
            try {
                rw.markUninteresting(rw.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
            }
        }
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        ins.setHashtags(magicBranch.getHashtags());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        ins.setHashtags(magicBranch.hashtags);
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).insert();
    created = true;
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                    replaceByCommit.remove(req.newCommit);
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#method_after
private void preparePatchSetsForReplace() {
    try {
        readChangesForReplace();
        for (Iterator<ReplaceRequest> itr = replaceByChange.values().iterator(); itr.hasNext(); ) {
            ReplaceRequest req = itr.next();
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.validate(false);
                if (req.skip && req.cmd == null) {
                    itr.remove();
                }
            }
        }
    } catch (OrmException err) {
        log.error(String.format("Cannot read database before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    } catch (IOException err) {
        log.error(String.format("Cannot read repository before replacement for project %s", project.getName()), err);
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand.getResult() == NOT_ATTEMPTED) {
                req.inputCommand.setResult(REJECTED_OTHER_REASON, "internal server error");
            }
        }
    }
    for (ReplaceRequest req : replaceByChange.values()) {
        if (req.inputCommand.getResult() == NOT_ATTEMPTED && req.cmd != null) {
            batch.addCommand(req.cmd);
        }
    }
    if (magicBranch != null && magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // Cancel creations tied to refs/for/ or refs/drafts/ command.
        for (ReplaceRequest req : replaceByChange.values()) {
            if (req.inputCommand == magicBranch.cmd && req.cmd != null) {
                req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
            }
        }
        for (CreateRequest req : newChanges) {
            req.cmd.setResult(Result.REJECTED_OTHER_REASON, "aborted");
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(FooterConstants.CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private ListMultimap<Change.Id, Ref> refsByChange() {
    if (refsByChange == null) {
        int estRefsPerChange = 4;
        refsByChange = ArrayListMultimap.create(allRefs.size() / estRefsPerChange, estRefsPerChange);
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() != null) {
                PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                if (psId != null) {
                    refsByChange.put(psId.getParentKey(), ref);
                }
            }
        }
    }
    return refsByChange;
}
#method_after
private ListMultimap<Change.Id, Ref> refsByChange() {
    initChangeRefMaps();
    return refsByChange;
}
#end_block

#method_before
private SetMultimap<ObjectId, Ref> changeRefsById() {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : refsByChange().values()) {
            refsById.put(r.getObjectId(), r);
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() {
    initChangeRefMaps();
    return refsById;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !RefNames.REFS_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, cmd.getRefName());
        Set<ObjectId> existing = changeRefsById().keySet();
        for (RevCommit c; (c = walk.next()) != null; ) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByKey(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(FooterConstants.CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        RevCommit newTip = rw.parseCommit(cmd.getNewId());
        Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), cmd.getRefName());
        rw.reset();
        rw.markStart(newTip);
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        Map<Change.Key, Change> byKey = null;
        final List<ReplaceRequest> toClose = new ArrayList<>();
        for (RevCommit c; (c = rw.next()) != null; ) {
            rw.parseBody(c);
            for (Ref ref : byCommit.get(c.copy())) {
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    if (byKey == null) {
                        byKey = openChangesByKey(branch);
                    }
                    byKey.remove(closedChange);
                }
            }
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                if (byKey == null) {
                    byKey = openChangesByKey(branch);
                }
                final Change onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto.getId(), c, cmd, false);
                    req.change = onto;
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // Update superproject gitlinks if required.
        subOpFactory.create(branch, newTip, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount()).update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, RevCommit cherryPickCommit, RefControl refControl, IdentifiedUser identifiedUser) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final ChangeControl changeControl = refControl.getProjectControl().controlFor(change);
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, changeControl, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    PatchSet current = db.get().patchSets().get(change.currentPatchSetId());
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setDraft(current.isDraft()).setUploader(identifiedUser.getAccountId()).setCopyLabels(true).insert();
    return change.getId();
}
#method_after
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, RevCommit cherryPickCommit, RefControl refControl, IdentifiedUser identifiedUser) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final ChangeControl changeControl = refControl.getProjectControl().controlFor(change);
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, changeControl, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    PatchSet current = db.get().patchSets().get(change.currentPatchSetId());
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").setDraft(current.isDraft()).setUploader(identifiedUser.getAccountId()).insert();
    return change.getId();
}
#end_block

#method_before
public String getContentType(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            return registry.getMimeType(path, Text.asByteArray(repo.open(tw.getObjectId(0)))).toString();
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public String getContentType(Project.NameKey project, String revstr, String path) throws ResourceNotFoundException, IOException {
    Repository repo = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectReader reader = repo.newObjectReader();
        try {
            RevCommit commit = rw.parseCommit(repo.resolve(revstr));
            TreeWalk tw = TreeWalk.forPath(rw.getObjectReader(), path, commit.getTree().getId());
            if (tw == null) {
                throw new ResourceNotFoundException();
            }
            ObjectLoader blobLoader = reader.open(tw.getObjectId(0), OBJ_BLOB);
            byte[] raw = blobLoader.isLarge() ? null : blobLoader.getCachedBytes();
            return registry.getMimeType(path, raw).toString();
        } finally {
            reader.release();
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessage expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#method_after
@Test
public void updateMessage() throws Exception {
    assertThat(modifier.createEdit(change, getCurrentPatchSet(changeId))).isEqualTo(RefUpdate.Result.NEW);
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    try {
        modifier.modifyMessage(edit.get(), edit.get().getEditCommit().getFullMessage());
        fail("UnchangedCommitMessageException expected");
    } catch (UnchangedCommitMessageException ex) {
        assertThat(ex.getMessage()).isEqualTo("New commit message cannot be same as existing commit message");
    }
    String msg = String.format("New commit message\n\nChange-Id: %s", change.getKey());
    assertThat(modifier.modifyMessage(edit.get(), msg)).isEqualTo(RefUpdate.Result.FORCED);
    edit = editUtil.byChange(change);
    assertThat(edit.get().getEditCommit().getFullMessage()).isEqualTo(msg);
    editUtil.publish(edit.get());
    assertThat(editUtil.byChange(change).isPresent()).isFalse();
    ChangeInfo info = get(changeId, ListChangesOption.CURRENT_COMMIT, ListChangesOption.CURRENT_REVISION);
    assertThat(info.revisions.get(info.currentRevision).commit.message).isEqualTo(msg);
}
#end_block

#method_before
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    for (int i = 1; i < args.length; i++) {
        commandName = commandName + "." + args[i];
    }
    return commandName;
}
#method_after
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    for (String arg : dcmd.getArguments()) {
        commandName = commandName + "." + arg;
    }
    return commandName;
}
#end_block

#method_before
@Override
public void start() {
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        ScheduledThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "ThreadPoolSize", Runtime.getRuntime().availableProcessors()), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        for (final Project.NameKey name : cache.all()) {
            pool.execute(new Runnable() {

                @Override
                public void run() {
                    cache.get(name);
                }
            });
        }
        pool.shutdown();
    }
}
#method_after
@Override
public void start() {
    int cpus = Runtime.getRuntime().availableProcessors();
    if (config.getBoolean("cache", "projects", "loadOnStartup", false)) {
        final ThreadPoolExecutor pool = new ScheduledThreadPoolExecutor(config.getInt("cache", "projects", "loadThreads", cpus), new ThreadFactoryBuilder().setNameFormat("ProjectCacheLoader-%d").build());
        log.info("Loading project cache");
        pool.execute(new Runnable() {

            @Override
            public void run() {
                for (final Project.NameKey name : cache.all()) {
                    pool.execute(new Runnable() {

                        @Override
                        public void run() {
                            cache.get(name);
                        }
                    });
                }
                pool.shutdown();
            }
        });
    }
}
#end_block

#method_before
public void evict(final Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#method_after
@Override
public void evict(final Project.NameKey p) {
    if (p != null) {
        byName.invalidate(p.get());
    }
}
#end_block

#method_before
protected void assertApproved(String changeId) throws IOException {
    ChangeInfo c = getChange(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertEquals(1, cr.all.size());
    assertEquals(2, cr.all.get(0).value.intValue());
    assertEquals("Administrator", cr.all.get(0).name);
}
#method_after
protected void assertApproved(String changeId) throws IOException {
    ChangeInfo c = getChange(changeId, DETAILED_LABELS);
    LabelInfo cr = c.labels.get("Code-Review");
    assertEquals(1, cr.all.size());
    assertEquals(2, cr.all.get(0).value.intValue());
    assertEquals(admin.getId(), new Account.Id(cr.all.get(0)._accountId));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = statusToChangeStatus(in.getStatus());
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, new ChangeResource(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
        if (userProvider.get().isIdentifiedUser() && in.getStatus().isOpen()) {
            UiAction.Description descr = new UiAction.Description();
            PrivateInternals_UiActionDescription.setId(descr, "followup");
            PrivateInternals_UiActionDescription.setMethod(descr, "POST");
            descr.setTitle("Create follow-up change");
            out.actions.put(descr.getId(), new ActionInfo(descr));
        }
    }
    return out;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#end_block

#method_before
private static void finish(ChangeInfo info) {
    info.id = Joiner.on('~').join(Url.encode(info.project), Url.encode(info.branch), Url.encode(info.changeId));
}
#method_after
static void finish(ChangeInfo info) {
    info.id = Joiner.on('~').join(Url.encode(info.project), Url.encode(info.branch), Url.encode(info.changeId));
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeJson.changeStatusToStatus(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(input.status != null ? Change.Status.forChangeStatus(input.status) : Change.Status.NEW);
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner.getAccountId());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeControl ctl, ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.ref = in.getRefName();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(ctl, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(ctl), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = plcUtil.draftByPatchSetAuthor(db.get(), in.getId(), user.getAccountId(), ctl.getNotes()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, in.getRevision().get());
        out.webLinks = links.isEmpty() ? null : links.toList();
    }
    return out;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, ccText);
    hashtags.init(style);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReview(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, ccText);
    hashtags.init(style);
    initReplyButton();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            editFileAction = new EditFileAction(new PatchSet.Id(changeId, edit == null ? rev._number() : 0), "", "", style, editMessage, review);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            editFileAction = new EditFileAction(new PatchSet.Id(changeId, edit == null ? rev._number() : 0), "", "", style, editMessage, reply);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
    }
}
#end_block

#method_before
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, review);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#method_after
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#end_block

#method_before
private void onReply() {
    if (Gerrit.isSignedIn()) {
        replyAction.onReply(null);
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
@UiHandler("reply")
void onReply(@SuppressWarnings("unused") ClickEvent e) {
    onReply();
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, review, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, edit != null);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, review, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0), fileTableMode);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.set(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply, edit != null);
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0), fileTableMode);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn() && fileTableMode == FileTable.Mode.REVIEW) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, review, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = Maps.newHashMap();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup(d.getGroupUUID())) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, UnprocessableEntityException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<AccountGroup.UUID, AccountGroupById> newIncludedGroups = Maps.newHashMap();
    List<GroupInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    for (String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canAddGroup()) {
            throw new AuthException(String.format("Cannot add group: %s", d.getName()));
        }
        if (!newIncludedGroups.containsKey(d.getGroupUUID())) {
            AccountGroupById.Key agiKey = new AccountGroupById.Key(group.getId(), d.getGroupUUID());
            AccountGroupById agi = db.get().accountGroupById().get(agiKey);
            if (agi == null) {
                agi = new AccountGroupById(agiKey);
                newIncludedGroups.put(d.getGroupUUID(), agi);
            }
        }
        result.add(json.format(d));
    }
    if (!newIncludedGroups.isEmpty()) {
        auditService.dispatchAddGroupsToGroup(me, newIncludedGroups.values());
        db.get().accountGroupById().insert(newIncludedGroups.values());
        for (AccountGroupById agi : newIncludedGroups.values()) {
            groupIncludeCache.evictParentGroupsOf(agi.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup(d.getGroupUUID())) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final GroupControl control = resource.getControl();
    final Map<AccountGroup.UUID, AccountGroupById> includedGroups = getIncludedGroups(internalGroup.getId());
    final List<AccountGroupById> toRemove = Lists.newLinkedList();
    for (final String includedGroup : input.groups) {
        GroupDescription.Basic d = groupsCollection.parse(includedGroup);
        if (!control.canRemoveGroup()) {
            throw new AuthException(String.format("Cannot delete group: %s", d.getName()));
        }
        AccountGroupById g = includedGroups.remove(d.getGroupUUID());
        if (g != null) {
            toRemove.add(g);
        }
    }
    if (!toRemove.isEmpty()) {
        writeAudits(toRemove);
        db.get().accountGroupById().delete(toRemove);
        for (final AccountGroupById g : toRemove) {
            groupIncludeCache.evictParentGroupsOf(g.getIncludeUUID());
        }
        groupIncludeCache.evictSubgroupsOf(internalGroup.getGroupUUID());
    }
    return Response.none();
}
#end_block

#method_before
private void writeAudits(final List<AccountGroupById> toRemoved) throws OrmException {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupsFromGroup(me, toRemoved);
}
#method_after
private void writeAudits(final List<AccountGroupById> toRemoved) {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupsFromGroup(me, toRemoved);
}
#end_block

#method_before
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) {
        if (w.isNotify(type)) {
            projectWatchers.add(w.getAccountId());
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\"", state.getProject().getName(), nc.getName(), nc.getFilter()), e);
                }
            }
        }
    }
    return matching;
}
#method_after
public final Watchers getWatchers(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(project)) {
        if (w.isNotify(type)) {
            projectWatchers.add(w.getAccountId());
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (ProjectState state : projectState.tree()) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc);
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\"", state.getProject().getName(), nc.getName(), nc.getFilter()), e);
                }
            }
        }
    }
    return matching;
}
#end_block

#method_before
private void add(Watchers matching, AccountProjectWatch w) throws OrmException {
    IdentifiedUser user = args.identifiedUserFactory.create(args.db, w.getAccountId());
    try {
        if (filterMatch(user, w.getFilter())) {
            matching.bcc.accounts.add(w.getAccountId());
        }
    } catch (QueryParseException e) {
    // Ignore broken filter expressions.
    }
}
#method_after
private void add(Watchers matching, NotifyConfig nc) throws OrmException, QueryParseException {
    for (GroupReference ref : nc.getGroups()) {
        CurrentUser user = new SingleGroupUser(args.capabilityControlFactory, ref.getUUID());
        if (filterMatch(user, nc.getFilter())) {
            deliverToMembers(matching.list(nc.getHeader()), ref.getUUID());
        }
    }
    if (!nc.getAddresses().isEmpty()) {
        if (filterMatch(null, nc.getFilter())) {
            matching.list(nc.getHeader()).emails.addAll(nc.getAddresses());
        }
    }
}
#end_block

#method_before
@Override
public CheckResult apply(ChangeResource rsrc) {
    CheckResult result = checkerProvider.get().check(rsrc.getChange());
    try {
        result.change = json.format(rsrc);
    } catch (OrmException e) {
        // Even with no options there are a surprising number of dependencies in
        // ChangeJson. Fall back to a very basic implementation with no
        // dependencies if this fails.
        String msg = "Error rendering final ChangeInfo";
        log.warn(msg, e);
        result.messages.add(msg);
        result.change = basicChangeInfo(rsrc.getChange());
    }
    return result;
}
#method_after
@Override
public CheckResult apply(ChangeResource rsrc) {
    CheckResult result = new CheckResult();
    result.messages = checkerProvider.get().check(rsrc.getChange());
    try {
        result.change = json.format(rsrc);
    } catch (OrmException e) {
        // Even with no options there are a surprising number of dependencies in
        // ChangeJson. Fall back to a very basic implementation with no
        // dependencies if this fails.
        String msg = "Error rendering final ChangeInfo";
        log.warn(msg, e);
        result.messages.add(msg);
        result.change = basicChangeInfo(rsrc.getChange());
    }
    return result;
}
#end_block

#method_before
private static ChangeInfo basicChangeInfo(Change c) {
    ChangeInfo info = new ChangeInfo();
    info.project = c.getProject().get();
    info.branch = c.getDest().getShortName();
    info.topic = c.getTopic();
    info.changeId = c.getKey().get();
    info.subject = c.getSubject();
    info.status = c.getStatus();
    info.owner = new AccountInfo(c.getOwner());
    info.created = c.getCreatedOn();
    info.updated = c.getLastUpdatedOn();
    info._number = c.getId().get();
    info._sortkey = c.getSortKey();
    info.finish();
    return info;
}
#method_after
private static ChangeInfo basicChangeInfo(Change c) {
    ChangeInfo info = new ChangeInfo();
    info.project = c.getProject().get();
    info.branch = c.getDest().getShortName();
    info.topic = c.getTopic();
    info.changeId = c.getKey().get();
    info.subject = c.getSubject();
    info.status = c.getStatus();
    info.owner = new AccountInfo(c.getOwner());
    info.created = c.getCreatedOn();
    info.updated = c.getLastUpdatedOn();
    info._number = c.getId().get();
    info.finish();
    return info;
}
#end_block

#method_before
public CheckResult check(Change c) {
    reset();
    change = c;
    try {
        checkImpl();
        CheckResult result = new CheckResult();
        result.messages = messages;
        return result;
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
public List<String> check(Change c) {
    reset();
    change = c;
    try {
        checkImpl();
        return messages;
    } finally {
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
private void checkImpl() {
    // All checks that require the repo.
    if (!openRepo()) {
        return;
    }
    if (!checkPatchSets()) {
        return;
    }
    checkMerged();
}
#method_after
private void checkImpl() {
    checkOwner();
    checkCurrentPatchSetEntity();
    // All checks that require the repo.
    if (!openRepo()) {
        return;
    }
    if (!checkPatchSets()) {
        return;
    }
    checkMerged();
}
#end_block

#method_before
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        all = db.get().patchSets().byChange(change.getId()).toList();
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    Multimap<ObjectId, PatchSet> bySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(Ordering.natural().onResultOf(new Function<PatchSet, Integer>() {

        @Override
        public Integer apply(PatchSet in) {
            return in.getId().get();
        }
    })).build();
    for (PatchSet ps : all) {
        ObjectId objId;
        String rev = ps.getRevision().get();
        int psNum = ps.getId().get();
        try {
            objId = ObjectId.fromString(rev);
        } catch (IllegalArgumentException e) {
            messages.add(String.format("Invalid revision on patch set %d: %s", psNum, rev));
            continue;
        }
        bySha.put(objId, ps);
        boolean isCurrent = ps.getId().equals(change.currentPatchSetId());
        if (isCurrent) {
            currPs = ps;
        }
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d: %s", psNum, rev));
        if (psCommit == null) {
            continue;
        }
        if (isCurrent) {
            currPsCommit = psCommit;
        }
    }
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : bySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            messages.add(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Joiner.on(", ").join(e.getValue())));
        }
    }
    if (currPs == null) {
        messages.add(String.format("Current patch set %d not found", change.currentPatchSetId().get()));
    }
    return currPs != null && currPsCommit != null;
}
#method_after
private boolean checkPatchSets() {
    List<PatchSet> all;
    try {
        all = db.get().patchSets().byChange(change.getId()).toList();
    } catch (OrmException e) {
        return error("Failed to look up patch sets", e);
    }
    Function<PatchSet, Integer> toPsId = new Function<PatchSet, Integer>() {

        @Override
        public Integer apply(PatchSet in) {
            return in.getId().get();
        }
    };
    Multimap<ObjectId, PatchSet> bySha = MultimapBuilder.hashKeys(all.size()).treeSetValues(Ordering.natural().onResultOf(toPsId)).build();
    for (PatchSet ps : all) {
        ObjectId objId;
        String rev = ps.getRevision().get();
        int psNum = ps.getId().get();
        try {
            objId = ObjectId.fromString(rev);
        } catch (IllegalArgumentException e) {
            error(String.format("Invalid revision on patch set %d: %s", psNum, rev), e);
            continue;
        }
        bySha.put(objId, ps);
        RevCommit psCommit = parseCommit(objId, String.format("patch set %d", psNum));
        if (psCommit == null) {
            continue;
        }
        if (ps.getId().equals(change.currentPatchSetId())) {
            currPsCommit = psCommit;
        }
    }
    for (Map.Entry<ObjectId, Collection<PatchSet>> e : bySha.asMap().entrySet()) {
        if (e.getValue().size() > 1) {
            messages.add(String.format("Multiple patch sets pointing to %s: %s", e.getKey().name(), Collections2.transform(e.getValue(), toPsId)));
        }
    }
    return currPs != null && currPsCommit != null;
}
#end_block

#method_before
private void checkMerged() {
    String refName = change.getDest().get();
    Ref dest;
    try {
        dest = repo.getRef(refName);
    } catch (IOException e) {
        messages.add("Failed to look up destination ref: " + refName);
        return;
    }
    if (dest == null) {
        messages.add("Destination ref not found (may be new branch): " + change.getDest());
    }
    RevCommit tip = parseCommit(dest.getObjectId(), "destination ref " + refName);
    if (tip == null) {
        return;
    }
    boolean merged;
    try {
        merged = rw.isMergedInto(currPsCommit, tip);
    } catch (IOException e) {
        messages.add("Error checking whether patch set " + currPs.getId().get() + " is merged");
        return;
    }
    if (merged && change.getStatus() != Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is merged into destination" + " ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    // TODO(dborowitz): Just fix it.
    } else if (!merged && change.getStatus() == Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is not merged into" + " destination ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    }
}
#method_after
private void checkMerged() {
    String refName = change.getDest().get();
    Ref dest;
    try {
        dest = repo.getRef(refName);
    } catch (IOException e) {
        messages.add("Failed to look up destination ref: " + refName);
        return;
    }
    if (dest == null) {
        messages.add("Destination ref not found (may be new branch): " + change.getDest().get());
        return;
    }
    RevCommit tip = parseCommit(dest.getObjectId(), "destination ref " + refName);
    if (tip == null) {
        return;
    }
    boolean merged;
    try {
        merged = rw.isMergedInto(currPsCommit, tip);
    } catch (IOException e) {
        messages.add("Error checking whether patch set " + currPs.getId().get() + " is merged");
        return;
    }
    if (merged && change.getStatus() != Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is merged into destination" + " ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    // TODO(dborowitz): Just fix it.
    } else if (!merged && change.getStatus() == Change.Status.MERGED) {
        messages.add(String.format("Patch set %d (%s) is not merged into" + " destination ref %s (%s), but change status is %s", currPs.getId().get(), currPsCommit.name(), refName, tip.name(), change.getStatus()));
    }
}
#end_block

#method_before
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, FluentIterable.from(Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(new FileUrlMapper()), Objects.firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#method_after
private void setDefaultRenderer(FilterConfig filterConfig) {
    if (renderer == null) {
        renderer = new DefaultRenderer(filterConfig.getServletContext().getContextPath() + STATIC_PREFIX, FluentIterable.from(Arrays.asList(config.getStringList("gitiles", null, "customTemplates"))).transform(new FileUrlMapper()), firstNonNull(config.getString("gitiles", null, "siteTitle"), "Gitiles"));
    }
}
#end_block

#method_before
private void setDefaultAccess() throws ServletException {
    if (accessFactory == null || resolver == null) {
        String basePath = config.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = config.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<HttpServletRequest>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(config), config, fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
}
#method_after
private void setDefaultAccess() throws ServletException {
    if (accessFactory == null || resolver == null) {
        String basePath = config.getString("gitiles", null, "basePath");
        if (basePath == null) {
            throw new ServletException("gitiles.basePath not set");
        }
        boolean exportAll = config.getBoolean("gitiles", null, "exportAll", false);
        FileResolver<HttpServletRequest> fileResolver;
        if (resolver == null) {
            fileResolver = new FileResolver<>(new File(basePath), exportAll);
            resolver = wrapResolver(fileResolver);
        } else if (resolver instanceof FileResolver) {
            fileResolver = (FileResolver<HttpServletRequest>) resolver;
        } else {
            fileResolver = null;
        }
        if (accessFactory == null) {
            checkState(fileResolver != null, "need a FileResolver when GitilesAccess.Factory not set");
            try {
                accessFactory = new DefaultAccess.Factory(new File(basePath), getBaseGitUrl(config), config, fileResolver);
            } catch (IOException e) {
                throw new ServletException(e);
            }
        }
    }
}
#end_block

#method_before
// We cannot have all user provided commentlinks in one regular expression
// because in these comment links we may have references to groups by number and name.
// To prevent any possible interference between the regular expressions, we use a matcher
public List<Map<String, String>> linkify(HttpServletRequest req, String message) {
    // Because we're relying on 'req' as a dynamic parameter, we need to construct
    // the CommentLinkInfo for ChangeIds on the fly
    String baseGerritUrl = urls.getBaseGerritUrl(req);
    CommentLinkInfo changeIds = new CommentLinkInfo("ChangeIdLinks", changeId, baseGerritUrl + "#/q/$2,n,z", "");
    mCommentLinks.add(changeIds);
    List<Map<String, String>> parsed = Lists.newArrayList();
    parsed.add(ImmutableMap.of("text", message));
    for (CommentLinkInfo clp : mCommentLinks) {
        for (int index = 0; index < parsed.size(); index++) {
            Map<String, String> piece = parsed.get(index);
            if (piece.get("url") == null) {
                List<Map<String, String>> resultingReplacement = clp.replace(piece.get("text"));
                if (resultingReplacement != null) {
                    parsed.remove(index);
                    for (Map<String, String> it : resultingReplacement) {
                        parsed.add(index, it);
                        index++;
                    }
                }
            }
        }
    }
    // remove the ChangeIds CommentLink
    mCommentLinks.remove(mCommentLinks.size() - 1);
    return parsed;
}
#method_after
public List<Map<String, String>> linkify(HttpServletRequest req, String message) {
    List<CommentLinkInfo> operationalCommentLinks = new ArrayList<>(commentLinks);
    // Because we're relying on 'req' as a dynamic parameter, we need to construct
    // the CommentLinkInfo for ChangeIds on the fly.
    String baseGerritUrl = urls.getBaseGerritUrl(req);
    if (baseGerritUrl != null) {
        CommentLinkInfo changeIds = new CommentLinkInfo(CHANGE_ID_PATTERN, baseGerritUrl + "#/q/$0,n,z");
        operationalCommentLinks.add(changeIds);
    }
    List<Map<String, String>> parsed = Lists.newArrayList();
    parsed.add(ImmutableMap.of("text", message));
    for (int index = 0; index < parsed.size(); index++) {
        if (parsed.get(index).get("url") != null) {
            continue;
        }
        Matcher m = allPattern.matcher(parsed.get(index).get("text"));
        if (!m.find()) {
            continue;
        }
        for (CommentLinkInfo cli : operationalCommentLinks) {
            // No need to apply more rules if this is already a link.
            if (parsed.get(index).get("url") != null) {
                break;
            }
            String text = parsed.get(index).get("text");
            parsed.remove(index);
            parsed.addAll(index, cli.linkify(text));
        }
    }
    return parsed;
}
#end_block

#method_before
@Test
public void linkifyMessageChangeId() throws Exception {
    Config config = new Config();
    config.setString("commentlink", "bugzilla", "match", "(bug\\s+#?)(\\d+)");
    config.setString("commentlink", "bugzilla", "link", "http://bugs.example.com/show_bug.cgi?id=$2");
    config.setString("commentlink", "tracker", "match", "([Bb]ug:\\s+)(\\d+)");
    config.setString("commentlink", "tracker", "html", "$1<a href=\"http://trak.example.com/$2\">$2</a>");
    Linkifier l = new Linkifier(TestGitilesUrls.URLS, config);
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "Change-Id: I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), ImmutableMap.of("text", " exists")), l.linkify(REQ, "Change-Id: I0123456789 exists"));
}
#method_after
@Test
public void linkifyMessageChangeId() throws Exception {
    Config config = new Config();
    Linkifier l = new Linkifier(TestGitilesUrls.URLS, config);
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z")), l.linkify(REQ, "Change-Id: I0123456789"));
    assertEquals(ImmutableList.of(ImmutableMap.of("text", "Change-Id: "), ImmutableMap.of("text", "I0123456789", "url", "http://test-host-review/foo/#/q/I0123456789,n,z"), ImmutableMap.of("text", " exists")), l.linkify(REQ, "Change-Id: I0123456789 exists"));
}
#end_block

#method_before
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    // Change proto.
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    // Approvals.
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    // Changed lines.
    IndexableField added = doc.getField(ADDED_FIELD);
    IndexableField deleted = doc.getField(DELETED_FIELD);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
    // Mergeable.
    cd.setMergeable("1".equals(doc.get(MERGEABLE_FIELD)));
    return cd;
}
#method_after
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    // Change proto.
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    // Approvals.
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    // Changed lines.
    IndexableField added = doc.getField(ADDED_FIELD);
    IndexableField deleted = doc.getField(DELETED_FIELD);
    if (added != null && deleted != null) {
        cd.setChangedLines(added.numericValue().intValue(), deleted.numericValue().intValue());
    }
    // Mergeable.
    String mergeable = doc.get(MERGEABLE_FIELD);
    if ("1".equals(mergeable)) {
        cd.setMergeable(true);
    } else if ("0".equals(mergeable)) {
        cd.setMergeable(false);
    }
    return cd;
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (Values<ChangeData> vs : schema.buildFields(cd, fillArgs)) {
            if (vs.getValues() != null) {
                add(result, vs);
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) {
    Document result = new Document();
    for (Values<ChangeData> vs : schema.buildFields(cd, fillArgs)) {
        if (vs.getValues() != null) {
            add(result, vs);
        }
    }
    return result;
}
#end_block

#method_before
private void add(Document doc, Values<ChangeData> values) throws OrmException {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        @SuppressWarnings("deprecation")
        boolean legacy = values.getField() == ChangeField.LEGACY_UPDATED;
        if (legacy) {
            for (Object value : values.getValues()) {
                int t = queryBuilder.toIndexTimeInMinutes((Timestamp) value);
                doc.add(new IntField(name, (int) t, store));
            }
        } else {
            for (Object value : values.getValues()) {
                doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
            }
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw QueryBuilder.badFieldType(type);
    }
}
#method_after
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        @SuppressWarnings("deprecation")
        boolean legacy = values.getField() == ChangeField.LEGACY_UPDATED;
        if (legacy) {
            for (Object value : values.getValues()) {
                int t = queryBuilder.toIndexTimeInMinutes((Timestamp) value);
                doc.add(new IntField(name, t, store));
            }
        } else {
            for (Object value : values.getValues()) {
                doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
            }
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw QueryBuilder.badFieldType(type);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = (IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#method_after
@SuppressWarnings("unchecked")
public static Integer getLimit(Predicate<ChangeData> p) {
    IntPredicate<?> ip = find(p, IntPredicate.class, FIELD_LIMIT);
    return ip != null ? ip.intValue() : null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new CommentPredicate(args, index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new CommentPredicate(args, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes));
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(schema(args.indexes), args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.db, args.projectCache, args.listChildProjects, args.self, name);
}
#method_after
@Operator
public Predicate<ChangeData> parentproject(String name) {
    return new ParentProjectPredicate(args.projectCache, args.listChildProjects, args.self, name);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> f(String file) throws QueryParseException {
    return file(file);
}
#method_after
@Operator
public Predicate<ChangeData> f(String file) {
    return file(file);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        return new RegexPathPredicate(FIELD_FILE, file);
    } else {
        return EqualsFilePredicate.create(args, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) {
    if (file.startsWith("^")) {
        return new RegexPathPredicate(file);
    } else {
        return EqualsFilePredicate.create(args, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> path(String path) throws QueryParseException {
    if (path.startsWith("^")) {
        return new RegexPathPredicate(FIELD_PATH, path);
    } else {
        return new EqualsPathPredicate(FIELD_PATH, path);
    }
}
#method_after
@Operator
public Predicate<ChangeData> path(String path) {
    if (path.startsWith("^")) {
        return new RegexPathPredicate(path);
    } else {
        return new EqualsPathPredicate(FIELD_PATH, path);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new MessagePredicate(args, index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) {
    ChangeIndex index = args.indexes.getSearchIndex();
    return new MessagePredicate(args, index, text);
}
#end_block

#method_before
@Override
protected Predicate<ChangeData> defaultField(String query) {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(file(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(message(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(comment(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(projects(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        return change(query);
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    try {
        predicates.add(projects(query));
    } catch (QueryParseException e) {
    // Skip.
    }
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#end_block

#method_before
public static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#method_after
static ChangeData createForTest(Change.Id id, int currentPatchSetId) {
    ChangeData cd = new ChangeData(null, null, null, null, null, null, null, null, null, null, null, null, null, id);
    cd.currentPatchSet = new PatchSet(new PatchSet.Id(id, currentPatchSetId));
    return cd;
}
#end_block

#method_before
public boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            Ref ref;
            Repository repo = null;
            try {
                repo = repoManager.openRepository(c.getProject());
                ref = repo.getRef(c.getDest().get());
            } catch (IOException e) {
                throw new OrmException(e);
            } finally {
                if (repo != null) {
                    repo.close();
                }
            }
            SubmitTypeRecord rec = new SubmitRuleEvaluator(this).setUser(userFactory.create(c.getOwner())).getSubmitType();
            if (rec.status != SubmitTypeRecord.Status.OK) {
                throw new OrmException("Error in mergeability check: " + rec.errorMessage);
            }
            String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
            mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref != null ? ref.getObjectId() : ObjectId.zeroId(), rec.type, mergeStrategy, c.getDest());
        }
    }
    return mergeable;
}
#method_after
public boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(c.getProject());
                Ref ref = repo.getRef(c.getDest().get());
                SubmitTypeRecord rec = new SubmitRuleEvaluator(this).getSubmitType();
                if (rec.status != SubmitTypeRecord.Status.OK) {
                    throw new OrmException("Error in mergeability check: " + rec.errorMessage);
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, rec.type, mergeStrategy, c.getDest(), repo, db);
            } catch (IOException e) {
                throw new OrmException(e);
            } finally {
                if (repo != null) {
                    repo.close();
                }
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    return object.isMergeable();
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    return getValue().equals(getField().get(object, args));
}
#end_block

#method_before
private void doAssertApproval(int expected, ChangeInfo c) {
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat((int) cr.defaultValue).isEqualTo(-1);
    assertThat(cr.all.size()).isEqualTo(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value.intValue()).isEqualTo(expected);
}
#method_after
private void doAssertApproval(int expected, ChangeInfo c) {
    LabelInfo cr = c.labels.get("Code-Review");
    assertThat((int) cr.defaultValue).isEqualTo(-1);
    assertThat(cr.all).hasSize(1);
    assertThat(cr.all.get(0).name).isEqualTo("Administrator");
    assertThat(cr.all.get(0).value.intValue()).isEqualTo(expected);
}
#end_block

#method_before
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoOp_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoOp");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("NoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#method_after
@Test
public void customLabelMaxNoBlock_NegativeVoteNotBlock() throws Exception {
    Q.setFunctionName("MaxNoBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isNull();
}
#end_block

#method_before
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    Q.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelAnyWithBlock_NegativeVoteBlock() throws Exception {
    Q.setFunctionName("AnyWithBlock");
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all.size()).isEqualTo(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#method_after
@Test
public void customLabelMaxWithBlock_NegativeVoteBlock() throws Exception {
    saveLabelConfig();
    PushOneCommit.Result r = createChange();
    revision(r).review(new ReviewInput().label(Q.getName(), -1));
    ChangeInfo c = get(r.getChangeId());
    LabelInfo q = c.labels.get(Q.getName());
    assertThat(q.all).hasSize(1);
    assertThat(q.disliked).isNull();
    assertThat(q.rejected).isNotNull();
    assertThat(q.blocking).isTrue();
}
#end_block

#method_before
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result.size()).isEqualTo(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void createDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    addDraft(changeId, revId, comment);
    Map<String, List<CommentInfo>> result = getDraftComments(changeId, revId);
    assertThat(result).hasSize(1);
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result.isEmpty()).isFalse();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#method_after
@Test
public void postComment() throws Exception {
    String file = "file";
    String contents = "contents";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), "first subject", file, contents);
    PushOneCommit.Result r = push.to(git, "refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput input = new ReviewInput();
    ReviewInput.CommentInput comment = newCommentInfo(file, Comment.Side.REVISION, 1, "comment 1");
    input.comments = new HashMap<>();
    input.comments.put(comment.path, Lists.newArrayList(comment));
    revision(r).review(input);
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
    assertCommentInfo(comment, actual);
}
#end_block

#method_before
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts.isEmpty()).isTrue();
}
#method_after
@Test
public void deleteDraft() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    ReviewInput.CommentInput comment = newCommentInfo("file1", Comment.Side.REVISION, 1, "comment 1");
    CommentInfo returned = addDraft(changeId, revId, comment);
    deleteDraft(changeId, revId, returned.id);
    Map<String, List<CommentInfo>> drafts = getDraftComments(changeId, revId);
    assertThat(drafts).isEmpty();
}
#end_block

#method_before
@Test
public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, "refs/for/master").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related.size()).isEqualTo(0);
}
#method_after
@Test
public void getRelatedNoResult() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent());
    PatchSet.Id ps = push.to(git, "refs/for/master").getPatchSetId();
    List<ChangeAndCommit> related = getRelated(ps);
    assertThat(related).isEmpty();
}
#end_block

#method_before
@Test
public void getRelatedLinear() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    for (Commit c : ImmutableList.of(c2, c1)) {
        List<ChangeAndCommit> related = getRelated(getPatchSetId(c));
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + c.getChangeId()).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + c.getChangeId()).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedLinear() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    for (Commit c : ImmutableList.of(c2, c1)) {
        List<ChangeAndCommit> related = getRelated(getPatchSetId(c));
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + c.getChangeId()).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + c.getChangeId()).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedReorder() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    for (PatchSet.Id ps : ImmutableList.of(c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedReorder() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    for (PatchSet.Id ps : ImmutableList.of(c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(2);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedReorderAndExtend() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits, create a new commit on top, and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    add(git, "c.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    PatchSet.Id c3ps1 = getPatchSetId(c3);
    for (PatchSet.Id ps : ImmutableList.of(c3ps1, c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related.size()).isEqualTo(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#method_after
@Test
public void getRelatedReorderAndExtend() throws Exception {
    // Create two commits and push.
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps1 = getPatchSetId(c1);
    PatchSet.Id c2ps1 = getPatchSetId(c2);
    // Swap the order of commits, create a new commit on top, and push again.
    git.reset().setMode(ResetType.HARD).setRef("HEAD^^").call();
    git.cherryPick().include(c2.getCommit()).include(c1.getCommit()).call();
    add(git, "c.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    PatchSet.Id c1ps2 = getPatchSetId(c1);
    PatchSet.Id c2ps2 = getPatchSetId(c2);
    PatchSet.Id c3ps1 = getPatchSetId(c3);
    for (PatchSet.Id ps : ImmutableList.of(c3ps1, c2ps2, c1ps2)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
    }
    for (PatchSet.Id ps : ImmutableList.of(c2ps1, c1ps1)) {
        List<ChangeAndCommit> related = getRelated(ps);
        assertThat(related).hasSize(3);
        assertThat(related.get(0).changeId).named("related to " + ps).isEqualTo(c3.getChangeId());
        assertThat(related.get(1).changeId).named("related to " + ps).isEqualTo(c2.getChangeId());
        assertThat(related.get(2).changeId).named("related to " + ps).isEqualTo(c1.getChangeId());
    }
}
#end_block

#method_before
@Test
public void getRelatedEdit() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    add(git, "b.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    Change ch2 = getChange(c2);
    editModifier.createEdit(ch2, getPatchSet(ch2));
    String editRev = editUtil.byChange(ch2).get().getRevision().get();
    List<ChangeAndCommit> related = getRelated(ch2.getId(), 0);
    assertThat(related.size()).isEqualTo(3);
    assertThat(related.get(0).changeId).named("related to " + c2.getChangeId()).isEqualTo(c3.getChangeId());
    assertThat(related.get(1).changeId).named("related to " + c2.getChangeId()).isEqualTo(c2.getChangeId());
    assertThat(related.get(1)._revisionNumber.intValue()).named("has edit revision number").isEqualTo(0);
    assertThat(related.get(1).commit.commit).named("has edit revision " + editRev).isEqualTo(editRev);
    assertThat(related.get(2).changeId).named("related to " + c2.getChangeId()).isEqualTo(c1.getChangeId());
}
#method_after
@Test
public void getRelatedEdit() throws Exception {
    add(git, "a.txt", "1");
    Commit c1 = createCommit(git, admin.getIdent(), "subject: 1");
    add(git, "b.txt", "2");
    Commit c2 = createCommit(git, admin.getIdent(), "subject: 2");
    add(git, "b.txt", "3");
    Commit c3 = createCommit(git, admin.getIdent(), "subject: 3");
    pushHead(git, "refs/for/master", false);
    Change ch2 = getChange(c2);
    editModifier.createEdit(ch2, getPatchSet(ch2));
    String editRev = editUtil.byChange(ch2).get().getRevision().get();
    List<ChangeAndCommit> related = getRelated(ch2.getId(), 0);
    assertThat(related).hasSize(3);
    assertThat(related.get(0).changeId).named("related to " + c2.getChangeId()).isEqualTo(c3.getChangeId());
    assertThat(related.get(1).changeId).named("related to " + c2.getChangeId()).isEqualTo(c2.getChangeId());
    assertThat(related.get(1)._revisionNumber.intValue()).named("has edit revision number").isEqualTo(0);
    assertThat(related.get(1).commit.commit).named("has edit revision " + editRev).isEqualTo(editRev);
    assertThat(related.get(2).changeId).named("related to " + c2.getChangeId()).isEqualTo(c1.getChangeId());
}
#end_block

#method_before
private void assertResult(RestResponse r, List<String> expected) throws IOException {
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    List<String> result = toHashtagList(r);
    assertThat(result).containsSequence(expected);
}
#method_after
private void assertResult(RestResponse r, List<String> expected) throws IOException {
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    List<String> result = toHashtagList(r);
    assertThat(result).containsExactlyElementsIn(expected);
}
#end_block

#method_before
private RestResponse POST(String changeId, String toAdd, String toRemove) throws IOException {
    HashtagsInput input = new HashtagsInput();
    if (toAdd != null) {
        input.add = new HashSet<String>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toAdd)));
    }
    if (toRemove != null) {
        input.remove = new HashSet<String>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toRemove)));
    }
    return adminSession.post("/changes/" + changeId + "/hashtags/", input);
}
#method_after
private RestResponse POST(String changeId, String toAdd, String toRemove) throws IOException {
    HashtagsInput input = new HashtagsInput();
    if (toAdd != null) {
        input.add = new HashSet<>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toAdd)));
    }
    if (toRemove != null) {
        input.remove = new HashSet<>(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",")).split(toRemove)));
    }
    return adminSession.post("/changes/" + changeId + "/hashtags/", input);
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertThat(subject).isEqualTo(c.getSubject());
    assertThat(expectedStatus).isEqualTo(c.getStatus());
    assertThat(expectedTopic).isEqualTo(Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = Iterables.getOnlyElement(db.changes().byKey(new Change.Key(commit.getChangeId())).toList());
    assertThat(resSubj).isEqualTo(c.getSubject());
    assertThat(expectedStatus).isEqualTo(c.getStatus());
    assertThat(expectedTopic).isEqualTo(Strings.emptyToNull(c.getTopic()));
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Ref ref = git.getRef(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, ref, result.submitType, git);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectCache.get(change.getProject()).getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, other, SubmitType.CHERRY_PICK, git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Ref ref = git.getRef(change.getDest().get());
        boolean refresh = force || isStale(change, ref);
        if (!refresh && !otherBranches) {
            return result;
        }
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        if (refresh) {
            result.mergeable = refresh(change, ps, ref, result.submitType, strategy, git);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, other, CHERRY_PICK, strategy, git)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#end_block

#method_before
private boolean refresh(final Change change, final PatchSet ps, final Ref ref, SubmitType type, Repository git) throws OrmException, IOException {
    final boolean mergeable = isMergeable(change, ps, ref, type, git);
    Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change c) {
            if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                c.setMergeable(mergeable);
                c.setLastSha1MergeTested(toRevId(ref));
                return c;
            } else {
                return null;
            }
        }
    });
    if (c != null) {
        indexer.index(db.get(), c);
    }
    return mergeable;
}
#method_after
private boolean refresh(final Change change, final PatchSet ps, final Ref ref, SubmitType type, String strategy, Repository git) throws OrmException, IOException {
    final boolean mergeable = isMergeable(change, ps, ref, type, strategy, git);
    Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change c) {
            if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                c.setMergeable(mergeable);
                c.setLastSha1MergeTested(toRevId(ref));
                return c;
            } else {
                return null;
            }
        }
    });
    if (reindex && c != null) {
        indexer.index(db.get(), c);
    }
    return mergeable;
}
#end_block

#method_before
private boolean isMergeable(Change change, PatchSet ps, Ref ref, SubmitType type, Repository git) {
    ObjectId commit;
    try {
        commit = ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Invalid revision on patch set " + ps);
        return false;
    }
    ObjectId into = ref != null && ref.getObjectId() != null ? ref.getObjectId() : ObjectId.zeroId();
    return cache.load(commit, into, type, change.getDest(), git);
}
#method_after
private boolean isMergeable(Change change, PatchSet ps, Ref ref, SubmitType type, String strategy, Repository git) {
    ObjectId commit;
    try {
        commit = ObjectId.fromString(ps.getRevision().get());
    } catch (IllegalArgumentException e) {
        log.error("Invalid revision on patch set " + ps);
        return false;
    }
    return cache.get(commit, ref, type, strategy, change.getDest(), git, db.get());
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(CACHE_NAME, EntryKey.class, Boolean.class).maximumWeight(1 << 20).weigher(MergeabilityWeigher.class);
            bind(MergeabilityCache.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(CACHE_NAME, EntryKey.class, Boolean.class).maximumWeight(1 << 20).weigher(MergeabilityWeigher.class).loader(Loader.class);
            bind(MergeabilityCache.class);
        }
    };
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof EntryKey) {
        EntryKey k = (EntryKey) o;
        return commit.equals(k.commit) && into.equals(k.into) && submitType == k.submitType;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o instanceof EntryKey) {
        EntryKey k = (EntryKey) o;
        return commit.equals(k.commit) && into.equals(k.into) && submitType == k.submitType && mergeStrategy.equals(k.mergeStrategy);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(commit, into, submitType);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(commit, into, submitType, mergeStrategy);
}
#end_block

#method_before
private void writeObject(ObjectOutputStream out) throws IOException {
    writeNotNull(out, commit);
    writeNotNull(out, into);
    writeVarInt32(out, submitType.ordinal());
}
#method_after
private void writeObject(ObjectOutputStream out) throws IOException {
    writeNotNull(out, commit);
    writeNotNull(out, into);
    Character c = SUBMIT_TYPES.get(submitType);
    if (c == null) {
        throw new IOException("Invalid submit type: " + submitType);
    }
    out.writeChar(c);
    writeString(out, mergeStrategy);
}
#end_block

#method_before
private void readObject(ObjectInputStream in) throws IOException {
    commit = readNotNull(in);
    into = readNotNull(in);
    submitType = SubmitType.values()[readVarInt32(in)];
}
#method_after
private void readObject(ObjectInputStream in) throws IOException {
    commit = readNotNull(in);
    into = readNotNull(in);
    char t = in.readChar();
    submitType = SUBMIT_TYPES.inverse().get(t);
    if (submitType == null) {
        throw new IOException("Invalid submit type code: " + t);
    }
    mergeStrategy = readString(in);
}
#end_block

#method_before
@Override
public int weigh(EntryKey k, Boolean v) {
    return // Size of EntryKey, 64-bit JVM.
    16 + 2 * (16 + 20) + 1 + // Size of Boolean.
    1;
}
#method_after
@Override
public int weigh(EntryKey k, Boolean v) {
    return // Size of EntryKey, 64-bit JVM.
    16 + 2 * (16 + 20) + 3 * 8 + // Size of Boolean.
    8;
}
#end_block

#method_before
public boolean get(ObjectId commit, ObjectId into, SubmitType submitType, Branch.NameKey dest) {
    EntryKey key = new EntryKey(commit, into, submitType);
    Boolean result = cache.getIfPresent(key);
    if (result != null) {
        return result;
    }
    Project.NameKey p = dest.getParentKey();
    try {
        Repository repo = repoManager.openRepository(p);
        try {
            return load(key, dest, repo);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        return failed(key, e);
    }
}
#method_after
public boolean get(ObjectId commit, Ref intoRef, SubmitType submitType, String mergeStrategy, Branch.NameKey dest, Repository repo, ReviewDb db) {
    ObjectId into = intoRef != null ? intoRef.getObjectId() : ObjectId.zeroId();
    EntryKey key = new EntryKey(commit, into, submitType, mergeStrategy, dest, repo, db);
    try {
        return cache.get(key);
    } catch (ExecutionException e) {
        log.error(String.format("Error checking mergeability of %s into %s (%s)", key.commit.name(), key.into.name(), key.submitType.name()), e.getCause());
        return false;
    }
}
#end_block

#method_before
public static ReplicationFilter all() {
    return new ReplicationFilter();
}
#method_after
public static ReplicationFilter all() {
    return new ReplicationFilter(Collections.<String>emptyList());
}
#end_block

#method_before
public boolean matches(NameKey name) {
    if (matchAll) {
        return true;
    } else {
        String projectName = name.get();
        for (final String projectMatch : projectsToMatch) {
            if (isRE(projectMatch)) {
                // projectMatch is a regular expression
                if (projectName.matches(projectMatch)) {
                    return true;
                }
            } else if (isWildcard(projectMatch)) {
                // projectMatch is a wildcard
                if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                    return true;
                }
            } else {
                // No special case, so we try to match directly
                if (projectName.equals(projectMatch)) {
                    return true;
                }
            }
        }
        // Nothing matched, so don't push the project
        return false;
    }
}
#method_after
public boolean matches(NameKey name) {
    if (projectPatterns.isEmpty()) {
        return true;
    } else {
        String projectName = name.get();
        for (String pattern : projectPatterns) {
            if (matchesPattern(projectName, pattern)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(new CommandProcessing(this));
    Future<?> future = null;
    ReplicationFilter projectFilter;
    if (all) {
        projectFilter = ReplicationFilter.all();
    } else {
        projectFilter = new ReplicationFilter(projectNames);
    }
    future = pushFactory.create(urlMatch, projectFilter, state).schedule(0, TimeUnit.SECONDS);
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                stateLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectPatterns.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(new CommandProcessing(this));
    Future<?> future = null;
    ReplicationFilter projectFilter;
    if (all) {
        projectFilter = ReplicationFilter.all();
    } else {
        projectFilter = new ReplicationFilter(projectPatterns);
    }
    future = pushFactory.create(urlMatch, projectFilter, state).schedule(0, TimeUnit.SECONDS);
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                stateLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                stateLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            stateLog.warn(String.format("project %s is not visible", project), state);
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#method_after
boolean wouldPushProject(final Project.NameKey project) {
    if (!isVisible(project)) {
        return false;
    }
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    return (new ReplicationFilter(Arrays.asList(projects))).matches(project);
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.isRE(projectMatch) || ReplicationFilter.isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (ReplicationFilter.getPatternType(projectMatch) != ReplicationFilter.PatternType.EXACT_MATCH) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
public RestView<ProjectResource> list() throws ResourceNotFoundException, AuthException {
    return list;
}
#method_after
@Override
public RestView<ProjectResource> list() throws ResourceNotFoundException {
    return list;
}
#end_block

#method_before
@Override
public TagResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, Exception {
    String tagName = id.get();
    if (!tagName.startsWith(Constants.R_TAGS)) {
        tagName = Constants.R_TAGS + tagName;
    }
    List<TagInfo> tags = list.apply(parent);
    for (TagInfo t : tags) {
        if (tagName.equals(t.getRef())) {
            return new TagResource(parent.getControl(), t);
        }
    }
    throw new ResourceNotFoundException();
}
#method_after
@Override
public TagResource parse(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    return new TagResource(resource.getControl(), list.get(resource, id));
}
#end_block

#method_before
@Override
public List<TagInfo> apply(ProjectResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    List<TagInfo> tags = Lists.newArrayList();
    final Repository repo;
    try {
        repo = repoManager.openRepository(resource.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            final Map<String, Ref> all = repo.getRefDatabase().getRefs(Constants.R_TAGS);
            for (Ref ref : all.values()) {
                String name = ref.getName();
                RefControl refControl = resource.getControl().controlForRef(name);
                if (refControl.isVisible()) {
                    RevObject object = rw.parseAny(ref.getObjectId());
                    if (object instanceof RevTag) {
                        // Annotated/signed tag
                        tags.add(createTagInfo((RevTag) object, name));
                    } else if (object instanceof RevCommit) {
                        // Lightweight tag
                        tags.add(createTagInfo((RevCommit) object, name));
                    }
                }
            }
        } finally {
            rw.dispose();
        }
    } finally {
        repo.close();
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.getRef().compareTo(b.getRef());
        }
    });
    return tags;
}
#method_after
@Override
public List<TagInfo> apply(ProjectResource resource) throws IOException, ResourceNotFoundException {
    List<TagInfo> tags = Lists.newArrayList();
    Repository repo = getRepository(resource.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            Map<String, Ref> all = visibleTags(resource.getControl(), repo, repo.getRefDatabase().getRefs(Constants.R_TAGS));
            for (Ref ref : all.values()) {
                tags.add(createTagInfo(ref, rw));
            }
        } finally {
            rw.dispose();
        }
    } finally {
        repo.close();
    }
    Collections.sort(tags, new Comparator<TagInfo>() {

        @Override
        public int compare(TagInfo a, TagInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    return tags;
}
#end_block

#method_before
private TagInfo createTagInfo(RevCommit commit, String name) {
    return new TagInfo(name, commit.getName());
}
#method_after
private static TagInfo createTagInfo(Ref ref, RevWalk rw) throws MissingObjectException, IOException {
    RevObject object = rw.parseAny(ref.getObjectId());
    if (object instanceof RevTag) {
        RevTag tag = (RevTag) object;
        // Annotated or signed tag
        return new TagInfo(Constants.R_TAGS + tag.getTagName(), tag.getName(), tag.getObject().getName(), tag.getFullMessage().trim(), CommonConverters.toGitPerson(tag.getTaggerIdent()));
    } else {
        // Lightweight tag
        return new TagInfo(ref.getName(), ref.getObjectId().getName());
    }
}
#end_block

#method_before
@Override
public Object apply(TagResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    return resource.getTagInfo();
}
#method_after
@Override
public TagInfo apply(TagResource resource) {
    return resource.getTagInfo();
}
#end_block

#method_before
@SuppressWarnings("resource")
private static PGPPublicKeyRingCollection readPubRing(final File pub) {
    try {
        InputStream in = new FileInputStream(pub);
        try {
            in = PGPUtil.getDecoderStream(in);
            return new PGPPublicKeyRingCollection(in);
        } finally {
            in.close();
        }
    } catch (IOException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    } catch (PGPException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    }
}
#method_after
private static PGPPublicKeyRingCollection readPubRing(final File pub) {
    try (InputStream fin = new FileInputStream(pub);
        InputStream in = PGPUtil.getDecoderStream(fin)) {
        return new PGPPublicKeyRingCollection(in);
    } catch (IOException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    } catch (PGPException e) {
        throw new ProvisionException("Cannot read " + pub, e);
    }
}
#end_block

#method_before
private byte[] encrypt(final String name, final Date date, final byte[] rawText) throws NoSuchProviderException, PGPException, IOException {
    final byte[] zText = compress(name, date, rawText);
    final BcPGPDataEncryptorBuilder builder = new BcPGPDataEncryptorBuilder(PGPEncryptedData.CAST5).setSecureRandom(prng);
    final PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(builder);
    final BcPublicKeyKeyEncryptionMethodGenerator methodGenerator = new BcPublicKeyKeyEncryptionMethodGenerator(dest);
    cpk.addMethod(methodGenerator);
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final ArmoredOutputStream aout = new ArmoredOutputStream(buf);
    final OutputStream cout = cpk.open(aout, zText.length);
    cout.write(zText);
    cout.close();
    aout.close();
    return buf.toByteArray();
}
#method_after
private byte[] encrypt(final String name, final Date date, final byte[] rawText) throws NoSuchProviderException, PGPException, IOException {
    final byte[] zText = compress(name, date, rawText);
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final ArmoredOutputStream aout = new ArmoredOutputStream(buf);
    final OutputStream cout = cpk().open(aout, zText.length);
    cout.write(zText);
    cout.close();
    aout.close();
    return buf.toByteArray();
}
#end_block

#method_before
public List<WebLinkInfo> getPatchSetLinks(String project, String commit) {
    List<WebLinkInfo> links = new ArrayList<>(4);
    for (PatchSetWebLink webLink : patchSetLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getPatchSetUrl(project, commit);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getPatchSetLinks(final String project, final String commit) {
    return filterLinks(patchSetLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((PatchSetWebLink) webLink).getPathSetWebLink(project, commit);
        }
    });
}
#end_block

#method_before
public List<WebLinkInfo> getFileLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = new ArrayList<>(4);
    for (FileWebLink webLink : fileLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getFileUrl(project, revision, file);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getFileLinks(final String project, final String revision, final String file) {
    return filterLinks(fileLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((FileWebLink) webLink).getFileWebLink(project, revision, file);
        }
    });
}
#end_block

#method_before
public Iterable<WebLinkInfo> getProjectLinks(String project) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getProjectUrl(project);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getProjectLinks(final String project) {
    return filterLinks(projectLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((ProjectWebLink) webLink).getProjectWeblink(project);
        }
    });
}
#end_block

#method_before
public Iterable<WebLinkInfo> getBranchLinks(String project, String branch) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (BranchWebLink webLink : branchLinks) {
        String name = webLink.getLinkName();
        String url = webLink.getBranchUrl(project, branch);
        if (!Strings.isNullOrEmpty(name) && !Strings.isNullOrEmpty(url)) {
            links.add(new WebLinkInfo(name, webLink.getImageUrl(), url, webLink.getTarget()));
        }
    }
    return links;
}
#method_after
public FluentIterable<WebLinkInfo> getBranchLinks(final String project, final String branch) {
    return filterLinks(branchLinks, new Function<WebLink, WebLinkInfo>() {

        @Override
        public WebLinkInfo apply(WebLink webLink) {
            return ((BranchWebLink) webLink).getBranchWebLink(project, branch);
        }
    });
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        if (!enabled) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, RUN_AS + " disabled by auth.enableRunAs = false", null);
            return;
        }
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS, e);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS, null);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        if (!enabled) {
            replyError(req, res, SC_FORBIDDEN, RUN_AS + " disabled by auth.enableRunAs = false", null);
            return;
        }
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            replyError(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS, null);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            replyError(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS, e);
            return;
        }
        if (target == null) {
            replyError(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS, null);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public static void replyError(HttpServletRequest req, HttpServletResponse res, int statusCode, String msg, CacheControl c, @Nullable Throwable err) throws IOException {
    res.setStatus(statusCode);
    configureCaching(req, res, null, c);
    replyText(req, res, msg);
    if (err != null) {
        req.setAttribute(ATTRIBUTE_ERROR_TRACE, err);
    }
}
#method_after
public static void replyError(HttpServletRequest req, HttpServletResponse res, int statusCode, String msg, CacheControl c, @Nullable Throwable err) throws IOException {
    res.setStatus(statusCode);
    configureCaching(req, res, null, c);
    replyText(req, res, msg);
    if (err != null) {
        RequestUtil.setErrorTraceAttribute(req, err);
    }
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) {
    if (!allowClosed && getChange().getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(getChange().currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    cd = changeData(db, cd);
    if ((getChange().getStatus() == Change.Status.DRAFT || patchSet.isDraft()) && !allowDraft) {
        return cannotSubmitDraft(db, patchSet, cd);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd, patchSet);
        results = evaluator.setFastEvalLabels(fastEvalLabels).evaluate();
    } catch (OrmException | RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed, boolean allowDraft) {
    if (!allowClosed && getChange().getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(getChange().currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    cd = changeData(db, cd);
    if ((getChange().getStatus() == Change.Status.DRAFT || patchSet.isDraft()) && !allowDraft) {
        return cannotSubmitDraft(db, patchSet, cd);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd);
        results = evaluator.setPatchSet(patchSet).setFastEvalLabels(fastEvalLabels).evaluate();
    } catch (OrmException | RuleEvalException e) {
        return logRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    return resultsToSubmitRecord(evaluator.getSubmitRule(), results);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd, patchSet);
        results = evaluator.evaluateSubmitType();
    } catch (OrmException | RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(cd);
        results = evaluator.evaluateSubmitType();
    } catch (OrmException | RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#method_after
private List<Term> evaluateImpl(String userRuleLocatorName, String userRuleWrapperName, String filterRuleLocatorName, String filterRuleWrapperName) throws RuleEvalException {
    PrologEnvironment env = getPrologEnvironment();
    try {
        submitRule = env.once("gerrit", userRuleLocatorName, new VariableTerm());
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        List<Term> results = new ArrayList<>();
        try {
            for (Term[] template : env.all("gerrit", userRuleWrapperName, submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (RuntimeException err) {
            throw new RuleEvalException("Exception calling " + submitRule + " on change " + cd.getId() + " of " + getProjectName(), err);
        }
        Term resultsTerm = toListTerm(results);
        if (!skipFilters) {
            resultsTerm = runSubmitFilters(resultsTerm, env, filterRuleLocatorName, filterRuleWrapperName);
        }
        if (resultsTerm.isList()) {
            List<Term> r = Lists.newArrayList();
            for (Term t = resultsTerm; t.isList(); ) {
                ListTerm l = (ListTerm) t;
                r.add(l.car().dereference());
                t = l.cdr().dereference();
            }
            return r;
        }
        return Collections.emptyList();
    } finally {
        env.close();
    }
}
#end_block

#method_before
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    return env;
}
#method_after
private PrologEnvironment getPrologEnvironment() throws RuleEvalException {
    if (patchSet == null) {
        try {
            patchSet = cd.currentPatchSet();
        } catch (OrmException err) {
            throw new RuleEvalException("Missing current patch set on change " + cd.getId() + " of " + getProjectName(), err);
        }
    }
    ProjectState projectState = control.getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        if (rule == null) {
            env = projectState.newPrologEnvironment();
        } else {
            env = projectState.newPrologEnvironment("stdin", new ByteArrayInputStream(rule.getBytes(UTF_8)));
        }
    } catch (CompileException err) {
        throw new RuleEvalException("Cannot consult rules.pl for " + getProjectName(), err);
    }
    env.set(StoredValues.REVIEW_DB, cd.db());
    env.set(StoredValues.CHANGE_DATA, cd);
    env.set(StoredValues.PATCH_SET, patchSet);
    env.set(StoredValues.CHANGE_CONTROL, control);
    return env;
}
#end_block

#method_before
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet());
    List<Term> results;
    try {
        results = evaluator.setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluateSubmitType();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<Term> results;
    try {
        results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluateSubmitType();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#end_block

#method_before
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getChange()), rsrc.getPatchSet());
    List<Term> results;
    try {
        results = evaluator.setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    } catch (RuleEvalException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#method_after
@Override
public List<Record> apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = MoreObjects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(changeDataFactory.create(db.get(), rsrc.getControl()));
    List<Term> results;
    try {
        results = evaluator.setPatchSet(rsrc.getPatchSet()).setSkipSubmitFilters(input.filters == Filters.SKIP).setRule(input.rule).evaluate();
    } catch (RuleEvalException e) {
        String msg = Joiner.on(": ").skipNulls().join(Iterables.transform(Throwables.getCausalChain(e), new Function<Throwable, String>() {

            @Override
            public String apply(Throwable in) {
                return in.getMessage();
            }
        }));
        throw new BadRequestException("rule failed: " + msg);
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solutions", evaluator.getSubmitRule().toString()));
    }
    List<SubmitRecord> records = rsrc.getControl().resultsToSubmitRecord(evaluator.getSubmitRule(), results);
    List<Record> out = Lists.newArrayListWithCapacity(records.size());
    AccountInfo.Loader accounts = accountInfoFactory.create(true);
    for (SubmitRecord r : records) {
        out.add(new Record(r, accounts));
    }
    accounts.fill();
    return out;
}
#end_block

#method_before
@Override
public Response<Result> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        Result result = new Result();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
            result.webLinksA = Lists.newArrayList();
            String rev = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
            for (WebLinkInfo link : webLinks.get().getPatchLinks(state.getProject().getName(), rev, result.metaA.name)) {
                if (!Strings.isNullOrEmpty(link.name) && !Strings.isNullOrEmpty(link.url)) {
                    result.webLinksA.add(link);
                }
            }
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
            result.webLinksB = Lists.newArrayList();
            for (WebLinkInfo link : webLinks.get().getPatchLinks(state.getProject().getName(), resource.getRevision().getPatchSet().getRefName(), result.metaB.name)) {
                if (!Strings.isNullOrEmpty(link.name) && !Strings.isNullOrEmpty(link.url)) {
                    result.webLinksB.add(link);
                }
            }
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<Result> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<Result> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet != null ? basePatchSet.getId() : null, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        Result result = new Result();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
            // TODO referring to the parent commit by refs/changes/12/60012/1^1
            // will likely not work for inline edits
            String rev = basePatchSet != null ? basePatchSet.getRefName() : resource.getRevision().getPatchSet().getRefName() + "^1";
            result.webLinksA = getFileWebLinks(state.getProject(), rev, result.metaA.name);
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
            result.webLinksB = getFileWebLinks(state.getProject(), resource.getRevision().getPatchSet().getRefName(), result.metaB.name);
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<Result> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public WebLinks get() {
    return new WebLinks(patchSetLinks, patchLinks, projectLinks, branchLinks);
}
#method_after
@Override
public WebLinks get() {
    return new WebLinks(patchSetLinks, fileLinks, projectLinks, branchLinks);
}
#end_block

#method_before
public Iterable<WebLinkInfo> getPatchLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (PatchWebLink webLink : patchLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchUrl(project, revision, file)));
    }
    return links;
}
#method_after
public Iterable<WebLinkInfo> getPatchLinks(String project, String revision, String file) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (FileWebLink webLink : fileLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getFileUrl(project, revision, file)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), PatchWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            res.setHeader(PathServlet.MODE_HEADER, "160000");
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            PathServlet.setTypeHeader(res, loader.getType());
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).setHashtags(magicBranch.getHashtags()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        ins.setHashtags(magicBranch.getHashtags());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
        Set<String> hashtags = magicBranch.getHashtags();
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    RevWalk walk = new RevWalk(repo);
    try {
        RevObject obj = walk.parseAny(view.getRevision().getId());
        switch(obj.getType()) {
            case OBJ_COMMIT:
                try (Writer writer = startRenderText(req, res);
                    OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                    out.write(((RevCommit) obj).getRawBuffer());
                }
                break;
            default:
                // TODO(dborowitz): Support showing other types.
                res.setStatus(SC_NOT_FOUND);
                break;
        }
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    Repository repo = ServletUtils.getRepository(req);
    ObjectReader reader = repo.newObjectReader();
    try {
        ObjectLoader loader = reader.open(view.getRevision().getId());
        if (loader.getType() != OBJ_COMMIT) {
            res.setStatus(SC_NOT_FOUND);
        } else {
            try (Writer writer = startRenderText(req, res);
                OutputStream out = BaseEncoding.base64().encodingStream(writer)) {
                loader.copyTo(out);
            }
        }
    } finally {
        reader.release();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    if (regex == null) {
        regex = "^*.*$";
    }
    switch(level.toLowerCase()) {
        case RESET:
            reset();
            break;
        case LEVEL_ALL:
            setLoggingLevel(Level.ALL);
            break;
        case LEVEL_TRACE:
            setLoggingLevel(Level.TRACE);
            break;
        case LEVEL_DEBUG:
            setLoggingLevel(Level.DEBUG);
            break;
        case LEVEL_INFO:
            setLoggingLevel(Level.INFO);
            break;
        case LEVEL_WARN:
            setLoggingLevel(Level.WARN);
            break;
        case LEVEL_ERROR:
            setLoggingLevel(Level.ERROR);
            break;
        case LEVEL_FATAL:
            setLoggingLevel(Level.FATAL);
            break;
        case LEVEL_OFF:
            setLoggingLevel(Level.OFF);
            break;
        default:
            stdout.println("Invalid argument");
            stdout.flush();
            break;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void run() throws MalformedURLException {
    if (level == LevelOption.RESET) {
        reset();
    } else {
        for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
            Logger log = logger.nextElement();
            if (name == null || log.getName().contains(name)) {
                log.setLevel(Level.toLevel(level.name()));
            }
        }
    }
}
#end_block

#method_before
private void reset() {
    LogManager.resetConfiguration();
    PropertyConfigurator.configure(getClass().getClassLoader().getResource("log4j.properties"));
}
#method_after
@SuppressWarnings("unchecked")
private static void reset() throws MalformedURLException {
    for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
        logger.nextElement().setLevel(null);
    }
    String path = System.getProperty(JAVA_OPTIONS_LOG_CONFIG);
    if (Strings.isNullOrEmpty(path)) {
        PropertyConfigurator.configure(Loader.getResource(LOG_CONFIGURATION));
    } else {
        PropertyConfigurator.configure(new URL(path));
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (regex == null) {
        regex = "^*.*$";
    }
    printAll();
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void run() {
    Map<String, String> logs = new TreeMap<>();
    for (Enumeration<Logger> logger = LogManager.getCurrentLoggers(); logger.hasMoreElements(); ) {
        Logger log = logger.nextElement();
        if (name == null || log.getName().contains(name)) {
            logs.put(log.getName(), log.getEffectiveLevel().toString());
        }
    }
    for (Map.Entry<String, String> e : logs.entrySet()) {
        stdout.println(e.getKey() + ": " + e.getValue());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(gerrit, SetLoggingLevelCommand.class);
    command(gerrit, ListLoggingLevelCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
    CurrentUser user = userProvider.get();
    if (user != null && user.isIdentifiedUser()) {
        IdentifiedUser who = (IdentifiedUser) user;
        if (who.getUserName() != null && !who.getUserName().isEmpty()) {
            req.setAttribute(REQ_ATTR_KEY, who.getUserName());
        } else {
            req.setAttribute(REQ_ATTR_KEY, who.getAccountId());
        }
    }
    chain.doFilter(req, resp);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
    CurrentUser user = userProvider.get();
    if (user != null && user.isIdentifiedUser()) {
        IdentifiedUser who = (IdentifiedUser) user;
        if (who.getUserName() != null && !who.getUserName().isEmpty()) {
            req.setAttribute(REQ_ATTR_KEY, who.getUserName());
        } else {
            req.setAttribute(REQ_ATTR_KEY, "a/" + who.getAccountId());
        }
    }
    chain.doFilter(req, resp);
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
    }
    modules.add(new DatabaseModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sitePath == null) {
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(File.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    modules.add(SchemaVersionCheck.module());
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@VisibleForTesting
public void start() {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (Objects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createCfgInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new AuthConfigModule());
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless));
            if (test) {
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private AbstractModule createIndexModule() {
    IndexType indexType = IndexModule.getIndexType(cfgInjector);
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        case SOLR:
            return new SolrIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#method_after
private AbstractModule createIndexModule() {
    if (slave) {
        return new DummyIndexModule();
    }
    IndexType indexType = IndexModule.getIndexType(cfgInjector);
    switch(indexType) {
        case LUCENE:
            return luceneModule != null ? luceneModule : new LuceneIndexModule();
        case SOLR:
            return new SolrIndexModule();
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createHttpdInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new JettyModule(new JettyEnv(webInjector)));
    return webInjector.createChildInjector(modules);
}
#method_after
private Injector createHttpdInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new JettyModule(new JettyEnv(webInjector)));
    return webInjector.createChildInjector(modules);
}
#end_block

#method_before
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, List<WebLinkInfo> webLinks, boolean editExists, int currentPatchSet) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (!sideA && Gerrit.isSignedIn() && meta != null && !Patch.COMMIT_MSG.equals(path)) {
        PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
        if ((editExists && id.get() == 0) || !editExists && id.get() == currentPatchSet) {
            linkPanel.add(createEditIcon());
        }
    }
    if (webLinks != null) {
        for (WebLinkInfo weblink : webLinks) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.target() != null && !weblink.target().isEmpty()) {
                a.setTarget(weblink.target());
            }
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            linkPanel.add(a);
        }
    }
}
#method_after
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, List<WebLinkInfo> webLinks, boolean editExists, int currentPatchSet) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (idActive != null && Gerrit.isSignedIn() && meta != null && !Patch.COMMIT_MSG.equals(path)) {
        if ((editExists && idActive.get() == 0) || (!editExists && idActive.get() == currentPatchSet)) {
            linkPanel.add(createEditIcon());
        }
    }
    if (webLinks != null) {
        for (WebLinkInfo weblink : webLinks) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.target() != null && !weblink.target().isEmpty()) {
                a.setTarget(weblink.target());
            }
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            linkPanel.add(a);
        }
    }
}
#end_block

#method_before
private Widget createEditIcon() {
    final Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
    anchor.addClickHandler(new ClickHandler() {

        boolean editing = false;

        @Override
        public void onClick(ClickEvent event) {
            final PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
            editing = !editing;
            parent.editSideB(editing);
            if (editing) {
                ChangeFileApi.getContent(id, path, new AsyncCallback<String>() {

                    @Override
                    public void onSuccess(String content) {
                        parent.setSiteBContent(content);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                    }
                });
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.save()));
            } else {
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
                String siteBContent = parent.getSiteBContent();
                ChangeFileApi.putContent(id, path, siteBContent, new AsyncCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                    }
                });
            }
        }
    });
    anchor.setTitle(PatchUtil.C.edit());
    return anchor;
}
#method_after
private Widget createEditIcon() {
    final Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
    anchor.addClickHandler(new ClickHandler() {

        boolean editing = false;

        @Override
        public void onClick(ClickEvent event) {
            final PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
            editing = !editing;
            parent.editSideB(editing);
            if (editing) {
                ChangeFileApi.getContent(id, path, new GerritCallback<String>() {

                    @Override
                    public void onSuccess(String content) {
                        parent.setSideBContent(content);
                    }
                });
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.save()));
            } else {
                anchor.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
                String siteBContent = parent.getSideBContent();
                ChangeFileApi.putContent(id, path, siteBContent, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                    }
                });
            }
        }
    });
    anchor.setTitle(PatchUtil.C.edit());
    return anchor;
}
#end_block

#method_before
private BeforeSelectionChangeHandler onSelectionChange(final CodeMirror cm) {
    return new BeforeSelectionChangeHandler() {

        private InsertCommentBubble bubble;

        @Override
        public void handle(CodeMirror cm, LineCharacter anchor, LineCharacter head) {
            if (anchor == head || (anchor.getLine() == head.getLine() && anchor.getCh() == head.getCh())) {
                if (bubble != null) {
                    bubble.setVisible(false);
                }
                return;
            } else if (bubble == null) {
                init(anchor);
            } else {
                bubble.setVisible(true);
            }
            bubble.position(cm.charCoords(head, "local"));
        }

        private void init(LineCharacter anchor) {
            bubble = new InsertCommentBubble(commentManager, cm);
            add(bubble);
            cm.addWidget(anchor, bubble.getElement(), false);
        }
    };
}
#method_after
private BeforeSelectionChangeHandler onSelectionChange(final CodeMirror cm) {
    return new BeforeSelectionChangeHandler() {

        private InsertCommentBubble bubble;

        @Override
        public void handle(CodeMirror cm, LineCharacter anchor, LineCharacter head) {
            if (isEdited) {
                return;
            }
            if (anchor == head || (anchor.getLine() == head.getLine() && anchor.getCh() == head.getCh())) {
                if (bubble != null) {
                    bubble.setVisible(false);
                }
                return;
            } else if (bubble == null) {
                init(anchor);
            } else {
                bubble.setVisible(true);
            }
            bubble.position(cm.charCoords(head, "local"));
        }

        private void init(LineCharacter anchor) {
            bubble = new InsertCommentBubble(commentManager, cm);
            add(bubble);
            cm.addWidget(anchor, bubble.getElement(), false);
        }
    };
}
#end_block

#method_before
public void editSideB(boolean state) {
    cmB.setOption("readOnly", !state);
    JumpKeys.enable(!state);
    if (state) {
        removeKeyHandlerRegistrations();
        cmB.removeKeyMap(sbsKeyMap);
    } else {
        cmB.addKeyMap(sbsKeyMap);
        registerKeys();
    }
}
#method_after
public void editSideB(boolean state) {
    isEdited = state;
    cmB.setOption("readOnly", !state);
    JumpKeys.enable(!state);
    if (state) {
        removeKeyHandlerRegistrations();
        cmB.removeKeyMap(sbsKeyMap);
        cmB.setOption("keyMap", "default");
        cmB.focus();
    } else {
        cmB.setOption("keyMap", "vim_ro");
        cmB.addKeyMap(sbsKeyMap);
        registerKeys();
    }
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (hashtags != null && hashtags.size() > 0) {
        try {
            ChangeResource c = changes.get().parse(change.getId());
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            postHashtags.get().apply(c, input);
        } catch (RestApiException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
    }
    return change;
}
#end_block

#method_before
void setHeaderVisible(boolean show) {
    headerVisible = !autoHideHeader || show;
    UIObject.setVisible(patchSetNavRow, headerVisible);
    UIObject.setVisible(diffHeaderRow, headerVisible && header);
    if (headerVisible) {
        parent.header.removeStyleName(style.fullscreen());
    } else {
        parent.header.addStyleName(style.fullscreen());
    }
    parent.resizeCodeMirror();
}
#method_after
void setHeaderVisible(boolean show) {
    headerVisible = !autoHideHeader || show;
    showHeader(headerVisible);
}
#end_block

#method_before
void setAutoHideDiffHeader(boolean hide) {
    autoHideHeader = hide;
    if (!hide) {
        setHeaderVisible(true);
    }
}
#method_after
void setAutoHideDiffHeader(boolean hide) {
    autoHideHeader = hide;
    if (!hide) {
        showHeader(true);
    }
}
#end_block

#method_before
@UiHandler("autoHideDiffTableHeader")
void onAutoHideDiffTableHeader(ValueChangeEvent<Boolean> e) {
    prefs.autoHideDiffTableHeader(!e.getValue());
    view.setAutoHideDiffHeader(!e.getValue());
}
#method_after
@UiHandler("autoHideDiffTableHeader")
void onAutoHideDiffTableHeader(ValueChangeEvent<Boolean> e) {
    prefs.autoHideDiffTableHeader(!e.getValue());
    view.setAutoHideDiffHeader(!e.getValue());
    view.resizeCodeMirror();
}
#end_block

#method_before
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTheme(Theme.DEFAULT);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    p.setHideEmptyPane(false);
    return p;
}
#method_after
public static AccountDiffPreference createDefault(Account.Id accountId) {
    AccountDiffPreference p = new AccountDiffPreference(accountId);
    p.setIgnoreWhitespace(Whitespace.IGNORE_NONE);
    p.setTheme(Theme.DEFAULT);
    p.setTabSize(8);
    p.setLineLength(100);
    p.setSyntaxHighlighting(true);
    p.setShowWhitespaceErrors(true);
    p.setShowLineEndings(true);
    p.setIntralineDifference(true);
    p.setShowTabs(true);
    p.setContext(DEFAULT_CONTEXT);
    p.setManualReview(false);
    p.setHideEmptyPane(false);
    p.setAutoHideDiffTableHeader(true);
    return p;
}
#end_block

#method_before
private Set<String> extractTags(Set<String> input) throws BadRequestException {
    if (input == null) {
        return Collections.emptySet();
    } else {
        HashSet<String> result = new HashSet<>();
        for (String hashtag : input) {
            if (hashtag.contains(",")) {
                throw new BadRequestException("Hashtags may not contain commas");
            }
            if (!hashtag.trim().isEmpty()) {
                result.add(hashtag.trim());
            }
        }
        return result;
    }
}
#method_after
private Set<String> extractTags(Set<String> input) throws IllegalArgumentException {
    if (input == null) {
        return Collections.emptySet();
    } else {
        HashSet<String> result = new HashSet<>();
        for (String hashtag : input) {
            if (hashtag.contains(",")) {
                throw new IllegalArgumentException("Hashtags may not contain commas");
            }
            if (!hashtag.trim().isEmpty()) {
                result.add(hashtag.trim());
            }
        }
        return result;
    }
}
#end_block

#method_before
public TreeSet<String> setHashtags(ChangeControl control, HashtagsInput input, boolean runHooks, boolean index) throws BadRequestException, OrmException, IOException, AuthException, ResourceConflictException {
    if (input == null || (input.add == null && input.remove == null)) {
        throw new BadRequestException("Hashtags are required");
    }
    if (!control.canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updatedHashtags = new HashSet<>();
    Set<String> toAdd = new HashSet<>(extractTags(input.add));
    Set<String> toRemove = new HashSet<>(extractTags(input.remove));
    for (HashtagValidationListener validator : hashtagValidationListeners) {
        try {
            validator.validateHashtags(update.getChange(), toAdd, toRemove);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updatedHashtags.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (toAdd.size() > 0 || toRemove.size() > 0) {
        updatedHashtags.addAll(toAdd);
        updatedHashtags.removeAll(toRemove);
        update.setHashtags(updatedHashtags);
        update.commit();
        if (index) {
            indexer.index(dbProvider.get(), update.getChange());
        }
        if (runHooks) {
            IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
            hooks.doHashtagsChangedHook(update.getChange(), currentUser.getAccount(), toAdd, toRemove, updatedHashtags, dbProvider.get());
        }
    }
    return new TreeSet<String>(updatedHashtags);
}
#method_after
public TreeSet<String> setHashtags(ChangeControl control, HashtagsInput input, boolean runHooks, boolean index) throws IllegalArgumentException, IOException, ValidationException, AuthException, OrmException {
    if (input == null || (input.add == null && input.remove == null)) {
        throw new IllegalArgumentException("Hashtags are required");
    }
    if (!control.canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updatedHashtags = new HashSet<>();
    Set<String> toAdd = new HashSet<>(extractTags(input.add));
    Set<String> toRemove = new HashSet<>(extractTags(input.remove));
    for (HashtagValidationListener validator : hashtagValidationListeners) {
        validator.validateHashtags(update.getChange(), toAdd, toRemove);
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updatedHashtags.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (toAdd.size() > 0 || toRemove.size() > 0) {
        updatedHashtags.addAll(toAdd);
        updatedHashtags.removeAll(toRemove);
        update.setHashtags(updatedHashtags);
        update.commit();
        if (index) {
            indexer.index(dbProvider.get(), update.getChange());
        }
        if (runHooks) {
            IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
            hooks.doHashtagsChangedHook(update.getChange(), currentUser.getAccount(), toAdd, toRemove, updatedHashtags, dbProvider.get());
        }
    }
    return new TreeSet<String>(updatedHashtags);
}
#end_block

#method_before
@Override
public Response<? extends Set<String>> apply(ChangeResource req, HashtagsInput input) throws AuthException, OrmException, IOException, BadRequestException, ResourceConflictException {
    return Response.ok(hashtagsUtil.setHashtags(req.getControl(), input, true, true));
}
#method_after
@Override
public Response<? extends Set<String>> apply(ChangeResource req, HashtagsInput input) throws AuthException, OrmException, IOException, BadRequestException, ResourceConflictException {
    try {
        return Response.ok(hashtagsUtil.setHashtags(req.getControl(), input, true, true));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    } catch (ValidationException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (com.google.gerrit.server.auth.AuthException e) {
        throw new AuthException(e.getMessage());
    }
}
#end_block

#method_before
@UiHandler("followUp")
void onFollowUp(ClickEvent e) {
    if (followUpAction == null) {
        followUpAction = new FollowUpAction(followUp, project, branch, key, changeId);
    }
    followUpAction.show();
}
#method_after
@UiHandler("followUp")
void onFollowUp(ClickEvent e) {
    if (followUpAction == null) {
        followUpAction = new FollowUpAction(followUp, project, branch, key);
    }
    followUpAction.show();
}
#end_block

#method_before
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
void send(String message) {
    ChangeApi.createChange(project, branch, message, base, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(PageLinks.toChange(id));
            hide();
        }
    });
}
#method_after
void send(String message) {
    ChangeApi.createChange(project, branch, message, base, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(PageLinks.toChange(result.legacy_id()));
            hide();
        }
    });
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException, InvalidChangeOperationException {
    if (!user.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        IdentifiedUser me = (IdentifiedUser) user.get();
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix(me.getAccountId(), change.getId()));
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, commit);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException, InvalidChangeOperationException {
    if (!user.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        IdentifiedUser me = (IdentifiedUser) user.get();
        String editRefPrefix = editRefPrefix(me.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            PatchSet basePatchSet = edit.getBasePatchSet();
            if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
                throw new ResourceConflictException("only edit for current patch set can be published");
            }
            insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(repo, rw, inserter, edit.getEditCommit(), basePatchSet));
        } finally {
            inserter.release();
            rw.release();
        }
        // TODO(davido): This should happen in the same BatchRefUpdate.
        ChangeEditModifier.deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#method_after
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            PatchSet basePatchSet = edit.getBasePatchSet();
            if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
                throw new ResourceConflictException("only edit for current patch set can be published");
            }
            insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(repo, rw, inserter, edit.getEditCommit(), basePatchSet));
        } finally {
            inserter.release();
            rw.release();
        }
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public void delete(ChangeEdit edit) throws IOException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        ChangeEditModifier.deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#method_after
public void delete(ChangeEdit edit) throws IOException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(Change change, RevCommit commit) throws IOException, InvalidChangeOperationException {
    if (commit.getParentCount() != 1) {
        throw new InvalidChangeOperationException("change edit commit has multiple parents");
    }
    RevCommit parentCommit = commit.getParent(0);
    ObjectId rev = parentCommit.getId();
    RevId parentRev = new RevId(ObjectId.toString(rev));
    try {
        List<PatchSet> r = db.get().patchSets().byRevision(parentRev).toList();
        if (r.isEmpty()) {
            throw new InvalidChangeOperationException(String.format("patch set %s change edit is based on doesn't exist", rev.abbreviate(8).name()));
        }
        if (r.size() > 1) {
            throw new InvalidChangeOperationException(String.format("multiple patch sets for change edit parent %s", rev.abbreviate(8).name()));
        }
        PatchSet parentPatchSet = Iterables.getOnlyElement(r);
        if (!change.getId().equals(parentPatchSet.getId().getParentKey())) {
            throw new InvalidChangeOperationException(String.format("different change edit ID %d and its parent patch set %d", change.getId().get(), parentPatchSet.getId().getParentKey().get()));
        }
        return parentPatchSet;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(Change change, Ref ref) throws IOException, InvalidChangeOperationException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return db.get().patchSets().get(new PatchSet.Id(change.getId(), Integer.valueOf(psId)));
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
static String editRefName(Account.Id accountId, Change.Id changeId, PatchSet.Id psId) {
    return String.format("%s/edit-%d/%d", RefNames.refsUsers(accountId), changeId.get(), psId.get());
}
#method_after
static String editRefName(Account.Id accountId, Change.Id changeId, PatchSet.Id psId) {
    return editRefPrefix(accountId, changeId) + psId.get();
}
#end_block

#method_before
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(change.getProject());
    String refPrefix = editRefPrefix(me.getAccountId(), change.getId());
    try {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit base = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            ObjectId commit = createCommit(me, inserter, base, base, base.getTree());
            inserter.flush();
            return update(repo, me, editRefName(me.getAccountId(), change.getId(), ps.getId()), rw, ObjectId.zeroId(), commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(change.getProject());
    String refPrefix = editRefPrefix(me.getAccountId(), change.getId());
    try {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit base = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            RevCommit changeBase = base.getParent(0);
            ObjectId commit = createCommit(me, inserter, base, changeBase, base.getTree());
            inserter.flush();
            String editRefName = editRefName(me.getAccountId(), change.getId(), ps.getId());
            return update(repo, me, editRefName, rw, ObjectId.zeroId(), commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit mergeTip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(editCommit.getParent(0));
            if (m.merge(mergeTip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < mergeTip.getParentCount(); i++) {
                    commit.addParentId(mergeTip.getParent(i));
                }
                commit.setParentId(mergeTip);
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                RefUpdate.Result res = update(repo, me, refName, rw, ObjectId.zeroId(), newEdit);
                switch(res) {
                    case FORCED:
                    case NEW:
                    case NO_CHANGE:
                        deleteRef(repo, edit);
                        return res;
                    default:
                        throw new IOException(String.format("Failed to delete ref %s: %s", refName, res));
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = rw.parseCommit(edit.getRef().getObjectId());
            PatchSet basePs = edit.getBasePatchSet();
            RevCommit base = rw.parseCommit(ObjectId.fromString(basePs.getRevision().get()));
            if (base.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            ObjectId newTree = writeNewTree(op, repo, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, repo, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    newChangeForAllNotInTarget.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    newChangeForAllNotInTarget = newInheritedBooleanBox();
    saveEnabler.listenTo(newChangeForAllNotInTarget);
    grid.add(Util.C.createNewChangeForAllNotInTarget(), newChangeForAllNotInTarget);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(newChangeForAllNotInTarget, result.create_new_change_for_all_not_in_target());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null || actions.isEmpty()) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        if (id.equals("create_change")) {
            ActionInfo create = actions.get(id);
            final Button createChange = new Button(create.label());
            createChange.setTitle(create.title());
            createChange.setEnabled(create.enabled());
            createChange.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    CreateChangeAction.call(createChange, getProjectKey().toString());
                }
            });
            actionsPanel.add(createChange);
        } else {
            actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
        }
    }
}
#method_after
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null || actions.isEmpty()) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
    }
    if (Gerrit.isSignedIn()) {
        actionsPanel.add(createChangeAction());
    }
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(newChangeForAllNotInTarget), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    call("create").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String subject, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText("Create");
            message.setText("Insert the description of the change.");
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, this.getDestinationBranch(), this.message.getText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, getDestinationBranch(), message.getText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
@Override
public String getDisplayString() {
    final String refsHeads = "refs/heads/";
    if (branch.ref().startsWith(refsHeads)) {
        return branch.ref().substring(refsHeads.length());
    }
    return branch.ref();
}
#method_after
@Override
public String getDisplayString() {
    if (branch.ref().startsWith(Branch.R_HEADS)) {
        return branch.ref().substring(Branch.R_HEADS.length());
    }
    return branch.ref();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("open".equals(statusName) || "pending".equals(statusName)) {
        return status_open();
    } else if ("closed".equals(statusName)) {
        return ChangeStatusPredicate.closed(args.db);
    } else if ("reviewed".equalsIgnoreCase(statusName)) {
        return new IsReviewedPredicate();
    } else {
        return new ChangeStatusPredicate(statusName);
    }
}
#method_after
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("reviewed".equalsIgnoreCase(statusName)) {
        return new IsReviewedPredicate();
    } else {
        return ChangeStatusPredicate.parse(statusName);
    }
}
#end_block

#method_before
public Predicate<ChangeData> status_open() {
    return ChangeStatusPredicate.open(args.db);
}
#method_after
public Predicate<ChangeData> status_open() {
    return ChangeStatusPredicate.open();
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    return getValue().equals(object.notes().load().getHashtags());
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    return object.notes().load().getHashtags().contains(getValue());
}
#end_block

#method_before
protected Injector createDbInjector(final DataSourceProvider.Context context) {
    final File sitePath = getSitePath();
    final List<Module> modules = new ArrayList<>();
    Module sitePathModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
        }
    };
    modules.add(sitePathModule);
    modules.add(new LifecycleModule() {

        @Override
        protected void configure() {
            bind(DataSourceProvider.Context.class).toInstance(context);
            if (dsProvider != null) {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(dsProvider).in(SINGLETON);
                if (LifecycleListener.class.isAssignableFrom(dsProvider.getClass())) {
                    listener().toInstance((LifecycleListener) dsProvider);
                }
            } else {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(SiteLibraryBasedDataSourceProvider.class).in(SINGLETON);
                listener().to(SiteLibraryBasedDataSourceProvider.class);
            }
        }
    });
    Module configModule = new GerritServerConfigModule();
    modules.add(configModule);
    Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
    Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String dbType;
    if (dsProvider != null) {
        dbType = getDbType(dsProvider);
    } else {
        dbType = cfg.getString("database", null, "type");
    }
    final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(DataSourceType.class).toInstance(dst);
        }
    });
    modules.add(new DatabaseModule());
    modules.add(new SchemaModule());
    modules.add(new SecureStoreModule(cfg));
    modules.add(new LocalDiskRepositoryManager.Module());
    try {
        return Guice.createInjector(PRODUCTION, modules);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof SQLException) {
            throw die("Cannot connect to SQL database", why);
        }
        if (why instanceof OrmException && why.getCause() != null && "Unable to determine driver URL".equals(why.getMessage())) {
            why = why.getCause();
            if (isCannotCreatePoolException(why)) {
                throw die("Cannot connect to SQL database", why.getCause());
            }
            throw die("Cannot connect to SQL database", why);
        }
        final StringBuilder buf = new StringBuilder();
        if (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
        } else {
            buf.append(first.getMessage());
        }
        while (why != null) {
            buf.append("\n  caused by ");
            buf.append(why.toString());
            why = why.getCause();
        }
        throw die(buf.toString(), new RuntimeException("DbInjector failed", ce));
    }
}
#method_after
protected Injector createDbInjector(final DataSourceProvider.Context context) {
    final File sitePath = getSitePath();
    final List<Module> modules = new ArrayList<>();
    Module sitePathModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            bind(SecureStore.class).toProvider(SecureStoreProvider.class);
        }
    };
    modules.add(sitePathModule);
    modules.add(new LifecycleModule() {

        @Override
        protected void configure() {
            bind(DataSourceProvider.Context.class).toInstance(context);
            if (dsProvider != null) {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(dsProvider).in(SINGLETON);
                if (LifecycleListener.class.isAssignableFrom(dsProvider.getClass())) {
                    listener().toInstance((LifecycleListener) dsProvider);
                }
            } else {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(SiteLibraryBasedDataSourceProvider.class).in(SINGLETON);
                listener().to(SiteLibraryBasedDataSourceProvider.class);
            }
        }
    });
    Module configModule = new GerritServerConfigModule();
    modules.add(configModule);
    Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
    Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String dbType;
    if (dsProvider != null) {
        dbType = getDbType(dsProvider);
    } else {
        dbType = cfg.getString("database", null, "type");
    }
    final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(DataSourceType.class).toInstance(dst);
        }
    });
    modules.add(new DatabaseModule());
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    try {
        return Guice.createInjector(PRODUCTION, modules);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof SQLException) {
            throw die("Cannot connect to SQL database", why);
        }
        if (why instanceof OrmException && why.getCause() != null && "Unable to determine driver URL".equals(why.getMessage())) {
            why = why.getCause();
            if (isCannotCreatePoolException(why)) {
                throw die("Cannot connect to SQL database", why.getCause());
            }
            throw die("Cannot connect to SQL database", why);
        }
        final StringBuilder buf = new StringBuilder();
        if (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
        } else {
            buf.append(first.getMessage());
        }
        while (why != null) {
            buf.append("\n  caused by ");
            buf.append(why.toString());
            why = why.getCause();
        }
        throw die(buf.toString(), new RuntimeException("DbInjector failed", ce));
    }
}
#end_block

#method_before
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, NameKey destBranch, Id patchSetId) throws MergeValidationException {
    try {
        db = schemaFactory.open();
        PatchSetApproval psa = approvalsUtil.getSubmitter(db, commit.notes(), patchSetId);
        if (psa == null) {
            throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
        }
        final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
        if (!submitter.getCapabilities().canAdministrateServer()) {
            throw new MergeValidationException(CommitMergeStatus.MISSING_DEPENDENCY);
        }
    } catch (OrmException e) {
        throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    PatchSetApproval psa = approvalsUtil.getSubmitter(reviewDb.get(), commit.notes(), patchSetId);
    if (psa == null) {
        throw new MergeValidationException(CommitMergeStatus.NO_PATCH_SET);
    }
    IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
    if (!submitter.getCapabilities().canAdministrateServer()) {
        throw new MergeValidationException(CommitMergeStatus.MISSING_DEPENDENCY);
    }
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = Maps.newHashMapWithExpectedSize(2);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        try (OutputStream out = startRenderStreamingHtml(req, res, "gitiles.logDetail", data);
            Writer w = newWriter(out, res)) {
            new LogSoyData(req, access, pretty).renderStreaming(paginator, null, renderer, w, df);
        }
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = Maps.newHashMapWithExpectedSize(2);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        try (OutputStream out = startRenderStreamingHtml(req, res, "gitiles.logDetail", data)) {
            Writer w = newWriter(out, res);
            new LogSoyData(req, access, pretty).renderStreaming(paginator, null, renderer, w, df);
            w.flush();
        }
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        walk.setRevFilter(new AuthorRevFilter(author));
    }
    return walk;
}
#end_block

#method_before
private static Paginator newPaginator(Repository repo, GitilesView view) throws IOException {
    if (view == null) {
        return null;
    }
    RevWalk walk = null;
    try {
        walk = newWalk(repo, view);
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
    Optional<ObjectId> start;
    try {
        start = getStart(view.getParameters(), walk.getObjectReader());
    } catch (IOException e) {
        walk.release();
        throw e;
    }
    if (start == null) {
        return null;
    }
    return new Paginator(walk, getLimit(view), start.orNull(), PaginatorFilters.fromQuery(view.getParameters()));
}
#method_after
private static Paginator newPaginator(Repository repo, GitilesView view) throws IOException {
    if (view == null) {
        return null;
    }
    RevWalk walk = null;
    try {
        walk = newWalk(repo, view);
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
    Optional<ObjectId> start;
    try {
        start = getStart(view.getParameters(), walk.getObjectReader());
    } catch (IOException e) {
        walk.release();
        throw e;
    }
    if (start == null) {
        return null;
    }
    return new Paginator(walk, getLimit(view), start.orNull());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // on the last ps or not
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (editBox == null) {
        editBox = new EditFileBox(id, content, file);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(editMessageButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(editBox);
    p.showRelativeTo(replyButton);
    GlobalKey.dialog(p);
    popup = p;
}
#method_after
void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (editBox == null) {
        editBox = new EditFileBox(id, content, file);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(editMessageButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(editBox);
    p.showRelativeTo(relativeTo);
    GlobalKey.dialog(p);
    popup = p;
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    String idStr = id.get();
    boolean edit = false;
    if (idStr.endsWith(".edit")) {
        idStr = idStr.substring(0, idStr.length() - 5);
        edit = true;
    }
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, idStr)) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0), edit);
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#end_block

#method_before
private List<PatchSet> find(ChangeResource change, String id) throws OrmException {
    ReviewDb db = dbProvider.get();
    if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) {
        // Legacy patch set number syntax.
        PatchSet ps = dbProvider.get().patchSets().get(new PatchSet.Id(change.getChange().getId(), Integer.parseInt(id)));
        if (ps != null) {
            return Collections.singletonList(ps);
        }
        return Collections.emptyList();
    } else if (id.length() < 4 || id.length() > RevId.LEN) {
        // Impossibly long identifier will never match.
        return Collections.emptyList();
    } else if (id.length() >= 8) {
        // Commit names are rather unique. Query for the commit and later
        // match to the change. This is most likely going to identify 1 or
        // at most 2 patch sets to consider, which is smaller than looking
        // for all patch sets in the change.
        RevId revid = new RevId(id);
        if (revid.isComplete()) {
            return db.patchSets().byRevision(revid).toList();
        } else {
            return db.patchSets().byRevisionRange(revid, revid.max()).toList();
        }
    } else {
        // Chance of collision rises; look at all patch sets on the change.
        List<PatchSet> out = Lists.newArrayList();
        for (PatchSet ps : db.patchSets().byChange(change.getChange().getId())) {
            if (ps.getRevision() != null && ps.getRevision().get().startsWith(id)) {
                out.add(ps);
            }
        }
        return out;
    }
}
#method_after
private List<PatchSet> find(ChangeResource change, String id) throws OrmException {
    ReviewDb db = dbProvider.get();
    if (id.equals("0")) {
        return loadEdit(change, null);
    } else if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) {
        // Legacy patch set number syntax.
        PatchSet ps = dbProvider.get().patchSets().get(new PatchSet.Id(change.getChange().getId(), Integer.parseInt(id)));
        if (ps != null) {
            return Collections.singletonList(ps);
        }
        return Collections.emptyList();
    } else if (id.length() < 4 || id.length() > RevId.LEN) {
        // Impossibly long identifier will never match.
        return Collections.emptyList();
    } else if (id.length() >= 8) {
        // Commit names are rather unique. Query for the commit and later
        // match to the change. This is most likely going to identify 1 or
        // at most 2 patch sets to consider, which is smaller than looking
        // for all patch sets in the change.
        RevId revid = new RevId(id);
        if (revid.isComplete()) {
            List<PatchSet> list = db.patchSets().byRevision(revid).toList();
            if (list.isEmpty()) {
                return loadEdit(change, revid);
            }
            return list;
        } else {
            return db.patchSets().byRevisionRange(revid, revid.max()).toList();
        }
    } else {
        // Chance of collision rises; look at all patch sets on the change.
        List<PatchSet> out = Lists.newArrayList();
        for (PatchSet ps : db.patchSets().byChange(change.getChange().getId())) {
            if (ps.getRevision() != null && ps.getRevision().get().startsWith(id)) {
                out.add(ps);
            }
        }
        return out;
    }
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnDeleteRestore(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnDeleteRestore(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditeable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDeleteRestore(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            boolean editeable = isEditeable(info);
            sb.openElement("button").setAttribute("title", editeable ? Resources.C.removeFileInline() : Resources.C.restoreFileInline()).setAttribute("onclick", (editeable ? DELETE : RESTORE) + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(editeable ? Gerrit.RESOURCES.redNot() : Gerrit.RESOURCES.editUndo())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnDeleteRestore(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            boolean editable = isEditable(info);
            sb.openElement("button").setAttribute("title", editable ? Resources.C.removeFileInline() : Resources.C.restoreFileInline()).setAttribute("onclick", (editable ? DELETE : RESTORE) + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(editable ? Gerrit.RESOURCES.redNot() : Gerrit.RESOURCES.editUndo())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnRemove(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnRemove(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditeable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnRemove(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser && isEditeable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.removeFileInline()).setAttribute("onclick", DELETE + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.redNot())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnRemove(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser && isEditable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.removeFileInline()).setAttribute("onclick", DELETE + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.redNot())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
@Override
protected void onLoad() {
    file.setText(fileName);
    file.setEnabled(fileName.isEmpty());
    reload.setEnabled(!fileName.isEmpty());
    content.setText(fileContent);
    save.setEnabled(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            content.setFocus(true);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    file.set(id, content);
    file.setText(fileName);
    file.setEnabled(fileName.isEmpty());
    content.setText(fileContent);
    save.setEnabled(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            content.setFocus(true);
        }
    });
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
        reviewMode.setVisible(!editMode.isVisible());
    }
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
        reviewMode.setVisible(!editMode.isVisible());
    }
    RevisionInfo rev = info.revision(revision);
    editFileAction = new EditFileAction(new PatchSet.Id(changeId, rev._number()), "", "", style, editMessage, reply);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // on the last ps or not
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    initEditFileAction(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, NoSuchChangeException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands);
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands);
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Post.Input input) throws AuthException, InvalidChangeOperationException, IOException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(resource.getChange());
    if (!edit.isPresent()) {
        edit = createEdit(resource.getChange());
    }
    if (input != null && !Strings.isNullOrEmpty(input.path) && input.restore != null && input.restore) {
        editModifier.restoreFile(edit.get(), input.path);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Post.Input input) throws AuthException, InvalidChangeOperationException, IOException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(resource.getChange());
    if (!edit.isPresent()) {
        edit = createEdit(resource.getChange());
    }
    if (input != null && !Strings.isNullOrEmpty(input.restorePath)) {
        editModifier.restoreFile(edit.get(), input.restorePath);
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    if (input.content == null) {
        throw new ResourceConflictException("no input provided");
    }
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
public static RevisionInfo fromEdit(EditInfo edit) {
    RevisionInfo revisionInfo = (RevisionInfo) createObject();
    revisionInfo.takeFromEdit(edit);
    return revisionInfo;
}
#method_after
public static RevisionInfo fromEdit(EditInfo edit) {
    RevisionInfo revisionInfo = createObject().cast();
    revisionInfo.takeFromEdit(edit);
    return revisionInfo;
}
#end_block

#method_before
public static void sortRevisionInfoByNumber(JsArray<RevisionInfo> list) {
    final int parent_edit_number = findEditParent(list);
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            int a_number = a._number();
            int b_number = b._number();
            if (a_number == 0) {
                a_number = parent_edit_number;
            }
            if (b_number == 0) {
                b_number = parent_edit_number;
            }
            return a_number - b_number;
        }
    });
}
#method_after
public static void sortRevisionInfoByNumber(JsArray<RevisionInfo> list) {
    final int editParent = findEditParent(list);
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return num(a) - num(b);
        }

        private int num(RevisionInfo r) {
            return !r.is_edit() ? 2 * (r._number() - 1) + 1 : 2 * editParent;
        }
    });
}
#end_block

#method_before
private Map<String, FetchInfo> fillFetchMap(ChangeEdit edit) {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        // No fluff, just stuff
        if (!scheme.isAuthSupported()) {
            continue;
        }
        String projectName = edit.getChange().getProject().get();
        String url = scheme.getUrl(projectName);
        String refName = edit.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        for (DynamicMap.Entry<DownloadCommand> e2 : downloadCommands) {
            String commandName = e2.getExportName();
            DownloadCommand command = e2.getProvider().get();
            String c = command.getCommand(scheme, projectName, refName);
            if (c != null) {
                addCommand(fetchInfo, commandName, c);
            }
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> fillFetchMap(ChangeEdit edit) {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        // No fluff, just stuff
        if (!scheme.isAuthSupported()) {
            continue;
        }
        String projectName = edit.getChange().getProject().get();
        String refName = edit.getRefName();
        FetchInfo fetchInfo = new FetchInfo(scheme.getUrl(projectName), refName);
        r.put(schemeName, fetchInfo);
        ChangeJson.populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
    }
    return r;
}
#end_block

#method_before
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo, null, null, null, null);
    Change change1 = ins1.getChange();
    change1.setStatus(Change.Status.NEW);
    ins1.insert();
    ChangeInserter ins2 = newChange(repo, null, null, null, null);
    Change change2 = ins2.getChange();
    change2.setStatus(Change.Status.MERGED);
    ins2.insert();
    assertResultEquals(change1, queryOne("status:n"));
    assertResultEquals(change1, queryOne("status:ne"));
    assertResultEquals(change1, queryOne("status:new"));
    assertResultEquals(change1, queryOne("status:N"));
    assertResultEquals(change1, queryOne("status:nE"));
    assertResultEquals(change1, queryOne("status:neW"));
    try {
        query("status:newx");
    } catch (BadRequestException e) {
    // Expected.
    }
}
#method_after
@Test
public void byStatusPrefix() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo, null, null, null, null);
    Change change1 = ins1.getChange();
    change1.setStatus(Change.Status.NEW);
    ins1.insert();
    ChangeInserter ins2 = newChange(repo, null, null, null, null);
    Change change2 = ins2.getChange();
    change2.setStatus(Change.Status.MERGED);
    ins2.insert();
    assertResultEquals(change1, queryOne("status:n"));
    assertResultEquals(change1, queryOne("status:ne"));
    assertResultEquals(change1, queryOne("status:new"));
    assertResultEquals(change1, queryOne("status:N"));
    assertResultEquals(change1, queryOne("status:nE"));
    assertResultEquals(change1, queryOne("status:neW"));
    assertBadQuery("status:nx");
    assertBadQuery("status:newx");
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.user.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new GerritCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                RevisionInfo revisionInfo = revisions.get(i + offset);
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisionInfo._number(), revisionInfo.edit())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    RevisionInfo revisionInfo = info.revision(revision);
    String currentlyViewedPatchSet = revisionInfo.id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    String currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision()).id();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1).id();
    }
    String currentlyViewedPatchSet = info.revision(revision).id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectQuery.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            Gerrit.display(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
        }
    }, ClickEvent.getType());
    projectLink.setText(info.project());
    projectLink.setTargetHistoryToken(PageLinks.toProject(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), info.topic())));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(r.id())) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    RevisionInfo revisionInfo = info.revision(revision);
    if (revisionInfo.edit()) {
        statusText.setInnerText(Util.C.revisionEdit());
    } else {
        if (!current && info.status() == Change.Status.NEW) {
            statusText.setInnerText(Util.C.notCurrent());
        } else {
            statusText.setInnerText(Util.toLongString(info.status()));
        }
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    quickApprove.set(info, revision, replyAction);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    } else {
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        SubmitType type = Project.SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(r.id())) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    com.google.gwt.user.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#method_after
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        CallbackGroup group = new CallbackGroup();
        if (Gerrit.isSignedIn()) {
            // TODO(davido): It shouldn't be necessary to make this call.
            // PatchSetsBox is constructed via PatchSetsAction which is
            // only initialized by CS2 after loading the EditInfo in that path.
            ChangeApi.edit(changeId.get(), group.add(new GerritCallback<EditInfo>() {

                @Override
                public void onSuccess(EditInfo result) {
                    edit = result;
                }
            }));
        }
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(group.addFinal(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.set_name(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r.id());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#method_after
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r._number());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : "";
    String cn = c.committer() != null ? c.committer().name() : "";
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#end_block

#method_before
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, r.id());
}
#method_after
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, String.valueOf(r._number()));
}
#end_block

#method_before
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, IndexRewriteImpl.DEFAULT_MAX_LIMIT);
}
#method_after
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, DEFAULT_MAX_QUERY_LIMIT);
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_QUERY_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#end_block

#method_before
private void checkComments(Map<String, List<Comment>> in) throws BadRequestException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c == null) {
                listItr.remove();
            } else {
                if (c.line < 0) {
                    throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
                }
                c.message = Strings.emptyToNull(c.message).trim();
                if (c.message.isEmpty()) {
                    listItr.remove();
                }
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(Map<String, List<Comment>> in) throws BadRequestException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
private boolean insertComments(RevisionResource rsrc, Map<String, List<Comment>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        drafts = scanDraftComments(rsrc);
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<Comment>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (Comment c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
            }
            ups.add(e);
        }
    }
    switch(Objects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                ups.add(e);
            }
            break;
    }
    db.get().patchComments().delete(del);
    db.get().patchComments().upsert(ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(RevisionResource rsrc, Map<String, List<Comment>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        drafts = scanDraftComments(rsrc);
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<Comment>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (Comment c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(Objects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                ups.add(e);
            }
            break;
    }
    db.get().patchComments().delete(del);
    db.get().patchComments().upsert(ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxNumberLimit = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxNumberLimit != 0 && pending.size() > maxNumberLimit) {
                reject(magicBranch.cmd, "The number of pushed changes in a batch exceeds the max limit " + maxNumberLimit);
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    Git git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
    String changeId = newChange(git, admin.getIdent());
    change = getChange(changeId);
    ps = getCurrentPatchSet(changeId);
    assertNotNull(ps);
    changeId = newChange2(git, admin.getIdent());
    change2 = getChange(changeId);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId);
    assertNotNull(ps2);
    session = new RestSession(server, admin);
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    session = new RestSession(server, admin);
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@After
public void cleanup() {
    db.close();
}
#method_after
@After
public void cleanup() {
    DateTimeUtils.setCurrentMillisSystem();
    db.close();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGet());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, EditInfo> result = toEditInfoMap(r);
    assertEquals(1, result.size());
    EditInfo info = Iterables.getOnlyElement(result.values());
    assertEquals(0, info._number);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlGet());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    assertEquals(0, toEditInfoMap(r).size());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Input in = new Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(204, session.putRaw(urlPut(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlPut());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(new String(CONTENT_NEW2, UTF_8), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(PutContent.class);
    delete(CHANGE_EDIT_KIND).to(DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(GetEditFileContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ListChangeEdits.Factory.class);
            factory(CreateOrModifyChangeEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGetFiles());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, FileInfo> result = toFileInfoMap(r);
    assertEquals(2, result.size());
    List<String> l = Lists.newArrayList(result.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Put.Input in = new Put.Input();
    in.restore = true;
    assertEquals(SC_NO_CONTENT, session.post(urlEditFile2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, session.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    Put.Input in = new Put.Input();
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#end_block

#method_before
private EditInfo toEditInfo() throws IOException {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = session.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create post(ChangeResource parent) throws RestApiException {
    return createFactory.create(parent.getChange(), null);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wipped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc) throws AuthException, IOException, NoSuchChangeException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        if (list) {
            PatchSet basePatchSet = null;
            if (base != null) {
                RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
                basePatchSet = baseResource.getPatchSet();
            }
            try {
                return Response.ok(fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet));
            } catch (PatchListNotAvailableException e) {
                throw new ResourceNotFoundException(e.getMessage());
            }
        } else {
            return Response.ok(editJson.toEditInfo(edit.get()));
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get());
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    byte[] content = null;
    if (input.content != null) {
        content = ByteStreams.toByteArray(input.content.getInputStream());
    }
    try {
        if (input.restore) {
            editModifier.restoreFile(rsrc.getChangeEdit(), path);
        } else {
            editModifier.modifyFile(rsrc.getChangeEdit(), path, content);
        }
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public BinaryResult apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath());
    } catch (ResourceNotFoundException rnfe) {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getBasePatchSet().getRevision().get(), rsrc.getPath());
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    put(FILE_KIND, "content").to(PutContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    int patchSetId = PatchSet.Id.fromRef(ref, ce);
    if (patchSetId >= 0 || ref.substring(ce).equals(RefNames.META_SUFFIX)) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#method_after
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    if (ref.substring(ce).equals(RefNames.META_SUFFIX) || PatchSet.Id.fromRef(ref, ce) >= 0) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#end_block

#method_before
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#method_after
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#end_block

#method_before
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
}
#method_after
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
    // Something other than patch set after change.
    assertNotRef("refs/changes/34/1234/0");
    assertNotRef("refs/changes/34/1234/foo");
    assertNotRef("refs/changes/34/1234|56");
    assertNotRef("refs/changes/34/1234foo");
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    boolean ok = true;
    for (final PatchSet patchSet : patchSets) {
        try {
            approveOne(patchSet);
        } catch (UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while approving " + patchSet.getId() + "\n");
            log.error("internal error while approving " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw error("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw error("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw error("json and message are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw error("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void applyReview(PatchSet patchSet, final ReviewInput review) throws Exception {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#method_after
private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#end_block

#method_before
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    notes.load();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        List<PatchLineComment> baseCommentsForThisPs = new ArrayList<>(allCommentsOnBases.get(psId));
        baseCommentsForThisPs.addAll(commentsForBase);
        commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        List<PatchLineComment> commentsForThisPs = new ArrayList<>(allCommentsOnPs.get(psId));
        commentsForThisPs.addAll(commentsForPs);
        commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter);
    }
    return noteMap.writeTree(inserter);
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes().load();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        List<PatchLineComment> baseCommentsForThisPs = new ArrayList<>(allCommentsOnBases.get(psId));
        baseCommentsForThisPs.addAll(commentsForBase);
        commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        List<PatchLineComment> commentsForThisPs = new ArrayList<>(allCommentsOnPs.get(psId));
        commentsForThisPs.addAll(commentsForPs);
        commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
private Iterable<Project.NameKey> scan() throws BadRequestException {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

                public boolean apply(Project.NameKey in) {
                    return a.run(in.get());
                }
            });
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    } else {
        return projectCache.all();
    }
}
#method_after
private Iterable<Project.NameKey> scan() throws BadRequestException {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        if (matchRegex.equals(".*")) {
            return projectCache.all();
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

                public boolean apply(Project.NameKey in) {
                    return a.run(in.get());
                }
            });
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    } else {
        return projectCache.all();
    }
}
#end_block

#method_before
@Override
public void onChangeEvent(ChangeEvent event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = new Project.NameKey(e.change.project);
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            Change.Id changeId = new Change.Id(Integer.parseInt(e.change.number));
            PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(e.patchSet.number));
            PatchSet ps = reviewDb.patchSets().get(psId);
            if (ps == null) {
                log.warn("Patch set " + psId.get() + " not found.");
                return;
            }
            final Change change = reviewDb.changes().get(psId.getParentKey());
            if (change == null) {
                log.warn("Change " + changeId.get() + " not found.");
                return;
            }
            ReviewerFilterSection found = findReviewerSection(sections, reviewDb, change);
            if (found == null || found.getReviewers().isEmpty()) {
                return;
            }
            final Runnable task = reviewersFactory.create(change, toAccounts(found.getReviewers(), projectName, e.uploader.email));
            workQueue.getDefaultQueue().submit(new Runnable() {

                public void run() {
                    RequestContext old = tl.setContext(new RequestContext() {

                        @Override
                        public CurrentUser getCurrentUser() {
                            return identifiedUserFactory.create(change.getOwner());
                        }

                        @Override
                        public Provider<ReviewDb> getReviewDbProvider() {
                            return new Provider<ReviewDb>() {

                                @Override
                                public ReviewDb get() {
                                    if (db == null) {
                                        try {
                                            db = schemaFactory.open();
                                        } catch (OrmException e) {
                                            throw new ProvisionException("Cannot open ReviewDb", e);
                                        }
                                    }
                                    return db;
                                }
                            };
                        }
                    });
                    try {
                        task.run();
                    } finally {
                        tl.setContext(old);
                        if (db != null) {
                            db.close();
                            db = null;
                        }
                    }
                }
            });
        } catch (OrmException | QueryParseException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#method_after
@Override
public void onChangeEvent(ChangeEvent event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = new Project.NameKey(e.change.project);
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            Change.Id changeId = new Change.Id(Integer.parseInt(e.change.number));
            PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(e.patchSet.number));
            PatchSet ps = reviewDb.patchSets().get(psId);
            if (ps == null) {
                log.warn("Patch set " + psId.get() + " not found.");
                return;
            }
            final Change change = reviewDb.changes().get(psId.getParentKey());
            if (change == null) {
                log.warn("Change " + changeId.get() + " not found.");
                return;
            }
            Set<String> reviewers = findReviewers(sections, reviewDb, change);
            if (reviewers.isEmpty()) {
                return;
            }
            final Runnable task = reviewersFactory.create(change, toAccounts(reviewers, projectName, e.uploader.email));
            workQueue.getDefaultQueue().submit(new Runnable() {

                public void run() {
                    RequestContext old = tl.setContext(new RequestContext() {

                        @Override
                        public CurrentUser getCurrentUser() {
                            return identifiedUserFactory.create(change.getOwner());
                        }

                        @Override
                        public Provider<ReviewDb> getReviewDbProvider() {
                            return new Provider<ReviewDb>() {

                                @Override
                                public ReviewDb get() {
                                    if (db == null) {
                                        try {
                                            db = schemaFactory.open();
                                        } catch (OrmException e) {
                                            throw new ProvisionException("Cannot open ReviewDb", e);
                                        }
                                    }
                                    return db;
                                }
                            };
                        }
                    });
                    try {
                        task.run();
                    } finally {
                        tl.setContext(old);
                        if (db != null) {
                            db.close();
                            db = null;
                        }
                    }
                }
            });
        } catch (OrmException | QueryParseException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, ?> json_data = buildData(req);
    renderJson(req, res, json_data, json_data.getClass());
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesAccess access = getAccess(req);
    RepositoryDescription desc = access.getRepositoryDescription();
    renderJson(req, res, desc, new TypeToken<RepositoryDescription>() {
    }.getType());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    install(new FactoryModuleBuilder().build(CreateBranch.Factory.class));
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    install(new FactoryModuleBuilder().build(CreateBranch.Factory.class));
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#end_block

#method_before
@Override
public CommitResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, AuthException, IOException {
    if (!parent.getControl().isOwner()) {
        throw new AuthException("no project owner");
    }
    ObjectId objectId;
    try {
        objectId = ObjectId.fromString(id.get());
    } catch (IllegalArgumentException e) {
        throw new ResourceNotFoundException(id);
    }
    Repository repo = repoManager.openRepository(parent.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(objectId);
            for (int i = 0; i < commit.getParentCount(); i++) {
                rw.parseCommit(commit.getParent(i));
            }
            return new CommitResource(parent.getControl(), commit);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
@Override
public CommitResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException {
    ObjectId objectId;
    try {
        objectId = ObjectId.fromString(id.get());
    } catch (IllegalArgumentException e) {
        throw new ResourceNotFoundException(id);
    }
    Repository repo = repoManager.openRepository(parent.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(objectId);
            if (!parent.getControl().canReadCommit(rw, commit)) {
                throw new ResourceNotFoundException(id);
            }
            for (int i = 0; i < commit.getParentCount(); i++) {
                rw.parseCommit(commit.getParent(i));
            }
            return new CommitResource(parent.getControl(), commit);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Test
public void getCommit() throws IOException {
    RestResponse r = adminSession.get("/projects/" + project.get() + "/branches/" + IdString.fromDecoded("refs/meta/config").encoded());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    BranchInfo branchInfo = newGson().fromJson(r.getReader(), BranchInfo.class);
    r.consume();
    r = adminSession.get("/projects/" + project.get() + "/commits/" + branchInfo.revision);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    CommitInfo commitInfo = newGson().fromJson(r.getReader(), CommitInfo.class);
    assertEquals(branchInfo.revision, commitInfo.commit);
    assertEquals("Created project", commitInfo.subject);
    assertEquals("Created project\n", commitInfo.message);
    assertNotNull(commitInfo.author);
    assertEquals("Administrator", commitInfo.author.name);
    assertNotNull(commitInfo.committer);
    assertEquals("Gerrit Code Review", commitInfo.committer.name);
    assertTrue(commitInfo.parents.isEmpty());
}
#method_after
@Test
public void getCommit() throws IOException {
    RestResponse r = adminSession.get("/projects/" + project.get() + "/branches/" + IdString.fromDecoded(RefNames.REFS_CONFIG).encoded());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    BranchInfo branchInfo = newGson().fromJson(r.getReader(), BranchInfo.class);
    r.consume();
    r = adminSession.get("/projects/" + project.get() + "/commits/" + branchInfo.revision);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    CommitInfo commitInfo = newGson().fromJson(r.getReader(), CommitInfo.class);
    assertEquals(branchInfo.revision, commitInfo.commit);
    assertEquals("Created project", commitInfo.subject);
    assertEquals("Created project\n", commitInfo.message);
    assertNotNull(commitInfo.author);
    assertEquals("Administrator", commitInfo.author.name);
    assertNotNull(commitInfo.committer);
    assertEquals("Gerrit Code Review", commitInfo.committer.name);
    assertTrue(commitInfo.parents.isEmpty());
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key.get()).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#end_block

#method_before
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#method_after
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getPatchSetComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#end_block

#method_before
private Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#method_after
private static Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#end_block

#method_before
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (final PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#method_after
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    // Here, we are writing the comments to the notedb so that we can
    // read from and test the notedb when the noteDb config is enabled.
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    update.putComment(plc1);
    update.putComment(plc3);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    update.putComment(plc2);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#method_after
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    NotesMigration migration = injector.getInstance(NotesMigration.class);
    plcUtil = new PatchLineCommentsUtil(migration);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    List<PatchLineComment> commentsByOwner = Lists.newArrayList();
    commentsByOwner.add(plc1);
    commentsByOwner.add(plc3);
    List<PatchLineComment> commentsByReviewer = Lists.newArrayList();
    commentsByReviewer.add(plc2);
    plca.upsert(commentsByOwner);
    expectLastCall().anyTimes();
    plca.upsert(commentsByReviewer);
    expectLastCall().anyTimes();
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByOwner);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByReviewer);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#end_block

#method_before
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return ChangesForTestUtil.stubChangeControl(repoManager, c, changeOwner);
}
#method_after
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return TestChanges.stubChangeControl(repoManager, c, changeOwner);
}
#end_block

#method_before
private Change newChange() {
    return ChangesForTestUtil.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#end_block

#method_before
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return ChangesForTestUtil.newUpdate(injector, repoManager, c, user);
}
#method_after
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return TestChanges.newUpdate(injector, repoManager, c, user);
}
#end_block

#method_before
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(roundTimestampToSecond(plc.getWrittenOn()), roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#method_after
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(TimeUtil.roundTimestampToSecond(plc.getWrittenOn()), TimeUtil.roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try {
        FileOutputStream out = new FileOutputStream(tmp);
        try {
            byte[] data = new byte[8192];
            int n;
            while ((n = in.read(data)) > 0) {
                out.write(data, 0, n);
            }
            keep = true;
            return tmp;
        } finally {
            out.close();
        }
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#method_after
static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try (FileOutputStream out = new FileOutputStream(tmp)) {
        byte[] data = new byte[8192];
        int n;
        while ((n = in.read(data)) > 0) {
            out.write(data, 0, n);
        }
        keep = true;
        return tmp;
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        /*
       * Pluggable plugin provider may have assigned a plugin name that could be
       * actually different from the initial one assigned during scan. It is
       * safer then to reassign it.
       */
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        name = serverPluginFactory.getPluginName(srcPlugin);
        return loadServerPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private ServerPlugin loadServerPlugin(String name, File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    return serverPluginFactory.get(scriptFile, pluginUserFactory.create(name), snapshot, getPluginCanonicalWebUrl(name), getPluginDataDir(name));
}
#method_after
private ServerPlugin loadServerPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = serverPluginFactory.getPluginName(scriptFile);
    return serverPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getGerritJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#method_after
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(File srcFile, PluginUser pluginUser, FileSnapshot snapshot, String pluginCanonicalWebUrl, File pluginDataDir) throws InvalidPluginException {
    try {
        File tmp;
        String name = getPluginName(srcFile);
        FileInputStream in = new FileInputStream(srcFile);
        String extension = getExtension(srcFile);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, pluginCanonicalWebUrl, pluginUser, pluginDataDir);
        } finally {
            in.close();
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription description) throws InvalidPluginException {
    try {
        String name = getPluginName(srcFile);
        String extension = getExtension(srcFile);
        try (FileInputStream in = new FileInputStream(srcFile)) {
            File tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, description);
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#end_block

#method_before
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, String pluginCanonicalWebUrl, PluginUser pluginUser, File pluginDataDir) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, pluginCanonicalWebUrl, pluginUser, srcJar, snapshot, new JarScanner(srcJar), pluginDataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, new JarScanner(srcJar), description.dataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Injector getPluginInjector(File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getGerritJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#method_after
private Injector getPluginInjector(final File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    change.revision(revision);
    setWebLinks(change, revision, revInfo);
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
}
#end_block

#method_before
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.linkUrl(), link.linkName());
        }
    }
}
#method_after
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.link_url(), link.link_name());
        }
    }
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    out.webLinks = Lists.newArrayList();
    for (WebLinks.Link link : webLinkFactory.create().getPatchSetLinks(project, in.getRevision().get())) {
        out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        out.webLinks = Lists.newArrayList();
        for (WebLinks.Link link : webLinks.get().getPatchSetLinks(project, in.getRevision().get())) {
            out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
        }
    }
    return out;
}
#end_block

#method_before
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    ArrayList<Link> links = new ArrayList<Link>();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(WebLinks.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getKey()));
    this.psId = psId;
}
#method_after
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getId()));
    this.psId = psId;
}
#end_block

#method_before
public void putComment(PatchLineComment comment) {
    commentsToAdd.add(comment);
}
#method_after
public void putComment(PatchLineComment comment) {
    checkArgument(psId != null, "setPatchSetId must be called before putComment");
    checkArgument(getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(comment), psId);
    checkArgument(comment.getRevId() != null);
    if (comment.getSide() == 0) {
        commentsForBase.add(comment);
    } else {
        commentsForPs.add(comment);
    }
}
#end_block

#method_before
private void storeCommentsInNotes(RevCommit c) throws OrmException, IOException {
    if (commentsToAdd.isEmpty()) {
        return;
    }
    // assume you can only add comments to one patchset at a time
    PatchSet.Id psId = commentsToAdd.get(0).getKey().getParentKey().getParentKey();
    ChangeNotes notes = ctl.getNotes();
    LinkedListMultimap<PatchSet.Id, PatchLineComment> allComments = LinkedListMultimap.create(notes.getPublishedComments());
    List<PatchLineComment> commentsOnSamePs = allComments.get(psId);
    // add all comments and re-sort list
    commentsOnSamePs.addAll(commentsToAdd);
    commentsOnSamePs = ChangeNotes.COMMENT_ORDERING.sortedCopy(commentsOnSamePs);
    String noteContents = PatchLineCommentsUtil.buildNote(accountCache, commentsOnSamePs);
    AnyObjectId oId = c.getId();
    NoteMap noteMap = notes.getNoteMap();
    noteMap.set(oId, noteContents, this.inserter);
    this.inserter.flush();
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnBases, commentsForBase);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnPs, commentsForPs);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        batch.write(new CommitBuilder());
        RevCommit c = batch.commit();
        storeCommentsInNotes(c);
        return c;
    } catch (OrmException e) {
        // TODO(yyonas): what to do with this exception?
        return null;
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        CommitBuilder builder = new CommitBuilder();
        if (migration.write()) {
            ObjectId treeId = storeCommentsInNotes();
            if (treeId != null) {
                builder.setTreeId(treeId);
            }
        }
        batch.write(builder);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#method_after
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#end_block

#method_before
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        publishedCommentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = publishedCommentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes);
        if (result == null) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        publishedComments.putAll(psId, result);
    }
}
#method_after
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        commentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = commentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = CommentsInNotesUtil.parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
}
#end_block

#method_before
private ConfigInvalidException parseException(String fmt, Object... args) {
    return new ConfigInvalidException("Change " + changeId + ": " + String.format(fmt, args));
}
#method_after
private ConfigInvalidException parseException(String fmt, Object... args) {
    return ChangeNotes.parseException(changeId, fmt, args);
}
#end_block

#method_before
public NoteMap getNoteMap() {
    return noteMap;
}
#method_after
NoteMap getNoteMap() {
    return noteMap;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        publishedComments = ImmutableListMultimap.copyOf(parser.publishedComments);
        noteMap = parser.publishedCommentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
    // TODO(yyonas): figure out how to handle this exception
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    publishedComments = ImmutableListMultimap.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    commentsForBase = ImmutableListMultimap.of();
    commentsForPS = ImmutableListMultimap.of();
}
#end_block

#method_before
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        // Pluggable plugin provider may have assigned
        name = newPlugin.getName();
        // a plugin name that could be actually
        // different from the initial
        // one assigned during scan. It is safer then
        // to reassign it.
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        name = externalPluginFactory.getPluginName(srcPlugin);
        return loadExternalPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        return loadExternalPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new ServerPlugin(name, getPluginCanonicalWebUrl(name), pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), getPluginDataDir(name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private ServerPlugin loadExternalPlugin(String name, File scriptFile, FileSnapshot snapshot) {
    return externalPluginFactory.get(name, scriptFile, pluginUserFactory.create(name), snapshot);
}
#method_after
private ServerPlugin loadExternalPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = externalPluginFactory.getPluginName(scriptFile);
    return externalPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
public static String getGerritJarPluginName(File srcFile) throws IOException {
    JarFile jarFile = new JarFile(srcFile);
    try {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    } finally {
        jarFile.close();
    }
}
#method_after
public static String getGerritJarPluginName(File srcFile) throws IOException {
    try (JarFile jarFile = new JarFile(srcFile)) {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    }
}
#end_block

#method_before
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<InitStep>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#method_after
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(String name, File srcFile, PluginUser pluginUser, FileSnapshot snapshot) {
    return providerOf(srcFile).get(name, srcFile, pluginUser, snapshot);
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription pluginDescription) throws InvalidPluginException {
    return providerOf(srcFile).get(srcFile, snapshot, pluginDescription);
}
#end_block

#method_before
@Override
public boolean handles(File srcFile) {
    for (ServerPluginProvider scriptingFactory : serverPluginProviders) {
        if (scriptingFactory.handles(srcFile)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean handles(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return true;
        case 0:
            return false;
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
private ServerPluginProvider providerOf(File srcFile) {
    for (ServerPluginProvider provider : serverPluginProviders) {
        if (provider.handles(srcFile)) {
            return provider;
        }
    }
    throw new IllegalArgumentException(srcFile.getAbsolutePath() + " is not a supported Gerrit plugin format");
}
#method_after
private ServerPluginProvider providerOf(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return providers.get(0);
        case 0:
            throw new IllegalArgumentException("No ServerPluginProvider found/loaded to handle plugin file " + srcFile.getAbsolutePath());
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(uploadValidatorsFactory.create(project, repo));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
    // UploadValidationException is used by the UploadValidationListener to
    // stop the uploadPack. We do not want this exception to go beyond this
    // point otherwise it would print a stacktrace in the logs and return an
    // internal server error to the client.
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(preUploadHooks)));
    return up;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    up.setPreUploadHook(uploadValidatorsFactory.create(pc.getProject(), repo));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        validator.onPreUpload(repository, project, wants, haves);
    }
}
#method_after
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        try {
            validator.onPreUpload(repository, project, remoteHost, up, wants, haves);
        } catch (ValidationException e) {
            throw new UploadValidationException(e.getMessage());
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null && isUnconditionalRequestOnModifiedDate(req)) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            PluginContentScanner scanner = holder.plugin.getContentScanner();
            Optional<PluginEntry> entry = scanner.getEntry(file);
            if (entry.isPresent()) {
                if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                    rsc.send(req, res);
                } else {
                    sendResource(scanner, entry.get(), key, res);
                }
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        PluginContentScanner scanner = holder.plugin.getContentScanner();
        Optional<PluginEntry> entry = scanner.getEntry(file);
        if (!entry.isPresent()) {
            entry = findSource(scanner, file);
        }
        if (!entry.isPresent() && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            long pluginLastModified = holder.plugin.getSrcFile().lastModified();
            if (hasUpToDateCachedResource(rsc, pluginLastModified)) {
                rsc.send(req, res);
            } else {
                sendAutoIndex(scanner, pfx, holder.plugin.getName(), key, res, pluginLastModified);
            }
        } else if (entry.isPresent() && entry.get().getName().endsWith(".md")) {
            if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                rsc.send(req, res);
            } else {
                sendMarkdownAsHtml(scanner, entry.get(), holder.plugin.getName(), key, res);
            }
        } else if (entry.isPresent()) {
            sendResource(scanner, entry.get(), key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null && req.getHeader(HttpHeaders.IF_MODIFIED_SINCE) == null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            PluginContentScanner scanner = holder.plugin.getContentScanner();
            Optional<PluginEntry> entry = scanner.getEntry(file);
            if (entry.isPresent()) {
                if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                    rsc.send(req, res);
                } else {
                    sendResource(scanner, entry.get(), key, res);
                }
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        PluginContentScanner scanner = holder.plugin.getContentScanner();
        Optional<PluginEntry> entry = scanner.getEntry(file);
        if (!entry.isPresent()) {
            entry = findSource(scanner, file);
        }
        if (!entry.isPresent() && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            long pluginLastModified = holder.plugin.getSrcFile().lastModified();
            if (hasUpToDateCachedResource(rsc, pluginLastModified)) {
                rsc.send(req, res);
            } else {
                sendAutoIndex(scanner, pfx, holder.plugin.getName(), key, res, pluginLastModified);
            }
        } else if (entry.isPresent() && entry.get().getName().endsWith(".md")) {
            if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                rsc.send(req, res);
            } else {
                sendMarkdownAsHtml(scanner, entry.get(), holder.plugin.getName(), key, res);
            }
        } else if (entry.isPresent()) {
            if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                rsc.send(req, res);
            } else {
                sendResource(scanner, entry.get(), key, res);
            }
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private boolean hasUpToDateCachedResource(Resource cachedResource, long lastUpdateTime) {
    return cachedResource != null && cachedResource.isUpToDate(lastUpdateTime);
}
#method_after
private boolean hasUpToDateCachedResource(Resource cachedResource, long lastUpdateTime) {
    return cachedResource != null && cachedResource.isUnchanged(lastUpdateTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.setDateHeader("Last-Modified", lastModifiedTime);
    res.getOutputStream().write(html);
}
#end_block

#method_before
@Override
public void setReviewed(String unencodedFilePath) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    try {
        RestModifyView<FileResource, Reviewed.Input> view;
        if (reviewed) {
            view = putReviewed;
        } else {
            view = deleteReviewed;
        }
        view.apply(files.get().parse(revision, IdString.fromDecoded(path)), new Reviewed.Input());
    } catch (Exception e) {
        throw new RestApiException("Cannot update reviewed flag", e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.setReviewed(true).apply(revision).value());
    } catch (OrmException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Set<String> reviewed() throws RestApiException {
    try {
        return ImmutableSet.copyOf((Iterable<String>) listFiles.get().setReviewed(true).apply(revision).value());
    } catch (OrmException e) {
        throw new RestApiException("Cannot list reviewed files", e);
    }
}
#end_block

#method_before
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    }
}
#method_after
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    } else {
        e.needMerge = true;
    }
}
#end_block

#method_before
private void threadSummary() {
    List<String> prefixes = Lists.newArrayList("HTTP", "IntraLineDiff", "ReceiveCommits", "SSH git-receive-pack", "SSH git-upload-pack", "SSH-Interactive-Worker", "SSH-Stream-Worker", "SshCommandStart");
    Runtime r = Runtime.getRuntime();
    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    stdout.format("Threads: %d cpus available, %d threads\n", r.availableProcessors(), threadMXBean.getThreadCount());
    Table<String, Thread.State, Integer> count = HashBasedTable.create();
    for (long id : threadMXBean.getAllThreadIds()) {
        ThreadInfo info = threadMXBean.getThreadInfo(id);
        if (info == null) {
            continue;
        }
        String name = info.getThreadName();
        for (String p : prefixes) {
            if (name.startsWith(p)) {
                Thread.State state = info.getThreadState();
                Integer c = count.get(p, state);
                count.put(p, info.getThreadState(), c != null ? c++ : 1);
            }
        }
    }
    stdout.print(String.format("  %22s", ""));
    for (Thread.State s : Thread.State.values()) {
        stdout.print(String.format(" %14s", s.name()));
    }
    stdout.print('\n');
    for (String p : prefixes) {
        stdout.print(String.format("  %-22s", p));
        for (Thread.State s : Thread.State.values()) {
            stdout.print(String.format(" %14d", nullToZero(count.get(p, s))));
        }
        stdout.print('\n');
    }
    stdout.print('\n');
}
#method_after
private void threadSummary() {
    List<String> prefixes = Arrays.asList("HTTP", "IntraLineDiff", "ReceiveCommits", "SSH git-receive-pack", "SSH git-upload-pack", "SSH-Interactive-Worker", "SSH-Stream-Worker", "SshCommandStart");
    String other = "Other";
    Runtime r = Runtime.getRuntime();
    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    stdout.format("Threads: %d CPUs available, %d threads\n", r.availableProcessors(), threadMXBean.getThreadCount());
    if (showThreads) {
        Table<String, Thread.State, Integer> count = HashBasedTable.create();
        for (long id : threadMXBean.getAllThreadIds()) {
            ThreadInfo info = threadMXBean.getThreadInfo(id);
            if (info == null) {
                continue;
            }
            String name = info.getThreadName();
            Thread.State state = info.getThreadState();
            String group = other;
            for (String p : prefixes) {
                if (name.startsWith(p)) {
                    group = p;
                    break;
                }
            }
            Integer c = count.get(group, state);
            count.put(group, state, c != null ? c + 1 : 1);
        }
        stdout.print(String.format("  %22s", ""));
        for (Thread.State s : Thread.State.values()) {
            stdout.print(String.format(" %14s", s.name()));
        }
        stdout.print('\n');
        for (String p : prefixes) {
            printThreadCounts(p, count.row(p));
        }
        printThreadCounts(other, count.row(other));
    }
    stdout.print('\n');
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        if (changeMessage != null) {
            Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
            ChangeControl otherControl = refControl.getProjectControl().controlFor(otherChange);
            ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, change.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
            updateForOtherChange.commit();
        }
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            if (changeMessage != null) {
                Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
                ChangeControl otherControl = ctlFactory.controlFor(otherChange, user);
                ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, updatedChange.getLastUpdatedOn());
                cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
                updateForOtherChange.commit();
            }
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#method_after
private static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#end_block

#method_before
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    List<ChangeMessage> changeMessages;
    if (!migration.readChangeMessages()) {
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> result = ImmutableListMultimap.builder();
        for (ChangeMessage cm : db.changeMessages().byChange(notes.getChangeId())) {
            result.put(cm.getPatchSetId(), cm);
        }
        changeMessages = sortChangeMessages(result.build().values());
    } else {
        changeMessages = sortChangeMessages(notes.load().getChangeMessages().values());
    }
    return changeMessages;
}
#method_after
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChangeMessages()) {
        return sortChangeMessages(db.changeMessages().byChange(notes.getChangeId()));
    } else {
        return sortChangeMessages(notes.load().getChangeMessages().values());
    }
}
#end_block

#method_before
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    List<ChangeMessage> cms = cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId());
    return Iterables.getFirst(Iterables.filter(Lists.reverse(cms), new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }), null);
}
#method_after
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    return FluentIterable.from(cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId())).filter(new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }).last().orNull();
}
#end_block

#method_before
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    Collections.sort(msgs, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return b.getWrittenOn().compareTo(a.getWrittenOn());
        }
    });
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#method_after
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    msgs = ChangeNotes.MESSAGE_BY_TIME.sortedCopy(msgs);
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO(yyonas): atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(submitter.getAccountId()));
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // I didn't see how this function was going to do anything different
        // if I did what was below or put it in the function and kept the lines in
        // there...I commented out the method below because ATM, it's not used.
        // addMergedMessage(submitter, msg);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // TODO(yyonas): we need to be able to change the author of the message
        // is not the person for whom the change was made. addMergedMessage
        // did this in the past.
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#end_block

#method_before
// private void addMergedMessage(PatchSetApproval submitter, ChangeMessage msg)
// throws OrmException {
// if (msg != null) {
// if (submitter != null && msg.getAuthor() == null) {
// msg.setAuthor(submitter.getAccountId());
// }
// db.changeMessages().insert(Collections.singleton(msg));
// }
// }
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO: atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#method_after
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control, change.getCreatedOn());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#method_after
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#end_block

#method_before
@Override
public void run() {
    try {
        rc.processCommands(commands, progress);
    } catch (NoSuchChangeException e) {
        // TODO(yyonas): Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void run() {
    rc.processCommands(commands, progress);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) throws NoSuchChangeException {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, NoSuchChangeException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException, NoSuchChangeException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException, NoSuchChangeException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        ChangeControl control = ctlFactory.controlFor(change, currentUser);
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = gApi.changes().query("status:open").get();
    assertEquals(1, results.size());
    results = gApi.changes().query("status:closed").get();
    assertTrue(results.isEmpty());
}
#method_after
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = query("status:open");
    assertEquals(1, results.size());
    results = query("status:closed");
    assertTrue(results.isEmpty());
}
#end_block

#method_before
@Test
public void queryChangesOneTerm() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = gApi.changes().query("status:open").get();
    assertEquals(2, results.size());
    assertEquals(r2.getChangeId(), results.get(0).changeId);
    assertEquals(r1.getChangeId(), results.get(1).changeId);
}
#method_after
@Test
public void queryChangesOneTerm() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = query("status:open");
    assertEquals(2, results.size());
    assertEquals(r2.getChangeId(), results.get(0).changeId);
    assertEquals(r1.getChangeId(), results.get(1).changeId);
}
#end_block

#method_before
@Test
public void queryChangesMultipleTerms() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query("status:open " + r1.getChangeId()).get();
    assertEquals(r1.getChangeId(), Iterables.getOnlyElement(results).changeId);
}
#method_after
@Test
public void queryChangesMultipleTerms() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = query("status:open " + r1.getChangeId());
    assertEquals(r1.getChangeId(), Iterables.getOnlyElement(results).changeId);
}
#end_block

#method_before
@Test
public void queryChangesNoOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertNull(result.labels);
    assertNull(result.messages);
    assertNull(result.revisions);
    assertNull(result.actions);
}
#method_after
@Test
public void queryChangesNoOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(query(r.getChangeId()));
    assertNull(result.labels);
    assertNull(result.messages);
    assertNull(result.revisions);
    assertNull(result.actions);
}
#end_block

#method_before
@Test
public void queryChangesReviewerAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    QueryRequest q = gApi.changes().query("owner:self");
    assertEquals(r.getChangeId(), Iterables.getOnlyElement(q.get()).changeId);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setAccountContext(user);
    revision(r).review(ReviewInput.recommend());
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertTrue(result.reviewed);
}
#method_after
@Test
public void queryChangesReviewerAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertNull(get(r.getChangeId()).reviewed);
    revision(r).review(ReviewInput.recommend());
    assertTrue(get(r.getChangeId()).reviewed);
}
#end_block

#method_before
@Test
public void queryChangesReviewerNotReviewed() throws Exception {
    PushOneCommit.Result r = createChange();
    QueryRequest q = gApi.changes().query("owner:self");
    assertEquals(r.getChangeId(), Iterables.getOnlyElement(q.get()).changeId);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setAccountContext(user);
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertNull(result.reviewed);
}
#method_after
@Test
public void queryChangesReviewerNotReviewed() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertNull(get(r.getChangeId()).reviewed);
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            JarFile jar = new JarFile(holder.plugin.getSrcFile());
            try {
                JarEntry entry = jar.getJarEntry(file);
                if (exists(entry)) {
                    sendResource(jar, entry, key, res);
                } else {
                    resourceCache.put(key, Resource.NOT_FOUND);
                    Resource.NOT_FOUND.send(req, res);
                }
            } finally {
                jar.close();
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix) && holder.plugin.getSrcFile().getName().endsWith(".jar")) {
        JarFile jar = new JarFile(holder.plugin.getSrcFile());
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res, holder.plugin.getSrcFile().lastModified());
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res, time);
}
#end_block

#method_before
private static String getPrefix(Plugin plugin, String attr, String def) {
    File srcFile = plugin.getSrcFile();
    if (srcFile == null || !srcFile.getName().endsWith(".jar")) {
        return def;
    }
    try {
        JarFile jarFile = new JarFile(plugin.getSrcFile());
        try {
            String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
            if (prefix != null) {
                return CharMatcher.is('/').trimFrom(prefix) + "/";
            } else {
                return def;
            }
        } finally {
            jarFile.close();
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#method_after
private static String getPrefix(Plugin plugin, String attr, String def) {
    JarFile jarFile = jarFileOf(plugin);
    if (jarFile == null) {
        return def;
    }
    try {
        String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
        if (prefix != null) {
            return CharMatcher.is('/').trimFrom(prefix) + "/";
        } else {
            return def;
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#end_block

#method_before
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarFile(srcJar), new JarScanner(srcJar), new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps1, changeMessages.get(0).getPatchSetId());
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Just a little code change.\n", cm.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm.getAuthor());
    assertEquals(ps1, cm.getPatchSetId());
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps2, changeMessages.get(0).getPatchSetId());
    assertEquals("This is the change message for the first PS.", changeMessages.get(1).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(1).getAuthor());
    assertEquals(ps1, changeMessages.get(1).getPatchSetId());
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("This is the change message for the first PS.", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
    ChangeMessage cm2 = Iterables.getOnlyElement(changeMessages.get(ps2));
    assertEquals(ps1, cm1.getPatchSetId());
    assertEquals("This is the change message for the second PS.", cm2.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm2.getAuthor());
    assertEquals(ps2, cm2.getPatchSetId());
}
#end_block

#method_before
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.size());
}
#method_after
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.keySet().size());
}
#end_block

#method_before
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing trailing double newline\n" + "\n", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing trailing double newline\n" + "\n", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessageString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMessageString);
    changeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMsgString);
    changeMessages.put(psId, changeMessage);
}
#end_block

#method_before
public ImmutableList<ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#method_after
public ImmutableListMultimap<PatchSet.Id, ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
        changeMessages = ImmutableList.copyOf(parser.changeMessages);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> cms = ImmutableListMultimap.builder();
        for (Map.Entry<PatchSet.Id, ChangeMessage> e : parser.changeMessages.entries()) {
            cms.put(e.getKey(), e.getValue());
        }
        this.changeMessages = cms.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableList.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    return new UiAction.Description().setLabel(label).setTitle(String.format(tooltip, resource.getPatchSet().getPatchSetId(), resource.getChange().getDest().getShortName())).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo actionInfo = actions.get("submit");
            submit.setTitle(actionInfo.title());
            submit.setText(actionInfo.label());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo action = actions.get("submit");
            submit.setTitle(action.title());
            submit.setHTML(new SafeHtmlBuilder().openDiv().append(action.label()).closeDiv());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        p.insert(new AvatarImage(AccountInfo.create(0, person.name(), person.email())), 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email()));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
@Override
public ChangeApi create(ChangeInfo in) throws RestApiException {
    try {
        ChangeJson.ChangeInfo out = createChangeFactory.create().apply(TopLevelResource.INSTANCE, in).value();
        return api.create(changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(out.changeId)));
    } catch (OrmException | IOException | InvalidChangeOperationException e) {
        throw new RestApiException("Cannot create change", e);
    }
}
#method_after
@Override
public ChangeApi create(ChangeInfo in) throws RestApiException {
    try {
        ChangeJson.ChangeInfo out = createChange.apply(TopLevelResource.INSTANCE, in).value();
        return api.create(changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(out.changeId)));
    } catch (OrmException | IOException | InvalidChangeOperationException e) {
        throw new RestApiException("Cannot create change", e);
    }
}
#end_block

#method_before
public void rebase(final PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, true, ValidatePolicy.GERRIT);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#method_after
public void rebase(final PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, true, ValidatePolicy.GERRIT);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
private void postAdd(Change change, List<PatchSetApproval> added) throws OrmException, EmailException {
    if (added.isEmpty()) {
        return;
    }
    // Execute hook for added reviewers
    // 
    PatchSet patchSet = dbProvider.get().patchSets().get(change.currentPatchSetId());
    for (PatchSetApproval psa : added) {
        Account account = accountCache.get(psa.getAccountId()).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, dbProvider.get());
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    IdentifiedUser idenitifiedUser = (IdentifiedUser) currentUser.get();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(idenitifiedUser.getAccountId())) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change);
            cm.setFrom(idenitifiedUser.getAccountId());
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void postAdd(Change change, List<PatchSetApproval> added) throws OrmException, EmailException {
    if (added.isEmpty()) {
        return;
    }
    // Execute hook for added reviewers
    // 
    PatchSet patchSet = dbProvider.get().patchSets().get(change.currentPatchSetId());
    for (PatchSetApproval psa : added) {
        Account account = accountCache.get(psa.getAccountId()).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, dbProvider.get());
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    IdentifiedUser identifiedUser = (IdentifiedUser) currentUser.get();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(identifiedUser.getAccountId())) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change);
            cm.setFrom(identifiedUser.getAccountId());
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateChange post(TopLevelResource parent) throws RestApiException {
    return createChangeFactory.create();
}
#method_after
@SuppressWarnings("unchecked")
@Override
public CreateChange post(TopLevelResource parent) throws RestApiException {
    return createChange;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = control2(cd);
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, cd, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    out.finish();
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, limitToPsId, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, changes.parse(control2(cd)), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, cd, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    out.finish();
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, limitToPsId, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, changes.parse(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#end_block

#method_before
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsProcent(cache.hitRatio.mem), formatAsProcent(cache.hitRatio.disk)));
}
#method_after
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsPercent(cache.hitRatio.mem), formatAsPercent(cache.hitRatio.disk)));
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "." + name;
    }
}
#method_after
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "-" + name;
    }
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    change.getProject();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    result.submitType = submitType.apply(resource);
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Map<String, Ref> refs = git.getRefDatabase().getRefs(RefDatabase.ALL);
        Ref ref = refs.get(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, result.submitType, git, refs, ref);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            ProjectConfig cfg = projectCache.get(change.getProject()).getConfig();
            BranchOrderSection branchOrder = cfg.getBranchOrderSection();
            int prefixLen = Constants.R_HEADS.length();
            for (String n : branchOrder.getMoreStable(ref.getName())) {
                Ref other = git.getRef(n);
                if (isMergeable(change, ps, SubmitType.CHERRY_PICK, git, refs, other)) {
                    result.mergeableInto.add(other.getName().substring(prefixLen));
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    result.submitType = submitType.apply(resource);
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Map<String, Ref> refs = git.getRefDatabase().getRefs(RefDatabase.ALL);
        Ref ref = refs.get(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, result.submitType, git, refs, ref);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectCache.get(change.getProject()).getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = refs.get(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, SubmitType.CHERRY_PICK, git, refs, other)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#end_block

#method_before
public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
        return order.subList(i + 1, order.size());
    } else {
        return Collections.emptyList();
    }
}
#method_after
public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
        return order.subList(i + 1, order.size());
    } else {
        return ImmutableList.of();
    }
}
#end_block

#method_before
private void loadBranchOrderSection(Config rc) {
    branchOrderSection = new BranchOrderSection(rc.getStringList(BRANCH_ORDER, null, BRANCH));
}
#method_after
private void loadBranchOrderSection(Config rc) {
    if (rc.getSections().contains(BRANCH_ORDER)) {
        branchOrderSection = new BranchOrderSection(rc.getStringList(BRANCH_ORDER, null, BRANCH));
    }
}
#end_block

#method_before
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
    } else {
        addStyleName(style.hideA());
    }
}
#method_after
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
        // match B's viewport
        parent.syncScroll(DisplaySide.B);
    } else {
        addStyleName(style.hideA());
    }
}
#end_block

#method_before
void set(JsArray<RevisionInfo> list, DiffInfo info) {
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    if (info.change_type() == ChangeType.ADDED) {
        // TODO(davido): Add user preference to control it,
        // as not all users would probably like this per default
        setVisibleA(false);
    }
}
#method_after
void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info) {
    this.changeType = info.change_type();
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    setHideEmptyPane(prefs.hideEmptyPane());
}
#end_block

#method_before
@Override
public ListParameter list() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ListRequest list() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public QueryParameter query() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public QueryRequest query() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public QueryParameter query() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public QueryRequest query(String query) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    return obj instanceof SecureStoreData && storeName.hashCode() == obj.hashCode();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof SecureStoreData) {
        SecureStoreData o = (SecureStoreData) obj;
        return storeName.equals(o.storeName);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return storeName.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(storeName);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "draft").to(DropDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND, "draft").to(DropDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "delete").to(DeleteDraftChange.Action.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    post(REVISION_KIND, "delete").to(DeleteDraftPatchSet.Action.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#end_block

#method_before
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    PostReview.Input review = new PostReview.Input();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = PostReview.DraftHandling.PUBLISH;
    review.strictLabels = false;
    review.waitForCommit = true;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        ChangeControl ctl = changeControlFactory.controlFor(patchSet.getId().getParentKey());
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            applyReview(ctl, patchSet, review);
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            try {
                restore.apply(new ChangeResource(ctl), input);
                applyReview(ctl, patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(ctl, patchSet, review);
        }
        if (submitChange) {
            Submit submit = submitProvider.get();
            Submit.Input input = new Submit.Input();
            input.waitForMerge = true;
            submit.apply(new RevisionResource(new ChangeResource(ctl), patchSet), input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            dropDraftPatchSet.apply(new RevisionResource(new ChangeResource(ctl), patchSet), new DropDraftPatchSet.Input());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    PostReview.Input review = new PostReview.Input();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = PostReview.DraftHandling.PUBLISH;
    review.strictLabels = false;
    review.waitForCommit = true;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        ChangeControl ctl = changeControlFactory.controlFor(patchSet.getId().getParentKey());
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            applyReview(ctl, patchSet, review);
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            try {
                restore.apply(new ChangeResource(ctl), input);
                applyReview(ctl, patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(ctl, patchSet, review);
        }
        if (submitChange) {
            Submit submit = submitProvider.get();
            Submit.Input input = new Submit.Input();
            input.waitForMerge = true;
            submit.apply(new RevisionResource(new ChangeResource(ctl), patchSet), input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            deleteDraftPatchSetImpl.apply(new RevisionResource(new ChangeResource(ctl), patchSet), new DeleteDraftPatchSet.Input());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Object apply(RevisionResource rsrc, Input input) throws IOException, NoSuchChangeException, OrmException, PatchSetInfoNotAvailableException {
    final PatchSet updatedPatchSet = dbProvider.get().patchSets().atomicUpdate(rsrc.getPatchSet().getId(), new AtomicUpdate<PatchSet>() {

        @Override
        public PatchSet update(PatchSet patchset) {
            patchset.setDraft(false);
            return patchset;
        }
    });
    final Change updatedChange = dbProvider.get().changes().atomicUpdate(rsrc.getChange().getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.DRAFT) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (!updatedPatchSet.isDraft() || updatedChange.getStatus() == Change.Status.NEW) {
        indexer.index(updatedChange);
        hooks.doDraftPublishedHook(updatedChange, updatedPatchSet, dbProvider.get());
        sender.send(rsrc.getChange().getStatus() == Change.Status.DRAFT, rsrc.getUser(), updatedChange, updatedPatchSet, rsrc.getControl().getLabelTypes());
    }
    return Response.none();
}
#method_after
@Override
public Object apply(RevisionResource rsrc, Input input) throws IOException, ResourceNotFoundException, ResourceConflictException, OrmException, AuthException {
    if (!rsrc.getPatchSet().isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    if (!rsrc.getControl().canPublish(dbProvider.get())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    PatchSet updatedPatchSet = updateDraftPatchSet(rsrc);
    Change updatedChange = updateDraftChange(rsrc);
    try {
        if (!updatedPatchSet.isDraft() || updatedChange.getStatus() == Change.Status.NEW) {
            indexer.index(updatedChange);
            hooks.doDraftPublishedHook(updatedChange, updatedPatchSet, dbProvider.get());
            sender.send(rsrc.getChange().getStatus() == Change.Status.DRAFT, rsrc.getUser(), updatedChange, updatedPatchSet, rsrc.getControl().getLabelTypes());
        }
    } catch (PatchSetInfoNotAvailableException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    try {
        return new UiAction.Description().setTitle(String.format("Publish Revision %d", resource.getPatchSet().getPatchSetId())).setVisible(resource.getPatchSet().isDraft() && resource.getPatchSet().getId().equals(current) && resource.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    PatchSet.Id current = rsrc.getChange().currentPatchSetId();
    try {
        return new UiAction.Description().setTitle(String.format("Publish Revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getPatchSet().getId().equals(current) && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, NoSuchChangeException, PatchSetInfoNotAvailableException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    return publish.apply(new RevisionResource(rsrc, ps), input);
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, ResourceConflictException, ResourceConflictException, IOException, OrmException, ResourceNotFoundException, AuthException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    return publish.apply(new RevisionResource(rsrc, ps), input);
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data;
        // Allow the user to select a logView variant with the "pretty" param.
        List<String> pretty_values = view.getParameters().get(PRETTY_PARAM);
        if (pretty_values.isEmpty()) {
            data = new LogSoyData(req, view).toSoyData(paginator, null, df);
            GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        } else {
            data = new LogSoyData(req, view, true).toSoyData(paginator, null, df);
            String variant = pretty_values.get(0);
            data.put("logPrettyVariant", pretty_values.get(0));
        }
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        Config config = access.getConfig();
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = new LogSoyData(req, view, config.getBoolean("logFormat", pretty, "verbose", false)).toSoyData(paginator, null, df);
        String variant = config.getString("logFormat", pretty, "variant");
        data.put("logEntryPretty", pretty);
        data.put("logEntryVariant", Objects.firstNonNull(variant, pretty));
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        DateFormatter df = new DateFormatter(getAccess(req), Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setTreeFilter(AndTreeFilter.create(PathFilter.create(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#end_block

#method_before
public Map<String, Object> toSoyData(Paginator paginator, @Nullable String revision, GitDateFormatter df) throws IOException {
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    List<Map<String, Object>> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
    for (RevCommit c : paginator) {
        if (verbose) {
            entries.add(new CommitSoyData().setRevWalk(paginator.getWalk()).toSoyData(req, c, VERBOSE_FIELDS, df));
        } else {
            entries.add(new CommitSoyData().toSoyData(req, c, FIELDS, df));
        }
    }
    data.put("entries", entries);
    ObjectId next = paginator.getNextStart();
    // TODO(mmoss): These urls don't include the n or pretty params.
    if (next != null) {
        data.put("nextUrl", copyAndCanonicalize(view, revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl());
    }
    ObjectId prev = paginator.getPreviousStart();
    if (prev != null) {
        GitilesView.Builder prevView = copyAndCanonicalize(view, revision);
        if (!prevView.getRevision().getId().equals(prev)) {
            prevView.replaceParam(LogServlet.START_PARAM, prev.name());
        }
        data.put("previousUrl", prevView.toUrl());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(RevWalk walk, int limit, @Nullable String revision, @Nullable ObjectId start, DateFormatter df) throws IOException {
    return toSoyData(new Paginator(walk, limit, start), revision, df);
}
#end_block

#method_before
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    try {
        setAccountIdentity(user, req);
        setAccoutPublicKeys(user, hubLogin, req);
        resp.getWriter().println("Created account.");
    } catch (IOException e) {
        resp.getWriter().println("Account creation failed: " + e.getCause());
        throw e;
    }
}
#method_after
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    try {
        setAccountIdentity(user, req);
        setAccoutPublicKeys(user, hubLogin, req);
        log.info("Created account '" + user.getUserName() + "'");
    } catch (IOException e) {
        log.error("Account '" + user.getUserName() + "' creation failed", e);
        throw e;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(DataSourceType.class).annotatedWith(Names.named("h2")).to(H2.class);
    bind(DataSourceType.class).annotatedWith(Names.named("jdbc")).to(JDBC.class);
    bind(DataSourceType.class).annotatedWith(Names.named("mysql")).to(MySql.class);
    bind(DataSourceType.class).annotatedWith(Names.named("oracle")).to(Oracle.class);
    bind(DataSourceType.class).annotatedWith(Names.named("postgresql")).to(PostgreSQL.class);
    bind(DataSourceType.class).annotatedWith(Names.named("maxdb")).to(MaxDb.class);
    bind(DataSourceType.class).annotatedWith(Names.named("sap db")).to(MaxDb.class);
}
#method_after
@Override
protected void configure() {
    bind(DataSourceType.class).annotatedWith(Names.named("h2")).to(H2.class);
    bind(DataSourceType.class).annotatedWith(Names.named("jdbc")).to(JDBC.class);
    bind(DataSourceType.class).annotatedWith(Names.named("mysql")).to(MySql.class);
    bind(DataSourceType.class).annotatedWith(Names.named("oracle")).to(Oracle.class);
    bind(DataSourceType.class).annotatedWith(Names.named("postgresql")).to(PostgreSQL.class);
    /*
     * DatabaseMetaData.getDatabaseProductName() returns "sap db" for MaxDB.
     * For auto-detection of the DB type (com.google.gerrit.pgm.util.SiteProgram#getDbType)
     * we have to map "sap db" additionally to "maxdb", which is used for explicit configuration.
     */
    bind(DataSourceType.class).annotatedWith(Names.named("maxdb")).to(MaxDb.class);
    bind(DataSourceType.class).annotatedWith(Names.named("sap db")).to(MaxDb.class);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.get().put(key.token, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = nowMs();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    Val val = self.get().getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.get().invalidate(key.token);
        return null;
    }
    return val;
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= nowMs()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
void destroy(final Key key) {
    self.get().invalidate(key.token);
}
#method_after
void destroy(final Key key) {
    self.invalidate(key.token);
}
#end_block

#method_before
boolean needsCookieRefresh() {
    return refreshCookieAt <= now();
}
#method_after
boolean needsCookieRefresh() {
    return refreshCookieAt <= nowMs();
}
#end_block

#method_before
private RAMDirectory index() throws IOException, UnsupportedEncodingException, FileNotFoundException {
    RAMDirectory directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        if (title != null) {
            Matcher matcher = SECTION_HEADER.matcher(title);
            if (matcher.matches()) {
                title = matcher.group(1);
            }
        } else {
            title = "";
        }
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    return directory;
}
#method_after
private RAMDirectory index() throws IOException, UnsupportedEncodingException, FileNotFoundException {
    RAMDirectory directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        if (file.length() == 0) {
            continue;
        }
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        Matcher matcher = SECTION_HEADER.matcher(title);
        if (matcher.matches()) {
            title = matcher.group(1);
        }
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    return directory;
}
#end_block

#method_before
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
public void doDraftPublishedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final DraftPublishedEvent event = new DraftPublishedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
public void doDraftPublishedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final DraftPublishedEvent event = new DraftPublishedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<String, Short> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<String, Short> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
public void doMergeFailedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final MergeFailedEvent event = new MergeFailedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
public void doMergeFailedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final MergeFailedEvent event = new MergeFailedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
public void doChangeRestoredHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeRestoredEvent event = new ChangeRestoredEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
public void doChangeRestoredHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeRestoredEvent event = new ChangeRestoredEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
public void doReviewerAddedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ReviewerAddedEvent event = new ReviewerAddedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
public void doReviewerAddedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ReviewerAddedEvent event = new ReviewerAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
public void doTopicChangedHook(final Change change, final Account account, final String oldTopic, final ReviewDb db) throws OrmException {
    final TopicChangedEvent event = new TopicChangedEvent();
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", event.change.owner.name + " (" + event.change.owner.email + ")");
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
public void doTopicChangedHook(final Change change, final Account account, final String oldTopic, final ReviewDb db) throws OrmException {
    final TopicChangedEvent event = new TopicChangedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<String>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<Comment>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    List<String> filePaths = changeDataFactory.create(db.get(), revision.getChange()).filePaths(revision.getPatchSet());
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in patch set %s", path, change.currentPatchSetId()));
        }
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<Comment>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getChange()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, change.currentPatchSetId()));
        }
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        files.put(Integer.valueOf(ps.getPatchSetId()), ImmutableList.copyOf(filePaths));
    }
}
#method_after
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        files.put(ps.getPatchSetId(), ImmutableList.copyOf(filePaths));
    }
}
#end_block

#method_before
public List<String> filePaths(PatchSet ps) throws OrmException {
    if (!files.containsKey(Integer.valueOf(ps.getPatchSetId()))) {
        Change c = change();
        if (c == null) {
            return null;
        }
        PatchList p;
        try {
            p = patchListCache.get(c, ps);
        } catch (PatchListNotAvailableException e) {
            List<String> emptyFileList = Collections.emptyList();
            files.put(Integer.valueOf(ps.getPatchSetId()), emptyFileList);
            return emptyFileList;
        }
        List<String> r = new ArrayList<String>(p.getPatches().size());
        for (PatchListEntry e : p.getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        files.put(Integer.valueOf(ps.getPatchSetId()), Collections.unmodifiableList(r));
    }
    return files.get(Integer.valueOf(ps.getPatchSetId()));
}
#method_after
public List<String> filePaths(PatchSet ps) throws OrmException {
    if (!files.containsKey(ps.getPatchSetId())) {
        Change c = change();
        if (c == null) {
            return null;
        }
        PatchList p;
        try {
            p = patchListCache.get(c, ps);
        } catch (PatchListNotAvailableException e) {
            List<String> emptyFileList = Collections.emptyList();
            files.put(ps.getPatchSetId(), emptyFileList);
            return emptyFileList;
        }
        List<String> r = new ArrayList<String>(p.getPatches().size());
        for (PatchListEntry e : p.getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        files.put(ps.getPatchSetId(), Collections.unmodifiableList(r));
    }
    return files.get(ps.getPatchSetId());
}
#end_block

#method_before
@Test
public void test() throws Exception {
    test(5);
}
#method_after
@Test
// we know it works now, so let's not clone a project 500 times ;-)
@Ignore
public void test() throws Exception {
    test(5);
}
#end_block

#method_before
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String reviewer = Gerrit.getUserAccountInfo().name();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#end_block

#method_before
public Map<String, ProjectInfo> display(OutputStream displayOutputStream) {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = Iterables.getFirst(e.parents(), null);
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                        info.state = parentState.getProject().getState();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = Iterables.getFirst(e.parents(), null);
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                info.state = e.getProject().getState();
                try {
                    if (!showBranch.isEmpty()) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public Map<String, ProjectInfo> display(OutputStream displayOutputStream) {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    int foundIndex = 0;
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = Iterables.getFirst(e.parents(), null);
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                        info.state = parentState.getProject().getState();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = Iterables.getFirst(e.parents(), null);
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                info.state = e.getProject().getState();
                try {
                    if (!showBranch.isEmpty()) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private Iterable<Project.NameKey> scan() {
    Iterable<Project.NameKey> results;
    if (matchPrefix != null) {
        results = projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        results = Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else {
        results = projectCache.all();
    }
    if (start > 0) {
        results = Iterables.skip(results, start);
    }
    if (limit > 0) {
        results = Iterables.limit(results, limit);
    }
    return results;
}
#method_after
private Iterable<Project.NameKey> scan() {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else {
        return projectCache.all();
    }
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordSettingsEnabled(!authConfig.isGitBasicAuth());
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setDownloadArchive(cfg.getBoolean("download", "archive", false));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordSettingsEnabled(!authConfig.isGitBasicAuth());
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    List<ArchiveFormat> allArchiveFormats = ConfigUtil.getEnumList(cfg, "download", null, "archive", ArchiveFormat.OFF);
    config.setArchiveFormats(new HashSet<>(allArchiveFormats));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
private void insertArchive() {
    if (!Gerrit.getConfig().getDownloadArchive()) {
        return;
    }
    List<Anchor> formats = new ArrayList<>(ARCHIVE.length);
    for (String f : ARCHIVE) {
        Anchor archive = new Anchor(f);
        archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
        formats.add(archive);
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = formats.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#method_after
private void insertArchive() {
    Set<ArchiveFormat> activated = Gerrit.getConfig().getArchiveFormats();
    if (activated.contains(ArchiveFormat.OFF)) {
        return;
    }
    List<Anchor> anchors = new ArrayList<>(activated.size());
    for (String f : ARCHIVE) {
        if (activated.contains(ArchiveFormat.valueOf(f.toUpperCase()))) {
            Anchor archive = new Anchor(f);
            archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
            anchors.add(archive);
        }
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = anchors.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    boolean admin;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            admin = getCurrentUser().getCapabilities().canAdministrateServer();
            break;
        default:
            owner = false;
            admin = false;
    }
    if (object instanceof RevCommit) {
        return admin || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, template_name, data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(CommitJsonData.toJsonData(c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
boolean set(ChangeInfo info, boolean current) {
    List<String> names = new ArrayList<String>(info.labels());
    Collections.sort(names);
    boolean canSubmit = info.status().isOpen();
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
        if (canSubmit && info.status() == Change.Status.NEW) {
            switch(label.status()) {
                case NEED:
                    if (current) {
                        statusText.setInnerText("Needs " + name);
                    }
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (current) {
                        statusText.setInnerText("Not " + name);
                    }
                    canSubmit = false;
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
boolean set(ChangeInfo info, boolean current) {
    List<String> names = new ArrayList<>(info.labels());
    Collections.sort(names);
    boolean canSubmit = info.status().isOpen();
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
        if (canSubmit && info.status() == Change.Status.NEW) {
            switch(label.status()) {
                case NEED:
                    if (current) {
                        statusText.setInnerText("Needs " + name);
                    }
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (current) {
                        statusText.setInnerText("Not " + name);
                    }
                    canSubmit = false;
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private Widget renderUsers(LabelInfo label) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<Integer, List<ApprovalInfo>>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<ApprovalInfo>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), Collections.<Integer>emptySet(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#method_after
private Widget renderUsers(LabelInfo label) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), Collections.<Integer>emptySet(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#end_block

#method_before
private static List<Integer> sort(Set<Integer> keySet, int a, int b) {
    List<Integer> r = new ArrayList<Integer>(keySet);
    Collections.sort(r);
    if (keySet.contains(a)) {
        r.remove(Integer.valueOf(a));
        r.add(0, a);
    } else if (keySet.contains(b)) {
        r.remove(Integer.valueOf(b));
        r.add(0, b);
    }
    return r;
}
#method_after
private static List<Integer> sort(Set<Integer> keySet, int a, int b) {
    List<Integer> r = new ArrayList<>(keySet);
    Collections.sort(r);
    if (keySet.contains(a)) {
        r.remove(Integer.valueOf(a));
        r.add(0, a);
    } else if (keySet.contains(b)) {
        r.remove(Integer.valueOf(b));
        r.add(0, b);
    }
    return r;
}
#end_block

#method_before
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, Map<Integer, ApprovalDetail> votable) {
    List<AccountInfo> users = new ArrayList<AccountInfo>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String nonVotableCategories = "";
        if (votable != null) {
            Set<String> nonVotable = votable.get(ai._account_id()).nonVotable();
            if (!nonVotable.isEmpty()) {
                StringBuilder sb = new StringBuilder("Non votable: ");
                for (Iterator<String> it = nonVotable.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                nonVotableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", nonVotableCategories).setStyleName(style.label_user());
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button").setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._account_id()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button").setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
void init(ChangeScreen2.Style style, Element reviewersText) {
    this.style = style;
    this.reviewersText = reviewersText;
}
#method_after
void init(ChangeScreen2.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#end_block

#method_before
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = new HashSet<Integer>();
    if (info.removable_reviewers() != null) {
        for (AccountInfo a : Natives.asList(info.removable_reviewers())) {
            removable.add(a._account_id());
        }
    }
    Map<Integer, ApprovalDetail> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
}
#method_after
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = new HashSet<>();
    if (info.removable_reviewers() != null) {
        for (AccountInfo a : Natives.asList(info.removable_reviewers())) {
            removable.add(a._account_id());
        }
    }
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
}
#end_block

#method_before
private static Map<Integer, ApprovalDetail> votable(ChangeInfo change) {
    Map<Integer, ApprovalDetail> d = new HashMap<Integer, ApprovalDetail>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                ApprovalDetail ad = d.get(id);
                if (ad == null) {
                    ad = new ApprovalDetail(new Account.Id(id));
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
                ad.value(name, ai.has_value() ? ai.value() : 0);
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
private Change.Id createNewChange(Repository git, RevWalk revWalk, Change.Key changeKey, Project.NameKey project, PatchSet.Id patchSetId, Ref destRef, RevCommit cherryPickCommit, RefControl refControl) throws OrmException, InvalidChangeOperationException, IOException {
    Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), currentUser.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit);
    PatchSet newPatchSet = ins.getPatchSet();
    CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), cherryPickCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), cherryPickCommit, currentUser);
    try {
        commitValidators.validateForGerritCommits(commitReceivedEvent);
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(cherryPickCommit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    ins.setMessage(buildChangeMessage(patchSetId, change)).insert();
    return change.getId();
}
#method_after
private Change.Id createNewChange(Repository git, RevWalk revWalk, Change.Key changeKey, Project.NameKey project, PatchSet.Id patchSetId, Ref destRef, RevCommit cherryPickCommit, RefControl refControl) throws OrmException, InvalidChangeOperationException, IOException {
    Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), currentUser.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit);
    PatchSet newPatchSet = ins.getPatchSet();
    CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), cherryPickCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), cherryPickCommit, currentUser);
    try {
        commitValidators.validateForGerritCommits(commitReceivedEvent);
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(cherryPickCommit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    ins.setMessage(buildChangeMessage(patchSetId, change, cherryPickCommit)).insert();
    return change.getId();
}
#end_block

#method_before
private ChangeMessage buildChangeMessage(PatchSet.Id patchSetId, Change dest) throws OrmException {
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), patchSetId);
    StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Cherry Picked");
    msgBuf.append("\n\n");
    msgBuf.append("This patchset was cherry picked to branch: " + dest.getDest().get());
    cmsg.setMessage(msgBuf.toString());
    return cmsg;
}
#method_after
private ChangeMessage buildChangeMessage(PatchSet.Id patchSetId, Change dest, RevCommit cherryPickCommit) throws OrmException {
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), patchSetId);
    String destBranchName = dest.getDest().get();
    StringBuilder msgBuf = new StringBuilder("Patch Set ").append(patchSetId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranchName.substring(destBranchName.indexOf("refs/heads/") + "refs/heads/".length())).append(" as commit ").append(cherryPickCommit.getId().getName());
    cmsg.setMessage(msgBuf.toString());
    return cmsg;
}
#end_block

#method_before
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<FindReplace>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                new ErrorDialog(e.getMessage()).center();
            }
        }
    }
    return commentLinks;
}
#method_after
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<FindReplace>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                int index = e.getMessage().indexOf("at Object");
                new ErrorDialog("Invalid commentlink configuration: " + (index == -1 ? e.getMessage() : e.getMessage().substring(0, index))).center();
            }
        }
    }
    return commentLinks;
}
#end_block

#method_before
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    patchZip = new Anchor(id + ".tar.gz");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#method_after
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#end_block

#method_before
private void insertArchive() {
    String id = revision.substring(0, 7);
    Anchor archive = new Anchor(id + ".tar.gz");
    archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(archive);
    insertCommand("Archive", p);
}
#method_after
private void insertArchive() {
    List<Anchor> formats = new ArrayList<>(ARCHIVE.length);
    for (String f : ARCHIVE) {
        Anchor archive = new Anchor(f);
        archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
        formats.add(archive);
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = formats.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken);
    self.put(key, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken, expiresAt);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    return self.getIfPresent(key.token);
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 0);
}
#method_after
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 6);
    writeFixInt64(out, expiresAt);
    writeVarInt32(out, 0);
}
#end_block

#method_before
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
}
#method_after
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            case 6:
                expiresAt = readFixInt64(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
    if (expiresAt == 0) {
        expiresAt = refreshCookieAt + TimeUnit.HOURS.toMillis(2);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).memoryLimit(// very large items, cache only a few
            128).populateWith(PatchListLoader.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).memoryLimit(// very large items, cache only a few
            128).populateWith(IntraLineLoader.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).maximumWeight(10 << 20).loader(PatchListLoader.class).weigher(PatchListWeigher.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).maximumWeight(10 << 20).loader(IntraLineLoader.class).weigher(IntraLineWeigher.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#end_block

#method_before
public PatchList get(PatchListKey key) {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        // TODO Handle PatchList errors in callers.
        return null;
    }
}
#method_after
@Override
public PatchList get(PatchListKey key) throws PatchListNotAvailableException {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e.getCause());
    }
}
#end_block

#method_before
public PatchList get(final Change change, final PatchSet patchSet) {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#method_after
@Override
public PatchList get(final Change change, final PatchSet patchSet) throws PatchListNotAvailableException {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).populateWith(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Inject
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.store = factory;
}
#method_after
@Inject(optional = true)
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.persistentCacheFactory = factory;
}
#end_block

#method_before
CacheBinding<K, V> persist(boolean p) {
    persist = p;
    return this;
}
#method_after
CacheBinding<K, V> persist(boolean p) {
    Preconditions.checkState(!frozen, "binding frozen, cannot be modified");
    persist = p;
    return this;
}
#end_block

#method_before
@Override
public Cache<K, V> get() {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.maximumSize(maxSize);
    if (0 < maxAge) {
        builder.expireAfterWrite(maxAge, TimeUnit.SECONDS);
    }
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && store != null) {
            return store.build(name, keyType, valType, builder, ldr);
        }
        return builder.build(ldr);
    } else if (persist && store != null) {
        return store.build(name, keyType, valType, builder);
    } else {
        return builder.build();
    }
}
#method_after
@Override
public Cache<K, V> get() {
    frozen = true;
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && persistentCacheFactory != null) {
            return persistentCacheFactory.build(this, ldr);
        }
        return memoryCacheFactory.build(this, ldr);
    } else if (persist && persistentCacheFactory != null) {
        return persistentCacheFactory.build(this);
    } else {
        return memoryCacheFactory.build(this);
    }
}
#end_block

#method_before
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(name, keyType, valType, this);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.memoryLimit(1024);
}
#method_after
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(this, name, keyType, valType);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.maximumWeight(1024);
}
#end_block

#method_before
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType.getType(), m.valType.getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType.getType(), m.valType.getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType.getType(), m.valType.getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#method_after
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType().getType(), m.valueType().getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType().getType(), m.valueType().getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType().getType(), m.valueType().getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).memoryLimit(// reasonable default for many sites
            1024).maxAge(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).maximumWeight(// reasonable default for many sites
            1024).expireAfterWrite(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#end_block

#method_before
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "");
}
#method_after
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "", 0);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).populateWith(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).memoryLimit(1).populateWith(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).loader(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).maximumWeight(1).loader(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).populateWith(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2BackedCache<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2BackedCache<?, ?>> entry : disks.entrySet()) {
        H2BackedCache<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2BackedCache.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#method_after
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2CacheImpl<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2CacheImpl<?, ?>> entry : disks.entrySet()) {
        H2CacheImpl<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2CacheImpl.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#end_block

#method_before
private void printMemoryCaches(Map<String, H2BackedCache<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2BackedCache) {
            disks.put(entry.getKey(), (H2BackedCache<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#method_after
private void printMemoryCaches(Map<String, H2CacheImpl<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2CacheImpl) {
            disks.put(entry.getKey(), (H2CacheImpl<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#end_block

#method_before
private String duration(double ns) {
    if (Math.abs(ns) < 0.01) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private String duration(double ns) {
    if (ns < 0.5) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).populateWith(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).loader(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).populateWith(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).populateWith(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).loader(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).loader(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).populateWith(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).loader(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new InMemoryCacheModule());
            install(new H2BackedPersistentCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).memoryLimit(4096).maxAge(10, TimeUnit.MINUTES);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).maximumWeight(4096).expireAfterWrite(10, TimeUnit.MINUTES);
        }
    });
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else if ("MULTIPLE".equals(param.type())) {
                w = renderTextArea(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    param.values();
    return txtArea;
}
#method_after
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    return txtArea;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            } else if (widget instanceof NpTextArea) {
                NpTextArea txtArea = (NpTextArea) widget;
                values.put(e2.getKey(), txtArea.getText().trim());
            } else {
                throw new UnsupportedOperationException("unupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                }
                if (v.getValue() != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                case MULTIPLE:
                                    cfg.setStringList(v.getKey(), Lists.newArrayList(Splitter.on("\n").split(v.getValue())));
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (!control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    checkSubmitRule(rsrc);
    change = submit(rsrc, caller);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller) throws OrmException, IOException {
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        approve(rsrc, update, caller, timestamp);
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    ChangeUtil.computeSortKey(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    ChangeUtil.computeSortKey(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private void approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    List<PatchSetApproval> approvals = approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), psId);
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMapWithExpectedSize(approvals.size());
    for (PatchSetApproval psa : approvals) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    approvals = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(approvals);
}
#method_after
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    List<PatchSetApproval> approvals = approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), psId);
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMapWithExpectedSize(approvals.size());
    for (PatchSetApproval psa : approvals) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.getDeleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void checkSubmitRule(RevisionResource rsrc) throws ResourceConflictException {
    List<SubmitRecord> results = rsrc.getControl().canSubmit(dbProvider.get(), rsrc.getPatchSet());
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
        }
    }
}
#method_after
private List<SubmitRecord> checkSubmitRule(RevisionResource rsrc, boolean force) throws ResourceConflictException {
    List<SubmitRecord> results = rsrc.getControl().canSubmit(dbProvider.get(), rsrc.getPatchSet());
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException {
    ChangeControl caller = rsrc.getControl();
    if (!caller.canSubmit()) {
        throw new AuthException("submit not permitted");
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    return new RevisionResource(changes.parse(target), rsrc.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException {
    ChangeControl caller = rsrc.getControl();
    if (!caller.canSubmit()) {
        throw new AuthException("submit not permitted");
    }
    if (!caller.canSubmitAs()) {
        throw new AuthException("submit on behalf of not permitted");
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    return new RevisionResource(changes.parse(target), rsrc.getPatchSet());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
    admin2 = accounts.admin2();
    user = accounts.user();
}
#method_after
@Before
public void setUp() throws Exception {
    admin2 = accounts.admin2();
}
#end_block

#method_before
@Test
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#end_block

#method_before
@Override
public String toString() {
    return "push " + uri;
}
#method_after
@Override
public String toString() {
    if (retryCount == 0) {
        return "push " + uri;
    }
    return "(retry " + retryCount + ") " + "push " + uri;
}
#end_block

#method_before
void setToRetry() {
    retrying = true;
}
#method_after
void setToRetry() {
    retrying = true;
    retryCount++;
}
#end_block

#method_before
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
}
#method_after
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    } finally {
        statesCleanUp();
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            log.error("Cannot replicate to " + uri + "; repository not found");
        } catch (NotSupportedException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else if (e instanceof RemoteRepositoryException && e.getMessage().endsWith("failed to lock")) {
                // The RemoteRepositoryException message contains both URI and reason
                // for this intermediate failure.
                log.error("Cannot replicate to " + e.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (RuntimeException e) {
            log.error("Unexpected error during replication to " + uri, e);
        } catch (Error e) {
            log.error("Unexpected error during replication to " + uri, e);
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        final String msg = e.getMessage();
        if (msg.contains("access denied")) {
            createRepository();
        } else {
            log.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            log.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            } else {
                log.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            log.error("Cannot replicate to " + uri, e);
            // The remote push operation should be retried.
            pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
        }
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    for (RemoteRefUpdate u : res.getRemoteUpdates()) {
        switch(u.getStatus()) {
            case OK:
            case UP_TO_DATE:
            case NON_EXISTING:
                break;
            case NOT_ATTEMPTED:
            case AWAITING_REPORT:
            case REJECTED_NODELETE:
            case REJECTED_NONFASTFORWARD:
            case REJECTED_REMOTE_CHANGED:
                log.error(String.format("Failed replicate of %s to %s: status %s", u.getRemoteName(), uri, u.getStatus()));
                break;
            case REJECTED_OTHER_REASON:
                if ("non-fast-forward".equals(u.getMessage())) {
                    log.error(String.format("Failed replicate of %s to %s" + ", remote rejected non-fast-forward push." + "  Check receive.denyNonFastForwards variable in config file" + " of destination repository.", u.getRemoteName(), uri));
                } else if ("failed to lock".equals(u.getMessage())) {
                    throw new RemoteRepositoryException(uri, u.getMessage());
                } else {
                    log.error(String.format("Failed replicate of %s to %s, reason: %s", u.getRemoteName(), uri, u.getMessage()));
                }
                break;
        }
    }
}
#method_after
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    updateStates(res.getRemoteUpdates());
}
#end_block

#method_before
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#method_after
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    log.info("Push to " + uri + " references: " + todo);
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (noPerms && GitRepositoryManager.REF_CONFIG.equals(src.getName())) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && !(noPerms && GitRepositoryManager.REF_CONFIG.equals(src))) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadGitChecks(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().all();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().iterateAllEntities();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#end_block

#method_before
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (doBind(meta.mode())) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#method_after
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (meta.runsAt().isSupported(slaveMode)) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    if (plugin.disabled() || plugin.indexUrl() == null) {
        table.setText(row, 1, plugin.name());
    } else {
        HorizontalPanel p = new HorizontalPanel();
        p.setStyleName(Gerrit.RESOURCES.css().pluginName());
        p.add(new Anchor(plugin.name(), Gerrit.selfRedirect(plugin.indexUrl()), "_blank"));
        if (plugin.adminUrl() != null) {
            Anchor adminScreenAcnhcor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.gear()), Gerrit.selfRedirect(plugin.adminUrl()));
            adminScreenAcnhcor.setTitle(Util.C.pluginAdminToolTip());
            p.add(adminScreenAcnhcor);
        }
        table.setWidget(row, 1, p);
    }
    table.setText(row, 2, plugin.version());
    table.setText(row, 3, plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    if (plugin.disabled() || plugin.indexUrl() == null) {
        table.setText(row, 1, plugin.name());
    } else {
        table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect(plugin.indexUrl()), "_blank"));
        if (new ExtensionScreen(plugin.name() + "/settings").isFound()) {
            InlineHyperlink adminScreenLink = new InlineHyperlink();
            adminScreenLink.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.gear()));
            adminScreenLink.setTargetHistoryToken("/x/" + plugin.name() + "/settings");
            adminScreenLink.setTitle(Util.C.pluginSettingsToolTip());
            table.setWidget(row, 2, adminScreenLink);
        }
    }
    table.setText(row, 3, plugin.version());
    table.setText(row, 4, plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
@Override
public ChangeDescription get(EnumSet<ListChangesOption> options) throws RestApiException {
    try {
        // TODO(davido): respect options in mapping
        return info2Description(changeJson.addOptions(options).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return new ChangeInfoMapper(s).map(changeJson.addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeDescription c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#method_after
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#end_block

#method_before
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName) {
    return getFromGerritConfig(pluginName, false);
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName, boolean refresh) {
    if (refresh && cfgSnapshot.isModified(site.gerrit_config)) {
        cfgSnapshot = FileSnapshot.save(site.gerrit_config);
        cfg = cfgProvider.get();
    }
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    detail(id).get(cb);
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, EnumSet<ListChangesOption> options, AsyncCallback<ChangeInfo> cb) {
    RestApi call = detail(id);
    if (!options.isEmpty()) {
        ChangeList.addOptions(call, options);
    }
    call.get(cb);
}
#end_block

#method_before
private static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#method_after
public static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#end_block

#method_before
public final void init() {
    if (labels0() != null) {
        labels0().copyKeysIntoChildren("_name");
    }
}
#method_after
public final void init() {
    if (all_labels() != null) {
        all_labels().copyKeysIntoChildren("_name");
    }
}
#end_block

#method_before
public final Set<String> labels() {
    return labels0().keySet();
}
#method_after
public final Set<String> labels() {
    return all_labels().keySet();
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static String toChange2(final Change.Id c) {
    return "/c2/" + c + "/";
}
#method_after
public static String toChange2(Change.Id c, String p) {
    return "/c2/" + c + "/" + p;
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        String s = skip(token);
        if (s.endsWith("/")) {
            s = s.substring(0, s.length() - 1);
        }
        Change.Id id = Change.Id.parse(s);
        Gerrit.display(token, new ChangeScreen2(id));
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        change2(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            loadConfigInfo(info);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info);
        }
    });
}
#end_block

#method_before
@UiHandler("starIcon")
void onToggleStar(ClickEvent e) {
    boolean newState = !starred;
    StarredChanges.toggleStar(changeId, newState);
    renderStar(newState);
}
#method_after
@UiHandler("star")
void onToggleStar(ValueChangeEvent<Boolean> e) {
    StarredChanges.toggleStar(changeId, e.getValue());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info) {
    CallbackGroup group = new CallbackGroup();
    DiffApi.list(changeId.get(), info.current_revision(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> files) {
            renderFiles(files);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(rev, group);
    loadCommit(rev, group);
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
    group.done();
    if (info.status().isOpen() && rev.name().equals(info.current_revision())) {
        loadSubmitAction(rev);
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    accountCache = new HashMap<String, AccountInfo>();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = renderLabels(info);
    renderStar(info.starred());
    renderOwner(info);
    renderActionTextDate(info);
    renderStandardActions(info, canSubmit);
    renderCommitInfo(info);
    renderHistory(info);
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    topicText.setInnerText(info.topic());
    idText.setInnerText(info.change_id());
    // submit_type?
    submitTypeText.setInnerText("Merge If Necessary");
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = labels.set(info);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision, canSubmit);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    boolean hasConflict = Gerrit.getConfig().testChangeMerge() && !info.mergeable();
    setVisible(notMergeable, hasConflict);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    reply.setVisible(replyAction != null);
    if (canSubmit && !hasConflict && actions.isSubmitEnabled()) {
        statusText.setInnerText(Util.C.readyToSubmit());
    } else if (canSubmit && hasConflict) {
        statusText.setInnerText(Util.C.mergeConflict());
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!v.name.matches("^[a-zA-Z0-9]*[a-zA-Z0-9-]*$")) {
                    log.warn("The name of the parameter '" + v.name + "' of the plugin '" + pluginName + "' is invalid.");
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.name, Boolean.parseBoolean(v.value));
                                break;
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case STRING:
                            case LIST:
                            default:
                                cfg.setString(v.name, v.value);
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException("The value '" + v.value + "' of config paramter '" + v.name + "' of plugin '" + pluginName + "' is invalid: " + ex.getMessage());
                    }
                }
            } else {
                throw new BadRequestException("The config paramter '" + v.name + "' of plugin '" + pluginName + "' does not exist.");
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    cfg.setString(v.getKey(), v.getValue());
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    NativeMap<JsArray<ConfigValueInput>> configValues = NativeMap.create().cast();
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        JsArray<ConfigValueInput> values = JsArray.createArray().cast();
        configValues.put(e.getKey(), values);
        for (Entry<String, String> e2 : e.getValue().entrySet()) {
            ConfigValueInput i = ConfigValueInput.create();
            i.setName(e2.getKey());
            i.setValue(e2.getValue());
            values.push(i);
        }
    }
    setPluginConfigValuesRaw(configValues);
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, Widget> widgetMap : pluginConfigWidgets.values()) {
            for (Widget widget : widgetMap.values()) {
                ((FocusWidget) widget).setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, FocusWidget> widgetMap : pluginConfigWidgets.values()) {
            for (FocusWidget widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, Widget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, Widget> widgetMap = new HashMap<String, Widget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                NpTextBox textBox = new NpTextBox();
                if (param.inheritable()) {
                    textBox.setValue(param.configuredValue());
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(textBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    textBox.setValue(param.value());
                    g.add(param.displayName() != null ? param.displayName() : param.name(), textBox);
                }
                saveEnabler.listenTo(textBox);
                widgetMap.put(param.name(), textBox);
            } else if ("BOOLEAN".equals(param.type())) {
                CheckBox checkbox = new CheckBox();
                checkbox.setValue(Boolean.parseBoolean(param.value()));
                g.add(param.displayName() != null ? param.displayName() : param.name(), checkbox);
                saveEnabler.listenTo(checkbox);
                widgetMap.put(param.name(), checkbox);
            } else if ("LIST".equals(param.type())) {
                ListBox listBox = new ListBox();
                if (param.inheritable()) {
                    listBox.addItem(Util.C.inheritListValue());
                    if (param.configuredValue() == null) {
                        listBox.setSelectedIndex(0);
                    }
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.configuredValue())) {
                            listBox.setSelectedIndex(i + 1);
                        }
                    }
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(listBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.value())) {
                            listBox.setSelectedIndex(i);
                        }
                    }
                    g.add(param.displayName() != null ? param.displayName() : param.name(), listBox);
                }
                saveEnabler.listenTo(listBox);
                widgetMap.put(param.name(), listBox);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, Widget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, Widget> e2 : e.getValue().entrySet()) {
            Widget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if ("INHERIT".equals(value)) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
public void onUpdate(ProjectConfig projectConfig, long newValue) {
}
#method_after
public void onUpdate(Project.NameKey project, String oldValue, String newValue) {
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.onProjectCreated(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#end_block

#method_before
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<com.google.gwt.dom.client.Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#method_after
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#end_block

#method_before
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    com.google.gwt.dom.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#method_after
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#end_block

#method_before
private static MyTable getMyTable(NativeEvent event) {
    com.google.gwt.dom.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof MyTable) {
            return (MyTable) l;
        }
    }
    return null;
}
#method_after
private static MyTable getMyTable(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof MyTable) {
            return (MyTable) l;
        }
    }
    return null;
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.dom.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
public static com.google.gwt.dom.client.Element parse(SafeHtml html) {
    com.google.gwt.dom.client.Element e = DOM.createDiv();
    setInnerHTML(e, html);
    return DOM.getFirstChild(e);
}
#method_after
public static Element parse(SafeHtml html) {
    Element e = DOM.createDiv();
    setInnerHTML(e, html);
    return DOM.getFirstChild(e);
}
#end_block

#method_before
public void log(Request request, Response response) {
    int status = response.getStatus();
    if (status < 0) {
        // Copied from NCSARequestLog
        status = 404;
    }
    TreeLogger.Type logStatus, logHeaders;
    if (status >= 500) {
        logStatus = TreeLogger.ERROR;
        logHeaders = TreeLogger.INFO;
    } else if (status >= 400) {
        logStatus = TreeLogger.WARN;
        logHeaders = TreeLogger.INFO;
    } else {
        logStatus = TreeLogger.INFO;
        logHeaders = TreeLogger.DEBUG;
    }
    String userString = request.getRemoteUser();
    if (userString == null) {
        userString = "";
    } else {
        userString += "@";
    }
    String bytesString = "";
    if (response.getContentCount() > 0) {
        bytesString = " " + response.getContentCount() + " bytes";
    }
    if (logger.isLoggable(logStatus)) {
        TreeLogger branch = logger.branch(logStatus, String.valueOf(status) + " - " + request.getMethod() + ' ' + request.getUri() + " (" + userString + request.getRemoteHost() + ')' + bytesString);
        if (branch.isLoggable(logHeaders)) {
            // Request headers
            TreeLogger headers = branch.branch(logHeaders, "Request headers");
            @SuppressWarnings("unchecked")
            Enumeration<String> headerNames = request.getHeaderNames();
            while (headerNames.hasMoreElements()) {
                String name = headerNames.nextElement();
                @SuppressWarnings("unchecked")
                List<String> values = Collections.list(request.getHeaders(name));
                headers.log(logHeaders, name + ": " + values.get(0));
            }
            // Response headers
            headers = branch.branch(logHeaders, "Response headers");
            Collection<String> names = response.getHeaderNames();
            for (String name : names) {
                headers.log(logHeaders, name + ": " + response.getHeader(name));
            }
        }
    }
}
#method_after
public void log(Request request, Response response) {
    int status = response.getStatus();
    if (status < 0) {
        // Copied from NCSARequestLog
        status = 404;
    }
    TreeLogger.Type logStatus, logHeaders;
    if (status >= 500) {
        logStatus = TreeLogger.ERROR;
        logHeaders = TreeLogger.INFO;
    } else if (status >= 400) {
        logStatus = TreeLogger.WARN;
        logHeaders = TreeLogger.INFO;
    } else {
        logStatus = TreeLogger.INFO;
        logHeaders = TreeLogger.DEBUG;
    }
    String userString = request.getRemoteUser();
    if (userString == null) {
        userString = "";
    } else {
        userString += "@";
    }
    String bytesString = "";
    if (response.getContentCount() > 0) {
        bytesString = " " + response.getContentCount() + " bytes";
    }
    if (logger.isLoggable(logStatus)) {
        TreeLogger branch = logger.branch(logStatus, String.valueOf(status) + " - " + request.getMethod() + ' ' + request.getUri() + " (" + userString + request.getRemoteHost() + ')' + bytesString);
        if (branch.isLoggable(logHeaders)) {
            // Request headers
            TreeLogger headers = branch.branch(logHeaders, "Request headers");
            for (HttpField f : request.getHttpFields()) {
                headers.log(logHeaders, f.getName() + ": " + f.getValue());
            }
            // Response headers
            headers = branch.branch(logHeaders, "Response headers");
            for (HttpField f : response.getHttpFields()) {
                headers.log(logHeaders, f.getName() + ": " + f.getValue());
            }
        }
    }
}
#end_block

#method_before
@Override
public ServletContainer start(TreeLogger logger, int port, File warDir) throws Exception {
    TreeLogger branch = logger.branch(TreeLogger.INFO, "Starting Jetty on port " + port, null);
    checkStartParams(branch, port, warDir);
    // Setup our branch logger during startup.
    Log.setLog(new JettyTreeLogger(branch));
    // Turn off XML validation.
    System.setProperty("org.mortbay.xml.XmlParser.Validating", "false");
    AbstractConnector connector = getConnector();
    if (bindAddress != null) {
        connector.setHost(bindAddress);
    }
    connector.setPort(port);
    // Don't share ports with an existing process.
    connector.setReuseAddress(false);
    // Linux keeps the port blocked after shutdown if we don't disable this.
    connector.setSoLingerTime(0);
    Server server = new Server();
    server.addConnector(connector);
    File top;
    String root = System.getProperty("gerrit.source_root");
    if (root != null) {
        top = new File(root);
    } else {
        // Under Maven warDir is "$top/gerrit-gwtui/target/gwt-hosted-mode"
        top = warDir.getParentFile().getParentFile().getParentFile();
    }
    File app = new File(top, "gerrit-war/src/main/webapp");
    File webxml = new File(app, "WEB-INF/web.xml");
    // Jetty won't start unless this directory exists.
    if (!warDir.exists() && !warDir.mkdirs())
        logger.branch(TreeLogger.ERROR, "Cannot create " + warDir, null);
    // Create a new web app in the war directory.
    // 
    WebAppContext wac = new MyWebAppContext(warDir.getAbsolutePath(), "/");
    wac.setDescriptor(webxml.getAbsolutePath());
    RequestLogHandler logHandler = new RequestLogHandler();
    logHandler.setRequestLog(new JettyRequestLogger(logger));
    logHandler.setHandler(wac);
    server.setHandler(logHandler);
    server.start();
    server.setStopAtShutdown(true);
    // Now that we're started, log to the top level logger.
    Log.setLog(new JettyTreeLogger(logger));
    return new JettyServletContainer(logger, server, wac, connector.getLocalPort(), warDir);
}
#method_after
@Override
public ServletContainer start(TreeLogger logger, int port, File warDir) throws Exception {
    TreeLogger branch = logger.branch(TreeLogger.INFO, "Starting Jetty on port " + port, null);
    checkStartParams(branch, port, warDir);
    // Setup our branch logger during startup.
    Log.setLog(new JettyTreeLogger(branch));
    // Turn off XML validation.
    System.setProperty("org.mortbay.xml.XmlParser.Validating", "false");
    Server server = new Server();
    HttpConfiguration config = defaultConfig();
    ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(config));
    if (bindAddress != null) {
        connector.setHost(bindAddress);
    }
    connector.setPort(port);
    // Don't share ports with an existing process.
    connector.setReuseAddress(false);
    // Linux keeps the port blocked after shutdown if we don't disable this.
    connector.setSoLingerTime(0);
    server.addConnector(connector);
    File top;
    String root = System.getProperty("gerrit.source_root");
    if (root != null) {
        top = new File(root);
    } else {
        // Under Maven warDir is "$top/gerrit-gwtui/target/gwt-hosted-mode"
        top = warDir.getParentFile().getParentFile().getParentFile();
    }
    File app = new File(top, "gerrit-war/src/main/webapp");
    File webxml = new File(app, "WEB-INF/web.xml");
    // Jetty won't start unless this directory exists.
    if (!warDir.exists() && !warDir.mkdirs())
        logger.branch(TreeLogger.ERROR, "Cannot create " + warDir, null);
    // Create a new web app in the war directory.
    // 
    WebAppContext wac = new MyWebAppContext(warDir.getAbsolutePath(), "/");
    wac.setDescriptor(webxml.getAbsolutePath());
    RequestLogHandler logHandler = new RequestLogHandler();
    logHandler.setRequestLog(new JettyRequestLogger(logger));
    logHandler.setHandler(wac);
    server.setHandler(logHandler);
    server.start();
    server.setStopAtShutdown(true);
    // Now that we're started, log to the top level logger.
    Log.setLog(new JettyTreeLogger(logger));
    return new JettyServletContainer(logger, server, wac, connector.getLocalPort(), warDir);
}
#end_block

#method_before
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        URL url = ConfigAnnotationParser.class.getResource(CONFIG_DIR + name);
        if (url != null) {
            cfg.fromText(Resources.toString(url, Charsets.UTF_8));
        }
    }
    return cfg;
}
#method_after
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        String resource = CONFIG_DIR + name + ".config";
        URL url = checkNotNull(ConfigAnnotationParser.class.getResource(resource), "test config resource not found: %s", resource);
        cfg.fromText(Resources.toString(url, Charsets.UTF_8));
    }
    return cfg;
}
#end_block

#method_before
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parse(cfg, c);
    }
    return cfg;
}
#method_after
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parseAnnotation(cfg, c);
    }
    return cfg;
}
#end_block

#method_before
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            LOG.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            LOG.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#method_after
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            log.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            log.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("No " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Empty " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + "does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(SecureCredentialsFactory.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#end_block

#method_before
@Override
protected void configure() {
    super.configure();
    install(ThreadLocalRequestContext.module());
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    cfgInjector = createCfgInjector();
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    // modules.add(new LogFileCompressor.Module());
    // modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModuleBase.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(NoSshKeyCache.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(CurrentUser.class).toProvider(new Provider<CurrentUser>() {

                @Override
                public CurrentUser get() {
                    return null;
                }
            });
            bind(IdentifiedUser.class).toProvider(new Provider<IdentifiedUser>() {

                @Override
                public IdentifiedUser get() {
                    return null;
                }
            });
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new FactoryModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
            factory(ChangeData.Factory.class);
            factory(ProjectState.Factory.class);
            bind(new TypeLiteral<List<CommentLinkInfo>>() {
            }).toProvider(CommentLinkProvider.class).in(SINGLETON);
            bind(CurrentUser.class).toProvider(Providers.<CurrentUser>of(null));
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
            factory(IncludingGroupMembership.Factory.class);
            bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
            DynamicSet.setOf(binder(), GroupBackend.class);
            bind(InternalGroupBackend.class).in(SINGLETON);
            DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
            DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
            factory(InternalUser.Factory.class);
            factory(PatchSetInserter.Factory.class);
            bind(ChangeHooks.class).to(DisabledChangeHooks.class);
            bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
            factory(CapabilityControl.Factory.class);
            factory(MergeUtil.Factory.class);
            DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
            DynamicSet.setOf(binder(), CommitValidationListener.class);
            factory(CommitValidators.Factory.class);
        }
    });
    modules.add(AccountCacheImpl.module());
    modules.add(AccountByEmailCacheImpl.module());
    modules.add(ChangeKindCache.module());
    modules.add(GroupCacheImpl.module());
    modules.add(GroupIncludeCacheImpl.module());
    modules.add(ProjectCacheImpl.module());
    modules.add(SectionSortCache.module());
    modules.add(new AccessControlModule());
    modules.add(new GitModule());
    modules.add(new PrologModule());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @MergeabilityChecksExecutor
        public WorkQueue.Executor createMergeabilityChecksExecutor(WorkQueue queues) {
            return queues.createQueue(1, "MergeabilityChecks");
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(GitRepositoryManager.REF_CONFIG)) {
        executor.submit(new RefUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(RefNames.REFS_CONFIG)) {
        executor.submit(new BranchUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
    if (ref.equals(RefNames.REFS_CONFIG)) {
        Project.NameKey p = new Project.NameKey(event.getProjectName());
        try {
            ProjectConfig oldCfg = parseConfig(p, event.getOldObjectId());
            ProjectConfig newCfg = parseConfig(p, event.getNewObjectId());
            if (recheckMerges(oldCfg, newCfg)) {
                try {
                    new ProjectUpdateTask(schemaFactory, p, true).call();
                } catch (Exception e) {
                    String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
                    log.error(msg, e);
                    Throwables.propagateIfPossible(e);
                    throw new RuntimeException(msg, e);
                }
            }
        } catch (ConfigInvalidException | IOException e) {
            String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
            log.error(msg, e);
            throw new RuntimeException(msg, e);
        }
    }
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return updateAsync(change, false);
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
private CheckedFuture<Boolean, IOException> updateAsync(Change change, boolean force) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change, force)), MAPPER);
}
#end_block

#method_before
public CheckedFuture<?, IOException> updateAndIndexAsync(final Change change) {
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(change);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#method_after
public CheckedFuture<?, IOException> updateAndIndexAsync(Change change) {
    final Change.Id id = change.getId();
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(id);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#end_block

#method_before
public boolean update(Change change) throws IOException {
    try {
        return new ChangeUpdateTask(schemaFactory, change).call();
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#method_after
public void update(Project.NameKey project) throws IOException {
    try {
        for (CheckedFuture<?, IOException> f : new ProjectUpdateTask(schemaFactory, project, false).call()) {
            f.checkedGet();
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        MergeableInfo info = mergeable.get().apply(new RevisionResource(new ChangeResource(changeControlFactory.controlFor(change, context.getCurrentUser())), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#method_after
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change, force);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        Mergeable m = mergeable.get();
        m.setForce(force);
        ChangeControl control = changeControlFactory.controlFor(change.getId(), context.getCurrentUser());
        MergeableInfo info = m.apply(new RevisionResource(new ChangeResource(control), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#end_block

#method_before
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
        // TODO(davido): include indexing of mergeable field in MPM above
        for (Project.NameKey project : projects) {
            List<CheckedFuture<?, IOException>> f = checker.reindexProject(project);
            for (CheckedFuture<?, IOException> checkedFuture : f) {
                checkedFuture.checkedGet();
            }
        }
    } catch (ExecutionException | IOException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        try {
            mergeabilityChecker.update(project);
        } catch (IOException e) {
            log.error("Error in mergeability checker", e);
            ok.set(false);
        }
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            ReviewDb db = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                db = schemaFactory.open();
                for (Change c : db.changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (db != null) {
                    db.close();
                }
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    user = accounts.user();
    admin = accounts.admin();
    initSsh(admin);
    project = new Project.NameKey("p");
    session = new RestSession(server, user);
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), user.getId())));
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    grant(cfg, Permission.forLabel("Code-Review"), -2, 2, anonymousUsers, "refs/heads/*");
    grant(cfg, Permission.SUBMIT, anonymousUsers, "refs/heads/*");
    codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review"));
    codeReview.setCopyMinScore(false);
    codeReview.setCopyMaxScore(false);
    codeReview.setCopyAllScoresOnTrivialRebase(false);
    codeReview.setCopyAllScoresIfNoCodeChange(false);
    saveProjectConfig(cfg);
}
#method_after
@Before
public void setUp() throws Exception {
    user = accounts.user();
    admin = accounts.admin();
    initSsh(admin);
    project = new Project.NameKey("p");
    session = new RestSession(server, user);
    SshSession sshSession = new SshSession(server, admin);
    try {
        createProject(sshSession, project.get());
        git = cloneProject(sshSession.getUrl() + "/" + project.get());
        db = reviewDbProvider.open();
        atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), user.getId())));
    } finally {
        sshSession.close();
    }
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    grant(cfg, Permission.forLabel("Code-Review"), -2, 2, anonymousUsers, "refs/heads/*");
    grant(cfg, Permission.SUBMIT, anonymousUsers, "refs/heads/*");
    codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review"));
    codeReview.setCopyMinScore(false);
    codeReview.setCopyMaxScore(false);
    codeReview.setCopyAllScoresOnTrivialRebase(false);
    codeReview.setCopyAllScoresIfNoCodeChange(false);
    saveProjectConfig(cfg);
}
#end_block

#method_before
private void merge(PushOneCommit.Result r) throws Exception {
    review(r, 2);
    SubmitInput input = new SubmitInput();
    input.waitForMerge = true;
    revision(r).submit(input);
    Repository repo = repoManager.openRepository(project);
    try {
        assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId());
    } finally {
        repo.close();
    }
}
#method_after
private void merge(PushOneCommit.Result r) throws Exception {
    review(r, 2);
    revision(r).submit();
    Repository repo = repoManager.openRepository(project);
    try {
        assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId());
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return new ChangeData(new Change.Id(id));
    }
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = new ChangeData(change);
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    return cd;
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    NIOFSDirectory directory = new NIOFSDirectory(tmpdir);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    zipDir(tmpdir, "", zip);
    zip.close();
}
#end_block

#method_before
private void postInitPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        if (initStep instanceof PostInitStep) {
            ((PostInitStep) initStep).postRun();
        }
    }
}
#method_after
private void postInitPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        initStep.postRun();
    }
}
#end_block

#method_before
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (!(step instanceof PostInitStep)) {
            continue;
        }
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        ((PostInitStep) step).postRun();
    }
}
#method_after
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.postRun();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ProjectResource projectResource = new ProjectResource(project);
        CreateBranch.Input input = new CreateBranch.Input();
        input.ref = ref;
        input.revision = revision;
        createBranchFactory.create(ref).apply(projectResource, input);
    } catch (IOException e) {
        throw new RestApiException("Cannot create branch", e);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        BranchInput in = new BranchInput();
        in.revision = revision;
        gApi.projects().name(project.getProject().getNameKey().get()).branch(name).create(in);
    } catch (RestApiException e) {
        throw new UnloggedFailure(1, "fatal: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugUrl = getConfig().getReportBugUrl();
    final String reportBugTitle = getConfig().getReportBugText();
    if (reportBugUrl != null) {
        Anchor a = new Anchor(reportBugTitle == null ? C.reportBug() : reportBugTitle, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    if (Strings.isNullOrEmpty(config.getReportBugText())) {
        config.setReportBugText(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
public void setReportBugText(String u) {
    reportBugText = u;
}
#method_after
public void setReportBugText(String t) {
    reportBugText = t;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private final PGPEncryptedDataGenerator cpk() throws NoSuchProviderException, PGPException {
    final PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(PGPEncryptedData.CAST5, true, prng, "BC");
    cpk.addMethod(dest);
    return cpk;
}
#method_after
@SuppressWarnings("deprecation")
private final PGPEncryptedDataGenerator cpk() throws NoSuchProviderException, PGPException {
    PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(PGPEncryptedData.CAST5, true, prng, "BC");
    cpk.addMethod(dest);
    return cpk;
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + "/plugins/";
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, base + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar == null) {
            String jsFileName = file.replaceFirst("static/", "");
            sendJsPlugin(jsFileName, key, req, res);
        } else {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            if (name.substring(prefix.length()).startsWith("cmd-")) {
                cmds.add(entry);
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (!docs.isEmpty()) {
        md.append("## Documentation ##\n");
        for (JarEntry entry : docs) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(0, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(0, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    if (!cmds.isEmpty()) {
        md.append("## Commands ##\n");
        for (JarEntry entry : cmds) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(4, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(4, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.substring(4).replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#end_block

#method_before
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        InputStream in = jar.getInputStream(entry);
        writeToResponse(res, in);
    }
}
#method_after
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        writeToResponse(res, jar.getInputStream(entry));
    }
}
#end_block

#method_before
private void sendJsPlugin(String jsFileName, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File jsFile = new File(pluginsDir, jsFileName);
    if (jsFile.exists()) {
        res.setHeader("Content-Length", Long.toString(jsFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(jsFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void sendJsPlugin(Plugin plugin, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File pluginFile = plugin.getSrcFile();
    if (req.getPathInfo().equals(getJsPluginPath(plugin)) && pluginFile.exists()) {
        res.setHeader("Content-Length", Long.toString(pluginFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(pluginFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
public String getServletPath() {
    return ((HttpServletRequest) getRequest()).getRequestURI().substring(contextPath.length());
}
#method_after
@Override
public String getServletPath() {
    return getRequestURI().substring(contextPath.length());
}
#end_block

#method_before
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.add(httpInjector);
    manager.start();
}
#method_after
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.start();
}
#end_block

#method_before
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
    }
}
#method_after
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
        httpInjector = null;
    }
}
#end_block

#method_before
@Override
boolean canReload() {
    return false;
}
#method_after
@Override
boolean canReload() {
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    bind(WebUiPlugin.class).annotatedWith(UniqueAnnotations.create()).toInstance(new JavaScriptPlugin(fileName));
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin(fileName));
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!(name.endsWith(".jar") || name.endsWith(".js"))) {
        throw new ParserInitializationException("Can only install files with '.jar' and '.js' extension");
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", name));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!(fileName.endsWith(".jar") || fileName.endsWith(".js"))) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    File dst = new File(pluginsDir, name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#method_after
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    if (!sitePaths.tmp_dir.exists()) {
        sitePaths.tmp_dir.mkdirs();
    }
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> plugins = scanJarsInPluginsDirectory();
    stopRemovedPlugins(plugins);
    dropRemovedDisabledPlugins(plugins);
    for (File plugin : plugins) {
        if (plugin.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(plugin);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(plugin)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(plugin)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, plugin, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File jar = entry.getValue();
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        cleanupHandle.cleanup();
    }
    return toCleanup.size();
}
#method_after
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        if (cleanupHandle != null) {
            cleanupHandle.cleanup();
        }
    }
    return toCleanup.size();
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
public static String nameOf(File plugin) {
    return nameOf(plugin.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(File file) {
    return getExtension(file.getName());
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcPlugin);
    String extension = getExtension(srcPlugin);
    try {
        tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
    } finally {
        in.close();
    }
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new RuntimeException("Unsupported plugin type");
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: ", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new JarPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
private boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#method_after
private static boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#end_block

#method_before
private boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#method_after
private static boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#end_block

#method_before
private boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#method_after
private static boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
            }
            if (reader != null) {
                reader.release();
            }
        }
    } finally {
        repo.close();
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    if (standalone) {
        step().to(InitPlugins.class);
    }
}
#method_after
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    if (standalone) {
        step().to(InitPlugins.class);
    }
}
#end_block

#method_before
@Override
public void run() throws Exception {
    ui.header("Review Labels");
    boolean enabled = ui.yesno(false, "Install Verified label");
    Config cfg = allProjectsConfig.load();
    if (enabled) {
        cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
        cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
        allProjectsConfig.save("Review Label Initialization");
    }
}
#method_after
@Override
public void run() throws Exception {
    Config cfg = allProjectsConfig.load();
    if (!cfg.getSubsections(KEY_LABEL).contains(LABEL_VERIFIED)) {
        ui.header("Review Labels");
        boolean enabled = ui.yesno(false, "Install Verified label");
        if (enabled) {
            cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
            cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
            allProjectsConfig.save("Review Label Initialization");
        }
    }
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return getCurrentUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#method_after
public List<PermissionRange> getLabelRanges(boolean isChangeOwner) {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule, isChangeOwner)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    return getRange(permission, false);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission, boolean isChangeOwner) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission, isChangeOwner));
    }
    return null;
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName) {
    return access(permissionName, false);
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName, boolean isChangeOwner) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0), isChangeOwner)) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule, isChangeOwner)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#end_block

#method_before
public ChangeControl validateFor(Change.Id id, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(id, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    return getProjectControl().getLabelTypes();
}
#method_after
public LabelTypes getLabelTypes() {
    String destBranch = getChange().getDest().get();
    List<LabelType> all = getProjectControl().getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (RefConfigSection.isValid(refPattern) && match(destBranch, refPattern)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges();
}
#method_after
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges(isOwner());
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    List<PermissionRule> rules = getRefControl().getRules(permission);
    if (isOwner() && rulesContainGroup(rules, AccountGroup.CHANGE_OWNERS)) {
        return getRefControl().getLabelRange(permission);
    } else {
        return getRefControl().getRange(permission);
    }
}
#method_after
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#end_block

#method_before
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owners"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#method_after
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owner"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#end_block

#method_before
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owners"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#method_after
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owner"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#end_block

#method_before
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owners"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#method_after
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owner"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#end_block

#method_before
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwners = newGroup(c, "Change Owners", AccountGroup.CHANGE_OWNERS);
    changeOwners.setDescription("The owners of a change");
    changeOwners.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwners)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#method_after
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwner = newGroup(c, "Change Owner", AccountGroup.CHANGE_OWNER);
    changeOwner.setDescription("The owner of a change");
    changeOwner.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwner.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwner));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwner)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, null);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(info.revisions().get(base), rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(!Gerrit.getConfig().testChangeDisableSubmit() || changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled();
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setTestChangeMerge(cfg.getBoolean("changeMerge", "test", false));
    config.setTestChangeDisableSubmit(cfg.getBoolean("changeMerge", "disableSubmit", true));
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
public HTMLPanel getSizeWidget(ChangeInfo c) {
    int largeChangeSize = Gerrit.getConfig().getLargeChangeSize();
    int changedLines = c.insertions() + c.deletions();
    int p = 100;
    if (changedLines < largeChangeSize) {
        p = Math.round(changedLines * 100 / largeChangeSize);
    }
    int width = Math.max(2, 70 * p / 100);
    int red = p > 50 ? 255 : (int) Math.round((p) * 5.12);
    int green = p < 50 ? 255 : (int) Math.round(256 - (p - 50) * 5.12);
    SafeHtmlBuilder sb = new SafeHtmlBuilder();
    sb.openDiv().setStyleName(Gerrit.RESOURCES.css().changeSize()).setAttribute("style", "width:" + width + "px; " + "background-color: #" + toHex(red) + toHex(green) + "00;").closeDiv();
    HTMLPanel panel = new HTMLPanel(sb);
    panel.setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    return panel;
}
#method_after
private static Widget getSizeWidget(ChangeInfo c) {
    int largeChangeSize = Gerrit.getConfig().getLargeChangeSize();
    int changedLines = c.insertions() + c.deletions();
    int p = 100;
    if (changedLines < largeChangeSize) {
        p = Math.round(changedLines * 100 / largeChangeSize);
    }
    int width = Math.max(2, 70 * p / 100);
    int red = p > 50 ? 255 : (int) Math.round((p) * 5.12);
    int green = p < 50 ? 255 : (int) Math.round(256 - (p - 50) * 5.12);
    String bg = "#" + toHex(red) + toHex(green) + "00";
    SimplePanel panel = new SimplePanel();
    panel.setStyleName(Gerrit.RESOURCES.css().changeSize());
    panel.setWidth(width + "px");
    panel.getElement().getStyle().setBackgroundColor(bg);
    panel.setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    return panel;
}
#end_block

#method_before
private static String toHex(int i) {
    String hex = Integer.toHexString(i);
    if (hex.length() == 1) {
        hex = "0" + hex;
    }
    return hex;
}
#method_after
private static String toHex(int i) {
    String hex = Integer.toHexString(i);
    return hex.length() == 1 ? "0" + hex : hex;
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    box.setVisible(true);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() : skip.getStartB();
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    Configuration markerConfig = Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true);
    Configuration lineWidgetConfig = Configuration.create().set("coverGutter", true).set("noHScroll", true);
    if (markStart == 0) {
        bar.setWidget(addLineWidget(cm, markEnd + 1, bar, lineWidgetConfig.set("above", true)));
    } else {
        bar.setWidget(addLineWidget(cm, markStart - 1, bar, lineWidgetConfig));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart, 0), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() : skip.getStartB();
    int markEnd = markStart + size - 1;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    Configuration markerConfig = Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true);
    Configuration lineWidgetConfig = Configuration.create().set("coverGutter", true).set("noHScroll", true);
    if (markStart == 0) {
        bar.setWidget(addLineWidget(cm, markEnd + 1, bar, lineWidgetConfig.set("above", true)));
    } else {
        bar.setWidget(addLineWidget(cm, markStart - 1, bar, lineWidgetConfig));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart, 0), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveBase(info, base);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = -1;
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null) {
            if (base.equals(String.valueOf(r._number()))) {
                selectedIdx = i;
            }
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    if (base != null) {
        diffBase.setSelectedIndex(selectedIdx - 1);
    } else {
        diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
    }
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, null, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static IncludedInDetail resolve(final Repository repo, final RevWalk rw, final RevCommit commit) throws IOException {
    Set<Ref> tags = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
    Set<Ref> branches = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
    Set<Ref> allTagsAndBranches = new HashSet<Ref>();
    allTagsAndBranches.addAll(tags);
    allTagsAndBranches.addAll(branches);
    Set<Ref> allMatchingTagsAndBranches = includedIn(repo, rw, commit, allTagsAndBranches, 0);
    IncludedInDetail detail = new IncludedInDetail();
    detail.setBranches(getMatchingRefNames(allMatchingTagsAndBranches, branches));
    detail.setTags(getMatchingRefNames(allMatchingTagsAndBranches, tags));
    return detail;
}
#method_after
public static IncludedInDetail resolve(final Repository repo, final RevWalk rw, final RevCommit commit) throws IOException {
    return new IncludedInResolver(repo, rw, commit).resolve();
}
#end_block

#method_before
public static boolean includedInOne(final Repository repo, final RevWalk rw, final RevCommit commit, final Set<Ref> tipRefs) throws IOException {
    return !includedIn(repo, rw, commit, tipRefs, 1).isEmpty();
}
#method_after
public static boolean includedInOne(final Repository repo, final RevWalk rw, final RevCommit commit, final Collection<Ref> refs) throws IOException {
    return new IncludedInResolver(repo, rw, commit).includedInOne(refs);
}
#end_block

#method_before
public static IncludedInDetail resolve(final Repository repo, final RevWalk rw, final RevCommit commit) throws IOException {
    Set<Ref> tags = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
    Set<Ref> branches = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
    Set<Ref> allTagsAndBranches = new HashSet<Ref>();
    allTagsAndBranches.addAll(tags);
    allTagsAndBranches.addAll(branches);
    Set<Ref> allMatchingTagsAndBranches = includedIn(repo, rw, commit, allTagsAndBranches, 0);
    IncludedInDetail detail = new IncludedInDetail();
    detail.setBranches(getMatchingRefNames(allMatchingTagsAndBranches, branches));
    detail.setTags(getMatchingRefNames(allMatchingTagsAndBranches, tags));
    return detail;
}
#method_after
private IncludedInDetail resolve() throws IOException {
    RefDatabase refDb = repo.getRefDatabase();
    Collection<Ref> tags = refDb.getRefs(Constants.R_TAGS).values();
    Collection<Ref> branches = refDb.getRefs(Constants.R_HEADS).values();
    List<Ref> allTagsAndBranches = Lists.newArrayListWithCapacity(tags.size() + branches.size());
    allTagsAndBranches.addAll(tags);
    allTagsAndBranches.addAll(branches);
    parseCommits(allTagsAndBranches);
    Set<String> allMatchingTagsAndBranches = includedIn(tipsByCommitTime, 0);
    IncludedInDetail detail = new IncludedInDetail();
    detail.setBranches(getMatchingRefNames(allMatchingTagsAndBranches, branches));
    detail.setTags(getMatchingRefNames(allMatchingTagsAndBranches, tags));
    return detail;
}
#end_block

#method_before
private static Set<Ref> includedIn(final Repository repo, final RevWalk rw, final RevCommit target, final Set<Ref> tipRefs, int limit) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    Set<Ref> result = new HashSet<Ref>();
    Map<RevCommit, Set<Ref>> tipsAndCommits = parseCommits(repo, rw, tipRefs);
    List<RevCommit> tips = new ArrayList<RevCommit>(tipsAndCommits.keySet());
    Collections.sort(tips, new Comparator<RevCommit>() {

        @Override
        public int compare(RevCommit c1, RevCommit c2) {
            return c1.getCommitTime() - c2.getCommitTime();
        }
    });
    Set<RevCommit> targetReachableFrom = new HashSet<RevCommit>();
    targetReachableFrom.add(target);
    for (RevCommit tip : tips) {
        boolean commitFound = false;
        rw.resetRetain(RevFlag.UNINTERESTING);
        rw.markStart(tip);
        for (RevCommit commit : rw) {
            if (targetReachableFrom.contains(commit)) {
                commitFound = true;
                targetReachableFrom.add(tip);
                result.addAll(tipsAndCommits.get(tip));
                break;
            }
        }
        if (0 < limit && limit < result.size()) {
            break;
        }
        if (!commitFound) {
            rw.markUninteresting(tip);
        }
    }
    return result;
}
#method_after
private Set<String> includedIn(final Collection<RevCommit> tips, int limit) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    Set<String> result = Sets.newHashSet();
    for (RevCommit tip : tips) {
        boolean commitFound = false;
        rw.resetRetain(RevFlag.UNINTERESTING, containsTarget);
        rw.markStart(tip);
        for (RevCommit commit : rw) {
            if (commit.equals(target) || commit.has(containsTarget)) {
                commitFound = true;
                tip.add(containsTarget);
                result.addAll(commitToRef.get(tip));
                break;
            }
        }
        if (!commitFound) {
            rw.markUninteresting(tip);
        } else if (0 < limit && limit < result.size()) {
            break;
        }
    }
    return result;
}
#end_block

#method_before
private static List<String> getMatchingRefNames(Set<Ref> matchingRefs, Set<Ref> allRefs) {
    List<String> refNames = new ArrayList<String>();
    for (Ref matchingRef : matchingRefs) {
        if (allRefs.contains(matchingRef)) {
            refNames.add(Repository.shortenRefName(matchingRef.getName()));
        }
    }
    return refNames;
}
#method_after
private static List<String> getMatchingRefNames(Set<String> matchingRefs, Collection<Ref> allRefs) {
    List<String> refNames = Lists.newArrayListWithCapacity(matchingRefs.size());
    for (Ref r : allRefs) {
        if (matchingRefs.contains(r.getName())) {
            refNames.add(Repository.shortenRefName(r.getName()));
        }
    }
    return refNames;
}
#end_block

#method_before
private static Map<RevCommit, Set<Ref>> parseCommits(final Repository repo, final RevWalk rw, final Set<Ref> refs) throws IOException {
    Map<RevCommit, Set<Ref>> result = new HashMap<RevCommit, Set<Ref>>();
    for (Ref ref : refs) {
        final RevCommit commit;
        try {
            commit = rw.parseCommit(ref.getObjectId());
        } catch (IncorrectObjectTypeException notCommit) {
            // 
            continue;
        } catch (MissingObjectException notHere) {
            // Log the problem with this branch, but keep processing.
            // 
            log.warn("Reference " + ref.getName() + " in " + repo.getDirectory() + " points to dangling object " + ref.getObjectId());
            continue;
        }
        Set<Ref> relatedRefs = result.get(commit);
        if (relatedRefs == null) {
            relatedRefs = new HashSet<Ref>();
            result.put(commit, relatedRefs);
        }
        relatedRefs.add(ref);
    }
    return result;
}
#method_after
private void parseCommits(final Collection<Ref> refs) throws IOException {
    if (commitToRef != null) {
        return;
    }
    commitToRef = LinkedListMultimap.create();
    for (Ref ref : refs) {
        final RevCommit commit;
        try {
            commit = rw.parseCommit(ref.getObjectId());
        } catch (IncorrectObjectTypeException notCommit) {
            // 
            continue;
        } catch (MissingObjectException notHere) {
            // Log the problem with this branch, but keep processing.
            // 
            log.warn("Reference " + ref.getName() + " in " + repo.getDirectory() + " points to dangling object " + ref.getObjectId());
            continue;
        }
        commitToRef.put(commit, ref.getName());
    }
    tipsByCommitTime = Lists.newArrayList(commitToRef.keySet());
    sortOlderFirst(tipsByCommitTime);
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            Map<String, Ref> allRefs = Maps.newHashMap();
            allRefs.putAll(refDb.getRefs(Constants.R_HEADS));
            allRefs.putAll(refDb.getRefs(Constants.R_TAGS));
            Set<Ref> canReadRefs = Sets.newHashSet();
            for (Entry<String, Ref> entry : allRefs.entrySet()) {
                if (controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    canReadRefs.add(entry.getValue());
                }
            }
            return !canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#method_after
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    if (controlForRef("refs/*").canPerform(Permission.READ)) {
        return true;
    }
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            List<Ref> allRefs = Lists.newLinkedList();
            allRefs.addAll(refDb.getRefs(Constants.R_HEADS).values());
            allRefs.addAll(refDb.getRefs(Constants.R_TAGS).values());
            List<Ref> canReadRefs = Lists.newLinkedList();
            for (Ref r : allRefs) {
                if (controlForRef(r.getName()).canPerform(Permission.READ)) {
                    canReadRefs.add(r);
                }
            }
            if (!canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs)) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return false;
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    table.setWidget(row, C_SIZE, getSizeWidget(c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(approve()).submit();
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#end_block

#method_before
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in).current().review(approve()).submit();
}
#method_after
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in);
    cApi.current().review(approve());
    cApi.current().submit();
}
#end_block

#method_before
@Override
public RevisionApi review(ReviewInput in) throws RestApiException {
    try {
        review.get().apply(revision, in);
        return this;
    } catch (OrmException e) {
        throw new RestApiException("Cannot post review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#method_after
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot post review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    try {
        rebase.get().apply(revision, null);
    } catch (OrmException e) {
        throw new RestApiException("Cannot rebase ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase() throws RestApiException {
    try {
        return changes.id(rebase.get().apply(revision, null)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot rebase ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.get().apply(revision, in)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    }
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.get().apply(revision, in)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot cherry pick", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#end_block

#method_before
@Override
public void start() {
    for (Destination cfg : configs.getDestinations()) {
        cfg.start(workQueue);
    }
    running = true;
}
#method_after
@Override
public void start() {
    for (Destination cfg : config.getDestinations()) {
        cfg.start(workQueue);
    }
    running = true;
}
#end_block

#method_before
@Override
public void stop() {
    running = false;
    int discarded = 0;
    for (Destination cfg : configs.getDestinations()) {
        discarded += cfg.shutdown();
    }
    if (discarded > 0) {
        log.warn(String.format("Cancelled %d replication events during shutdown", discarded));
    }
}
#method_after
@Override
public void stop() {
    running = false;
    int discarded = 0;
    for (Destination cfg : config.getDestinations()) {
        discarded += cfg.shutdown();
    }
    if (discarded > 0) {
        log.warn(String.format("Cancelled %d replication events during shutdown", discarded));
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs.getDestinations()) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations()) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs.getDestinations()) {
            if (cfg.wouldPushProject(project) && cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(changeHooks, database));
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations()) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs.getDestinations()) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    for (URIish uri : getURIs(new Project.NameKey(event.getProjectName()), false)) {
        createProject(uri, event.getHeadName());
    }
}
#end_block

#method_before
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        log.error(String.format("Failed to create repository %s", uri.getPath()), e);
    }
}
#method_after
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            if (head != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.disableRefLog();
                u.link(head);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        log.error(String.format("Failed to create repository %s", uri.getPath()), e);
    }
}
#end_block

#method_before
private static void createRemoteSsh(URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + "&& cd " + quotedPath + "&& git init --bare" + "&& git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    OutputStream errStream = newErrorBufferStream();
    try {
        RemoteSession ssh = connect(uri);
        Process proc = ssh.exec(cmd, 0);
        proc.getOutputStream().close();
        StreamCopyThread out = new StreamCopyThread(proc.getInputStream(), errStream);
        StreamCopyThread err = new StreamCopyThread(proc.getErrorStream(), errStream);
        out.start();
        err.start();
        try {
            proc.waitFor();
            out.halt();
            err.halt();
        } catch (InterruptedException interrupted) {
        // Don't wait, drop out immediately.
        }
        ssh.disconnect();
    } catch (IOException e) {
        log.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
private static void createRemoteSsh(URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + " && cd " + quotedPath + " && git init --bare";
    if (head != null) {
        cmd = cmd + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    }
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemotSsh(uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (isDuplicate(msg)) {
        return;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    if (isDuplicate(msg)) {
        return;
    }
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    Element element = context.getElement().getFirstChildElement();
    while (element.getPropertyInt("value") != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        element = element.getNextSiblingElement();
    }
    if (element.getPropertyInt("value") == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        if (enableSmallFileFeatures) {
            element.removeAttribute("disabled");
        } else {
            element.setAttribute("disabled", "disabled");
            if (AccountDiffPreference.CONTEXT_CHOICES[context.getSelectedIndex()] == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
                for (int i = 0; i < AccountDiffPreference.CONTEXT_CHOICES.length; i++) {
                    if (AccountDiffPreference.CONTEXT_CHOICES[i] == PatchScreen.LARGE_FILE_CONTEXT) {
                        context.setSelectedIndex(i);
                        break;
                    }
                }
            }
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    NodeList<OptionElement> options = context.getElement().<SelectElement>cast().getOptions();
    // WHOLE_FILE_CONTEXT is the last option in the list.
    int lastIndex = options.getLength() - 1;
    OptionElement currOption = options.getItem(lastIndex);
    if (enableSmallFileFeatures) {
        currOption.setDisabled(false);
    } else {
        currOption.setDisabled(true);
        if (context.getSelectedIndex() == lastIndex) {
            // Select the next longest context from WHOLE_FILE_CONTEXT
            context.setSelectedIndex(lastIndex - 1);
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> r = Lists.newArrayList();
    for (final Change c : changes) {
        List<Predicate<ChangeData>> r2 = Lists.newArrayList();
        for (String file : (new ChangeData(c)).currentFilePaths(db, plc)) {
            r2.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> r3 = Lists.newArrayList();
        r3.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        r3.add(or(r2));
        r3.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        ObjectInserter inserter = repo.newObjectInserter();
                        try {
                            RevWalk rw = new RevWalk(repo) {

                                @Override
                                protected RevCommit createCommit(final AnyObjectId id) {
                                    return new CodeReviewCommit(id);
                                }
                            };
                            try {
                                RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                                CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(new ChangeData(c).currentPatchSet(db).getRevision().get()));
                                SubmitStrategy strategy = submitStrategyFactory.create(getSubmitType(object), db.get(), repo, rw, inserter, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                                CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(object.currentPatchSet(db).getRevision().get()));
                                otherCommit.add(canMergeFlag);
                                return !strategy.dryRun(commit, otherCommit);
                            } catch (MergeException e) {
                                throw new IllegalStateException();
                            } catch (NoSuchProjectException e) {
                                throw new IllegalStateException();
                            } finally {
                                rw.release();
                            }
                        } finally {
                            inserter.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (final Ref r : repo.getAllRefs().values()) {
                        if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                            try {
                                alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                            } catch (IncorrectObjectTypeException iote) {
                            // Not a commit? Skip over it.
                            }
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        r.add(and(r3));
    }
    return r;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final ProjectCache projectCache, final ConflictsCache conflictsCache, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, projectCache);
        List<String> files = new ChangeData(c).currentFilePaths(db, plc);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(db, c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(db, c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet(db).getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#method_after
@SuppressWarnings("unchecked")
public static boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#method_after
@SuppressWarnings("unchecked")
public static int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#end_block

#method_before
public boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#method_after
public static boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for comment:" + value);
    }
    return new CommentPredicate(args.dbProvider, args.index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = requireIndex(FIELD_COMMENT, value);
    return new CommentPredicate(args.dbProvider, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for " + FIELD_CONFLICTS + ":" + value);
    }
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, value, parseChange(value));
}
#method_after
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    requireIndex(FIELD_CONFLICTS, value);
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, args.projectCache, args.conflictsCache, value, parseChange(value));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (!allowFileRegex) {
            requireIndex(FIELD_FILE, file);
        }
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        requireIndex(FIELD_FILE, file);
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for message:" + text);
    }
    return new MessagePredicate(args.dbProvider, args.index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    if (index == null) {
        return new LegacyMessagePredicate(args.dbProvider, args.repoManager, text);
    }
    return new MessagePredicate(args.dbProvider, index, text);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser.isIdentifiedUser() && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
public Predicate<ChangeData> limit(int limit) {
    return new IntPredicate<ChangeData>(FIELD_LIMIT, limit) {

        @Override
        public boolean match(ChangeData object) {
            return true;
        }

        @Override
        public int getCost() {
            return 0;
        }
    };
}
#method_after
public Predicate<ChangeData> limit(int limit) {
    return new LimitPredicate(limit);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        Change.Key b = a.max();
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, b).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#method_after
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, a.max()).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#end_block

#method_before
private Account.Id self() {
    if (currentUser instanceof IdentifiedUser) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#method_after
private Account.Id self() {
    if (currentUser.isIdentifiedUser()) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(dbProvider, cut), a);
}
#method_after
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(schema(indexes), dbProvider, cut), a);
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProjectName(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProject(value.getProjectName());
        parentProjectBox.setParentProject(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(editing && (!value.getOwnerOf().isEmpty() || value.canUpload()));
}
#end_block

#method_before
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getProjectName());
}
#method_after
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getParentProjectName());
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    detail.setLabelTypes(pc.getLabelTypes());
    return detail;
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, parentProjectName, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    changeProjectAccessFactory.create(projectName, getBase(baseRevision), sections, parentProjectName, msg).to(cb);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.projectAccess(getProjectKey(), new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities(cbs.add(new AsyncCallback<NativeMap<CapabilityInfo>>() {

        @Override
        public void onSuccess(NativeMap<CapabilityInfo> result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addFinal(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#end_block

#method_before
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty());
    edit.setEnabled(!access.getOwnerOf().isEmpty());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#method_after
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    commit.setVisible(!access.getOwnerOf().isEmpty());
    review.setVisible(access.canUpload());
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess access) {
            enable(true);
            commitMessage.setText("");
            displayReadOnly(access);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
                if (access.canUpload()) {
                    error.add(new Label(Gerrit.C.projectAccessProposeForReviewHint()));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final List<AccessSection> wantedSections = mergeSections(removeEmptyPermissionsAndSections(wantedAccess.getLocal()));
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedSections);
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedSections.size() + newAccess.getLocal().size());
            different.addAll(wantedSections);
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            if (caught instanceof RemoteJsonException && caught.getMessage().startsWith(UpdateParentFailedException.MESSAGE)) {
                new ErrorDialog(Gerrit.M.parentUpdateFailed(caught.getMessage().substring(UpdateParentFailedException.MESSAGE.length() + 1))).center();
            } else {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#method_after
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled ? !access.getOwnerOf().isEmpty() : false);
    review.setEnabled(enabled ? access.canUpload() : false);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#end_block

#method_before
public void setCanChangeParent(final boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#method_after
public void setCanChangeParent(boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#end_block

#method_before
public void testHeadRefReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/heads/master", "someHost", RefPushResult.SUCCEEDED);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicatedEventEquals.eqEvent(expectedEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    verify(changeHooksMock);
}
#method_after
public void testHeadRefReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/heads/master", "someHost", RefPushResult.SUCCEEDED);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicatedEventEquals.eqEvent(expectedEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    verify(changeHooksMock);
}
#end_block

#method_before
public void testChangeRefReplicated() throws URISyntaxException, OrmException {
    Change expectedChange = new Change(null, null, null, null, null);
    reset(changeAccessMock);
    expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange);
    replay(changeAccessMock);
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", RefPushResult.FAILED);
    changeHooksMock.postEvent(eq(expectedChange), RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(ReviewDb.class));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/changes/1/1/1", new URIish("git://someHost/someProject.git"), RefPushResult.FAILED);
    verify(changeHooksMock);
}
#method_after
public void testChangeRefReplicated() throws URISyntaxException, OrmException {
    Change expectedChange = new Change(null, null, null, null, null);
    reset(changeAccessMock);
    expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange);
    replay(changeAccessMock);
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", RefPushResult.FAILED);
    changeHooksMock.postEvent(eq(expectedChange), RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(ReviewDb.class));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/changes/1/1/1", new URIish("git://someHost/someProject.git"), RefPushResult.FAILED);
    verify(changeHooksMock);
}
#end_block

#method_before
public void testOnAllNodesReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), anyObject(RefReplicatedEvent.class));
    expectLastCall().times(5);
    RefReplicationDoneEvent expectedDoneEvent = new RefReplicationDoneEvent("someProject", "refs/heads/master", 5);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicationDoneEventEquals.eqEvent(expectedDoneEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onAllNodesReplicated(5);
    verify(changeHooksMock);
}
#method_after
public void testOnAllNodesReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicationDoneEvent expectedDoneEvent = new RefReplicationDoneEvent("someProject", "refs/heads/master", 5);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicationDoneEventEquals.eqEvent(expectedDoneEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToAllNodes("someProject", "refs/heads/master", 5);
    verify(changeHooksMock);
}
#end_block

#method_before
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicatedEvent)) {
        return false;
    }
    RefReplicatedEvent actualRefReplicatedEvent = (RefReplicatedEvent) actual;
    if (!checkObjectsEquals(expected.project, actualRefReplicatedEvent.project)) {
        return false;
    }
    if (!checkObjectsEquals(expected.ref, actualRefReplicatedEvent.ref)) {
        return false;
    }
    if (!checkObjectsEquals(expected.targetNode, actualRefReplicatedEvent.targetNode)) {
        return false;
    }
    if (!checkObjectsEquals(expected.status, actualRefReplicatedEvent.status)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicatedEvent)) {
        return false;
    }
    RefReplicatedEvent actualRefReplicatedEvent = (RefReplicatedEvent) actual;
    if (!equals(expected.project, actualRefReplicatedEvent.project)) {
        return false;
    }
    if (!equals(expected.ref, actualRefReplicatedEvent.ref)) {
        return false;
    }
    if (!equals(expected.targetNode, actualRefReplicatedEvent.targetNode)) {
        return false;
    }
    if (!equals(expected.status, actualRefReplicatedEvent.status)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicationDoneEvent)) {
        return false;
    }
    RefReplicationDoneEvent actualRefReplicatedDoneEvent = (RefReplicationDoneEvent) actual;
    if (!checkObjectsEquals(expected.project, actualRefReplicatedDoneEvent.project)) {
        return false;
    }
    if (!checkObjectsEquals(expected.ref, actualRefReplicatedDoneEvent.ref)) {
        return false;
    }
    if (expected.nodesCount != actualRefReplicatedDoneEvent.nodesCount) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicationDoneEvent)) {
        return false;
    }
    RefReplicationDoneEvent actualRefReplicatedDoneEvent = (RefReplicationDoneEvent) actual;
    if (!equals(expected.project, actualRefReplicatedDoneEvent.project)) {
        return false;
    }
    if (!equals(expected.ref, actualRefReplicatedDoneEvent.ref)) {
        return false;
    }
    if (expected.nodesCount != actualRefReplicatedDoneEvent.nodesCount) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED, injector);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(changeHooks, database));
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            for (Entry<String, Ref> entry : repo.getAllRefs().entrySet()) {
                String refName = entry.getKey();
                if (refName.startsWith("refs/changes") || refName.startsWith("refs/cache-automerge")) {
                    continue;
                }
                RevCommit tip;
                try {
                    tip = rw.parseCommit(entry.getValue().getObjectId());
                } catch (IncorrectObjectTypeException e) {
                    continue;
                }
                if (rw.isMergedInto(commit, tip) && controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    return true;
                }
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#method_after
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            for (Entry<String, Ref> entry : repo.getAllRefs().entrySet()) {
                String refName = entry.getKey();
                if (!refName.startsWith("refs/heads") && !refName.startsWith("refs/tags")) {
                    continue;
                }
                RevCommit tip;
                try {
                    tip = rw.parseCommit(entry.getValue().getObjectId());
                } catch (IncorrectObjectTypeException e) {
                    continue;
                }
                if (rw.isMergedInto(commit, tip) && controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    return true;
                }
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(approve());
}
#method_after
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name());
    rApi.review(approve());
    rApi.submit(new SubmitInput());
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).current();
    rApi.review(approve());
    rApi.submit();
}
#end_block

#method_before
private static ReviewInput approve() {
    ReviewInput in = new ReviewInput();
    in.message = "Looks good!";
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    return in;
}
#method_after
private static ReviewInput approve() {
    return new ReviewInput().message("Looks good!").label("Code-Review", 2);
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot submit change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit() throws RestApiException {
    SubmitInput in = new SubmitInput();
    in.waitForMerge = true;
    submit(in);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
}
#method_after
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
}
#end_block

#method_before
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
    gApi.changes().id("p~master~" + r.getChangeId()).restore(new RestoreInput());
}
#method_after
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
    gApi.changes().id("p~master~" + r.getChangeId()).restore();
}
#end_block

#method_before
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            SubmitInput input = new SubmitInput();
            input.waitForMerge = true;
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit(input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).deleteDraftPatchSet(new DeleteDraftPatchSetInput());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit();
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).delete();
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon() throws RestApiException {
    abandon(new AbandonInput());
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore() throws RestApiException {
    restore(new RestoreInput());
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
private void approve(String changeId) throws IOException {
    ReviewInput in = new ReviewInput();
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void approve(String changeId) throws IOException {
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", new ReviewInput().label("Code-Review", 2));
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    } catch (IOException e) {
        // TODO: propagate this exception
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#end_block

#method_before
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(Change.Id id, CurrentUser user) throws NoSuchChangeException {
    final Change change;
    try {
        change = db.get().changes().get(id);
        if (change == null) {
            throw new NoSuchChangeException(id);
        }
    } catch (OrmException e) {
        throw new NoSuchChangeException(id, e);
    }
    return controlFor(change, user);
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canPublish(final ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db);
}
#end_block

#method_before
public boolean canDeleteDraft(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canDeleteDraft(final ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canDeleteDrafts()) && isVisible(db);
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    return canRemoveReviewer(approval.getAccountId(), approval.getValue());
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> getSubmitRecords(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, true);
}
#method_after
public List<SubmitRecord> getSubmitRecords(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, true, false);
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.CHANGE_DATA, cd);
        env.set(StoredValues.PATCH_SET, patchSet);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    if (fastEvalLabels) {
                        env.once("gerrit", "assume_range_from_label");
                    }
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public boolean canSubmit() {
    return getRefControl().canSubmit();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, false);
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, false, false);
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private boolean isDraftVisible(ReviewDb db, ChangeData cd) throws OrmException {
    return isOwner() || isReviewer(db, cd);
}
#method_after
private boolean isDraftVisible(ReviewDb db, ChangeData cd) throws OrmException {
    return isOwner() || isReviewer(db, cd) || getRefControl().canViewDrafts();
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

#method_before
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#end_block

#method_before
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#end_block

#method_before
public void increasePushTaskCount(String project, String ref) {
    getRefReplicationInfo(project, ref).nodesToReplicateCount.incrementAndGet();
    totalPushTasksCount.incrementAndGet();
}
#method_after
public void increasePushTaskCount(String project, String ref) {
    countingLock.lock();
    try {
        getRefStatus(project, ref).nodesToReplicateCount++;
        totalPushTasksCount++;
    } finally {
        countingLock.unlock();
    }
}
#end_block

#method_before
public boolean hasPushTask() {
    return totalPushTasksCount.get() != 0;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationInfo refReplicationInfo = getRefReplicationInfo(project, ref);
    refReplicationInfo.replicatedNodesCount.incrementAndGet();
    if (allScheduled && refReplicationInfo.nodesToReplicateCount.get() == refReplicationInfo.replicatedNodesCount.get()) {
        fireOnRefReplicatedToAllNodes(project, ref);
    }
    finishedPushTasksCount.incrementAndGet();
    verifyAllPushTasksCompleted();
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationStatus completedRefStatus = null;
    boolean allPushTaksCompleted = false;
    countingLock.lock();
    try {
        RefReplicationStatus refStatus = getRefStatus(project, ref);
        refStatus.replicatedNodesCount++;
        finishedPushTasksCount++;
        if (allScheduled) {
            if (refStatus.allDone()) {
                completedRefStatus = statusByProjectRef.remove(project, ref);
            }
            allPushTaksCompleted = finishedPushTasksCount == totalPushTasksCount;
        }
    } finally {
        countingLock.unlock();
    }
    if (completedRefStatus != null) {
        doRefPushTasksCompleted(completedRefStatus);
    }
    if (allPushTaksCompleted) {
        doAllPushTasksCompleted();
    }
}
#end_block

#method_before
public void markAllPushTasksScheduled() {
    allScheduled = true;
    verifyAllPushTasksCompleted();
}
#method_after
public void markAllPushTasksScheduled() {
    countingLock.lock();
    try {
        allScheduled = true;
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
private void fireRemainingOnRefReplicatedToAllNodes() {
    // Some could be remaining if replication of a ref is completed before all tasks are scheduled
    for (SimpleEntry<String, String> projectRefKey : replicationInfoPerProjectRef.keySet()) {
        fireOnRefReplicatedToAllNodes(projectRefKey.getKey(), projectRefKey.getValue());
    }
}
#method_after
private void fireRemainingOnRefReplicatedToAllNodes() {
    for (RefReplicationStatus refStatus : statusByProjectRef.values()) {
        doRefPushTasksCompleted(refStatus);
    }
}
#end_block

#method_before
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToStrict(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToDefault(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final DocInfo item) {
    return item.url();
}
#method_after
@Override
protected Object getRowItemKey(DocInfo item) {
    return item.url();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final DocInfo d = getRowItem(row);
    Gerrit.display("/" + d.url());
}
#method_after
@Override
protected void onOpenRow(int row) {
    DocInfo d = getRowItem(row);
    Window.Location.assign(d.getFullUrl());
}
#end_block

#method_before
private void insertNoneRow(final int row) {
    insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setColSpan(row, 0, columns);
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#method_after
private void insertNoneRow(int row) {
    table.insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#method_after
@Override
protected void applyDataRowStyle(int row) {
    super.applyDataRowStyle(row);
    CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#end_block

#method_before
private void populateDocRow(final int row, final DocInfo d) {
    String title = com.google.gerrit.client.changes.Util.cropSubject(d.title());
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#method_after
private void populateDocRow(int row, DocInfo d) {
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/doc/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void docSearch(final String token) {
    Gerrit.display(token, new DocScreen(skip(token)));
}
#method_after
private static void docSearch(final String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, new DocScreen(skip(token)));
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    section = new DocTable.Section();
    table.addSection(section);
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable();
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    docs.query(loadCallback(), query);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    doQuery();
}
#end_block

#method_before
protected AsyncCallback<DocList> loadCallback() {
    return new GerritCallback<DocList>() {

        @Override
        public final void onSuccess(DocList result) {
            display(result);
            DocScreen.this.display();
        }
    };
}
#method_after
private AsyncCallback<JsArray<DocInfo>> loadCallback() {
    return new GerritCallback<JsArray<DocInfo>>() {

        @Override
        public void onSuccess(JsArray<DocInfo> result) {
            displayResults(result);
            display();
        }
    };
}
#end_block

#method_before
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repository, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL));
    } catch (ServiceMayNotContinueException e) {
        throw e;
    } catch (IOException e) {
        throw new ServiceMayNotContinueException().initCause(e);
    }
}
#method_after
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repository, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL));
    } catch (ServiceMayNotContinueException e) {
        throw e;
    } catch (IOException e) {
        ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
        ex.initCause(e);
        throw ex;
    }
}
#end_block

#method_before
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    if (oldRefs == null) {
        try {
            oldRefs = rp.getRepository().getRefDatabase().getRefs(ALL);
        } catch (ServiceMayNotContinueException e) {
            throw e;
        } catch (IOException e) {
            throw new ServiceMayNotContinueException().initCause(e);
        }
    }
    Map<String, Ref> r = Maps.newHashMapWithExpectedSize(oldRefs.size());
    for (Map.Entry<String, Ref> e : oldRefs.entrySet()) {
        String name = e.getKey();
        if (!skip(name)) {
            r.put(name, e.getValue());
        }
    }
    rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp));
}
#method_after
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    if (oldRefs == null) {
        try {
            oldRefs = rp.getRepository().getRefDatabase().getRefs(ALL);
        } catch (ServiceMayNotContinueException e) {
            throw e;
        } catch (IOException e) {
            ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
            ex.initCause(e);
            throw ex;
        }
    }
    Map<String, Ref> r = Maps.newHashMapWithExpectedSize(oldRefs.size());
    for (Map.Entry<String, Ref> e : oldRefs.entrySet()) {
        String name = e.getKey();
        if (!skip(name)) {
            r.put(name, e.getValue());
        }
    }
    rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp));
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        shellInjector = createShellInjector();
        manager.add(dbInjector, cfgInjector, sysInjector, shellInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (shell) {
            InteractiveShell interp = shellInjector.getInstance(InteractiveShell.class);
            interp.set("m", manager);
            interp.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
        manager.add(dbInjector, cfgInjector, sysInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new EhcachePoolImpl.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initSshd() {
    sshInjector = createSshInjector();
    manager.add(sshInjector);
}
#method_after
private void initSshd() {
    sshInjector = createSshInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setSshInjector(sshInjector);
    manager.add(sshInjector);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new SshModule());
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(sysInjector.getInstance(SshModule.class));
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#method_after
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setHttpInjector(webInjector);
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
protected Object runMethod0(Class klazz, Object instance, String name, Class[] sig, Object[] args) throws InvocationTargetException {
    Method interpMethod;
    try {
        interpMethod = klazz.getMethod(name, sig);
        return interpMethod.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod0(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) throws InvocationTargetException {
    try {
        Method m;
        m = klazz.getMethod(name, sig);
        return m.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runMethod(Class klazz, Object instance, String name, Class[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runInterpreter(String name, Class[] sig, Object[] args) {
    return runMethod(console, interp, name, sig, args);
}
#method_after
protected Object runInterpreter(String name, Class<?>[] sig, Object[] args) {
    return runMethod(console, shell, name, sig, args);
}
#end_block

#method_before
private static Class findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#method_after
private static Class<?> findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#end_block

#method_before
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, interp, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#method_after
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, shell, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#end_block

#method_before
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, interp, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#method_after
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, shell, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#end_block

#method_before
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final ArrayList<URL> jars = new ArrayList<URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith("WEB-INF/lib/")) {
                    final File tmp = createTempFile(safeName(ze), ".jar");
                    final FileOutputStream out = new FileOutputStream(tmp);
                    try {
                        final InputStream in = zf.getInputStream(ze);
                        try {
                            final byte[] buf = new byte[4096];
                            int n;
                            while ((n = in.read(buf, 0, buf.length)) > 0) {
                                out.write(buf, 0, n);
                            }
                        } finally {
                            in.close();
                        }
                    } finally {
                        out.close();
                    }
                    jars.add(tmp.toURI().toURL());
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    Collections.sort(jars, new Comparator<URL>() {

        public int compare(URL o1, URL o2) {
            return o1.toString().compareTo(o2.toString());
        }
    });
    return new URLClassLoader(jars.toArray(new URL[jars.size()]));
}
#method_after
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final SortedMap<String, URL> jars = new TreeMap<String, URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                } else if (ze.getName().startsWith("WEB-INF/lib/")) {
                    extractJar(zf, ze, jars);
                } else if (ze.getName().startsWith("WEB-INF/pgm-lib/")) {
                    extractJar(zf, ze, jars);
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    // The extension API needs to be its own ClassLoader, along
    // with a few of its dependencies. Try to construct this first.
    List<URL> extapi = new ArrayList<URL>();
    move(jars, "gerrit-extension-api-", extapi);
    move(jars, "guice-", extapi);
    move(jars, "javax.inject-1.jar", extapi);
    move(jars, "aopalliance-1.0.jar", extapi);
    move(jars, "guice-servlet-", extapi);
    move(jars, "tomcat-servlet-api-", extapi);
    ClassLoader parent = ClassLoader.getSystemClassLoader();
    if (!extapi.isEmpty()) {
        parent = new URLClassLoader(extapi.toArray(new URL[extapi.size()]), parent);
    }
    return new URLClassLoader(jars.values().toArray(new URL[jars.size()]), parent);
}
#end_block

#method_before
private static File tmproot() {
    // Use $HOME/.gerritcodereview/tmp for our temporary file area.
    // 
    final File tmp = new File(getHomeDirectory(), "tmp");
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#method_after
private static File tmproot() {
    File tmp;
    String gerritTemp = System.getenv("GERRIT_TMP");
    if (gerritTemp != null && gerritTemp.length() > 0) {
        tmp = new File(gerritTemp);
    } else {
        tmp = new File(getHomeDirectory(), "tmp");
    }
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    bind(DocQueryProcessor.class).to(DocQueryLucene.class);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?docsearch/(.*)$").with(DocSearchRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DocQueryLucene.DOC_FIELD, reader));
        doc.add(new StringField(DocQueryLucene.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(DocQueryLucene.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStatsAttribute stats = new QueryStatsAttribute();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                LabelTypes labelTypes = changeControlFactory.controlFor(d.getChange()).getLabelTypes();
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                ChangeResource rsrc = new ChangeResource(changeControlFactory.controlFor(d.getChange()));
                eventFactory.currentreviewers(c, rsrc, includeApprovals ? d.approvalsMap(db).asMap() : null);
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, includeFiles, d.change(db), labelTypes);
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, labelTypes);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(db), labelTypes);
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        } catch (NoSuchChangeException e) {
            log.error("Missing change: " + e.getMessage(), e);
            ErrorMessage m = new ErrorMessage();
            m.message = "missing change " + e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStatsAttribute stats = new QueryStatsAttribute();
            stats.runTimeMilliseconds = TimeUtil.nowMs();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                LabelTypes labelTypes = changeControlFactory.controlFor(d.getChange()).getLabelTypes();
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeAllReviewers) {
                    eventFactory.addAllReviewers(c, d.getChange());
                }
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, includeFiles, d.change(db), labelTypes);
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, labelTypes);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(db), labelTypes);
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = TimeUtil.nowMs() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        } catch (NoSuchChangeException e) {
            log.error("Missing change: " + e.getMessage(), e);
            ErrorMessage m = new ErrorMessage();
            m.message = "missing change " + e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    String arrow = Character.toString((char) 0x25be);
    userSummaryPanel.add(new InlineLabel(" " + arrow));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#end_block

#method_before
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, message, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(cherryPickCommit.getTree(), mergeTip, cherryPickCommit.getAuthorIdent(), myIdent, message);
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), myIdent, message);
            String commitMessage = ChangeIdUtil.insertId(message, computedChangeId);
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSetId);
    cmsg.setMessage("Uploaded patch set " + newPatchSetId.get() + ".");
    inserter.setMessage(cmsg).insert();
    return change.getId();
}
#method_after
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").insert();
    return change.getId();
}
#end_block

#method_before
void build(Repository git, TagSet old, TagMatcher m) {
    if (old != null && m != null && refresh(old, m)) {
        return;
    }
    TagWalk rw = new TagWalk(git);
    rw.setRetainBody(false);
    try {
        for (Ref ref : git.getRefDatabase().getRefs(RefDatabase.ALL).values()) {
            if (skip(ref)) {
                continue;
            } else if (isTag(ref)) {
                // For a tag, remember where it points to.
                addTag(rw, git.peel(ref));
            } else {
                // New reference to include in the set.
                addRef(rw, ref);
            }
        }
        // Traverse the complete history. Copy any flags from a commit to
        // all of its ancestors. This automatically updates any Tag object
        // as the TagCommit and the stored Tag object share the same
        // underlying bit set.
        TagCommit c;
        while ((c = (TagCommit) rw.next()) != null) {
            BitSet mine = c.refFlags;
            int pCnt = c.getParentCount();
            for (int pIdx = 0; pIdx < pCnt; pIdx++) {
                ((TagCommit) c.getParent(pIdx)).refFlags.or(mine);
            }
        }
    } catch (IOException e) {
        log.warn("Repository " + projectName + " has corruption", e);
    } finally {
        rw.release();
    }
}
#method_after
void build(Repository git, TagSet old, TagMatcher m) {
    if (old != null && m != null && refresh(old, m)) {
        return;
    }
    TagWalk rw = new TagWalk(git);
    rw.setRetainBody(false);
    try {
        for (Ref ref : git.getRefDatabase().getRefs(RefDatabase.ALL).values()) {
            if (skip(ref)) {
                continue;
            } else if (isTag(ref)) {
                // For a tag, remember where it points to.
                addTag(rw, git.peel(ref));
            } else {
                // New reference to include in the set.
                addRef(rw, ref);
            }
        }
        // Traverse the complete history. Copy any flags from a commit to
        // all of its ancestors. This automatically updates any Tag object
        // as the TagCommit and the stored Tag object share the same
        // underlying bit set.
        TagCommit c;
        while ((c = (TagCommit) rw.next()) != null) {
            BitSet mine = c.refFlags;
            int pCnt = c.getParentCount();
            for (int pIdx = 0; pIdx < pCnt; pIdx++) {
                ((TagCommit) c.getParent(pIdx)).refFlags.or(mine);
            }
        }
    } catch (IOException e) {
        log.warn("Error building tags for repository " + projectName, e);
    } finally {
        rw.release();
    }
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    Account userAccount = null;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    Repository repo = null;
    try {
        repo = repoManager.openRepository(userProjectControl.getProject().getNameKey());
        Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
        for (final String ref : refsMap.keySet()) {
            if (!onlyRefsHeads || ref.startsWith(Branch.R_HEADS)) {
                stdout.println(ref);
            }
        }
    } catch (RepositoryNotFoundException e) {
        throw new UnloggedFailure("fatal: '" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw new UnloggedFailure("fatal: Error opening: '" + projectControl.getProject().getNameKey());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    Account userAccount = null;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    Repository repo;
    try {
        repo = repoManager.openRepository(userProjectControl.getProject().getNameKey());
    } catch (RepositoryNotFoundException e) {
        throw new UnloggedFailure("fatal: '" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw new UnloggedFailure("fatal: Error opening: '" + projectControl.getProject().getNameKey());
    }
    try {
        Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
        for (final String ref : refsMap.keySet()) {
            if (!onlyRefsHeads || ref.startsWith(Branch.R_HEADS)) {
                stdout.println(ref);
            }
        }
    } catch (IOException e) {
        throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            ReviewDb db = schemaFactory.open();
            try {
                Repository repo = repoManager.openRepository(project);
                try {
                    Map<String, Ref> refs = repo.getAllRefs();
                    for (Change c : db.changes().byProject(project)) {
                        Ref r = refs.get(c.currentPatchSetId().toRefName());
                        if (r != null) {
                            byId.put(r.getObjectId(), new ChangeData(c));
                        }
                    }
                    new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
                } finally {
                    repo.close();
                // TODO(dborowitz): Opening all repositories in a live server may be
                // wasteful; see if we can determine which ones it is safe to close
                // with RepositoryCache.close(repo).
                }
            } finally {
                db.close();
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = repoManager.openRepository(project);
            try {
                Map<String, Ref> refs = repo.getAllRefs();
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } finally {
                repo.close();
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                        indexer.indexAsync(chg);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.indexAsync(c);
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(c);
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, boolean makeNew) {
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            Change change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            db.changeMessages().insert(Collections.singleton(msg));
            db.commit();
            indexer.indexAsync(change);
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, boolean makeNew) {
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    Change change = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            db.changeMessages().insert(Collections.singleton(msg));
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change);
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, Input input) throws BadRequestException, AuthException, ResourceConflictException, Exception {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to \"" + newTopicName + "\".";
        } else if (newTopicName.isEmpty()) {
            summary = "Topic \"" + oldTopicName + "\" removed.";
        } else {
            summary = String.format("Topic updated from \"%s\" to \"%s\".", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        indexer.indexAsync(change);
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.none() : newTopicName;
}
#method_after
@Override
public Object apply(ChangeResource req, Input input) throws BadRequestException, AuthException, ResourceConflictException, Exception {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to \"" + newTopicName + "\".";
        } else if (newTopicName.isEmpty()) {
            summary = "Topic \"" + oldTopicName + "\" removed.";
        } else {
            summary = String.format("Topic updated from \"%s\" to \"%s\".", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.none() : newTopicName;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException, UnprocessableEntityException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        dirty |= insertComments(revision, input.comments, input.drafts);
        dirty |= updateLabels(revision, input.labels);
        dirty |= insertMessage(revision, input.message);
        if (dirty) {
            db.changes().update(Collections.singleton(change));
            db.commit();
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change);
    } else {
        indexWrite = null;
    }
    if (input.notify.compareTo(NotifyHandling.NONE) > 0 && message != null) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
        fireCommentAddedHook(revision);
    }
    Output output = new Output();
    output.labels = input.labels;
    if (input.waitForCommit && dirty) {
        indexWrite.checkedGet();
    }
    return output;
}
#method_after
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException, UnprocessableEntityException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        dirty |= insertComments(revision, input.comments, input.drafts);
        dirty |= updateLabels(revision, input.labels);
        dirty |= insertMessage(revision, input.message);
        if (dirty) {
            db.changes().update(Collections.singleton(change));
            db.commit();
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change);
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (input.notify.compareTo(NotifyHandling.NONE) > 0 && message != null) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
        fireCommentAddedHook(revision);
    }
    Output output = new Output();
    output.labels = input.labels;
    if (input.waitForCommit) {
        indexWrite.checkedGet();
    }
    return output;
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            if (indexes != null) {
                for (ChangeIndex i : indexes.getWriteIndexes()) {
                    apply(i, cd);
                }
            } else {
                apply(index, cd);
            }
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    Provider<ReviewDb> db = dbRef.get();
                    if (db == null) {
                        try {
                            db = Providers.of(schemaFactory.open());
                        } catch (OrmException e) {
                            ProvisionException pe = new ProvisionException("error opening ReviewDb");
                            pe.initCause(e);
                            throw pe;
                        }
                        dbRef.set(db);
                    }
                    return db;
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            if (indexes != null) {
                for (ChangeIndex i : indexes.getWriteIndexes()) {
                    apply(i, cd);
                }
            } else {
                apply(index, cd);
            }
            return null;
        } finally {
            context.setContext(null);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#end_block

#method_before
private SafeHtml formatList(JsArrayString l) {
    SafeHtmlBuilder sb = new SafeHtmlBuilder();
    int size = l.length();
    for (int i = 0; i < size; i++) {
        sb.openSpan().addStyleName(style.includedInElement()).append(l.get(i)).closeSpan();
        if (i < size - 1) {
            sb.append(", ");
        }
    }
    return sb;
}
#method_after
private SafeHtml formatList(JsArrayString l) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    int size = l.length();
    for (int i = 0; i < size; i++) {
        html.openSpan().addStyleName(style.includedInElement()).append(l.get(i)).closeSpan();
        if (i < size - 1) {
            html.append(", ");
        }
    }
    return html;
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status().isClosed()) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id()).append(r._number());
    if (r.has_draft_comments()) {
        sb.append(" ...");
    }
    if (r.draft()) {
        sb.append(" ").append(Resources.C.draft());
    }
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#method_after
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id()).append(r._number());
    if (r.draft()) {
        sb.append(" ").append(Resources.C.draft());
    }
    if (r.has_draft_comments()) {
        sb.append(" ").openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan();
    }
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change(db).currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(db), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        boolean hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext();
        out.draftComments = hasDraftComments ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change(db).currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(db), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
public boolean canCreate(Repository repo, RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && canReadCommit(repo, rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public void insert(final Widget i, int beforeIndex) {
    if (body.getWidgetCount() > 0 && body.getWidgetCount() == beforeIndex) {
        add(i);
        return;
    }
    body.insert(i, beforeIndex);
}
#method_after
public void insert(final Widget i, int beforeIndex) {
    if (body.getWidgetCount() == 0 || body.getWidgetCount() <= beforeIndex) {
        add(i);
        return;
    }
    body.insert(i, beforeIndex);
}
#end_block

