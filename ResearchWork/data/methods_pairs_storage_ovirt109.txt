870
#method_before
Grid createRow(final HostVLan hostVLan) {
    // Check box, icon and name
    HorizontalPanel checkboxPanel = new HorizontalPanel();
    // $NON-NLS-1$
    checkboxPanel.setWidth("100%");
    if (isSelectionAvailable) {
        checkboxPanel.add(getCheckBox());
    }
    checkboxPanel.add(new Image(resources.splitRotateImage()));
    checkboxPanel.add(new Label(new HostVLanNameRenderer().render(hostVLan)));
    Grid row = createVlanRowColumn(checkboxPanel, hostVLan.getInterface().getIsManagement(), hostVLan.getNetworkName(), new Label(hostVLan.getAddress()));
    Style gridStyle = row.getElement().getStyle();
    // $NON-NLS-1$
    gridStyle.setBorderColor("white");
    gridStyle.setBorderWidth(1, Unit.PX);
    gridStyle.setBorderStyle(BorderStyle.SOLID);
    return row;
}
#method_after
Grid createRow(final HostVLan hostVLan) {
    // Check box, icon and name
    HorizontalPanel checkboxPanel = new HorizontalPanel();
    // $NON-NLS-1$
    checkboxPanel.setWidth("100%");
    if (isSelectionAvailable) {
        checkboxPanel.add(getCheckBox());
    }
    checkboxPanel.add(new Image(resources.splitRotateImage()));
    checkboxPanel.add(new Label(new HostVLanNameRenderer().render(hostVLan)));
    Grid row = createBaseVlanRow(checkboxPanel, hostVLan.getInterface().getIsManagement(), hostVLan.getNetworkName(), hostVLan.getAddress());
    Style gridStyle = row.getElement().getStyle();
    // $NON-NLS-1$
    gridStyle.setBorderColor("white");
    gridStyle.setBorderWidth(1, Unit.PX);
    gridStyle.setBorderStyle(BorderStyle.SOLID);
    return row;
}
#end_block

#method_before
Grid createBlankRow(final HostInterfaceLineModel lineModel) {
    return createVlanRowColumn(new Label(), lineModel.getIsManagement(), lineModel.getNetworkName(), new Label(lineModel.getAddress()));
}
#method_after
Grid createBlankRow(final HostInterfaceLineModel lineModel) {
    return createBaseVlanRow(new Label(), lineModel.getIsManagement(), lineModel.getNetworkName(), lineModel.getAddress());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVdsId(getParameters().getVdsId());
    VdsActionParameters vdsActionParams = new VdsActionParameters(getVdsId());
    boolean succeeded = runInternalAction(VdcActionType.RefreshHostCapabilities, vdsActionParams).getSucceeded();
    if (succeeded) {
        succeeded = runInternalAction(VdcActionType.RefreshHostDevices, vdsActionParams).getSucceeded();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeCommand() {
    VdsActionParameters vdsActionParams = new VdsActionParameters(getVdsId());
    if (!runInternalAction(VdcActionType.RefreshHostCapabilities, vdsActionParams).getSucceeded()) {
        return;
    }
    if (!runInternalAction(VdcActionType.RefreshHostDevices, vdsActionParams).getSucceeded()) {
        return;
    }
    setSucceeded(true);
}
#end_block

#method_before
protected void executeImport(ImportVmFromExportDomainModel importVmModel) {
    importVmModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            VmListModel.this.setWindow(null);
        }
    }, cloneObjectMap);
}
#method_after
protected void executeImport(ImportVmFromExportDomainModel importVmModel) {
    importVmModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            setWindow(null);
        }
    }, cloneObjectMap);
}
#end_block

#method_before
public void init() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (VDS vds : vdsDao.getAll()) {
        // will have their devices refreshed in InitVdsOnUpCommand
        if (vds.getStatus().equals(VDSStatus.Up)) {
            parameters.add(new VdsActionParameters(vds.getId()));
        }
    }
    backend.runInternalMultipleActions(VdcActionType.RefreshHostDevices, parameters);
}
#method_after
public void init() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    // will have their devices refreshed in InitVdsOnUpCommand
    for (Guid hostId : hostDynamicDao.getIdsOfHostsWithStatus(VDSStatus.Up)) {
        parameters.add(new VdsActionParameters(hostId));
    }
    backend.runInternalMultipleActions(VdcActionType.RefreshHostDevices, parameters);
}
#end_block

#method_before
public void init() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    for (VDS vds : vdsDao.getAll()) {
        // will have their devices refreshed in InitVdsOnUpCommand
        if (vds.getStatus().equals(VDSStatus.Up)) {
            parameters.add(new VdsActionParameters(vds.getId()));
        }
    }
    backend.runInternalMultipleActions(VdcActionType.RefreshHostDevices, parameters);
    cleanupDownVmsFromDeviceTable();
}
#method_after
public void init() {
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<>();
    // will have their devices refreshed in InitVdsOnUpCommand
    for (Guid hostId : hostDynamicDao.getIdsOfHostsWithStatus(VDSStatus.Up)) {
        parameters.add(new VdsActionParameters(hostId));
    }
    backend.runInternalMultipleActions(VdcActionType.RefreshHostDevices, parameters);
    hostDeviceDao.cleanDownVms();
}
#end_block

#method_before
@Override
public List<Guid> getIdsOfHostsWithStatus(VDSStatus status) {
    return getCallsHandler().executeReadList("getIdsOfHostsWithStatus", createGuidMapper(), getCustomMapSqlParameterSource().addValue("status", status.getValue()));
}
#method_after
@Override
public List<Guid> getIdsOfHostsWithStatus(VDSStatus status) {
    return getCallsHandler().executeReadList("GetIdsOfHostsWithStatus", createGuidMapper(), getCustomMapSqlParameterSource().addValue("status", status.getValue()));
}
#end_block

#method_before
@Override
public NonOperationalReason persistAndEnforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<VdsNetworkInterface> userConfiguredNics) {
    List<VdsNetworkInterface> dbIfaces = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(host.getId());
    List<Network> clusterNetworks = DbFacade.getInstance().getNetworkDao().getAllForCluster(host.getVdsGroupId());
    persistTopology(host.getInterfaces(), dbIfaces, userConfiguredNics);
    NonOperationalReason nonOperationalReason = enforceNetworkCompliance(host, skipManagementNetwork, clusterNetworks);
    auditNetworkCompliance(host, dbIfaces, clusterNetworks);
    return nonOperationalReason;
}
#method_after
@Override
public NonOperationalReason persistAndEnforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<VdsNetworkInterface> userConfiguredNics) {
    List<VdsNetworkInterface> dbIfaces = interfaceDao.getAllInterfacesForVds(host.getId());
    List<Network> clusterNetworks = networkDao.getAllForCluster(host.getVdsGroupId());
    persistTopology(host.getInterfaces(), dbIfaces, userConfiguredNics);
    NonOperationalReason nonOperationalReason = enforceNetworkCompliance(host, skipManagementNetwork, clusterNetworks);
    auditNetworkCompliance(host, dbIfaces, clusterNetworks);
    return nonOperationalReason;
}
#end_block

#method_before
private NonOperationalReason enforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<Network> clusterNetworks) {
    if (host.getStatus() != VDSStatus.Maintenance) {
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(host.getInterfaces(), clusterNetworks);
        }
        Map<String, String> customLogValues;
        // here we check if the host networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
    }
    return NonOperationalReason.NONE;
}
#method_after
private NonOperationalReason enforceNetworkCompliance(VDS host, boolean skipManagementNetwork, List<Network> clusterNetworks) {
    if (host.getStatus() != VDSStatus.Maintenance) {
        if (skipManagementNetwork) {
            skipManagementNetworkCheck(host.getInterfaces(), clusterNetworks, host.getVdsGroupId());
        }
        Map<String, String> customLogValues;
        // here we check if the host networks match it's cluster networks
        String networks = getMissingOperationalClusterNetworks(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.NETWORK_UNREACHABLE, customLogValues);
            return NonOperationalReason.NETWORK_UNREACHABLE;
        }
        // Check that VM networks are implemented above a bridge.
        networks = getVmNetworksImplementedAsBridgeless(host, clusterNetworks);
        if (networks.length() > 0) {
            customLogValues = new HashMap<String, String>();
            customLogValues.put("Networks", networks);
            setNonOperational(host, NonOperationalReason.VM_NETWORK_IS_BRIDGELESS, customLogValues);
            return NonOperationalReason.VM_NETWORK_IS_BRIDGELESS;
        }
    }
    return NonOperationalReason.NONE;
}
#end_block

#method_before
private void skipManagementNetworkCheck(List<VdsNetworkInterface> ifaces, List<Network> clusterNetworks) {
    String managementNetworkName = NetworkUtils.getEngineNetwork();
    for (VdsNetworkInterface iface : ifaces) {
        if (managementNetworkName.equals(iface.getNetworkName())) {
            return;
        }
    }
    for (Iterator<Network> iterator = clusterNetworks.iterator(); iterator.hasNext(); ) {
        Network network = iterator.next();
        if (managementNetworkName.equals(network.getName())) {
            iterator.remove();
            break;
        }
    }
}
#method_after
private void skipManagementNetworkCheck(List<VdsNetworkInterface> ifaces, List<Network> clusterNetworks, Guid clusterId) {
    final Network managementNetwork = managementNetworkUtil.getManagementNetwork(clusterId);
    final String managementNetworkName = managementNetwork.getName();
    for (VdsNetworkInterface iface : ifaces) {
        if (managementNetworkName.equals(iface.getNetworkName())) {
            return;
        }
    }
    for (Iterator<Network> iterator = clusterNetworks.iterator(); iterator.hasNext(); ) {
        Network network = iterator.next();
        if (managementNetworkName.equals(network.getName())) {
            iterator.remove();
            break;
        }
    }
}
#end_block

#method_before
private void logChangedDisplayNetwork(VDS host, Collection<Network> engineHostNetworks, Collection<VdsNetworkInterface> engineInterfaces) {
    if (isVmRunningOnHost(host.getId())) {
        final Network engineDisplayNetwork = findDisplayNetwork(engineHostNetworks);
        if (engineDisplayNetwork == null) {
            return;
        }
        final IsNetworkOnInterfacePredicate isNetworkOnInterfacePredicate = new IsNetworkOnInterfacePredicate(engineDisplayNetwork.getName());
        final VdsNetworkInterface vdsmDisplayInterface = LinqUtils.firstOrNull(host.getInterfaces(), isNetworkOnInterfacePredicate);
        final VdsNetworkInterface engineDisplayInterface = LinqUtils.firstOrNull(engineInterfaces, isNetworkOnInterfacePredicate);
        final DisplayInterfaceEqualityPredicate displayIneterfaceEqualityPredicate = new DisplayInterfaceEqualityPredicate(engineDisplayInterface);
        if (// the display interface is't on host anymore
        vdsmDisplayInterface == null || !displayIneterfaceEqualityPredicate.eval(vdsmDisplayInterface)) {
            final AuditLogableBase loggable = new AuditLogableBase(host.getId());
            AuditLogDirector.log(loggable, AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_HOST_WITH_ACTIVE_VM);
        }
    }
}
#method_after
private void logChangedDisplayNetwork(VDS host, Collection<Network> engineHostNetworks, Collection<VdsNetworkInterface> engineInterfaces) {
    if (isVmRunningOnHost(host.getId())) {
        final Network engineDisplayNetwork = findDisplayNetwork(host.getVdsGroupId(), engineHostNetworks);
        if (engineDisplayNetwork == null) {
            return;
        }
        final IsNetworkOnInterfacePredicate isNetworkOnInterfacePredicate = new IsNetworkOnInterfacePredicate(engineDisplayNetwork.getName());
        final VdsNetworkInterface vdsmDisplayInterface = LinqUtils.firstOrNull(host.getInterfaces(), isNetworkOnInterfacePredicate);
        final VdsNetworkInterface engineDisplayInterface = LinqUtils.firstOrNull(engineInterfaces, isNetworkOnInterfacePredicate);
        final DisplayInterfaceEqualityPredicate displayIneterfaceEqualityPredicate = new DisplayInterfaceEqualityPredicate(engineDisplayInterface);
        if (// the display interface is't on host anymore
        vdsmDisplayInterface == null || !displayIneterfaceEqualityPredicate.eval(vdsmDisplayInterface)) {
            final AuditLogableBase loggable = new AuditLogableBase(host.getId());
            auditLogDirector.log(loggable, AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_HOST_WITH_ACTIVE_VM);
        }
    }
}
#end_block

#method_before
private boolean isVmRunningOnHost(Guid hostId) {
    return !DbFacade.getInstance().getVmDynamicDao().getAllRunningForVds(hostId).isEmpty();
}
#method_after
private boolean isVmRunningOnHost(Guid hostId) {
    return !vmDynamicDao.getAllRunningForVds(hostId).isEmpty();
}
#end_block

#method_before
private Network findDisplayNetwork(Collection<Network> networks) {
    Network managementNetwork = null;
    for (Network network : networks) {
        if (network.getCluster().isDisplay()) {
            return network;
        }
        if (NetworkUtils.isManagementNetwork(network)) {
            managementNetwork = network;
        }
    }
    return managementNetwork;
}
#method_after
private Network findDisplayNetwork(Guid clusterId, Collection<Network> networks) {
    Network managementNetwork = null;
    for (Network network : networks) {
        if (network.getCluster().isDisplay()) {
            return network;
        }
        if (managementNetworkUtil.isManagementNetwork(network.getId(), clusterId)) {
            managementNetwork = network;
        }
    }
    return managementNetwork;
}
#end_block

#method_before
private void logUnsynchronizedNetworks(VDS host, Map<String, Network> networks) {
    List<String> networkNames = new ArrayList<>();
    HostNetworkQosDao qosDao = DbFacade.getInstance().getHostNetworkQosDao();
    for (VdsNetworkInterface iface : host.getInterfaces()) {
        Network network = networks.get(iface.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, network == null ? null : qosDao.get(network.getQosId()), iface);
        if (networkImplementationDetails != null && !networkImplementationDetails.isInSync() && networkImplementationDetails.isManaged()) {
            networkNames.add(iface.getNetworkName());
        }
    }
    if (!networkNames.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase(host.getId());
        logable.addCustomValue("Networks", StringUtils.join(networkNames, ","));
        AuditLogDirector.log(logable, AuditLogType.VDS_NETWORKS_OUT_OF_SYNC);
    }
}
#method_after
private void logUnsynchronizedNetworks(VDS host, Map<String, Network> networks) {
    List<String> networkNames = new ArrayList<>();
    for (VdsNetworkInterface iface : host.getInterfaces()) {
        Network network = networks.get(iface.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, network == null ? null : hostNetworkQosDao.get(network.getQosId()), iface);
        if (networkImplementationDetails != null && !networkImplementationDetails.isInSync() && networkImplementationDetails.isManaged()) {
            networkNames.add(iface.getNetworkName());
        }
    }
    if (!networkNames.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase(host.getId());
        logable.addCustomValue("Networks", StringUtils.join(networkNames, ","));
        auditLogDirector.log(logable, AuditLogType.VDS_NETWORKS_OUT_OF_SYNC);
    }
}
#end_block

#method_before
private void persistTopology(List<VdsNetworkInterface> reportedNics, List<VdsNetworkInterface> dbNics, List<VdsNetworkInterface> userConfiguredNics) {
    final HostNetworkInterfacesPersister networkInterfacesPersister = new HostNetworkInterfacesPersisterImpl(DbFacade.getInstance().getInterfaceDao(), reportedNics, dbNics, userConfiguredNics);
    networkInterfacesPersister.persistTopology();
}
#method_after
private void persistTopology(List<VdsNetworkInterface> reportedNics, List<VdsNetworkInterface> dbNics, List<VdsNetworkInterface> userConfiguredNics) {
    final HostNetworkInterfacesPersister networkInterfacesPersister = new HostNetworkInterfacesPersisterImpl(interfaceDao, reportedNics, dbNics, userConfiguredNics);
    networkInterfacesPersister.persistTopology();
}
#end_block

#method_before
private String getMissingOperationalClusterNetworks(VDS host, List<Network> clusterNetworks) {
    List<String> networkNames = new ArrayList<>();
    for (Network net : clusterNetworks) {
        if (net.getCluster().getStatus() == OPERATIONAL && net.getCluster().isRequired() && !host.getNetworks().contains(net.getName())) {
            networkNames.add(net.getName());
        }
    }
    return StringUtils.join(networkNames, ",");
}
#method_after
private String getMissingOperationalClusterNetworks(VDS host, List<Network> clusterNetworks) {
    List<String> networkNames = new ArrayList<>();
    for (Network net : clusterNetworks) {
        if (net.getCluster().getStatus() == OPERATIONAL && net.getCluster().isRequired() && !host.getNetworkNames().contains(net.getName())) {
            networkNames.add(net.getName());
        }
    }
    return StringUtils.join(networkNames, ",");
}
#end_block

#method_before
private void setNonOperational(VDS host, NonOperationalReason reason, Map<String, String> customLogValues) {
    ResourceManager.getInstance().getEventListener().vdsNonOperational(host.getId(), reason, true, Guid.Empty, customLogValues);
}
#method_after
private void setNonOperational(VDS host, NonOperationalReason reason, Map<String, String> customLogValues) {
    resourceManager.getEventListener().vdsNonOperational(host.getId(), reason, true, Guid.Empty, customLogValues);
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                AuditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static double computeInterfaceUsage(VdsNetworkInterface iface) {
    return Math.max(truncatePercentage(iface.getStatistics().getReceiveRate()), truncatePercentage(iface.getStatistics().getTransmitRate()));
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = truncatePercentage(iface.getStatistics().getReceiveRate());
    Double transmitRate = truncatePercentage(iface.getStatistics().getTransmitRate());
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static double truncatePercentage(double value) {
    return Math.min(100, value);
}
#method_after
private static Double truncatePercentage(Double value) {
    return value == null ? null : Math.min(100, value);
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode node = buildVdsNumaNodeStatistics(percentageFormatter, item);
            vdsNumaNodes.add(node);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Double returnValue = null;
    if (input.containsKey(name)) {
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        returnValue = (stringValue == null) ? null : Double.parseDouble(stringValue);
    }
    return returnValue;
}
#method_after
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Object value = input.get(name);
    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        return Double.parseDouble((String) value);
    }
    return null;
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Object> bridges = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            String networkName = entry.getKey();
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                VdsNetworkInterface networkIface = vdsInterfaces.get(interfaceName);
                Map<String, Object> bridge = (bridges == null) ? null : (Map<String, Object>) bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                String addr = extractAddress(network);
                String subnet = extractSubnet(network);
                String gateway = (String) network.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, bridgesReported, networkIface, bridgesReported ? bridge : network);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(network, vds, iface);
                    }
                }
                vds.getNetworks().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> network = entry.getValue();
            String networkName = entry.getKey();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                String addr = extractAddress(network);
                String subnet = extractSubnet(network);
                String gateway = (String) network.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridges) : findBridgedNetworkInterfaces(network, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(network, vds, iface);
                    }
                }
                vds.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, boolean bridgesReported, VdsNetworkInterface iface, Map<String, Object> entry) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    if (bridgesReported) {
        if (iface == null) {
            if (entry != null) {
                interfaces.addAll(findBridgedNetworkInterfaces(entry, vdsInterfaces));
            }
        } else {
            interfaces.add(iface);
        }
    } else {
        interfaces.addAll(findBridgedNetworkInterfaces(entry, vdsInterfaces));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Map<String, Object>> bridges) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridges != null) {
            Map<String, Object> bridgeProperties = bridges.get(interfaceName);
            if (bridgeProperties != null) {
                interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
            }
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nic = (Map<String, Object>) entry.getValue();
            if (nic != null) {
                if (nic.get("speed") != null) {
                    Object speed = nic.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nic.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nic.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS vds, Entry<String, Object> entry) {
    iface.setName(entry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(vds.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(vds.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nic = (Map<String, Object>) entry.getValue();
    if (nic != null) {
        iface.setAddress(extractAddress(nic));
        iface.setSubnet(extractSubnet(nic));
        String mtu = (String) nic.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), vds, iface);
    }
}
#method_after
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setAddress(extractAddress(nicProperties));
        iface.setSubnet(extractSubnet(nicProperties));
        String mtu = (String) nicProperties.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol((Map<String, Object>) nicProperties.get("cfg"), host, iface);
    }
}
#end_block

#method_before
private static String extractAddress(Map<String, Object> nic) {
    return (String) nic.get("addr");
}
#method_after
private static String extractAddress(Map<String, Object> properties) {
    return (String) properties.get("addr");
}
#end_block

#method_before
private static String extractSubnet(Map<String, Object> nic) {
    return (String) nic.get("netmask");
}
#method_after
private static String extractSubnet(Map<String, Object> properties) {
    return (String) properties.get("netmask");
}
#end_block

#method_before
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || NetworkUtils.getEngineNetwork().equals(iface.getNetworkName()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (vdsStatic == null ? 0 : vdsStatic.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (spmStatus == null ? 0 : spmStatus.hashCode());
    result = prime * result + (imagesLastCheck == null ? 0 : imagesLastCheck.hashCode());
    result = prime * result + (imagesLastDelay == null ? 0 : imagesLastDelay.hashCode());
    result = prime * result + (interfaces == null ? 0 : interfaces.hashCode());
    result = prime * result + (networks == null ? 0 : networks.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (privateDomains == null ? 0 : privateDomains.hashCode());
    result = prime * result + (vdsSpmId == null ? 0 : vdsSpmId.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (vdsGroupCompatibilityVersion == null ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + (vdsGroupCpuName == null ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + (vdsGroupDescription == null ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + (vdsGroupName == null ? 0 : vdsGroupName.hashCode());
    result = prime * result + (vdsGroupVirtService == null ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + (vdsGroupGlusterService == null ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (vdsStatic == null ? 0 : vdsStatic.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (spmStatus == null ? 0 : spmStatus.hashCode());
    result = prime * result + (imagesLastCheck == null ? 0 : imagesLastCheck.hashCode());
    result = prime * result + (imagesLastDelay == null ? 0 : imagesLastDelay.hashCode());
    result = prime * result + (interfaces == null ? 0 : interfaces.hashCode());
    result = prime * result + (networkNames == null ? 0 : networkNames.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (privateDomains == null ? 0 : privateDomains.hashCode());
    result = prime * result + (vdsSpmId == null ? 0 : vdsSpmId.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (vdsGroupCompatibilityVersion == null ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + (vdsGroupCpuName == null ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + (vdsGroupDescription == null ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + (vdsGroupName == null ? 0 : vdsGroupName.hashCode());
    result = prime * result + (vdsGroupVirtService == null ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + (vdsGroupGlusterService == null ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDS)) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(vdsStatic, other.vdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && spmStatus == other.spmStatus && ObjectUtils.objectsEqual(imagesLastCheck, other.imagesLastCheck) && ObjectUtils.objectsEqual(imagesLastDelay, other.imagesLastDelay) && ObjectUtils.objectsEqual(interfaces, other.interfaces) && ObjectUtils.objectsEqual(networks, other.networks) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDS)) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(vdsStatic, other.vdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && spmStatus == other.spmStatus && ObjectUtils.objectsEqual(imagesLastCheck, other.imagesLastCheck) && ObjectUtils.objectsEqual(imagesLastDelay, other.imagesLastDelay) && ObjectUtils.objectsEqual(interfaces, other.interfaces) && ObjectUtils.objectsEqual(networkNames, other.networkNames) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    return vds;
}
#end_block

#method_before
public void setVdsName(String value) {
    vdsStatic.setVdsName(value);
}
#method_after
public void setVdsName(String value) {
    vdsStatic.setName(value);
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                AuditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static double computeInterfaceUsage(VdsNetworkInterface iface) {
    return Math.max(truncatePercentage(iface.getStatistics().getReceiveRate()), truncatePercentage(iface.getStatistics().getTransmitRate()));
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = truncatePercentage(iface.getStatistics().getReceiveRate());
    Double transmitRate = truncatePercentage(iface.getStatistics().getTransmitRate());
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static double truncatePercentage(double value) {
    return Math.min(100, value);
}
#method_after
private static Double truncatePercentage(Double value) {
    return value == null ? null : Math.min(100, value);
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode node = buildVdsNumaNodeStatistics(percentageFormatter, item);
            vdsNumaNodes.add(node);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Double returnValue = null;
    if (input.containsKey(name)) {
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        returnValue = (stringValue == null) ? null : Double.parseDouble(stringValue);
    }
    return returnValue;
}
#method_after
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Object value = input.get(name);
    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        return Double.parseDouble((String) value);
    }
    return null;
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nic = (Map<String, Object>) entry.getValue();
            if (nic != null) {
                if (nic.get("speed") != null) {
                    Object speed = nic.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nic.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nic.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS vds, Entry<String, Object> entry) {
    iface.setName(entry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(vds.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(vds.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nic = (Map<String, Object>) entry.getValue();
    if (nic != null) {
        iface.setAddress((String) nic.get("addr"));
        iface.setSubnet((String) nic.get("netmask"));
        String mtu = (String) nic.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), vds, iface);
    }
}
#method_after
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setAddress((String) nicProperties.get("addr"));
        iface.setSubnet((String) nicProperties.get("netmask"));
        String mtu = (String) nicProperties.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol((Map<String, Object>) nicProperties.get("cfg"), host, iface);
    }
}
#end_block

#method_before
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(network);
        iface.setQos(qosMapper.deserialize());
    }
}
#method_after
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        // set the management ip
        if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(network);
        iface.setQos(qosMapper.deserialize());
    }
}
#end_block

#method_before
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || NetworkUtils.getEngineNetwork().equals(iface.getNetworkName()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                AuditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static double computeInterfaceUsage(VdsNetworkInterface iface) {
    return Math.max(truncatePercentage(iface.getStatistics().getReceiveRate()), truncatePercentage(iface.getStatistics().getTransmitRate()));
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = truncatePercentage(iface.getStatistics().getReceiveRate());
    Double transmitRate = truncatePercentage(iface.getStatistics().getTransmitRate());
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static double truncatePercentage(double value) {
    return Math.min(100, value);
}
#method_after
private static Double truncatePercentage(Double value) {
    return value == null ? null : Math.min(100, value);
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode node = buildVdsNumaNodeStatistics(percentageFormatter, item);
            vdsNumaNodes.add(node);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Double returnValue = null;
    if (input.containsKey(name)) {
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        returnValue = (stringValue == null) ? null : Double.parseDouble(stringValue);
    }
    return returnValue;
}
#method_after
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Object value = input.get(name);
    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        return Double.parseDouble((String) value);
    }
    return null;
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Object> bridges = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                VdsNetworkInterface networkIface = vdsInterfaces.get(interfaceName);
                Map<String, Object> bridge = (bridges == null) ? null : (Map<String, Object>) bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, bridgesReported, networkIface, bridgesReported ? bridge : network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, bridgedNetwork, qos, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> network = entry.getValue();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridges) : findBridgedNetworkInterfaces(network, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, bridgedNetwork, qos, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, boolean bridgesReported, VdsNetworkInterface iface, Map<String, Object> entry) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    if (bridgesReported) {
        if (iface == null) {
            if (entry != null) {
                interfaces.addAll(findBridgedNetworkInterfaces(entry, vdsInterfaces));
            }
        } else {
            interfaces.add(iface);
        }
    } else {
        interfaces.addAll(findBridgedNetworkInterfaces(entry, vdsInterfaces));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Map<String, Object>> bridges) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridges != null) {
            Map<String, Object> bridgeProperties = bridges.get(interfaceName);
            if (bridgeProperties != null) {
                interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
            }
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nic = (Map<String, Object>) entry.getValue();
            if (nic != null) {
                if (nic.get("speed") != null) {
                    Object speed = nic.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nic.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nic.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS vds, Entry<String, Object> entry) {
    iface.setName(entry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(vds.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(vds.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nic = (Map<String, Object>) entry.getValue();
    if (nic != null) {
        iface.setAddress((String) nic.get("addr"));
        iface.setSubnet((String) nic.get("netmask"));
        String mtu = (String) nic.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol((Map<String, Object>) nic.get("cfg"), vds, iface);
    }
}
#method_after
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setAddress((String) nicProperties.get("addr"));
        iface.setSubnet((String) nicProperties.get("netmask"));
        String mtu = (String) nicProperties.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol((Map<String, Object>) nicProperties.get("cfg"), host, iface);
    }
}
#end_block

#method_before
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Object> network, boolean bridgedNetwork, HostNetworkQos qos, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        iface.setQos(qos);
    }
}
#method_after
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Object> network, boolean bridgedNetwork, HostNetworkQos qos, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        // set the management ip
        if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
        iface.setQos(qos);
    }
}
#end_block

#method_before
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || NetworkUtils.getEngineNetwork().equals(iface.getNetworkName()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    ImagesHandler.updateImageStatus(getDiskId(), ImageStatus.ILLEGAL);
    onFinish(cmdId);
}
#method_after
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    ImagesHandler.updateImageStatus(getDiskId(), ImageStatus.ILLEGAL);
    getCommand().getParameters().setTaskGroupSuccess(false);
    onFinish(cmdId);
}
#end_block

#method_before
@Override
public void setVmIdOnVfs(Guid hostId, Guid vmId, final Set<String> vfsNames) {
    List<HostDevice> hostDevices = hostDeviceDao.getHostDevicesByHostId(hostId);
    List<HostDevice> vfs = LinqUtils.filter(hostDevices, new Predicate<HostDevice>() {

        @Override
        public boolean eval(HostDevice device) {
            return vfsNames.contains(device.getDeviceName()) && isVf(device);
        }
    });
    setVmIdOnVfsDevices(hostId, vmId, new HashSet<HostDevice>(vfs));
}
#method_after
@Override
public void setVmIdOnVfs(Guid hostId, Guid vmId, final Set<String> vfsNames) {
    List<HostDevice> hostDevices = hostDeviceDao.getHostDevicesByHostId(hostId);
    List<HostDevice> vfs = LinqUtils.filter(hostDevices, new Predicate<HostDevice>() {

        @Override
        public boolean eval(HostDevice device) {
            return vfsNames.contains(device.getDeviceName());
        }
    });
    setVmIdOnVfsDevices(hostId, vmId, new HashSet<HostDevice>(vfs));
}
#end_block

#method_before
private void setVmIdOnVfsDevices(Guid hostId, final Guid vmId, final Set<HostDevice> vfs) {
    for (HostDevice vf : vfs) {
        hostDeviceDao.setVmIdOnHostDevice(vf.getId(), vmId);
    }
}
#method_after
private void setVmIdOnVfsDevices(Guid hostId, Guid vmId, Set<HostDevice> vfs) {
    for (HostDevice vf : vfs) {
        hostDeviceDao.setVmIdOnHostDevice(vf.getId(), vmId);
    }
}
#end_block

#method_before
private List<HostDevice> mockVfsOnNetDevice(int numOfVfs) {
    return mockVfsOnNetDevice(numOfVfs, null);
}
#method_after
private List<HostDevice> mockVfsOnNetDevice(int numOfVfs) {
    List<HostDevice> vfs = new ArrayList<>();
    for (int i = 0; i < numOfVfs; ++i) {
        HostDevice vfPciDevice = new HostDevice();
        vfPciDevice.setParentPhysicalFunction(pciDevice.getDeviceName());
        vfPciDevice.setDeviceName(String.valueOf(i));
        vfPciDevice.setHostId(HOST_ID);
        vfs.add(vfPciDevice);
    }
    return vfs;
}
#end_block

#method_before
private void mockHostDevices(List<HostDevice> extraDevices) {
    List<HostDevice> devices = new ArrayList<>();
    devices.add(pciDevice);
    devices.add(netDevice);
    devices.addAll(extraDevices);
    when(hostDeviceDao.getHostDevicesByHostId(HOST_ID)).thenReturn(devices);
    when(hostDeviceDao.getAll()).thenReturn(devices);
}
#method_after
private void mockHostDevices(List<HostDevice> extraDevices) {
    List<HostDevice> devices = new ArrayList<>();
    devices.add(pciDevice);
    devices.add(netDevice);
    devices.addAll(extraDevices);
    when(hostDeviceDao.getHostDevicesByHostId(HOST_ID)).thenReturn(devices);
}
#end_block

#method_before
@Override
public HostDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    HostDevice device = new HostDevice();
    device.setHostId(getGuid(rs, "host_id"));
    device.setDeviceName(rs.getString("device_name"));
    device.setParentDeviceName(rs.getString("parent_device_name"));
    device.setCapability(rs.getString("capability"));
    device.setIommuGroup((Integer) rs.getObject("iommu_group"));
    device.setProductName(rs.getString("product_name"));
    device.setProductId(rs.getString("product_id"));
    device.setVendorName(rs.getString("vendor_name"));
    device.setVendorId(rs.getString("vendor_id"));
    device.setParentPhysicalFunction(rs.getString("physfn"));
    device.setTotalVirtualFunctions((Integer) rs.getObject("total_vfs"));
    device.setNetworkInterfaceName(rs.getString("net_iface_name"));
    device.setVmId(getGuid(rs, "vm_id"));
    return device;
}
#method_after
@Override
public HostDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    HostDevice device = new HostDevice();
    map(rs, device);
    return device;
}
#end_block

#method_before
public void setVolumeType(GlusterVolumeType volumeType) {
    this.volumeType = volumeType;
    if (!volumeType.isReplicatedType()) {
        setReplicaCount(0);
    }
    if (!volumeType.isStripedType()) {
        setStripeCount(0);
    }
}
#method_after
public void setVolumeType(GlusterVolumeType volumeType) {
    this.volumeType = volumeType;
    if (!volumeType.isReplicatedType()) {
        setReplicaCount(0);
    }
    if (!volumeType.isStripedType()) {
        setStripeCount(0);
    }
    if (!volumeType.isDispersedType()) {
        setDisperseCount(0);
        setRedundancyCount(0);
    }
}
#end_block

#method_before
public Boolean getIsGeoRepSlave() {
    return isGeoRepSlave;
}
#method_after
public Boolean getIsGeoRepSlave() {
    return getGeoRepMasterVolAndClusterName() != null;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((volumeType == null) ? 0 : volumeType.hashCode());
    result = prime * result + ((transportTypes == null) ? 0 : transportTypes.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((replicaCount == null) ? 0 : replicaCount.hashCode());
    result = prime * result + ((stripeCount == null) ? 0 : stripeCount.hashCode());
    result = prime * result + ((options == null) ? 0 : options.hashCode());
    result = prime * result + ((accessProtocols == null) ? 0 : accessProtocols.hashCode());
    result = prime * result + ((bricks == null) ? 0 : bricks.hashCode());
    result = prime * result + ((asyncTask == null) ? 0 : asyncTask.hashCode());
    result = prime * result + ((advancedDetails == null) ? 0 : advancedDetails.hashCode());
    result = prime * result + ((snapshotsCount == null) ? 0 : snapshotsCount.hashCode());
    result = prime * result + ((snapMaxLimit == null) ? 0 : snapMaxLimit.hashCode());
    result = prime * result + ((snapshotScheduled == null) ? 0 : snapshotScheduled.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((clusterId == null) ? 0 : clusterId.hashCode());
    result = prime * result + ((volumeType == null) ? 0 : volumeType.hashCode());
    result = prime * result + ((transportTypes == null) ? 0 : transportTypes.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((replicaCount == null) ? 0 : replicaCount.hashCode());
    result = prime * result + ((stripeCount == null) ? 0 : stripeCount.hashCode());
    result = prime * result + ((disperseCount == null) ? 0 : disperseCount.hashCode());
    result = prime * result + ((redundancyCount == null) ? 0 : redundancyCount.hashCode());
    result = prime * result + ((options == null) ? 0 : options.hashCode());
    result = prime * result + ((accessProtocols == null) ? 0 : accessProtocols.hashCode());
    result = prime * result + ((bricks == null) ? 0 : bricks.hashCode());
    result = prime * result + ((asyncTask == null) ? 0 : asyncTask.hashCode());
    result = prime * result + ((advancedDetails == null) ? 0 : advancedDetails.hashCode());
    result = prime * result + ((snapshotsCount == null) ? 0 : snapshotsCount.hashCode());
    result = prime * result + ((snapMaxLimit == null) ? 0 : snapMaxLimit.hashCode());
    result = prime * result + ((snapshotScheduled == null) ? 0 : snapshotScheduled.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) obj;
    if (!(clusterId.equals(volume.getClusterId()))) {
        return false;
    }
    if (!(name.equals(volume.getName()) && volumeType == volume.getVolumeType() && status == volume.getStatus() && ObjectUtils.objectsEqual(replicaCount, volume.getReplicaCount()) && ObjectUtils.objectsEqual(stripeCount, volume.getStripeCount()))) {
        return false;
    }
    if (!ListUtils.listsEqual(getOptions(), volume.getOptions())) {
        return false;
    }
    if (!ListUtils.listsEqual(accessProtocols, volume.getAccessProtocols())) {
        return false;
    }
    if (!ListUtils.listsEqual(transportTypes, volume.getTransportTypes())) {
        return false;
    }
    if (!ListUtils.listsEqual(bricks, volume.getBricks())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getAsyncTask(), volume.getAsyncTask())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getAdvancedDetails(), volume.getAdvancedDetails())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(snapshotsCount, volume.getSnapshotsCount())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(snapMaxLimit, volume.getSnapMaxLimit())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(snapshotScheduled, volume.getSnapshotScheduled())) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity volume = (GlusterVolumeEntity) obj;
    if (!(clusterId.equals(volume.getClusterId()))) {
        return false;
    }
    if (!(name.equals(volume.getName()) && volumeType == volume.getVolumeType() && status == volume.getStatus() && ObjectUtils.objectsEqual(replicaCount, volume.getReplicaCount()) && ObjectUtils.objectsEqual(stripeCount, volume.getStripeCount()) && ObjectUtils.objectsEqual(disperseCount, volume.getDisperseCount()) && ObjectUtils.objectsEqual(redundancyCount, volume.getRedundancyCount()))) {
        return false;
    }
    if (!ListUtils.listsEqual(getOptions(), volume.getOptions())) {
        return false;
    }
    if (!ListUtils.listsEqual(accessProtocols, volume.getAccessProtocols())) {
        return false;
    }
    if (!ListUtils.listsEqual(transportTypes, volume.getTransportTypes())) {
        return false;
    }
    if (!ListUtils.listsEqual(bricks, volume.getBricks())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getAsyncTask(), volume.getAsyncTask())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(getAdvancedDetails(), volume.getAdvancedDetails())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(snapshotsCount, volume.getSnapshotsCount())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(snapMaxLimit, volume.getSnapMaxLimit())) {
        return false;
    }
    if (!ObjectUtils.objectsEqual(snapshotScheduled, volume.getSnapshotScheduled())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    ImageResource img;
    if (volume.getIsGeoRepMaster()) {
        img = geoRepMasterImage;
    }
}
#method_after
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    if (volume.getIsGeoRepMaster()) {
        SafeHtml geoRepMasterHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(geoRepMasterImage).getHTML());
        sb.append(applicationTemplates.statusTemplate(geoRepMasterHtml, constants.geoRepMasterVolumeToolTip()));
    }
    if (volume.getIsGeoRepSlave()) {
        SafeHtml geoRepSlaveHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(geoRepSlaveImage).getHTML());
        String[] volClusterNames = formatVolClusterName(volume.getGeoRepMasterVolAndClusterName());
        String volName = volClusterNames[0];
        // $NON-NLS-1$
        String clusterName = volClusterNames.length == 2 ? volClusterNames[1] : "UNKNOWN";
        sb.append(applicationTemplates.statusTemplate(geoRepSlaveHtml, messages.geoRepSlaveVolumeToolTip(volName, clusterName)));
    }
}
#end_block

#method_before
@Override
public List<GlusterVolumeEntity> getAllWithQuery(String query) {
    List<GlusterVolumeEntity> volumes = jdbcTemplate.query(query, volumeRowMapper);
    fetchRelatedEntities(volumes);
    return volumes;
}
#method_after
@Override
public List<GlusterVolumeEntity> getAllWithQuery(String query) {
    List<GlusterVolumeEntity> volumes = getJdbcTemplate().query(query, volumeRowMapper);
    fetchRelatedEntities(volumes);
    return volumes;
}
#end_block

#method_before
private void insertVolumeBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getVolumeId() == null) {
            brick.setVolumeId(volume.getId());
        }
        dbFacade.getGlusterBrickDao().save(brick);
    }
}
#method_after
private void insertVolumeBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getVolumeId() == null) {
            brick.setVolumeId(volume.getId());
        }
        glusterBrickDao.save(brick);
    }
}
#end_block

#method_before
private void insertVolumeOptions(GlusterVolumeEntity volume) {
    Collection<GlusterVolumeOptionEntity> options = volume.getOptions();
    for (GlusterVolumeOptionEntity option : options) {
        if (option.getVolumeId() == null) {
            option.setVolumeId(volume.getId());
        }
        dbFacade.getGlusterOptionDao().save(option);
    }
}
#method_after
private void insertVolumeOptions(GlusterVolumeEntity volume) {
    Collection<GlusterVolumeOptionEntity> options = volume.getOptions();
    for (GlusterVolumeOptionEntity option : options) {
        if (option.getVolumeId() == null) {
            option.setVolumeId(volume.getId());
        }
        glusterOptionDao.save(option);
    }
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        GlusterVolumeAdvancedDetails advancedDetails = fetchAdvancedDatails(volume.getId());
        if (advancedDetails != null) {
            volume.setAdvancedDetails(advancedDetails);
        }
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
        GlusterVolumeSnapshotConfig config = dbFacade.getGlusterVolumeSnapshotConfigDao().getConfigByVolumeIdAndName(volume.getClusterId(), volume.getId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        if (config == null || StringUtils.isEmpty(config.getParamValue())) {
            config = dbFacade.getGlusterVolumeSnapshotConfigDao().getConfigByClusterIdAndName(volume.getClusterId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        }
        volume.setSnapMaxLimit(config != null ? Integer.valueOf(config.getParamValue()) : 0);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(glusterOptionDao.getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<>(getTransportTypesOfVolume(volume.getId())));
        GlusterVolumeAdvancedDetails advancedDetails = fetchAdvancedDatails(volume.getId());
        if (advancedDetails != null) {
            volume.setAdvancedDetails(advancedDetails);
        }
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = glusterBrickDao.getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
        GlusterVolumeSnapshotConfig config = glusterVolumeSnapshotConfigDao.getConfigByVolumeIdAndName(volume.getClusterId(), volume.getId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        if (config == null || StringUtils.isEmpty(config.getParamValue())) {
            config = glusterVolumeSnapshotConfigDao.getConfigByClusterIdAndName(volume.getClusterId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        }
        volume.setSnapMaxLimit(config != null ? Integer.valueOf(config.getParamValue()) : 0);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterVolumeEntity entity = new GlusterVolumeEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setName(rs.getString("vol_name"));
    entity.setVolumeType(GlusterVolumeType.valueOf(rs.getString("vol_type")));
    entity.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    entity.setReplicaCount(rs.getInt("replica_count"));
    entity.setStripeCount(rs.getInt("stripe_count"));
    entity.setSnapshotsCount(rs.getInt("snapshot_count"));
    entity.setSnapshotScheduled(rs.getBoolean("snapshot_scheduled"));
    entity.setIsGeoRepMaster(rs.getBoolean("is_master"));
    entity.setIsGeoRepSlave(rs.getBoolean("is_slave"));
    return entity;
}
#method_after
@Override
public GlusterVolumeEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterVolumeEntity entity = new GlusterVolumeEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setName(rs.getString("vol_name"));
    entity.setVolumeType(GlusterVolumeType.valueOf(rs.getString("vol_type")));
    entity.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    entity.setReplicaCount(rs.getInt("replica_count"));
    entity.setStripeCount(rs.getInt("stripe_count"));
    entity.setDisperseCount(rs.getInt("disperse_count"));
    entity.setRedundancyCount(rs.getInt("redundancy_count"));
    entity.setSnapshotsCount(rs.getInt("snapshot_count"));
    entity.setSnapshotScheduled(rs.getBoolean("snapshot_scheduled"));
    entity.setIsGeoRepMaster(rs.getBoolean("is_master"));
    entity.setGeoRepMasterVolAndClusterName(rs.getString("master_vol_cluster"));
    return entity;
}
#end_block

#method_before
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#method_after
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(GlusterVolumeEntity volume) {
    return getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(GlusterVolumeEntity volume) {
    return getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount());
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(remoteUserName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(userName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(remoteUserName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, remoteUserName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String slaveUserName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, slaveUserName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String slaveUserName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, slaveUserName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, remoteUserName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String slaveUserName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName, slaveUserName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String slaveUserName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName, slaveUserName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName, remoteUserName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, remoteUserName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String slaveUserName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue, slaveUserName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String slaveUserName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey, slaveUserName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String slaveUserName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName, slaveUserName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final ClientPolicy policy = client.getClientRetryPolicy();
    final FutureCallable callable = new FutureCallable(new Callable<Map<String, Object>>() {

        @Override
        public Map<String, Object> call() throws Exception {
            updateHeartbeatPolicy(policy.clone(), false);
            return new FutureMap(client, request).withResponseKey("status");
        }
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                updateHeartbeatPolicy(policy, true);
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
private void updateHeartbeatPolicy(boolean isHeartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setIncomingHeartbeat(isHeartbeat);
    policy.setOutgoingHeartbeat(isHeartbeat);
    client.setClientRetryPolicy(policy);
}
#method_after
private void updateHeartbeatPolicy(ClientPolicy policy, boolean isHeartbeat) {
    policy.setIncomingHeartbeat(isHeartbeat);
    policy.setOutgoingHeartbeat(isHeartbeat);
    client.setClientRetryPolicy(policy);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    // forceRemove not used in gluster API
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStart").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String slaveUserName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", slaveUserName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String slaveUserName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", slaveUserName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String slaveUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", slaveUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String slaveUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", slaveUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String slaveUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", slaveUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String slaveUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", slaveUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String slaveUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", slaveUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#end_block

#method_before
protected void executeImport() {
    importModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            VmBackupModel vmBackupModel = VmBackupModel.this;
            vmBackupModel.getWindow().stopProgress();
            vmBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && vmBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedVms = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmBackupModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms.append(vm.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    confirmModel.setHelpTag(HelpTag.import_virtual_machine);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(StringHelper.trimEnd(importedVms.toString().trim(), ',')));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmBackupModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, cloneObjectMap);
}
#method_after
protected void executeImport() {
    importModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            getWindow().stopProgress();
            cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && getSelectedItems().size() == retVals.size()) {
                StringBuilder importedVms = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms.append(vm.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    confirmModel.setHelpTag(HelpTag.import_virtual_machine);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(StringHelper.trimEnd(importedVms.toString().trim(), ',')));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", VmBackupModel.this);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, cloneObjectMap);
}
#end_block

#method_before
private void localize(CommonApplicationConstants constants) {
    aliasEditor.setLabel(constants.aliasVmDiskPopup());
    sizeEditor.setLabel(constants.sizeVmDiskPopup());
    sizeExtendEditor.setLabel(constants.extendImageSizeBy());
    descriptionEditor.setLabel(constants.descriptionVmDiskPopup());
    datacenterEditor.setLabel(constants.dcVmDiskPopup());
    storageDomainEditor.setLabel(constants.storageDomainVmDiskPopup());
    hostListEditor.setLabel(constants.hostVmDiskPopup());
    quotaEditor.setLabel(constants.quotaVmDiskPopup());
    diskProfileEditor.setLabel(constants.diskProfileVmDiskPopup());
    interfaceEditor.setLabel(constants.interfaceVmDiskPopup());
    volumeTypeEditor.setLabel(constants.allocationDisk());
    storageTypeEditor.setLabel(constants.storageTypeVmDiskPopup());
    plugDiskToVmEditor.setLabel(constants.activateVmDiskPopup());
    wipeAfterDeleteEditor.setLabel(constants.wipeAfterDeleteVmDiskPopup());
    isBootableEditor.setLabel(constants.isBootableVmDiskPopup());
    isShareableEditor.setLabel(constants.isShareableVmDiskPopup());
    isReadOnlyEditor.setLabel(constants.isReadOnlyVmDiskPopup());
    isScsiReservationUsedEditor.setLabel(constants.isScsiReservationUsedEditor());
    isScsiPassthroughEditor.setLabel(constants.isScsiPassthroughEditor());
    isSgIoUnfilteredEditor.setLabel(constants.isSgIoUnfilteredEditor());
}
#method_after
private void localize() {
    aliasEditor.setLabel(constants.aliasVmDiskPopup());
    sizeEditor.setLabel(constants.sizeVmDiskPopup());
    sizeExtendEditor.setLabel(constants.extendImageSizeBy());
    descriptionEditor.setLabel(constants.descriptionVmDiskPopup());
    datacenterEditor.setLabel(constants.dcVmDiskPopup());
    storageDomainEditor.setLabel(constants.storageDomainVmDiskPopup());
    hostListEditor.setLabel(constants.hostVmDiskPopup());
    quotaEditor.setLabel(constants.quotaVmDiskPopup());
    diskProfileEditor.setLabel(constants.diskProfileVmDiskPopup());
    interfaceEditor.setLabel(constants.interfaceVmDiskPopup());
    volumeTypeEditor.setLabel(constants.allocationDisk());
    cinderVolumeTypeEditor.setLabel(constants.cinderVolumeTypeDisk());
    storageTypeEditor.setLabel(constants.storageTypeVmDiskPopup());
    plugDiskToVmEditor.setLabel(constants.activateVmDiskPopup());
    wipeAfterDeleteEditor.setLabel(constants.wipeAfterDeleteVmDiskPopup());
    isBootableEditor.setLabel(constants.isBootableVmDiskPopup());
    isShareableEditor.setLabel(constants.isShareableVmDiskPopup());
    isReadOnlyEditor.setLabel(constants.isReadOnlyVmDiskPopup());
    isUsingScsiReservationEditor.setLabel(constants.isUsingScsiReservationEditor());
    isScsiPassthroughEditor.setLabel(constants.isScsiPassthroughEditor());
    isSgIoUnfilteredEditor.setLabel(constants.isSgIoUnfilteredEditor());
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "rawtypes" })
private void initManualWidgets(CommonApplicationConstants constants, CommonApplicationResources resources, CommonApplicationTemplates templates) {
    storageDomainEditor = new ListModelListBoxEditor<StorageDomain>(new StorageDomainFreeSpaceRenderer());
    hostListEditor = new ListModelListBoxEditor<VDS>(new AbstractRenderer<VDS>() {

        @Override
        public String render(VDS vds) {
            // $NON-NLS-1$
            return vds == null ? "" : vds.getName();
        }
    });
    diskProfileEditor = new ListModelListBoxEditor<DiskProfile>(new NullSafeRenderer<DiskProfile>() {

        @Override
        protected String renderNullSafe(DiskProfile object) {
            return object.getName();
        }
    });
    quotaEditor = new ListModelListBoxEditor<Quota>(new NullSafeRenderer<Quota>() {

        @Override
        public String renderNullSafe(Quota quota) {
            return quota.getQuotaName();
        }
    });
    interfaceEditor = new ListModelListBoxEditor<DiskInterface>(new EnumRenderer());
    datacenterEditor = new ListModelListBoxEditor<StoragePool>(new NullSafeRenderer<StoragePool>() {

        @Override
        public String renderNullSafe(StoragePool storagePool) {
            return storagePool.getName();
        }
    });
    volumeTypeEditor = new ListModelListBoxEditor<VolumeType>(new EnumRenderer());
    storageTypeEditor = new ListModelListBoxEditor<StorageType>(new EnumRenderer());
    plugDiskToVmEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    wipeAfterDeleteEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isBootableEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isShareableEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isReadOnlyEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isScsiReservationUsedEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isScsiPassthroughEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isSgIoUnfilteredEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    interfaceInfoIcon = new InfoIcon(templates.italicText(constants.diskInterfaceInfo()), resources);
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
private void initManualWidgets() {
    storageDomainEditor = new ListModelListBoxEditor<>(new StorageDomainFreeSpaceRenderer());
    hostListEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>());
    diskProfileEditor = new ListModelListBoxEditor<>(new NameRenderer<DiskProfile>());
    quotaEditor = new ListModelListBoxEditor<>(new NameRenderer<Quota>());
    interfaceEditor = new ListModelListBoxEditor<>(new EnumRenderer());
    datacenterEditor = new ListModelListBoxEditor<>(new NameRenderer<StoragePool>());
    cinderVolumeTypeEditor = new ListModelListBoxEditor<>();
    volumeTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer());
    storageTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer());
    plugDiskToVmEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    wipeAfterDeleteEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isBootableEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isShareableEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isReadOnlyEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isUsingScsiReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isScsiPassthroughEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    isSgIoUnfilteredEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    interfaceInfoIcon = new InfoIcon(templates.italicText(constants.diskInterfaceInfo()));
    scsiReservationInfoIcon = new InfoIcon(templates.italicText(constants.scsiReservationInfoIcon()));
}
#end_block

#method_before
@Override
public void edit(final AbstractDiskModel disk) {
    driver.edit(disk);
    disk.getIsDirectLunDiskAvaialable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isDirectLunDiskAvaialable = ((EntityModel<Boolean>) sender).getEntity();
            externalDiskPanel.setVisible(isDirectLunDiskAvaialable);
        }
    });
    disk.getIsVirtioScsiEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (disk.getVm() == null) {
                // not relevant for floating disks
                return;
            }
            boolean isVirtioScsiEnabled = Boolean.TRUE.equals(((EntityModel) sender).getEntity());
            Version clusterVersion = disk.getVm().getVdsGroupCompatibilityVersion();
            // Show the info icon if VirtIO-SCSI is supported by the cluster but disabled for the VM
            interfaceInfoIcon.setVisible(clusterVersion.compareTo(Version.v3_3) >= 0 && !isVirtioScsiEnabled);
        }
    });
    diskTypePanel.addRadioButton(constants.internalDisk(), disk.getIsNew() || disk.getDisk().getDiskStorageType() == DiskStorageType.IMAGE, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.externalDisk(), !disk.getIsNew() && disk.getDisk().getDiskStorageType() == DiskStorageType.LUN, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.LUN);
            revealStorageView(disk);
            revealDiskPanel(disk);
        }
    });
    storageModel = new StorageModel(new NewEditStorageModelBehavior());
    // Create IscsiStorageModel
    iscsiStorageModel = new IscsiStorageModel();
    iscsiStorageModel.setContainer(storageModel);
    iscsiStorageModel.setIsGrouppedByTarget(true);
    iscsiStorageModel.setIgnoreGrayedOut(true);
    iscsiStorageView = new IscsiStorageView(false, 115, 214, 244, 275, 142, 55, -67);
    iscsiStorageView.edit(iscsiStorageModel);
    // Create FcpStorageModel
    fcpStorageModel = new FcpStorageModel();
    fcpStorageModel.setContainer(storageModel);
    fcpStorageModel.setIsGrouppedByTarget(false);
    fcpStorageModel.setIgnoreGrayedOut(true);
    fcpStorageView = new FcpStorageView(false, 278, 240);
    fcpStorageView.edit(fcpStorageModel);
    // Set 'StorageModel' items
    ArrayList<IStorageModel> items = new ArrayList<IStorageModel>();
    items.add(iscsiStorageModel);
    items.add(fcpStorageModel);
    storageModel.setItems(items);
    storageModel.setHost(disk.getHost());
    // SelectedItemChangedEvent handlers
    disk.getStorageType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    disk.getHost().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    revealDiskPanel(disk);
}
#method_after
@Override
public void edit(final AbstractDiskModel disk) {
    driver.edit(disk);
    disk.getIsDirectLunDiskAvaialable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isDirectLunDiskAvaialable = ((EntityModel<Boolean>) sender).getEntity();
            externalDiskPanel.setVisible(isDirectLunDiskAvaialable);
        }
    });
    disk.getIsUsingScsiReservation().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            scsiReservationInfoIcon.setVisible(disk.getIsUsingScsiReservation().getEntity());
        }
    });
    disk.getIsVirtioScsiEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (disk.getVm() == null) {
                // not relevant for floating disks
                return;
            }
            boolean isVirtioScsiEnabled = Boolean.TRUE.equals(((EntityModel) sender).getEntity());
            Version clusterVersion = disk.getVm().getVdsGroupCompatibilityVersion();
            // Show the info icon if VirtIO-SCSI is supported by the cluster but disabled for the VM
            interfaceInfoIcon.setVisible(clusterVersion.compareTo(Version.v3_3) >= 0 && !isVirtioScsiEnabled);
        }
    });
    disk.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                if (!StringHelper.isNullOrEmpty(disk.getMessage())) {
                    disableWidget(getWidget());
                    enableWidget(diskTypePanel);
                    disk.getDefaultCommand().setIsExecutionAllowed(false);
                    disk.setIsChangable(false);
                } else {
                    enableWidget(getWidget());
                    disk.getDefaultCommand().setIsExecutionAllowed(true);
                    disk.setIsChangable(true);
                }
            }
        }
    });
    diskTypePanel.addRadioButton(constants.imageDisk(), disk.getDisk() == null || disk.getDisk().getDiskStorageType() == DiskStorageType.IMAGE, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.directLunDisk(), disk.getDisk() != null && disk.getDisk().getDiskStorageType() == DiskStorageType.LUN, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.LUN);
            revealStorageView(disk);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.cinderDisk(), disk.getDisk() != null && disk.getDisk().getDiskStorageType() == DiskStorageType.CINDER, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.CINDER);
            revealDiskPanel(disk);
        }
    });
    if (disk.getStorageModel() == null) {
        storageModel = new StorageModel(new NewEditStorageModelBehavior());
        // Create IscsiStorageModel
        iscsiStorageModel = new IscsiStorageModel();
        iscsiStorageModel.setContainer(storageModel);
        iscsiStorageModel.setIsGrouppedByTarget(true);
        iscsiStorageModel.setIgnoreGrayedOut(true);
        // Create FcpStorageModel
        fcpStorageModel = new FcpStorageModel();
        fcpStorageModel.setContainer(storageModel);
        fcpStorageModel.setIsGrouppedByTarget(false);
        fcpStorageModel.setIgnoreGrayedOut(true);
        // Set 'StorageModel' items
        ArrayList<IStorageModel> items = new ArrayList<>();
        items.add(iscsiStorageModel);
        items.add(fcpStorageModel);
        storageModel.setItems(items);
        storageModel.setHost(disk.getHost());
        disk.setStorageModel(storageModel);
    } else {
        storageModel = disk.getStorageModel();
        iscsiStorageModel = Linq.findByType(storageModel.getItems(), IscsiStorageModel.class);
        iscsiStorageModel.getPropertyChangedEvent().clearListeners();
        fcpStorageModel = Linq.findByType(storageModel.getItems(), FcpStorageModel.class);
        fcpStorageModel.getPropertyChangedEvent().clearListeners();
    }
    iscsiStorageView = new IscsiStorageView(false, 115, 214, 244, 275, 142, 55, -67);
    iscsiStorageView.edit(iscsiStorageModel);
    fcpStorageView = new FcpStorageView(false, 278, 240);
    fcpStorageView.edit(fcpStorageModel);
    // SelectedItemChangedEvent handlers
    disk.getStorageType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    disk.getHost().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    revealStorageView(disk);
    revealDiskPanel(disk);
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    sizeEditor.setTabIndex(nextTabIndex++);
    sizeExtendEditor.setTabIndex(nextTabIndex++);
    aliasEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    interfaceEditor.setTabIndex(nextTabIndex++);
    datacenterEditor.setTabIndex(nextTabIndex++);
    storageDomainEditor.setTabIndex(nextTabIndex++);
    volumeTypeEditor.setTabIndex(nextTabIndex++);
    diskProfileEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    hostListEditor.setTabIndex(nextTabIndex++);
    storageTypeEditor.setTabIndex(nextTabIndex++);
    plugDiskToVmEditor.setTabIndex(nextTabIndex++);
    wipeAfterDeleteEditor.setTabIndex(nextTabIndex++);
    isBootableEditor.setTabIndex(nextTabIndex++);
    isShareableEditor.setTabIndex(nextTabIndex++);
    isReadOnlyEditor.setTabIndex(nextTabIndex++);
    isScsiPassthroughEditor.setTabIndex(nextTabIndex++);
    isSgIoUnfilteredEditor.setTabIndex(nextTabIndex++);
    isScsiReservationUsedEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    sizeEditor.setTabIndex(nextTabIndex++);
    sizeExtendEditor.setTabIndex(nextTabIndex++);
    aliasEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    interfaceEditor.setTabIndex(nextTabIndex++);
    datacenterEditor.setTabIndex(nextTabIndex++);
    storageDomainEditor.setTabIndex(nextTabIndex++);
    volumeTypeEditor.setTabIndex(nextTabIndex++);
    cinderVolumeTypeEditor.setTabIndex(nextTabIndex++);
    diskProfileEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    hostListEditor.setTabIndex(nextTabIndex++);
    storageTypeEditor.setTabIndex(nextTabIndex++);
    plugDiskToVmEditor.setTabIndex(nextTabIndex++);
    wipeAfterDeleteEditor.setTabIndex(nextTabIndex++);
    isBootableEditor.setTabIndex(nextTabIndex++);
    isShareableEditor.setTabIndex(nextTabIndex++);
    isReadOnlyEditor.setTabIndex(nextTabIndex++);
    isScsiPassthroughEditor.setTabIndexes(nextTabIndex++);
    isSgIoUnfilteredEditor.setTabIndex(nextTabIndex++);
    isUsingScsiReservationEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vmUsesScsiReservation()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_USES_SCSI_RESERVATION);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getParameters().getTargetVdsGroupId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetVdsGroupId());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetVdsGroupId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetVdsGroupId());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsScsiPassthrough().setEntity(getDisk().isScsiPassthrough());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        getDiskStorageType().setEntity(DiskStorageType.IMAGE);
        getSize().setEntity((int) diskImage.getSizeInGigabytes());
        getVolumeType().setSelectedItem(diskImage.getVolumeType());
        setVolumeFormat(diskImage.getVolumeFormat());
        boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
        getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
        Guid storageDomainId = diskImage.getStorageIds().get(0);
        AsyncDataProvider.getInstance().getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                DiskModel diskModel = (DiskModel) target;
                StorageDomain storageDomain = (StorageDomain) returnValue;
                diskModel.getStorageDomain().setSelectedItem(storageDomain);
            }
        }), storageDomainId);
    } else {
        LunDisk lunDisk = (LunDisk) getDisk();
        getDiskStorageType().setEntity(DiskStorageType.LUN);
        getSize().setEntity(lunDisk.getLun().getDeviceSize());
        getSizeExtend().setIsAvailable(false);
        getIsScsiReservationUsed().setEntity(lunDisk.isScsiReservationUsed());
    }
    updateReadOnlyChangeability();
    updateWipeAfterDeleteChangeability();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    disableNonChangeableEntities();
    getAlias().setEntity(getDisk().getDiskAlias());
    getDescription().setEntity(getDisk().getDiskDescription());
    getIsShareable().setEntity(getDisk().isShareable());
    getIsWipeAfterDelete().setEntity(getDisk().isWipeAfterDelete());
    getIsScsiPassthrough().setEntity(getDisk().isScsiPassthrough());
    getIsSgIoUnfiltered().setEntity(getDisk().getSgio() == ScsiGenericIO.UNFILTERED);
    getIsReadOnly().setEntity(getDisk().getReadOnly());
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            DiskImage diskImage = (DiskImage) getDisk();
            getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            getSize().setEntity((int) diskImage.getSizeInGigabytes());
            getVolumeType().setSelectedItem(diskImage.getVolumeType());
            boolean isExtendImageSizeEnabled = getVm() != null && !diskImage.isDiskSnapshot() && VdcActionUtils.canExecute(Arrays.asList(getVm()), VM.class, VdcActionType.ExtendImageSize);
            getSizeExtend().setIsChangable(isExtendImageSizeEnabled);
            break;
        case LUN:
            LunDisk lunDisk = (LunDisk) getDisk();
            getDiskStorageType().setEntity(DiskStorageType.LUN);
            getSize().setEntity(lunDisk.getLun().getDeviceSize());
            getSizeExtend().setIsAvailable(false);
            break;
        case CINDER:
            CinderDisk cinderDisk = (CinderDisk) getDisk();
            getDiskStorageType().setEntity(DiskStorageType.CINDER);
            getSize().setEntity((int) cinderDisk.getSizeInGigabytes());
            getSizeExtend().setIsChangable(true);
            break;
    }
    updateReadOnlyChangeability();
    updateWipeAfterDeleteChangeability();
}
#end_block

#method_before
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    if (!isEditEnabled()) {
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#method_after
private void disableNonChangeableEntities() {
    getStorageDomain().setIsChangable(false);
    getHost().setIsChangable(false);
    getStorageType().setIsChangable(false);
    getDataCenter().setIsChangable(false);
    getVolumeType().setIsChangable(false);
    getSize().setIsChangable(false);
    getCinderVolumeType().setIsChangable(false);
    if (!isEditEnabled()) {
        getIsShareable().setIsChangable(false);
        getIsBootable().setIsChangable(false);
        getDiskInterface().setIsChangable(false);
        getIsReadOnly().setIsChangable(false);
    }
}
#end_block

#method_before
@Override
protected void updateStorageDomains(final StoragePool datacenter) {
// do nothing
}
#method_after
@Override
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getStorageDomainById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            StorageDomain storageDomain = (StorageDomain) returnValue;
            diskModel.getStorageDomain().setSelectedItem(storageDomain);
        }
    }), getStorageDomainId());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    if (resizeDiskImageRequested()) {
        extendDiskImageSize();
    } else {
        try {
            performDiskUpdate(false);
        } finally {
            freeLock();
        }
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    if (resizeDiskImageRequested()) {
        switch(getOldDisk().getDiskStorageType()) {
            case IMAGE:
                extendDiskImageSize();
                break;
            case CINDER:
                extendCinderDiskSize();
                break;
        }
    } else {
        try {
            performDiskUpdate(false);
        } finally {
            freeLock();
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validate(diskValidator.isVirtIoScsiValid(getVm())) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if ((DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validate(diskValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
private void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                diskImage.setQuotaId(getQuotaId());
                if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                    diskImage.setImageStatus(ImageStatus.OK);
                }
                getImageDao().update(diskImage.getImage());
                updateQuota(diskImage);
                updateDiskProfile();
            } else {
                updateLunProperties();
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties() {
            vmDeviceForVm.setScsiReservationUsed(((LunDisk) getNewDisk()).isScsiReservationUsed());
            getVmDeviceDao().update(vmDeviceForVm);
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk disk = getDiskDao().get(getParameters().getDiskId());
    applyUserChanges(disk);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(disk);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) disk;
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#end_block

#method_before
private void auditLogForNoMetadataDescriptionUpdate(AuditLogType auditLogType, StorageDomain storageDomain, DiskImage diskImage) {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
    auditLogableBase.addCustomValue("StorageDomainName", storageDomain.getName());
    auditLogableBase.addCustomValue("DiskName", diskImage.getDiskAlias());
    AuditLogDirector.log(auditLogableBase, auditLogType);
}
#method_after
private void auditLogForNoMetadataDescriptionUpdate(AuditLogType auditLogType, StorageDomain storageDomain, DiskImage diskImage) {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
    auditLogableBase.addCustomValue("StorageDomainName", storageDomain.getName());
    auditLogableBase.addCustomValue("DiskName", diskImage.getDiskAlias());
    auditLogDirector.log(auditLogableBase, auditLogType);
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    VdcReturnValueBase ret = getBackend().endAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#method_after
@Override
protected void endSuccessfully() {
    if (!isDiskImage()) {
        return;
    }
    VdcReturnValueBase ret = getBackend().endAction(VdcActionType.ExtendImageSize, createExtendImageSizeParameters(), getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
    if (ret.getSucceeded()) {
        performDiskUpdate(true);
    } else {
        unlockImageInDb();
    }
    getReturnValue().setEndActionTryAgain(false);
    setSucceeded(ret.getSucceeded());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VM_DISK : AuditLogType.USER_FAILED_UPDATE_VM_DISK;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return isCinderDisk() && resizeDiskImageRequested() ? AuditLogType.USER_EXTENDED_DISK_SIZE : AuditLogType.USER_UPDATE_VM_DISK;
    } else {
        return AuditLogType.USER_FAILED_UPDATE_VM_DISK;
    }
}
#end_block

#method_before
private boolean isDiskImage() {
    return getOldDisk() != null && getNewDisk() != null && DiskStorageType.IMAGE == getOldDisk().getDiskStorageType();
}
#method_after
private boolean isDiskImage() {
    return isDiskStorageType(DiskStorageType.IMAGE);
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (isDiskImage()) {
        DiskImage oldDiskImage = (DiskImage) getOldDisk();
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        if (emptyOldQuota || differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getStorageIds().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getStorageIds().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (isDiskImage()) {
        DiskImage oldDiskImage = (DiskImage) getOldDisk();
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        long diskExtendingDiff = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        if (emptyOldQuota || differentNewQuota) {
            list.add(generateQuotaConsumeParameters(newDiskImage, newDiskImage.getSizeInGigabytes()));
        } else if (diskExtendingDiff > 0L) {
            list.add(generateQuotaConsumeParameters(newDiskImage, diskExtendingDiff));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getStorageIds().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
private boolean resizeDiskImageRequested() {
    return getNewDisk().getDiskStorageType() == DiskStorageType.IMAGE && vmDeviceForVm.getSnapshotId() == null && getNewDisk().getSize() != getOldDisk().getSize();
}
#method_after
private boolean resizeDiskImageRequested() {
    boolean sizeChanged = getNewDisk().getSize() != getOldDisk().getSize();
    switch(getNewDisk().getDiskStorageType()) {
        case IMAGE:
            return sizeChanged && vmDeviceForVm.getSnapshotId() == null;
        case CINDER:
            return sizeChanged;
    }
    return false;
}
#end_block

#method_before
private Disk getNewDisk() {
    return getParameters().getDiskInfo();
}
#method_after
protected Disk getNewDisk() {
    return getParameters().getDiskInfo();
}
#end_block

#method_before
private void unlockImageInDb() {
    final DiskImage diskImage = (DiskImage) getOldDisk();
    diskImage.setImageStatus(ImageStatus.OK);
    ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.OK);
}
#method_after
public void unlockImageInDb() {
    final DiskImage diskImage = (DiskImage) getOldDisk();
    diskImage.setImageStatus(ImageStatus.OK);
    ImagesHandler.updateImageStatus(diskImage.getImageId(), ImageStatus.OK);
}
#end_block

#method_before
@Override
public List<Disk> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, DiskRowMapper.instance);
}
#method_after
@Override
public List<Disk> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, DiskRowMapper.instance);
}
#end_block

#method_before
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = null;
    DiskStorageType diskStorageType = Disk.DiskStorageType.forValue(rs.getInt("disk_storage_type"));
    switch(diskStorageType) {
        case IMAGE:
            disk = DiskImageRowMapper.instance.mapRow(rs, rowNum);
            break;
        case LUN:
            disk = LunDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
    }
    return disk;
}
#method_after
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = null;
    DiskStorageType diskStorageType = DiskStorageType.forValue(rs.getInt("disk_storage_type"));
    switch(diskStorageType) {
        case IMAGE:
            disk = DiskImageRowMapper.instance.mapRow(rs, rowNum);
            break;
        case LUN:
            disk = LunDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
        case CINDER:
            disk = CinderDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
    }
    return disk;
}
#end_block

#method_before
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = DiskRowMapper.instance.mapRow(rs, rowNum);
    disk.setPlugged(rs.getBoolean("is_plugged"));
    disk.setReadOnly(rs.getBoolean("is_readonly"));
    disk.setLogicalName(rs.getString("logical_name"));
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        ((LunDisk) disk).setScsiReservationUsed(rs.getBoolean("is_scsi_reservation_used"));
    }
    return disk;
}
#method_after
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = DiskRowMapper.instance.mapRow(rs, rowNum);
    disk.setPlugged(rs.getBoolean("is_plugged"));
    disk.setReadOnly(rs.getBoolean("is_readonly"));
    disk.setLogicalName(rs.getString("logical_name"));
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        ((LunDisk) disk).setUsingScsiReservation(rs.getBoolean("is_using_scsi_reservation"));
    }
    return disk;
}
#end_block

#method_before
@Mapping(from = ImageStatus.class, to = DiskStatus.class)
public static DiskStatus map(ImageStatus imageStatus) {
    switch(imageStatus) {
        case ILLEGAL:
            return DiskStatus.ILLEGAL;
        case LOCKED:
            return DiskStatus.LOCKED;
        case OK:
            return DiskStatus.OK;
        default:
            return null;
    }
}
#method_after
@Mapping(from = Disk.class, to = org.ovirt.engine.core.common.businessentities.storage.Disk.class)
public static org.ovirt.engine.core.common.businessentities.storage.Disk map(Disk disk, org.ovirt.engine.core.common.businessentities.storage.Disk template) {
    org.ovirt.engine.core.common.businessentities.storage.Disk engineDisk = template;
    if (engineDisk == null) {
        if (disk.isSetLunStorage()) {
            engineDisk = new LunDisk();
        } else if (disk.getStorageType() != null) {
            DiskStorageType diskStorageType = DiskStorageType.fromValue(disk.getStorageType());
            if (diskStorageType != null) {
                switch(diskStorageType) {
                    case CINDER:
                        engineDisk = new CinderDisk();
                        break;
                    case IMAGE:
                        engineDisk = new DiskImage();
                        break;
                }
            }
        }
        if (engineDisk == null) {
            engineDisk = new DiskImage();
        }
    }
    // name is depreciated, use alias instead.
    if (disk.isSetName()) {
        engineDisk.setDiskAlias(disk.getName());
    }
    if (disk.isSetAlias()) {
        engineDisk.setDiskAlias(disk.getAlias());
    }
    if (disk.isSetId()) {
        engineDisk.setId(GuidUtils.asGuid(disk.getId()));
    }
    if (disk.isSetBootable()) {
        engineDisk.setBoot(disk.isBootable());
    }
    if (disk.isSetPropagateErrors()) {
        engineDisk.setPropagateErrors(disk.isPropagateErrors() ? PropagateErrors.On : PropagateErrors.Off);
    }
    if (disk.isSetWipeAfterDelete()) {
        engineDisk.setWipeAfterDelete(disk.isWipeAfterDelete());
    }
    if (disk.isSetActive()) {
        engineDisk.setPlugged(disk.isActive());
    }
    if (disk.isSetReadOnly()) {
        engineDisk.setReadOnly(disk.isReadOnly());
    }
    if (disk.isSetLogicalName()) {
        engineDisk.setLogicalName(disk.getLogicalName());
    }
    if (disk.isSetDescription()) {
        engineDisk.setDiskDescription(disk.getDescription());
    }
    if (disk.isSetInterface()) {
        DiskInterface diskInterface = DiskInterface.fromValue(disk.getInterface());
        if (diskInterface != null) {
            engineDisk.setDiskInterface(map(diskInterface, null));
        }
    }
    if (disk.isSetShareable()) {
        engineDisk.setShareable(disk.isShareable());
    }
    if (disk.isSetLunStorage()) {
        ((LunDisk) engineDisk).setLun(StorageLogicalUnitMapper.map(disk.getLunStorage(), null));
        if (disk.isSetUsesScsiReservation()) {
            ((LunDisk) engineDisk).setUsingScsiReservation(disk.isUsesScsiReservation());
        }
        if (disk.isSetSgio() && engineDisk.getDiskInterface() == map(DiskInterface.VIRTIO_SCSI, null)) {
            ScsiGenericIO scsiGenericIO = ScsiGenericIO.fromValue(disk.getSgio());
            if (scsiGenericIO != null) {
                engineDisk.setSgio(map(scsiGenericIO, null));
            }
        }
    } else {
        mapDiskToDiskImageProperties(disk, (DiskImage) engineDisk);
    }
    return engineDisk;
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    if (getVm() != null) {
        updateSuggestedDiskAlias();
        getIsPlugged().setIsAvailable(true);
    } else {
        // Read only disk can be created only in the scope of VM.
        getIsReadOnly().setIsAvailable(false);
        getIsPlugged().setEntity(false);
    }
    getSizeExtend().setIsAvailable(false);
}
#method_after
@Override
public void initialize() {
    super.initialize();
    if (getVm() != null) {
        updateSuggestedDiskAliasFromServer();
        getIsPlugged().setIsAvailable(true);
    } else {
        // Read only disk can be created only in the scope of VM.
        getIsReadOnly().setIsAvailable(false);
        getIsPlugged().setEntity(false);
        // set using scsi reservation to be invisible
        getIsUsingScsiReservation().setIsAvailable(false);
        getIsUsingScsiReservation().setEntity(false);
    }
    getSizeExtend().setIsAvailable(false);
}
#end_block

#method_before
@Override
public boolean validate() {
    if (getDiskStorageType().getEntity() == Disk.DiskStorageType.LUN && getSanStorageModel() != null) {
        getSanStorageModel().validate();
        if (!getSanStorageModel().getIsValid()) {
            return false;
        }
        ArrayList<String> partOfSdLunsMessages = getSanStorageModel().getPartOfSdLunsMessages();
        if (!partOfSdLunsMessages.isEmpty() && !getSanStorageModel().isForce()) {
            forceCreationWarning(partOfSdLunsMessages);
            return false;
        }
    }
    StorageType storageType = getStorageDomain().getSelectedItem() == null ? StorageType.UNKNOWN : getStorageDomain().getSelectedItem().getStorageType();
    IntegerValidation sizeValidation = new IntegerValidation();
    sizeValidation.setMinimum(1);
    if (storageType.isBlockDomain()) {
        sizeValidation.setMaximum((Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MaxBlockDiskSize));
    }
    getSize().validateEntity(new IValidation[] { new NotEmptyValidation(), sizeValidation });
    getStorageDomain().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return super.validate() && getSize().getIsValid() && getStorageDomain().getIsValid();
}
#method_after
@Override
public boolean validate() {
    if (getDiskStorageType().getEntity() == DiskStorageType.LUN && getSanStorageModel() != null) {
        getSanStorageModel().validate();
        if (!getSanStorageModel().getIsValid()) {
            return false;
        }
        ArrayList<String> partOfSdLunsMessages = getSanStorageModel().getPartOfSdLunsMessages();
        if (!partOfSdLunsMessages.isEmpty() && !getSanStorageModel().isForce()) {
            forceCreationWarning(partOfSdLunsMessages);
            return false;
        }
    }
    StorageType storageType = getStorageDomain().getSelectedItem() == null ? StorageType.UNKNOWN : getStorageDomain().getSelectedItem().getStorageType();
    IntegerValidation sizeValidation = new IntegerValidation();
    sizeValidation.setMinimum(1);
    if (storageType.isBlockDomain()) {
        sizeValidation.setMaximum((Integer) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MaxBlockDiskSize));
    }
    getSize().validateEntity(new IValidation[] { new NotEmptyValidation(), sizeValidation });
    getStorageDomain().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return super.validate() && getSize().getIsValid() && getStorageDomain().getIsValid();
}
#end_block

#method_before
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(entity, isBalloonEnabled(params));
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
        updateVirtioScsiController(entity.getId(), params.isVirtioScsiEnabled());
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null, false);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(entity, isBalloonEnabled(params));
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
        updateVirtioScsiController(entity.getId(), params.isVirtioScsiEnabled());
    }
}
#end_block

#method_before
public static void updateSmartcardDevice(Guid vmId, boolean smartcardEnabled) {
    List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD.getName());
    if (!smartcardEnabled) {
        for (VmDevice device : vmDevices) {
            dao.remove(device.getId());
        }
    } else if (vmDevices.isEmpty()) {
        addSmartcardDevice(vmId);
    }
}
#method_after
public static void updateSmartcardDevice(Guid vmId, boolean smartcardEnabled) {
    List<VmDevice> vmDevices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD.getName());
    if (!smartcardEnabled) {
        for (VmDevice device : vmDevices) {
            dao.remove(device.getId());
        }
    } else if (vmDevices.isEmpty()) {
        addSmartcardDevice(vmId);
    }
}
#end_block

#method_before
public static void addSmartcardDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD, new SmartcardSpecParams(), true, false, null);
}
#method_after
public static void addSmartcardDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD, new SmartcardSpecParams(), true, false, null, false);
}
#end_block

#method_before
public static void updateConsoleDevice(Guid vmId, Boolean consoleEnabled) {
    if (consoleEnabled == null) {
        // we don't want to update the device
        return;
    }
    List<VmDevice> consoles = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE.getName());
    if (consoleEnabled) {
        if (consoles.isEmpty()) {
            addConsoleDevice(vmId);
        }
    } else {
        for (VmDevice device : consoles) {
            dao.remove(device.getId());
        }
    }
}
#method_after
public static void updateConsoleDevice(Guid vmId, Boolean consoleEnabled) {
    if (consoleEnabled == null) {
        // we don't want to update the device
        return;
    }
    List<VmDevice> consoles = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE.getName());
    if (consoleEnabled) {
        if (consoles.isEmpty()) {
            addConsoleDevice(vmId);
        }
    } else {
        for (VmDevice device : consoles) {
            dao.remove(device.getId());
        }
    }
}
#end_block

#method_before
public static void updateVirtioScsiController(Guid vmId, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    List<VmDevice> controllers = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    if (isVirtioScsiEnabled) {
        if (controllers.isEmpty()) {
            addVirtioScsiController(vmId);
        }
    } else {
        for (VmDevice device : controllers) {
            dao.remove(device.getId());
        }
    }
}
#method_after
public static void updateVirtioScsiController(Guid vmId, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    List<VmDevice> controllers = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    if (isVirtioScsiEnabled) {
        if (controllers.isEmpty()) {
            addVirtioScsiController(vmId);
        }
    } else {
        for (VmDevice device : controllers) {
            dao.remove(device.getId());
        }
    }
}
#end_block

#method_before
private static void addConsoleDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE, new HashMap<String, Object>(), true, false, null);
}
#method_after
private static void addConsoleDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE, new HashMap<String, Object>(), true, false, null, false);
}
#end_block

#method_before
private static void addVirtioScsiController(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, new HashMap<String, Object>(), true, false, null);
}
#method_after
private static void addVirtioScsiController(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, new HashMap<String, Object>(), true, false, null, false);
}
#end_block

#method_before
public static void updateAudioDevice(VmBase oldVm, VmBase newVmBase, Version compatibilityVersion, Boolean isSoundDeviceEnabled) {
    boolean removeDevice = false;
    boolean createDevice = false;
    Guid vmId = oldVm.getId();
    boolean osChanged = oldVm.getOsId() != newVmBase.getOsId();
    List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
    // recreate device only if previously existed and os has changed
    if (isSoundDeviceEnabled == null) {
        if (!list.isEmpty() && osChanged) {
            removeDevice = createDevice = true;
        }
    } else {
        // if soundeDevice disabled or os changed, and device exist, remove
        removeDevice = (!isSoundDeviceEnabled || osChanged) && !list.isEmpty();
        // if soundDevice enabled and missing or os changed, create
        createDevice = isSoundDeviceEnabled && (list.isEmpty() || osChanged);
    }
    if (removeDevice) {
        removeNumberOfDevices(list, list.size());
    }
    if (createDevice) {
        String soundDevice = osRepository.getSoundDevice(newVmBase.getOsId(), compatibilityVersion);
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
    }
}
#method_after
public static void updateAudioDevice(VmBase oldVm, VmBase newVmBase, Version compatibilityVersion, Boolean isSoundDeviceEnabled) {
    boolean removeDevice = false;
    boolean createDevice = false;
    Guid vmId = oldVm.getId();
    boolean osChanged = oldVm.getOsId() != newVmBase.getOsId();
    List<VmDevice> list = dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
    // recreate device only if previously existed and os has changed
    if (isSoundDeviceEnabled == null) {
        if (!list.isEmpty() && osChanged) {
            removeDevice = createDevice = true;
        }
    } else {
        // if soundeDevice disabled or os changed, and device exist, remove
        removeDevice = (!isSoundDeviceEnabled || osChanged) && !list.isEmpty();
        // if soundDevice enabled and missing or os changed, create
        createDevice = isSoundDeviceEnabled && (list.isEmpty() || osChanged);
    }
    if (removeDevice) {
        removeNumberOfDevices(list, list.size());
    }
    if (createDevice) {
        String soundDevice = osRepository.getSoundDevice(newVmBase.getOsId(), compatibilityVersion);
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null, false);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    Guid id;
    if (graphicsToSkip == null) {
        graphicsToSkip = new HashSet<>();
    }
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasVmGraphicsDeviceOfType(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            addSoundCard(vmBase, cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = getNumOfMonitors(vm);
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    Guid id;
    if (graphicsToSkip == null) {
        graphicsToSkip = new HashSet<>();
    }
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<String, Object>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null, false);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasVmGraphicsDeviceOfType(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            addSoundCard(vmBase, cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = getNumOfMonitors(vm);
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
private static void addSoundCard(VmBase vmBase, Version vdsGroupCompatibilityVersion) {
    String soundDevice = osRepository.getSoundDevice(vmBase.getOsId(), vdsGroupCompatibilityVersion);
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
}
#method_after
private static void addSoundCard(VmBase vmBase, Version vdsGroupCompatibilityVersion) {
    String soundDevice = osRepository.getSoundDevice(vmBase.getOsId(), vdsGroupCompatibilityVersion);
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null, false);
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VM vm = DbFacade.getInstance().getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = DbFacade.getInstance().getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices);
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    VM vm = dbFacade.getVmDao().get(dstId);
    VmBase vmBase = (vm != null) ? vm.getStaticData() : null;
    boolean isVm = (vmBase != null);
    if (!isVm) {
        vmBase = dbFacade.getVmTemplateDao().get(dstId);
    }
    List<VmDevice> devices = dao.getVmDeviceByVmId(srcId);
    copyVmDevices(srcId, dstId, vm, vmBase, isVm, devices, srcDeviceIdToTargetDeviceIdMapping, soundDeviceEnabled, isConsoleEnabled, isVirtioScsiEnabled, isBalloonEnabled, graphicsToSkip, copySnapshotDevices);
}
#end_block

#method_before
private static void addVideoDevice(VmBase vm) {
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vm.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(vm.getNumOfMonitors(), vm.getSingleQxlPci()), true, true, null);
}
#method_after
private static void addVideoDevice(VmBase vm) {
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vm.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(vm.getNumOfMonitors(), vm.getSingleQxlPci()), true, true, null, false);
}
#end_block

#method_before
public static VmDevice addNetworkInterfaceDevice(VmDeviceId id, boolean plugged) {
    return addManagedDevice(id, VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, Collections.<String, Object>emptyMap(), plugged, false, null);
}
#method_after
public static VmDevice addNetworkInterfaceDevice(VmDeviceId id, boolean plugged, boolean hostDev) {
    return addManagedDevice(id, VmDeviceGeneralType.INTERFACE, hostDev ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, Collections.<String, Object>emptyMap(), plugged, false, null, false);
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean plugged, Boolean readOnly, String address, Map<String, String> customProp) {
    VmDevice managedDevice = addManagedDevice(id, type, device, specParams, plugged, readOnly, customProp);
    if (StringUtils.isNotBlank(address)) {
        managedDevice.setAddress(address);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean plugged, Boolean readOnly, String address, Map<String, String> customProp) {
    VmDevice managedDevice = addManagedDevice(id, type, device, specParams, plugged, readOnly, customProp, false);
    if (StringUtils.isNotBlank(address)) {
        managedDevice.setAddress(address);
    }
    return managedDevice;
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp, boolean isScsiReservationUsed) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null, null, isScsiReservationUsed);
    return addManagedDeviceImpl(managedDevice);
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp, boolean isUsingScsiReservation) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null, null, isUsingScsiReservation);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = dbFacade.getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#end_block

#method_before
public static <T extends VmBase> void addImportedDevices(T entity, boolean isImportAsNewEntity) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(entity);
    }
    List<VmDevice> vmDeviceToAdd = new ArrayList<VmDevice>();
    List<VmDevice> vmDeviceToUpdate = new ArrayList<VmDevice>();
    VmDeviceDAO dao = DbFacade.getInstance().getVmDeviceDao();
    addImportedDisks(entity, vmDeviceToUpdate);
    addImportedInterfaces(entity, vmDeviceToUpdate);
    addOtherDevices(entity, vmDeviceToAdd);
    dao.saveAll(vmDeviceToAdd);
    dao.updateAll(vmDeviceToUpdate);
}
#method_after
public static <T extends VmBase> void addImportedDevices(T entity, boolean isImportAsNewEntity) {
    if (isImportAsNewEntity) {
        setNewIdInImportedCollections(entity);
    }
    List<VmDevice> vmDeviceToAdd = new ArrayList<VmDevice>();
    List<VmDevice> vmDeviceToUpdate = new ArrayList<VmDevice>();
    VmDeviceDAO dao = dbFacade.getVmDeviceDao();
    addImportedDisks(entity, vmDeviceToUpdate);
    addImportedInterfaces(entity, vmDeviceToUpdate);
    addOtherDevices(entity, vmDeviceToAdd);
    dao.saveAll(vmDeviceToAdd);
    dao.updateAll(vmDeviceToUpdate);
}
#end_block

#method_before
public static void setVmDevices(VmBase vmBase) {
    Map<Guid, VmDevice> vmManagedDeviceMap = new HashMap<Guid, VmDevice>();
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vmBase.getId());
    vmBase.setUnmanagedDeviceList(DbFacade.getInstance().getVmDeviceDao().getUnmanagedDevicesByVmId(vmBase.getId()));
    for (VmDevice device : devices) {
        if (device.getIsManaged()) {
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vmBase.setManagedDeviceMap(vmManagedDeviceMap);
}
#method_after
public static void setVmDevices(VmBase vmBase) {
    Map<Guid, VmDevice> vmManagedDeviceMap = new HashMap<Guid, VmDevice>();
    List<VmDevice> devices = dbFacade.getVmDeviceDao().getVmDeviceByVmId(vmBase.getId());
    vmBase.setUnmanagedDeviceList(dbFacade.getVmDeviceDao().getUnmanagedDevicesByVmId(vmBase.getId()));
    for (VmDevice device : devices) {
        if (device.getIsManaged()) {
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        }
    }
    vmBase.setManagedDeviceMap(vmManagedDeviceMap);
}
#end_block

#method_before
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = DbFacade.getInstance().getVmDao().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId()));
        VmHandler.updateNetworkInterfacesFromDb(vm);
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#method_after
public static List<VmDevice> updateBootOrderInVmDevice(VmBase vmBase) {
    if (vmBase instanceof VmStatic) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = dao.getVmDeviceByVmId(vmBase.getId());
        // reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VM vm = dbFacade.getVmDao().get(vmBase.getId());
        VmHandler.updateDisksForVm(vm, dbFacade.getDiskDao().getAllForVm(vm.getId()));
        VmHandler.updateNetworkInterfacesFromDb(vm);
        boolean isOldCluster = VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion());
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices, isOldCluster);
        return devices;
    }
    return Collections.emptyList();
}
#end_block

#method_before
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    List<VmDevice> cdList = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(oldVmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
    if (cdList.size() > 0) {
        // this is done only for safety, each VM must have at least an Empty CD
        // only one managed CD is currently supported.
        VmDevice cd = cdList.get(0);
        cd.getSpecParams().put(VdsProperties.Path, (newVmBase.getIsoPath() == null) ? "" : newVmBase.getIsoPath());
        dao.update(cd);
    }
}
#method_after
private static void updateCdInVmDevice(VmBase oldVmBase, VmBase newVmBase) {
    List<VmDevice> cdList = dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(oldVmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName());
    if (cdList.size() > 0) {
        // this is done only for safety, each VM must have at least an Empty CD
        // only one managed CD is currently supported.
        VmDevice cd = cdList.get(0);
        cd.getSpecParams().put(VdsProperties.Path, (newVmBase.getIsoPath() == null) ? "" : newVmBase.getIsoPath());
        dao.update(cd);
    }
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNic iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), null);
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNic iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, iface.isPassthrough() ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), null);
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#end_block

#method_before
private static void addUsbSlots(VmBase vm, int numOfSlots) {
    for (int index = 1; index <= numOfSlots; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC, getUsbSlotSpecParams(), true, false, null);
    }
}
#method_after
private static void addUsbSlots(VmBase vm, int numOfSlots) {
    for (int index = 1; index <= numOfSlots; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC, getUsbSlotSpecParams(), true, false, null, false);
    }
}
#end_block

#method_before
private static void addUsbControllers(VmBase vm, int numOfControllers) {
    // For each controller we need to create one EHCI and companion UHCI controllers
    for (int index = 0; index < numOfControllers; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false, null);
        for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false, null);
        }
    }
}
#method_after
private static void addUsbControllers(VmBase vm, int numOfControllers) {
    // For each controller we need to create one EHCI and companion UHCI controllers
    for (int index = 0; index < numOfControllers; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false, null, false);
        for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false, null, false);
        }
    }
}
#end_block

#method_before
private static void addEmptyCD(Guid dstId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, Collections.<String, Object>singletonMap(VdsProperties.Path, ""), true, true, null);
}
#method_after
private static void addEmptyCD(Guid dstId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, Collections.<String, Object>singletonMap(VdsProperties.Path, ""), true, true, null, false);
}
#end_block

#method_before
public static void updateMemoryBalloon(Guid id, boolean shouldHaveBalloon) {
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<String, Object>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.newGuid(), id), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true, null);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(id, VmDeviceGeneralType.BALLOON);
            removeNumberOfDevices(list, 1);
        }
    }
}
#method_after
public static void updateMemoryBalloon(Guid id, boolean shouldHaveBalloon) {
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<String, Object>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.newGuid(), id), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true, null, false);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(id, VmDeviceGeneralType.BALLOON);
            removeNumberOfDevices(list, 1);
        }
    }
}
#end_block

#method_before
private static boolean isDiskOrInterface(VmDevice vmDevice) {
    return VmDeviceCommonUtils.isDisk(vmDevice) || VmDeviceCommonUtils.isBridge(vmDevice);
}
#method_after
private static boolean isDiskOrInterface(VmDevice vmDevice) {
    return VmDeviceCommonUtils.isDisk(vmDevice) || VmDeviceCommonUtils.isNetwork(vmDevice);
}
#end_block

#method_before
public static boolean hasVmRngDevice(Guid vmId) {
    return !DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.RNG).isEmpty();
}
#method_after
public static boolean hasVmRngDevice(Guid vmId) {
    return !dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.RNG).isEmpty();
}
#end_block

#method_before
public static boolean hasVmGraphicsDeviceOfType(Guid vmId, GraphicsType type) {
    return !DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.GRAPHICS, type.name().toLowerCase()).isEmpty();
}
#method_after
public static boolean hasVmGraphicsDeviceOfType(Guid vmId, GraphicsType type) {
    return !dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmId, VmDeviceGeneralType.GRAPHICS, type.name().toLowerCase()).isEmpty();
}
#end_block

#method_before
public static List<VmDevice> getSoundDevices(Guid vmId) {
    return DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
}
#method_after
public static List<VmDevice> getSoundDevices(Guid vmId) {
    return dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
}
#end_block

#method_before
public static List<VmDevice> getBalloonDevices(Guid vmId) {
    return DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.BALLOON);
}
#method_after
public static List<VmDevice> getBalloonDevices(Guid vmId) {
    return dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.BALLOON);
}
#end_block

#method_before
public static List<VmDevice> getWatchdogs(Guid vmId) {
    return DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.WATCHDOG);
}
#method_after
public static List<VmDevice> getWatchdogs(Guid vmId) {
    return dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.WATCHDOG);
}
#end_block

#method_before
public static List<GraphicsType> getGraphicsTypesOfEntity(Guid entityId) {
    List<GraphicsType> result = new ArrayList<>();
    if (entityId != null) {
        List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(entityId, VmDeviceGeneralType.GRAPHICS);
        if (devices != null) {
            for (VmDevice device : devices) {
                result.add(GraphicsType.fromString(device.getDevice()));
            }
        }
    }
    return result;
}
#method_after
public static List<GraphicsType> getGraphicsTypesOfEntity(Guid entityId) {
    List<GraphicsType> result = new ArrayList<>();
    if (entityId != null) {
        List<VmDevice> devices = dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(entityId, VmDeviceGeneralType.GRAPHICS);
        if (devices != null) {
            for (VmDevice device : devices) {
                result.add(GraphicsType.fromString(device.getDevice()));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id.hashCode();
    result = prime * result + device.hashCode();
    result = prime * result + type.hashCode();
    result = prime * result + address.hashCode();
    result = prime * result + bootOrder;
    result = prime * result + ((specParams == null) ? 0 : specParams.hashCode());
    result = prime * result + (isManaged ? 1231 : 1237);
    result = prime * result + (isPlugged ? 1231 : 1237);
    result = prime * result + (getIsReadOnly() ? 1231 : 1237);
    result = prime * result + alias.hashCode();
    result = prime * result + (customProperties == null ? 0 : customProperties.hashCode());
    result = prime * result + (snapshotId == null ? 0 : snapshotId.hashCode());
    result = prime * result + (logicalName == null ? 0 : logicalName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id.hashCode();
    result = prime * result + device.hashCode();
    result = prime * result + type.hashCode();
    result = prime * result + address.hashCode();
    result = prime * result + bootOrder;
    result = prime * result + ((specParams == null) ? 0 : specParams.hashCode());
    result = prime * result + (isManaged ? 1231 : 1237);
    result = prime * result + (isPlugged ? 1231 : 1237);
    result = prime * result + (getIsReadOnly() ? 1231 : 1237);
    result = prime * result + alias.hashCode();
    result = prime * result + (customProperties == null ? 0 : customProperties.hashCode());
    result = prime * result + (snapshotId == null ? 0 : snapshotId.hashCode());
    result = prime * result + (logicalName == null ? 0 : logicalName.hashCode());
    result = prime * result + (usingScsiReservation ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && bootOrder == other.bootOrder && ObjectUtils.objectsEqual(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged().equals(other.getIsPlugged()) && getIsReadOnly().equals(other.getIsReadOnly()) && alias.equals(other.alias) && ObjectUtils.objectsEqual(customProperties, other.customProperties) && ObjectUtils.objectsEqual(snapshotId, other.snapshotId) && ObjectUtils.objectsEqual(logicalName, other.logicalName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmDevice)) {
        return false;
    }
    VmDevice other = (VmDevice) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && device.equals(other.device) && type.equals(other.type) && address.equals(other.address) && bootOrder == other.bootOrder && ObjectUtils.objectsEqual(specParams, other.specParams) && isManaged == other.isManaged && getIsPlugged().equals(other.getIsPlugged()) && getIsReadOnly().equals(other.getIsReadOnly()) && alias.equals(other.alias) && ObjectUtils.objectsEqual(customProperties, other.customProperties) && ObjectUtils.objectsEqual(snapshotId, other.snapshotId) && ObjectUtils.objectsEqual(logicalName, other.logicalName) && usingScsiReservation == other.usingScsiReservation);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder("VmDevice {");
    sb.append("vmId=");
    sb.append(id.getVmId());
    sb.append(", deviceId=");
    sb.append(id.getDeviceId());
    sb.append(", device=");
    sb.append(getDevice());
    sb.append(", type=");
    sb.append(getType());
    sb.append(", bootOrder=");
    sb.append(getBootOrder());
    sb.append(", specParams=");
    sb.append(getSpecParams());
    sb.append(", address=");
    sb.append(getAddress());
    sb.append(", managed=");
    sb.append(getIsManaged());
    sb.append(", plugged=");
    sb.append(getIsPlugged());
    sb.append(", readOnly=");
    sb.append(getIsReadOnly());
    sb.append(", deviceAlias=");
    sb.append(getAlias());
    sb.append(", customProperties=");
    sb.append(getCustomProperties());
    sb.append(", snapshotId=");
    sb.append(getSnapshotId());
    sb.append(", logicalName=");
    sb.append(getLogicalName());
    sb.append("}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", id).append("device", getDevice()).append("type", getType()).append("bootOrder", getBootOrder()).append("specParams", getSpecParams()).append("address", getAddress()).append("managed", getIsManaged()).append("plugged", getIsPlugged()).append("readOnly", getIsReadOnly()).append("deviceAlias", getAlias()).append("customProperties", getCustomProperties()).append("snapshotId", getSnapshotId()).append("logicalName", getLogicalName()).append("usingScsiReservation", isUsingScsiReservation()).build();
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("is_scsi_reservation_used", entity.isScsiReservationUsed());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("is_using_scsi_reservation", entity.isUsingScsiReservation());
}
#end_block

#method_before
@Override
public boolean isMemBalloonEnabled(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", vmId);
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("isMemBalloonEnabled").execute(parameterSource);
    String resultKey = dialect.getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Boolean) dbResults.get(resultKey)).booleanValue() : false;
}
#method_after
@Override
public boolean isMemBalloonEnabled(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", vmId);
    Map<String, Object> dbResults = new SimpleJdbcCall(getJdbcTemplate()).withFunctionName("isMemBalloonEnabled").execute(parameterSource);
    String resultKey = getDialect().getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Boolean) dbResults.get(resultKey)).booleanValue() : false;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    vmDevice.setScsiReservationUsed(rs.getBoolean("is_scsi_reservation_used"));
    return vmDevice;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    vmDevice.setUsingScsiReservation(rs.getBoolean("is_using_scsi_reservation"));
    return vmDevice;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits());
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null && !validate(diskValidator.isLunDiskVisible(lun, getVds()))) {
        return false;
    }
    // verify that scsi reservation is enabled only when scsi passthrough is enabled
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    if (lunDisk.isScsiReservationUsed() && !lunDisk.isScsiPassthrough()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_SCSI_RESERVATION_USE);
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null && !validate(diskValidator.isLunDiskVisible(lun, getVds()))) {
        return false;
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getParameters().getDiskInfo().setId(Guid.newGuid());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        createDiskBasedOnImage();
    } else {
        createDiskBasedOnLun(((LunDisk) getParameters().getDiskInfo()).isScsiReservationUsed());
    }
}
#method_after
@Override
protected void executeVmCommand() {
    getParameters().getDiskInfo().setId(Guid.newGuid());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
    }
}
#end_block

#method_before
private void createDiskBasedOnLun(final boolean isScsiReservationUsed) {
    final LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null, isScsiReservationUsed);
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#method_after
private void createDiskBasedOnLun() {
    final LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
private boolean shouldDiskBePlugged() {
    return getVm().getStatus() == VMStatus.Down && !Boolean.FALSE.equals(getParameters().getPlugDiskToVm());
}
#method_after
protected boolean shouldDiskBePlugged() {
    return getVm().getStatus() == VMStatus.Down && !Boolean.FALSE.equals(getParameters().getPlugDiskToVm());
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void addDiskPermissions(Disk disk) {
    if (getCurrentUser() != null) {
        Permissions perms = new Permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), disk.getId(), VdcObjectType.Disk);
        MultiLevelAdministrationHandler.addPermission(perms);
    }
}
#method_after
private void addDiskPermissions(Disk disk) {
    if (getCurrentUser() != null) {
        Permission perms = new Permission(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), disk.getId(), VdcObjectType.Disk);
        MultiLevelAdministrationHandler.addPermission(perms);
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getParameters().getDiskInfo().getDiskStorageType() == DiskStorageType.IMAGE) {
                return getExecuteAuditLogTypeValue(getSucceeded());
            } else {
                return getEndSuccessAuditLogTypeValue(getSucceeded());
            }
        case END_SUCCESS:
            return getEndSuccessAuditLogTypeValue(getSucceeded());
        default:
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isDiskStorageTypeRequiresExecuteState()) {
                return getExecuteAuditLogTypeValue(getSucceeded());
            } else {
                return getEndSuccessAuditLogTypeValue(getSucceeded());
            }
        case END_SUCCESS:
            return getEndSuccessAuditLogTypeValue(getSucceeded());
        default:
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
    }
}
#end_block

#method_before
private AuditLogType getEndSuccessAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS;
        }
    } else {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
        }
    }
}
#method_after
protected AuditLogType getEndSuccessAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS;
        }
    } else {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
        }
    }
}
#end_block

#method_before
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(getVmId(), getParameters().getDiskInfo().getId());
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            AuditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#method_after
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(getVmId(), getParameters().getDiskInfo().getId());
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#end_block

#method_before
protected boolean isEditEnabled() {
    return getIsFloating() || getIsNew() || getVm().isDown() || !getDisk().getPlugged();
}
#method_after
protected boolean isEditEnabled() {
    return (getIsFloating() || getIsNew() || getVm().isDown() || !getDisk().getPlugged()) && getIsChangable();
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    commonInitialize();
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
public void initialize(List<Disk> currentDisks) {
    commonInitialize();
    updateBootableFrom(currentDisks != null ? currentDisks : new ArrayList<Disk>());
}
#end_block

#method_before
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (!a.getStorageDomainType().isIsoOrImportExportDomain() && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            diskModel.setMessage(storage == null ? CONSTANTS.noActiveStorageDomainsInDC() : "");
        }
    }), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<>();
            switch(getDiskStorageType().getEntity()) {
                case IMAGE:
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageDomainType(storageDomains, StorageDomainType.Master));
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageDomainType(storageDomains, StorageDomainType.Data));
                    break;
                case CINDER:
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER));
                    break;
            }
            filteredStorageDomains = (ArrayList<StorageDomain>) Linq.filterStorageDomainsByStorageStatus(filteredStorageDomains, StorageDomainStatus.Active);
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains, storage);
            if (storage == null) {
                switch(getDiskStorageType().getEntity()) {
                    case IMAGE:
                        diskModel.setMessage(constants.noActiveStorageDomainsInDC());
                        break;
                    case CINDER:
                        diskModel.setMessage(constants.noCinderStorageDomainsInDC());
                        break;
                }
            }
        }
    }), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById((new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters);
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(CONSTANTS.relevantDCnotActive());
                }
            }
        })), getVm().getStoragePoolId());
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<StoragePool>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(CONSTANTS.noActiveDataCenters());
                }
            }
        }));
    }
}
#method_after
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById((new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters, Linq.firstOrDefault(dataCenters));
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(constants.relevantDCnotActive());
                }
            }
        })), getVm().getStoragePoolId());
        updateBootableDiskAvailable();
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<StoragePool>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(constants.noActiveDataCenters());
                }
            }
        }));
    }
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            updateBootableFrom(disks);
        }
    }), getVm().getId());
}
#end_block

#method_before
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupported());
    getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
}
#method_after
private void updateShareableDiskEnabled(StoragePool datacenter) {
    boolean isShareableDiskEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.ShareableDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsShareable().setChangeProhibitionReason(constants.shareableDiskNotSupported());
    getIsShareable().setIsChangable(isShareableDiskEnabled && isEditEnabled());
}
#end_block

#method_before
private void updateDirectLunDiskEnabled(StoragePool datacenter) {
    if (getDiskStorageType().getEntity() != DiskStorageType.LUN) {
        return;
    }
    boolean isDirectLUNDiskkEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DirectLUNDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsDirectLunDiskAvaialable().setEntity(isDirectLUNDiskkEnabled);
    // $NON-NLS-1$
    setMessage(!isDirectLUNDiskkEnabled ? CONSTANTS.directLUNDiskNotSupported() : "");
}
#method_after
private void updateDirectLunDiskEnabled(StoragePool datacenter) {
    if (getDiskStorageType().getEntity() != DiskStorageType.LUN) {
        return;
    }
    boolean isDirectLUNDiskkEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DirectLUNDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsDirectLunDiskAvaialable().setEntity(isDirectLUNDiskkEnabled);
    // $NON-NLS-1$
    setMessage(!isDirectLUNDiskkEnabled ? constants.directLUNDiskNotSupported() : "");
}
#end_block

#method_before
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#method_after
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(constants.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#end_block

#method_before
private void setDiskProfilesList(List<DiskProfile> diskProfiles) {
    // set disk profiles
    if (diskProfiles != null && !diskProfiles.isEmpty()) {
        getDiskProfile().setItems(diskProfiles);
    }
    // handle disk profile selected item
    Guid defaultProfileId = getDisk() != null ? ((DiskImage) getDisk()).getDiskProfileId() : null;
    if (defaultProfileId != null) {
        for (DiskProfile profile : diskProfiles) {
            if (profile.getId().equals(defaultProfileId)) {
                getDiskProfile().setSelectedItem(profile);
                return;
            }
        }
        // set dummy disk profile (if not fetched because of permissions, and it's attached to disk.
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(defaultProfileId);
        if (getDisk() != null) {
            diskProfile.setName(getDiskImage().getDiskProfileName());
        }
        diskProfiles.add(diskProfile);
        getDiskProfile().setItems(diskProfiles);
        getDiskProfile().setSelectedItem(diskProfile);
    }
}
#method_after
private void setDiskProfilesList(List<DiskProfile> diskProfiles) {
    // set disk profiles
    if (diskProfiles != null && !diskProfiles.isEmpty()) {
        getDiskProfile().setItems(diskProfiles);
    }
    // handle disk profile selected item
    Guid defaultProfileId = (getDisk() != null && getDisk().getDiskStorageType() == DiskStorageType.IMAGE) ? ((DiskImage) getDisk()).getDiskProfileId() : null;
    if (defaultProfileId != null) {
        for (DiskProfile profile : diskProfiles) {
            if (profile.getId().equals(defaultProfileId)) {
                getDiskProfile().setSelectedItem(profile);
                return;
            }
        }
        // set dummy disk profile (if not fetched because of permissions, and it's attached to disk.
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(defaultProfileId);
        if (getDisk() != null) {
            diskProfile.setName(getDiskImage().getDiskProfileName());
        }
        diskProfiles.add(diskProfile);
        getDiskProfile().setItems(diskProfiles);
        getDiskProfile().setSelectedItem(diskProfile);
    }
}
#end_block

#method_before
protected void diskStorageType_EntityChanged() {
    boolean isInVm = getVm() != null;
    boolean isDiskImage = getDiskStorageType().getEntity() == DiskStorageType.IMAGE;
    boolean isLunDisk = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    getSize().setIsAvailable(isDiskImage);
    getSizeExtend().setIsAvailable(isDiskImage && !getIsNew());
    getStorageDomain().setIsAvailable(isDiskImage);
    getVolumeType().setIsAvailable(isDiskImage);
    getIsWipeAfterDelete().setIsAvailable(isDiskImage);
    getHost().setIsAvailable(isLunDisk);
    getStorageType().setIsAvailable(isLunDisk);
    getDataCenter().setIsAvailable(!isInVm);
    getDiskProfile().setIsAvailable(isDiskImage);
    if (!isDiskImage) {
        previousIsQuotaAvailable = getQuota().getIsAvailable();
    }
    getQuota().setIsAvailable(isDiskImage ? previousIsQuotaAvailable : false);
    updateDatacenters();
}
#method_after
protected void diskStorageType_EntityChanged() {
    boolean isInVm = getVm() != null;
    boolean isDiskImage = getDiskStorageType().getEntity() == DiskStorageType.IMAGE;
    boolean isLunDisk = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    boolean isCinderDisk = getDiskStorageType().getEntity() == DiskStorageType.CINDER;
    getSize().setIsAvailable(isDiskImage || isCinderDisk);
    getSizeExtend().setIsAvailable((isDiskImage || isCinderDisk) && !getIsNew());
    getStorageDomain().setIsAvailable(isDiskImage || isCinderDisk);
    getVolumeType().setIsAvailable(isDiskImage);
    getIsWipeAfterDelete().setIsAvailable(isDiskImage);
    getHost().setIsAvailable(isLunDisk);
    getStorageType().setIsAvailable(isLunDisk);
    getDataCenter().setIsAvailable(!isInVm);
    getDiskProfile().setIsAvailable(isDiskImage);
    getCinderVolumeType().setIsAvailable(isCinderDisk);
    if (!isDiskImage) {
        previousIsQuotaAvailable = getQuota().getIsAvailable();
    }
    getQuota().setIsAvailable(isDiskImage ? previousIsQuotaAvailable : false);
    setIsChangable(true);
    updateDatacenters();
}
#end_block

#method_before
protected void volumeType_SelectedItemChanged() {
    if (getVolumeType().getSelectedItem() == null || getDataCenter().getSelectedItem() == null || getStorageDomain().getSelectedItem() == null) {
        return;
    }
    VolumeType volumeType = getVolumeType().getSelectedItem();
    StorageType storageType = getStorageDomain().getSelectedItem().getStorageType();
    updateVolumeFormat(volumeType, storageType);
    updateShareable(volumeType, storageType);
}
#method_after
protected void volumeType_SelectedItemChanged() {
    if (getVolumeType().getSelectedItem() == null || getDataCenter().getSelectedItem() == null || getStorageDomain().getSelectedItem() == null) {
        return;
    }
    VolumeType volumeType = getVolumeType().getSelectedItem();
    StorageType storageType = getStorageDomain().getSelectedItem().getStorageType();
    updateShareable(volumeType, storageType);
}
#end_block

#method_before
private void DiskInterface_SelectedItemChanged() {
    boolean isLunDisk = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsScsiPassthrough().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsScsiReservationUsed().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    updateScsiPassthroguhChangeability();
    changeScsiReservationChangeability();
    updateReadOnlyChangeability();
    updatePlugChangeability();
}
#method_after
private void DiskInterface_SelectedItemChanged() {
    boolean isLunDisk = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    getIsSgIoUnfiltered().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsScsiPassthrough().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    getIsUsingScsiReservation().setIsAvailable(isLunDisk && DiskInterface.VirtIO_SCSI.equals(diskInterface));
    updateScsiPassthroguhChangeability();
    updateScsiReservationChangeability();
    updateReadOnlyChangeability();
    updatePlugChangeability();
}
#end_block

#method_before
protected void updateScsiPassthroguhChangeability() {
    getIsScsiPassthrough().setIsChangable(!getIsReadOnly().getEntity() && isEditEnabled());
    getIsScsiPassthrough().setChangeProhibitionReason(CONSTANTS.cannotEnableScsiPassthroughForLunReadOnlyDisk());
    updateSgIoUnfilteredChangeability();
}
#method_after
protected void updateScsiPassthroguhChangeability() {
    getIsScsiPassthrough().setIsChangable(!getIsReadOnly().getEntity() && isEditEnabled());
    getIsScsiPassthrough().setChangeProhibitionReason(constants.cannotEnableScsiPassthroughForLunReadOnlyDisk());
    updateSgIoUnfilteredChangeability();
}
#end_block

#method_before
protected void updateSgIoUnfilteredChangeability() {
    if (!getIsScsiPassthrough().getEntity()) {
        getIsSgIoUnfiltered().setChangeProhibitionReason(CONSTANTS.cannotEnableSgioWhenScsiPassthroughDisabled());
        getIsSgIoUnfiltered().setIsChangable(false);
        getIsSgIoUnfiltered().setEntity(false);
        return;
    }
    getIsSgIoUnfiltered().setIsChangable(isEditEnabled());
}
#method_after
protected void updateSgIoUnfilteredChangeability() {
    if (!getIsScsiPassthrough().getEntity()) {
        getIsSgIoUnfiltered().setChangeProhibitionReason(constants.cannotEnableSgioWhenScsiPassthroughDisabled());
        getIsSgIoUnfiltered().setIsChangable(false);
        getIsSgIoUnfiltered().setEntity(false);
        return;
    }
    getIsSgIoUnfiltered().setIsChangable(isEditEnabled());
}
#end_block

#method_before
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    boolean isScsiPassthrough = getIsScsiPassthrough().getEntity();
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN && isScsiPassthrough) {
        getIsReadOnly().setChangeProhibitionReason(CONSTANTS.cannotEnableReadonlyWhenScsiPassthroughEnabled());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    if (isVmAttachedToPool() && !getIsNew()) {
        getIsReadOnly().setIsChangable(false);
    } else {
        getIsReadOnly().setIsChangable(isEditEnabled());
    }
    getIsReadOnly().setEntity(getIsNew() ? Boolean.FALSE : getDisk().getReadOnly());
}
#method_after
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(constants.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    boolean isScsiPassthrough = getIsScsiPassthrough().getEntity();
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN && isScsiPassthrough) {
        getIsReadOnly().setChangeProhibitionReason(constants.cannotEnableReadonlyWhenScsiPassthroughEnabled());
        getIsReadOnly().setIsChangable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    if (isVmAttachedToPool() && !getIsNew()) {
        getIsReadOnly().setIsChangable(false);
    } else {
        getIsReadOnly().setIsChangable(isEditEnabled());
    }
    getIsReadOnly().setEntity(getIsNew() ? Boolean.FALSE : getDisk().getReadOnly());
}
#end_block

#method_before
private void updatePlugChangeability() {
    if (getVm() == null) {
        // No point in updating plug to VM if there's no VM
        return;
    }
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    boolean isVmRunning = getVm() != null && getVm().getStatus() != VMStatus.Down;
    if (DiskInterface.IDE.equals(diskInterface) && isVmRunning) {
        getIsPlugged().setChangeProhibitionReason(CONSTANTS.cannotHotPlugDiskWithIdeInterface());
        getIsPlugged().setIsChangable(false);
        getIsPlugged().setEntity(false);
    } else {
        if (!canDiskBePlugged(getVm())) {
            getIsPlugged().setChangeProhibitionReason(CONSTANTS.cannotPlugDiskIncorrectVmStatus());
            getIsPlugged().setIsChangable(false);
            getIsPlugged().setEntity(false);
        } else {
            getIsPlugged().setIsChangable(isEditEnabled());
            getIsPlugged().setEntity(true);
        }
    }
}
#method_after
private void updatePlugChangeability() {
    if (getVm() == null) {
        // No point in updating plug to VM if there's no VM
        return;
    }
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    boolean isVmRunning = getVm() != null && getVm().getStatus() != VMStatus.Down;
    if (DiskInterface.IDE.equals(diskInterface) && isVmRunning) {
        getIsPlugged().setChangeProhibitionReason(constants.cannotHotPlugDiskWithIdeInterface());
        getIsPlugged().setIsChangable(false);
        getIsPlugged().setEntity(false);
    } else {
        if (!canDiskBePlugged(getVm())) {
            getIsPlugged().setChangeProhibitionReason(constants.cannotPlugDiskIncorrectVmStatus());
            getIsPlugged().setIsChangable(false);
            getIsPlugged().setEntity(false);
        } else {
            getIsPlugged().setIsChangable(isEditEnabled());
            getIsPlugged().setEntity(true);
        }
    }
}
#end_block

#method_before
private void datacenter_SelectedItemChanged() {
    StoragePool datacenter = getDataCenter().getSelectedItem();
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    updateInterface(isInVm ? getVm().getVdsGroupCompatibilityVersion() : null);
    if (getDiskStorageType().getEntity() == DiskStorageType.IMAGE) {
        updateStorageDomains(datacenter);
    } else {
        updateHosts(datacenter);
    }
}
#method_after
protected void datacenter_SelectedItemChanged() {
    StoragePool datacenter = getDataCenter().getSelectedItem();
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    updateInterface(isInVm ? getVm().getVdsGroupCompatibilityVersion() : null);
    switch(getDiskStorageType().getEntity()) {
        case IMAGE:
        case CINDER:
            updateStorageDomains(datacenter);
            break;
        default:
            updateHosts(datacenter);
            break;
    }
}
#end_block

#method_before
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        if (getIsNew()) {
            getIsWipeAfterDelete().setEntity(selectedStorage.getWipeAfterDelete());
        }
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
}
#method_after
private void storageDomain_SelectedItemChanged() {
    StorageDomain selectedStorage = getStorageDomain().getSelectedItem();
    if (selectedStorage != null) {
        updateVolumeType(selectedStorage.getStorageType());
        if (getIsNew()) {
            getIsWipeAfterDelete().setEntity(selectedStorage.getWipeAfterDelete());
        }
    }
    updateQuota(getDataCenter().getSelectedItem());
    updateDiskProfiles(getDataCenter().getSelectedItem());
    updateCinderVolumeTypes();
}
#end_block

#method_before
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    if (getVm() == null) {
        getAlias().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    } else {
        getAlias().validateEntity(new IValidation[] { new I18NNameValidation() });
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid();
}
#method_after
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    if (getVm() == null) {
        getAlias().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    } else {
        getAlias().validateEntity(new IValidation[] { new I18NNameValidation() });
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getCinderVolumeType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid();
}
#end_block

#method_before
protected void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    ConfirmationModel confirmationModel = new ConfirmationModel();
    setConfirmWindow(confirmationModel);
    confirmationModel.setTitle(CONSTANTS.forceStorageDomainCreation());
    confirmationModel.setMessage(CONSTANTS.lunsAlreadyPartOfSD());
    confirmationModel.setHelpTag(HelpTag.force_lun_disk_creation);
    // $NON-NLS-1$
    confirmationModel.setHashName("force_lun_disk_creation");
    confirmationModel.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand forceSaveCommand = new UICommand("OnForceSave", this);
    forceSaveCommand.setTitle(CONSTANTS.ok());
    forceSaveCommand.setIsDefault(true);
    confirmationModel.getCommands().add(forceSaveCommand);
    // $NON-NLS-1$
    UICommand cancelconfirmCommand = new UICommand("CancelConfirm", this);
    cancelconfirmCommand.setTitle(CONSTANTS.cancel());
    cancelconfirmCommand.setIsCancel(true);
    confirmationModel.getCommands().add(cancelconfirmCommand);
}
#method_after
protected void forceCreationWarning(ArrayList<String> usedLunsMessages) {
    ConfirmationModel confirmationModel = new ConfirmationModel();
    setConfirmWindow(confirmationModel);
    confirmationModel.setTitle(constants.forceStorageDomainCreation());
    confirmationModel.setMessage(constants.lunsAlreadyPartOfSD());
    confirmationModel.setHelpTag(HelpTag.force_lun_disk_creation);
    // $NON-NLS-1$
    confirmationModel.setHashName("force_lun_disk_creation");
    confirmationModel.setItems(usedLunsMessages);
    // $NON-NLS-1$
    UICommand forceSaveCommand = new UICommand("OnForceSave", this);
    forceSaveCommand.setTitle(constants.ok());
    forceSaveCommand.setIsDefault(true);
    confirmationModel.getCommands().add(forceSaveCommand);
    // $NON-NLS-1$
    UICommand cancelconfirmCommand = new UICommand("CancelConfirm", this);
    cancelconfirmCommand.setTitle(constants.cancel());
    cancelconfirmCommand.setIsCancel(true);
    confirmationModel.getCommands().add(cancelconfirmCommand);
}
#end_block

#method_before
public void onSave() {
    if (getDiskStorageType().getEntity() == DiskStorageType.IMAGE) {
        DiskImage diskImage = getDiskImage();
        if (getQuota().getIsAvailable() && getQuota().getSelectedItem() != null) {
            diskImage.setQuotaId(getQuota().getSelectedItem().getId());
        }
        long sizeToAddInGigabytes = Long.valueOf(getSizeExtend().getEntity());
        if (sizeToAddInGigabytes > 0) {
            diskImage.setSizeInGigabytes(diskImage.getSizeInGigabytes() + sizeToAddInGigabytes);
        }
        setDisk(diskImage);
    } else {
        LunDisk lunDisk = getLunDisk();
        DiskInterface diskInterface = getDiskInterface().getSelectedItem();
        if (DiskInterface.VirtIO_SCSI.equals(diskInterface) && getIsScsiPassthrough().getEntity()) {
            lunDisk.setSgio(getIsSgIoUnfiltered().getEntity() ? ScsiGenericIO.UNFILTERED : ScsiGenericIO.FILTERED);
            lunDisk.setScsiReservationUsed(getIsScsiReservationUsed().getEntity());
        } else {
            getIsScsiPassthrough().setEntity(false);
            lunDisk.setSgio(null);
            lunDisk.setScsiReservationUsed(false);
        }
        setDisk(lunDisk);
    }
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskProfile selectedDiskProfile = getDiskProfile().getSelectedItem();
        if (selectedDiskProfile != null) {
            ((DiskImage) getDisk()).setDiskProfileId(selectedDiskProfile.getId());
        }
    }
    getDisk().setDiskAlias(getAlias().getEntity());
    getDisk().setDiskDescription(getDescription().getEntity());
    getDisk().setDiskInterface(getDiskInterface().getSelectedItem());
    getDisk().setWipeAfterDelete(getIsWipeAfterDelete().getEntity());
    getDisk().setBoot(getIsBootable().getEntity());
    getDisk().setShareable(getIsShareable().getEntity());
    getDisk().setPlugged(getIsPlugged().getEntity());
    getDisk().setPropagateErrors(PropagateErrors.Off);
    getDisk().setReadOnly(getIsReadOnly().getIsAvailable() ? getIsReadOnly().getEntity() : null);
}
#method_after
public void onSave() {
    flush();
    store(null);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateScsiPassthroguhChangeability();
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
            changeScsiReservationChangeability();
        } else if (sender == getDiskStorageType()) {
            diskStorageType_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVolumeType()) {
            volumeType_SelectedItemChanged();
        } else if (sender == getDiskInterface()) {
            DiskInterface_SelectedItemChanged();
        } else if (sender == getDataCenter()) {
            datacenter_SelectedItemChanged();
        } else if (sender == getStorageDomain()) {
            storageDomain_SelectedItemChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getIsReadOnly()) {
            updateScsiPassthroguhChangeability();
        } else if (sender == getIsScsiPassthrough()) {
            updateScsiPassthroguhChangeability();
            updateSgIoUnfilteredChangeability();
            updateReadOnlyChangeability();
            updateScsiReservationChangeability();
        } else if (sender == getIsSgIoUnfiltered()) {
            updateScsiReservationChangeability();
        } else if (sender == getDiskStorageType()) {
            diskStorageType_EntityChanged();
        }
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVolumeType()) {
            volumeType_SelectedItemChanged();
        } else if (sender == getDiskInterface()) {
            DiskInterface_SelectedItemChanged();
        } else if (sender == getDataCenter()) {
            datacenter_SelectedItemChanged();
        } else if (sender == getStorageDomain()) {
            storageDomain_SelectedItemChanged();
        }
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (compatVersion == null ? 0 : compatVersion.hashCode());
    result = prime * result + (compatibilityVersion == null ? 0 : compatibilityVersion.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (description == null ? 0 : description.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + (migrateOnError == null ? 0 : migrateOnError.hashCode());
    result = prime * result + (name == null ? 0 : name.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + (clusterPolicyName == null ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + (optimizationType == null ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (groupHostsAndVms == null ? 0 : groupHostsAndVms.hashCode());
    result = prime * result + (fencingPolicy == null ? 0 : fencingPolicy.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + (tunedProfile == null ? 0 : tunedProfile.hashCode());
    result = prime * result + (maintenanceReasonRequired ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (compatVersion == null ? 0 : compatVersion.hashCode());
    result = prime * result + (compatibilityVersion == null ? 0 : compatibilityVersion.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (description == null ? 0 : description.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + (migrateOnError == null ? 0 : migrateOnError.hashCode());
    result = prime * result + (name == null ? 0 : name.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + (clusterPolicyName == null ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + (optimizationType == null ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (groupHostsAndVms == null ? 0 : groupHostsAndVms.hashCode());
    result = prime * result + (fencingPolicy == null ? 0 : fencingPolicy.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + (glusterTunedProfile == null ? 0 : glusterTunedProfile.hashCode());
    result = prime * result + (maintenanceReasonRequired ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDSGroup)) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(groupHostsAndVms, other.groupHostsAndVms) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources) && ObjectUtils.objectsEqual(fencingPolicy, other.fencingPolicy) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(tunedProfile, other.tunedProfile) && ObjectUtils.objectsEqual(maintenanceReasonRequired, other.maintenanceReasonRequired);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDSGroup)) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(groupHostsAndVms, other.groupHostsAndVms) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources) && ObjectUtils.objectsEqual(fencingPolicy, other.fencingPolicy) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(glusterTunedProfile, other.glusterTunedProfile) && ObjectUtils.objectsEqual(maintenanceReasonRequired, other.maintenanceReasonRequired);
}
#end_block

#method_before
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getDescription()).addValue("name", group.getName()).addValue("free_text_comment", group.getComment()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getCpuName()).addValue("storage_pool_id", group.getStoragePoolId()).addValue("max_vds_memory_over_commit", group.getMaxVdsMemoryOverCommit()).addValue("count_threads_as_cores", group.getCountThreadsAsCores()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getCompatibilityVersion()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService()).addValue("tunnel_migration", group.isTunnelMigration()).addValue("required_rng_sources", VmRngDevice.sourcesToCsv(group.getRequiredRngSources())).addValue("emulated_machine", group.getEmulatedMachine()).addValue("detect_emulated_machine", group.isDetectEmulatedMachine()).addValue("trusted_service", group.supportsTrustedService()).addValue("ha_reservation", group.supportsHaReservation()).addValue("optional_reason", group.isOptionalReasonRequired()).addValue("maintenance_reason_required", group.isMaintenanceReasonRequired()).addValue("cluster_policy_id", group.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(group.getClusterPolicyProperties())).addValue("architecture", group.getArchitecture()).addValue("enable_balloon", group.isEnableBallooning()).addValue("optimization_type", group.getOptimizationType()).addValue("enable_ksm", group.isEnableKsm()).addValue("spice_proxy", group.getSpiceProxy()).addValue("serial_number_policy", group.getSerialNumberPolicy() == null ? null : group.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", group.getCustomSerialNumber()).addValue("skip_fencing_if_sd_active", group.getFencingPolicy().isSkipFencingIfSDActive()).addValue("skip_fencing_if_connectivity_broken", group.getFencingPolicy().isSkipFencingIfConnectivityBroken()).addValue("hosts_with_broken_connectivity_threshold", group.getFencingPolicy().getHostsWithBrokenConnectivityThreshold()).addValue("fencing_enabled", group.getFencingPolicy().isFencingEnabled()).addValue("is_auto_converge", group.getAutoConverge()).addValue("is_migrate_compressed", group.getMigrateCompressed()).addValue("tuned_profile", group.getTunedProfile());
    return parameterSource;
}
#method_after
private MapSqlParameterSource getVdsGroupParamSource(VDSGroup group) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("description", group.getDescription()).addValue("name", group.getName()).addValue("free_text_comment", group.getComment()).addValue("vds_group_id", group.getId()).addValue("cpu_name", group.getCpuName()).addValue("storage_pool_id", group.getStoragePoolId()).addValue("max_vds_memory_over_commit", group.getMaxVdsMemoryOverCommit()).addValue("count_threads_as_cores", group.getCountThreadsAsCores()).addValue("transparent_hugepages", group.getTransparentHugepages()).addValue("compatibility_version", group.getCompatibilityVersion()).addValue("migrate_on_error", group.getMigrateOnError()).addValue("virt_service", group.supportsVirtService()).addValue("gluster_service", group.supportsGlusterService()).addValue("tunnel_migration", group.isTunnelMigration()).addValue("required_rng_sources", VmRngDevice.sourcesToCsv(group.getRequiredRngSources())).addValue("emulated_machine", group.getEmulatedMachine()).addValue("detect_emulated_machine", group.isDetectEmulatedMachine()).addValue("trusted_service", group.supportsTrustedService()).addValue("ha_reservation", group.supportsHaReservation()).addValue("optional_reason", group.isOptionalReasonRequired()).addValue("maintenance_reason_required", group.isMaintenanceReasonRequired()).addValue("cluster_policy_id", group.getClusterPolicyId()).addValue("cluster_policy_custom_properties", SerializationFactory.getSerializer().serialize(group.getClusterPolicyProperties())).addValue("architecture", group.getArchitecture()).addValue("enable_balloon", group.isEnableBallooning()).addValue("optimization_type", group.getOptimizationType()).addValue("enable_ksm", group.isEnableKsm()).addValue("spice_proxy", group.getSpiceProxy()).addValue("serial_number_policy", group.getSerialNumberPolicy() == null ? null : group.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", group.getCustomSerialNumber()).addValue("skip_fencing_if_sd_active", group.getFencingPolicy().isSkipFencingIfSDActive()).addValue("skip_fencing_if_connectivity_broken", group.getFencingPolicy().isSkipFencingIfConnectivityBroken()).addValue("hosts_with_broken_connectivity_threshold", group.getFencingPolicy().getHostsWithBrokenConnectivityThreshold()).addValue("fencing_enabled", group.getFencingPolicy().isFencingEnabled()).addValue("is_auto_converge", group.getAutoConverge()).addValue("is_migrate_compressed", group.getMigrateCompressed()).addValue("gluster_tuned_profile", group.getGlusterTunedProfile());
    return parameterSource;
}
#end_block

#method_before
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setDescription(rs.getString("description"));
    entity.setName(rs.getString("name"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setCompatibilityVersion(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    entity.setTunnelMigration(rs.getBoolean("tunnel_migration"));
    entity.getRequiredRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("required_rng_sources")));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    entity.setDetectEmulatedMachine(rs.getBoolean("detect_emulated_machine"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setHaReservation(rs.getBoolean("ha_reservation"));
    entity.setOptionalReasonRequired(rs.getBoolean("optional_reason"));
    entity.setMaintenanceReasonRequired(rs.getBoolean("maintenance_reason_required"));
    entity.setClusterPolicyId(Guid.createGuidFromString(rs.getString("cluster_policy_id")));
    entity.setClusterPolicyName(rs.getString("cluster_policy_name"));
    entity.setClusterPolicyProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("cluster_policy_custom_properties"), LinkedHashMap.class));
    entity.setEnableBallooning(rs.getBoolean("enable_balloon"));
    entity.setEnableKsm(rs.getBoolean("enable_ksm"));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOptimizationType(OptimizationType.from(rs.getInt("optimization_type")));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.getFencingPolicy().setSkipFencingIfSDActive(rs.getBoolean("skip_fencing_if_sd_active"));
    entity.getFencingPolicy().setSkipFencingIfConnectivityBroken(rs.getBoolean("skip_fencing_if_connectivity_broken"));
    entity.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(rs.getInt("hosts_with_broken_connectivity_threshold"));
    entity.getFencingPolicy().setFencingEnabled(rs.getBoolean("fencing_enabled"));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    entity.setTunedProfile(rs.getString("tuned_profile"));
    return entity;
}
#method_after
@Override
public VDSGroup mapRow(ResultSet rs, int rowNum) throws SQLException {
    VDSGroup entity = new VDSGroup();
    entity.setDescription(rs.getString("description"));
    entity.setName(rs.getString("name"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCountThreadsAsCores(rs.getBoolean("count_threads_as_cores"));
    entity.setTransparentHugepages(rs.getBoolean("transparent_hugepages"));
    entity.setCompatibilityVersion(new Version(rs.getString("compatibility_version")));
    entity.setMigrateOnError(MigrateOnErrorOptions.forValue(rs.getInt("migrate_on_error")));
    entity.setVirtService(rs.getBoolean("virt_service"));
    entity.setGlusterService(rs.getBoolean("gluster_service"));
    entity.setTunnelMigration(rs.getBoolean("tunnel_migration"));
    entity.getRequiredRngSources().addAll(VmRngDevice.csvToSourcesSet(rs.getString("required_rng_sources")));
    entity.setEmulatedMachine(rs.getString("emulated_machine"));
    entity.setDetectEmulatedMachine(rs.getBoolean("detect_emulated_machine"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setHaReservation(rs.getBoolean("ha_reservation"));
    entity.setOptionalReasonRequired(rs.getBoolean("optional_reason"));
    entity.setMaintenanceReasonRequired(rs.getBoolean("maintenance_reason_required"));
    entity.setClusterPolicyId(Guid.createGuidFromString(rs.getString("cluster_policy_id")));
    entity.setClusterPolicyName(rs.getString("cluster_policy_name"));
    entity.setClusterPolicyProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("cluster_policy_custom_properties"), LinkedHashMap.class));
    entity.setEnableBallooning(rs.getBoolean("enable_balloon"));
    entity.setEnableKsm(rs.getBoolean("enable_ksm"));
    entity.setArchitecture(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOptimizationType(OptimizationType.from(rs.getInt("optimization_type")));
    entity.setSpiceProxy(rs.getString("spice_proxy"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.getFencingPolicy().setSkipFencingIfSDActive(rs.getBoolean("skip_fencing_if_sd_active"));
    entity.getFencingPolicy().setSkipFencingIfConnectivityBroken(rs.getBoolean("skip_fencing_if_connectivity_broken"));
    entity.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(rs.getInt("hosts_with_broken_connectivity_threshold"));
    entity.getFencingPolicy().setFencingEnabled(rs.getBoolean("fencing_enabled"));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    entity.setGlusterTunedProfile(rs.getString("gluster_tuned_profile"));
    return entity;
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangable(cluster.getGroupHostsAndVms().getHosts() == 0);
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setTunedProfile(model.getTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void updateActionAvailability() {
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster));
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    getResetEmulatedMachineCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster));
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuThreads".equals(command.getName())) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuLevel".equals(command.getName())) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnSaveHosts".equals(command.getName())) {
        onSaveHosts();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getResetEmulatedMachineCommand()) {
        resetEmulatedMachine();
    } else if ("OnResetClusterEmulatedMachine".equals(command.getName())) {
        // $NON-NLS-1$
        onResetClusterEmulatedMachine();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuThreads".equals(command.getName())) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuLevel".equals(command.getName())) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnSaveHosts".equals(command.getName())) {
        onSaveHosts();
    }
}
#end_block

#method_before
private void initTunedProfiles() {
    this.startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterTunedProfiles, new VdcQueryParametersBase(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterModel.this.stopProgress();
            List<String> tunedProfiles = new ArrayList<>();
            if (((VdcQueryReturnValue) returnValue).getSucceeded()) {
                // $NON-NLS-1$
                tunedProfiles.addAll(Arrays.asList(((String) ((VdcQueryReturnValue) returnValue).getReturnValue()).split(",")));
            }
            tunedProfile.setItems(tunedProfiles);
        }
    }));
}
#method_after
public void initTunedProfiles() {
    this.startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterTunedProfiles, new VdcQueryParametersBase(), new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ClusterModel.this.stopProgress();
            List<String> glusterTunedProfiles = new ArrayList<>();
            if (((VdcQueryReturnValue) returnValue).getSucceeded()) {
                glusterTunedProfiles.addAll((List<String>) (((VdcQueryReturnValue) returnValue).getReturnValue()));
            }
            glusterTunedProfile.setItems(glusterTunedProfiles, glusterTunedProfile.getSelectedItem());
            glusterTunedProfile.setIsAvailable(glusterTunedProfile.getItems().size() > 0);
        }
    }));
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setEnableHostMaintenanceReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<Boolean>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    setGlusterTunedProfile(new ListModel<String>());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
            getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
            if (getEnableGlusterService().getEntity()) {
                initTunedProfiles();
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<Boolean>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void setVisibilities() {
    tunedProfileEditor.setVisible(ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
}
#method_after
private void setVisibilities() {
    rngLabel.setVisible(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#end_block

#method_before
private void localize() {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    managementNetworkEditor.setLabel(constants.managementNetworkLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    tunedProfileEditor.setLabel(constants.tunedProfileLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    enableHostMaintenanceReasonEditor.setLabel(constants.clusterPolicyEnableHostMaintenanceReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
    skipFencingIfConnectivityBrokenCheckBox.setLabel(constants.skipFencingWhenConnectivityBroken());
    hostsWithBrokenConnectivityThresholdEditor.setLabel(constants.hostsWithBrokenConnectivityThresholdLabel());
}
#method_after
private void localize() {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    managementNetworkEditor.setLabel(constants.managementNetworkLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    glusterTunedProfileEditor.setLabel(constants.glusterTunedProfileLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    enableHostMaintenanceReasonEditor.setLabel(constants.clusterPolicyEnableHostMaintenanceReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
    skipFencingIfConnectivityBrokenCheckBox.setLabel(constants.skipFencingWhenConnectivityBroken());
    hostsWithBrokenConnectivityThresholdEditor.setLabel(constants.hostsWithBrokenConnectivityThresholdLabel());
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getBookmarkDao();
    // create some test data
    new_bookmark = new Bookmark();
    Random r = new Random(System.currentTimeMillis());
    new_bookmark.setbookmark_id(Guid.newGuid());
    new_bookmark.setbookmark_name("newbookmarkname" + (r.nextInt() % BOOKMARK_MAX_RANDOM_NUMBER));
    new_bookmark.setbookmark_value("newbookmarkvalue");
    existing_bookmark = dao.get(new Guid("a4affabf-7b45-4a6c-b0a9-107d0bbe265e"));
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getBookmarkDao();
    // create some test data
    newBookmark = new Bookmark();
    Random r = new Random(System.currentTimeMillis());
    newBookmark.setbookmark_id(Guid.newGuid());
    newBookmark.setbookmark_name("newbookmarkname" + (r.nextInt() % BOOKMARK_MAX_RANDOM_NUMBER));
    newBookmark.setbookmark_value("newbookmarkvalue");
    existingBookmark = dao.get(new Guid("a4affabf-7b45-4a6c-b0a9-107d0bbe265e"));
}
#end_block

#method_before
@Test
public void testGetByName() {
    Bookmark result = dao.getByName(existing_bookmark.getbookmark_name());
    assertNotNull(result);
    assertEquals(existing_bookmark.getbookmark_name(), result.getbookmark_name());
}
#method_after
@Test
public void testGetByName() {
    Bookmark result = dao.getByName(existingBookmark.getbookmark_name());
    assertNotNull(result);
    assertEquals(existingBookmark.getbookmark_name(), result.getbookmark_name());
}
#end_block

#method_before
@Override
public Bookmark getByName(String name) {
    return super.singleResult(getEntityManager().createQuery("select b from Bookmark b where b.name = :name").setParameter("name", name));
}
#method_after
@Override
public Bookmark getByName(String name) {
    final TypedQuery<Bookmark> query = entityManager.createNamedQuery("Bookmark.byName", Bookmark.class);
    query.setParameter("name", name);
    return singleResult(query);
}
#end_block

#method_before
void initTable(ApplicationConstants constants, ApplicationTemplates templates) {
    // Interface Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.empty(), "30px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.nameInterface(), "200px");
    // Bond Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.bondInterface(), "200px");
    // Vlan Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.vlanInterface(), "200px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.networkNameInterface(), "200px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.hostOutOfSync(), "75px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.addressInterface(), "120px");
    // Statistics Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.macInterface(), "120px");
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.speedInterface(), constants.mbps()).asString(), // $NON-NLS-1$
    "100px");
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.rxInterface(), constants.mbps()).asString(), // $NON-NLS-1$
    "100px");
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.txInterface(), constants.mbps()).asString(), // $NON-NLS-1$
    "100px");
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.dropsInterface(), constants.pkts()).asString(), // $NON-NLS-1$
    "100px");
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.addEditInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.editManageNetInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditManagementNetworkCommand();
        }
    });
    // TODO: separator
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.bondInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBondCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.detachInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getDetachCommand();
        }
    });
    // TODO: separator
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.setupHostNetworksInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getSetupNetworksCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.saveNetConfigInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getSaveNetworkConfigCommand();
        }
    });
    // The table items are in the form, so the table itself will never have items, so don't display the 'empty
    // message'
    table.table.setEmptyTableWidget(null);
}
#method_after
void initTable() {
    // Interface Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.empty(), "30px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.nameInterface(), "200px");
    // Bond Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.bondInterface(), "200px");
    // Vlan Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.vlanInterface(), "200px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.hostOutOfSync(), "75px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.networkNameInterface(), "200px");
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.addressInterface(), "120px");
    // Statistics Panel
    // $NON-NLS-1$
    table.addColumn(new EmptyColumn(), constants.macInterface(), "120px");
    // $NON-NLS-1$
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.speedInterface(), constants.mbps()), "100px");
    // $NON-NLS-1$
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.rxRate(), constants.mbps()), "100px");
    // $NON-NLS-1$
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.txRate(), constants.mbps()), "100px");
    // $NON-NLS-1$
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.rxTotal(), constants.bytes()), "150px");
    // $NON-NLS-1$
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.txTotal(), constants.bytes()), "150px");
    // $NON-NLS-1$
    table.addColumnWithHtmlHeader(new EmptyColumn(), templates.sub(constants.dropsInterface(), constants.pkts()), "100px");
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.addEditInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.editManageNetInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getEditManagementNetworkCommand();
        }
    });
    // TODO: separator
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.bondInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBondCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.detachInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getDetachCommand();
        }
    });
    // TODO: separator
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.setupHostNetworksInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getSetupNetworksCommand();
        }
    });
    table.addActionButton(new WebAdminButtonDefinition<HostInterfaceLineModel>(constants.saveNetConfigInterface()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getSaveNetworkConfigCommand();
        }
    });
    // The table items are in the form, so the table itself will never have items, so don't display the 'empty
    // message'
    table.table.setEmptyTableWidget(null);
}
#end_block

#method_before
Grid createRow(final HostVLan hostVLan) {
    Grid row = new Grid(1, 4);
    row.getColumnFormatter().setWidth(0, VLanPanel.CHECK_BOX_COLUMN_WIDTH);
    row.getColumnFormatter().setWidth(1, VLanPanel.NETWORK_NAME_COLUMN_WIDTH);
    row.getColumnFormatter().setWidth(2, VLanPanel.OUT_OF_SYNC_WIDTH);
    row.getColumnFormatter().setWidth(3, VLanPanel.ADDRESS_COLUMN_WIDTH);
    // $NON-NLS-1$
    row.setWidth("100%");
    // $NON-NLS-1$
    row.setHeight("100%");
    Style gridStyle = row.getElement().getStyle();
    // $NON-NLS-1$
    gridStyle.setBorderColor("white");
    gridStyle.setBorderWidth(1, Unit.PX);
    gridStyle.setBorderStyle(BorderStyle.SOLID);
    // Check box, icon and name
    HorizontalPanel chekboxPanel = new HorizontalPanel();
    // $NON-NLS-1$
    chekboxPanel.setWidth("100%");
    if (isSelectionAvailable) {
        chekboxPanel.add(getCheckBox());
    }
    chekboxPanel.add(new Image(ClientGinjectorProvider.getApplicationResources().splitRotateImage()));
    chekboxPanel.add(new Label(new HostVLanNameRenderer().render(hostVLan)));
    row.setWidget(0, 0, chekboxPanel);
    // Network name
    Label networkName = new Label(hostVLan.getNetworkName());
    if (hostVLan.getInterface().getIsManagement()) {
        networkName.getElement().getStyle().setFontWeight(FontWeight.BOLD);
        // $NON-NLS-1$
        networkName.setText("* " + hostVLan.getNetworkName());
    }
    row.setWidget(0, 1, networkName);
    // Network sync status
    row.setWidget(0, 2, getSyncPanel(hostVLan.getInterface().getNetworkImplementationDetails().isInSync()));
    // Address
    row.setWidget(0, 3, new Label(hostVLan.getAddress()));
    return row;
}
#method_after
Grid createRow(final HostVLan hostVLan) {
    // Check box, icon and name
    HorizontalPanel checkboxPanel = new HorizontalPanel();
    // $NON-NLS-1$
    checkboxPanel.setWidth("100%");
    if (isSelectionAvailable) {
        checkboxPanel.add(getCheckBox());
    }
    checkboxPanel.add(new Image(resources.splitRotateImage()));
    checkboxPanel.add(new Label(new HostVLanNameRenderer().render(hostVLan)));
    Grid row = createBaseVlanRow(checkboxPanel, hostVLan.getInterface().getIsManagement(), hostVLan.getNetworkName(), hostVLan.getInterface().getNetworkImplementationDetails(), hostVLan.getAddress());
    Style gridStyle = row.getElement().getStyle();
    // $NON-NLS-1$
    gridStyle.setBorderColor("white");
    gridStyle.setBorderWidth(1, Unit.PX);
    gridStyle.setBorderStyle(BorderStyle.SOLID);
    return row;
}
#end_block

#method_before
Grid createBlankRow(final HostInterfaceLineModel lineModel) {
    Grid row = new Grid(1, 4);
    row.getColumnFormatter().setWidth(0, VLanPanel.CHECK_BOX_COLUMN_WIDTH);
    row.getColumnFormatter().setWidth(1, VLanPanel.NETWORK_NAME_COLUMN_WIDTH);
    row.getColumnFormatter().setWidth(2, VLanPanel.OUT_OF_SYNC_WIDTH);
    row.getColumnFormatter().setWidth(3, VLanPanel.ADDRESS_COLUMN_WIDTH);
    // $NON-NLS-1$
    row.setWidth("100%");
    // $NON-NLS-1$
    row.setHeight("100%");
    // Empty name
    row.setWidget(0, 0, new Label());
    // Network name
    Label networkName = new Label(lineModel.getNetworkName());
    if (lineModel.getIsManagement()) {
        networkName.getElement().getStyle().setFontWeight(FontWeight.BOLD);
        // $NON-NLS-1$
        networkName.setText("* " + lineModel.getNetworkName());
    }
    row.setWidget(0, 1, networkName);
    // Network sync status
    VdsNetworkInterface iface = lineModel.getIsBonded() ? lineModel.getInterface() : lineModel.getInterfaces().get(0).getInterface();
    VdsNetworkInterface.NetworkImplementationDetails ifaceNetworkImpDetails = (iface != null) ? iface.getNetworkImplementationDetails() : null;
    boolean isSYnc = (ifaceNetworkImpDetails != null) ? ifaceNetworkImpDetails.isInSync() : true;
    row.setWidget(0, 2, getSyncPanel(isSYnc));
    // Address
    row.setWidget(0, 3, new Label(lineModel.getAddress()));
    return row;
}
#method_after
Grid createBlankRow(final HostInterfaceLineModel lineModel) {
    VdsNetworkInterface iface = lineModel.getIsBonded() ? lineModel.getInterface() : lineModel.getInterfaces().get(0).getInterface();
    return createBaseVlanRow(new Label(), lineModel.getIsManagement(), lineModel.getNetworkName(), iface.getNetworkImplementationDetails(), lineModel.getAddress());
}
#end_block

#method_before
private void handleRadioButtonClick(ClickEvent event) {
    getDetailModel().setViewFilterType((viewRadioGroup.getSelectedValue()));
    boolean attached = viewRadioGroup.getSelectedValue() == NetworkHostFilter.attached;
    // $NON-NLS-1$
    getTable().ensureColumnPresent(hostStatus, constants.empty(), true, "30px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nameColumn, constants.nameHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(clusterColumn, constants.clusterHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicStatusColumn, constants.statusNetworkHost(), attached, "140px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(hostOutOfSync, constants.hostOutOfSync(), true, "100px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicColumn, constants.nicNetworkHost(), attached, "100px");
    getTable().ensureColumnPresent(speedColumn, templates.sub(constants.speedNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(nicRxColumn, templates.sub(constants.rxNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(nicTxColumn, templates.sub(constants.txNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "100px");
}
#method_after
private void handleRadioButtonClick(ClickEvent event) {
    getDetailModel().setViewFilterType((viewRadioGroup.getSelectedValue()));
    boolean attached = viewRadioGroup.getSelectedValue() == NetworkHostFilter.attached;
    // $NON-NLS-1$
    getTable().ensureColumnPresent(hostStatus, constants.empty(), true, "30px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nameColumn, constants.nameHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(clusterColumn, constants.clusterHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(dcColumn, constants.dcHost(), true, "200px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicStatusColumn, constants.statusNetworkHost(), attached, "140px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(hostOutOfSync, constants.hostOutOfSync(), attached, "75px");
    // $NON-NLS-1$
    getTable().ensureColumnPresent(nicColumn, constants.nicNetworkHost(), attached, "100px");
    getTable().ensureColumnPresent(speedColumn, templates.sub(constants.speedNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(nicRxColumn, templates.sub(constants.rxNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(nicTxColumn, templates.sub(constants.txNetworkHost(), constants.mbps()).asString(), attached, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(totalRxColumn, templates.sub(constants.rxTotal(), constants.bytes()).asString(), attached, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(totalTxColumn, templates.sub(constants.txTotal(), constants.bytes()).asString(), attached, // $NON-NLS-1$
    "150px");
}
#end_block

#method_before
private void initSorting() {
    hostStatus.makeSortable();
    nameColumn.makeSortable();
    hostOutOfSync.makeSortable((new Comparator<PairQueryable<VdsNetworkInterface, VDS>>() {

        @Override
        public int compare(PairQueryable<VdsNetworkInterface, VDS> o1, PairQueryable<VdsNetworkInterface, VDS> o2) {
            boolean syncStatus1 = (o1.getFirst() == null) ? false : o1.getFirst().getNetworkImplementationDetails().isInSync();
            boolean syncStatus2 = (o2.getFirst() == null) ? false : o2.getFirst().getNetworkImplementationDetails().isInSync();
            return Boolean.compare(syncStatus1, syncStatus2);
        }
    }));
    clusterColumn.makeSortable();
    dcColumn.makeSortable();
    nicStatusColumn.makeSortable(new SimpleStatusColumnComparator<PairQueryable<VdsNetworkInterface, VDS>>(nicStatusColumn));
    nicColumn.makeSortable(new Comparator<PairQueryable<VdsNetworkInterface, VDS>>() {

        private final LexoNumericComparator lexoNumeric = new LexoNumericComparator();

        @Override
        public int compare(PairQueryable<VdsNetworkInterface, VDS> o1, PairQueryable<VdsNetworkInterface, VDS> o2) {
            String name1 = (o1.getFirst() == null) ? null : o1.getFirst().getName();
            String name2 = (o2.getFirst() == null) ? null : o2.getFirst().getName();
            return lexoNumeric.compare(name1, name2);
        }
    });
    speedColumn.makeSortable();
    nicRxColumn.makeSortable();
    nicTxColumn.makeSortable();
}
#method_after
private void initSorting() {
    hostStatus.makeSortable();
    nameColumn.makeSortable();
    hostOutOfSync.makeSortable((new Comparator<PairQueryable<VdsNetworkInterface, VDS>>() {

        @Override
        public int compare(PairQueryable<VdsNetworkInterface, VDS> o1, PairQueryable<VdsNetworkInterface, VDS> o2) {
            boolean syncStatus1 = (o1.getFirst() == null) ? false : o1.getFirst().getNetworkImplementationDetails().isInSync();
            boolean syncStatus2 = (o2.getFirst() == null) ? false : o2.getFirst().getNetworkImplementationDetails().isInSync();
            return Boolean.compare(syncStatus1, syncStatus2);
        }
    }));
    clusterColumn.makeSortable();
    dcColumn.makeSortable();
    nicStatusColumn.makeSortable(new SimpleStatusColumnComparator<PairQueryable<VdsNetworkInterface, VDS>>(nicStatusColumn));
    nicColumn.makeSortable(new Comparator<PairQueryable<VdsNetworkInterface, VDS>>() {

        private final LexoNumericComparator lexoNumeric = new LexoNumericComparator();

        @Override
        public int compare(PairQueryable<VdsNetworkInterface, VDS> o1, PairQueryable<VdsNetworkInterface, VDS> o2) {
            String name1 = (o1.getFirst() == null) ? null : o1.getFirst().getName();
            String name2 = (o2.getFirst() == null) ? null : o2.getFirst().getName();
            return lexoNumeric.compare(name1, name2);
        }
    });
    speedColumn.makeSortable();
    nicRxColumn.makeSortable();
    nicTxColumn.makeSortable();
    totalRxColumn.makeSortable();
    totalTxColumn.makeSortable();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VDS> vdsList = getDbFacade().getVdsDao().getAllForNetwork(getParameters().getId());
    List<VdsNetworkInterface> vdsNetworkInterfaceList = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getParameters().getId());
    final Map<Guid, VDS> vdsById = Entities.businessEntitiesById(vdsList);
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    Map<String, Network> networks = Entities.entitiesByName(getDbFacade().getNetworkDao().getAll());
    List<PairQueryable<VdsNetworkInterface, VDS>> vdsInterfaceVdsPairs = new ArrayList<PairQueryable<VdsNetworkInterface, VDS>>();
    for (final VdsNetworkInterface vdsNetworkInterface : vdsNetworkInterfaceList) {
        vdsInterfaceVdsPairs.add(new PairQueryable<VdsNetworkInterface, VDS>(vdsNetworkInterface, vdsById.get(vdsNetworkInterface.getVdsId())));
        if (!Boolean.TRUE.equals(vdsNetworkInterface.getBonded()) || LinqUtils.filter(vdsNetworkInterfaceList, new Predicate<VdsNetworkInterface>() {

            @Override
            public boolean eval(VdsNetworkInterface bond) {
                return StringUtils.equals(bond.getBondName(), vdsNetworkInterface.getName());
            }
        }).size() > 0) {
            Network network = networks.get(vdsNetworkInterface.getNetworkName());
            vdsNetworkInterface.setNetworkImplementationDetails(NetworkUtils.calculateNetworkImplementationDetails(network, network == null ? null : qosDao.get(network.getQosId()), vdsNetworkInterface));
        }
    }
    getQueryReturnValue().setReturnValue(vdsInterfaceVdsPairs);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VDS> vdsList = getVdsDao().getAllForNetwork(getParameters().getId());
    List<VdsNetworkInterface> vdsNetworkInterfaceList = getInterfaceDao().getVdsInterfacesByNetworkId(getParameters().getId());
    final Map<Guid, VDS> vdsById = Entities.businessEntitiesById(vdsList);
    List<PairQueryable<VdsNetworkInterface, VDS>> vdsInterfaceVdsPairs = new ArrayList<PairQueryable<VdsNetworkInterface, VDS>>();
    Network network = getNetworkDao().get(getParameters().getId());
    HostNetworkQos qos = getHostNetworkQosDao().get(network.getQosId());
    for (final VdsNetworkInterface vdsNetworkInterface : vdsNetworkInterfaceList) {
        vdsInterfaceVdsPairs.add(new PairQueryable<VdsNetworkInterface, VDS>(vdsNetworkInterface, vdsById.get(vdsNetworkInterface.getVdsId())));
        VdsNetworkInterface.NetworkImplementationDetails vdsInterfaceNetworkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, qos, vdsNetworkInterface);
        vdsNetworkInterface.setNetworkImplementationDetails(vdsInterfaceNetworkImplementationDetails);
    }
    getQueryReturnValue().setReturnValue(vdsInterfaceVdsPairs);
}
#end_block

#method_before
@Test
public void testExecuteQueryCommand() {
    // Set up the query parameters
    when(params.getId()).thenReturn(networkId);
    setupVdsDao();
    setupVdsNetworkInterfaceDao();
    PairQueryable<VdsNetworkInterface, VDS> vdsInterfaceVdsPair = new PairQueryable<VdsNetworkInterface, VDS>(vdsNetworkInterface, vds);
    List<PairQueryable<VdsNetworkInterface, VDS>> expected = Collections.singletonList(vdsInterfaceVdsPair);
    // Run the query
    GetVdsAndNetworkInterfacesByNetworkIdQuery<IdQueryParameters> query = getQuery();
    query.executeQueryCommand();
    // Assert the result
    assertEquals("Wrong result returned", expected, getQuery().getQueryReturnValue().getReturnValue());
}
#method_after
@Test
public void testExecuteQueryCommand() {
    // Set up the query parameters
    when(params.getId()).thenReturn(networkId);
    setupVdsDao();
    setupVdsNetworkInterfaceDao();
    setupNetworkDao();
    setupHostNetworkQosDao();
    PairQueryable<VdsNetworkInterface, VDS> vdsInterfaceVdsPair = new PairQueryable<VdsNetworkInterface, VDS>(vdsNetworkInterface, vds);
    List<PairQueryable<VdsNetworkInterface, VDS>> expected = Collections.singletonList(vdsInterfaceVdsPair);
    // Run the query
    GetVdsAndNetworkInterfacesByNetworkIdQuery<IdQueryParameters> query = getQuery();
    setupQuerySpy();
    query.executeQueryCommand();
    // Assert the result
    assertEquals("Wrong result returned", expected, getQuery().getQueryReturnValue().getReturnValue());
}
#end_block

#method_before
private void setupVdsDao() {
    List<VDS> expectedVds = Collections.singletonList(vds);
    VdsDAO vdsDaoMock = mock(VdsDAO.class);
    when(vdsDaoMock.getAllForNetwork(networkId)).thenReturn(expectedVds);
    when(getDbFacadeMockInstance().getVdsDao()).thenReturn(vdsDaoMock);
}
#method_after
private void setupVdsDao() {
    List<VDS> expectedVds = Collections.singletonList(vds);
    when(vdsDAOMocked.getAllForNetwork(networkId)).thenReturn(expectedVds);
}
#end_block

#method_before
private void setupVdsNetworkInterfaceDao() {
    List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface);
    InterfaceDao vdsNetworkInterfaceDaoMock = mock(InterfaceDao.class);
    when(vdsNetworkInterfaceDaoMock.getVdsInterfacesByNetworkId(networkId)).thenReturn(expectedVdsNetworkInterface);
    when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(vdsNetworkInterfaceDaoMock);
    NetworkDao networkDaoMock = mock(NetworkDao.class);
    when(getDbFacadeMockInstance().getNetworkDao()).thenReturn(networkDaoMock);
}
#method_after
private void setupVdsNetworkInterfaceDao() {
    List<VdsNetworkInterface> expectedVdsNetworkInterface = Collections.singletonList(vdsNetworkInterface);
    when(interfaceDaoMocked.getVdsInterfacesByNetworkId(networkId)).thenReturn(expectedVdsNetworkInterface);
}
#end_block

#method_before
private void setVisibilities() {
    rngLabel.setVisible(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
}
#method_after
private void setVisibilities() {
    rngLabel.setVisible(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setEnableHostMaintenanceReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<Boolean>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<Boolean>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private List<String> getMountPointsFilter() {
    return Arrays.asList(Config.<String>getValue(ConfigValues.MountPointsToIgoreInGlusterStorageList).split(","));
}
#method_after
private List<String> getMountPointsFilter() {
    return Arrays.asList(Config.<String>getValue(ConfigValues.GlusterStorageDeviceListMountPointsToIgore).split(","));
}
#end_block

#method_before
private List<String> getFsTypesFilter() {
    return Arrays.asList(Config.<String>getValue(ConfigValues.FileSystemTypesToIgoreInGlusterStorageList).split(","));
}
#method_after
private List<String> getFsTypesFilter() {
    return Arrays.asList(Config.<String>getValue(ConfigValues.GlusterStorageDeviceListFileSystemTypesToIgore).split(","));
}
#end_block

#method_before
private void updateBricksFromHost() {
    VDS selectedServer = getServers().getSelectedItem();
    if (selectedServer != null) {
        AsyncDataProvider.getInstance().getUnusedBricksFromServer(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<StorageDevice> bricks = (List<StorageDevice>) returnValue;
                List<String> brickDirectories = new ArrayList<String>();
                for (StorageDevice brick : bricks) {
                    String mountPoint = brick.getMountPoint();
                    if (mountPoint != null && !mountPoint.isEmpty()) {
                        brickDirectories.add(mountPoint + mountPoint.substring(mountPoint.lastIndexOf("/")));
                    }
                }
                getBricksFromServer().setItems(brickDirectories);
            }
        }), selectedServer.getId());
    }
}
#method_after
private void updateBricksFromHost() {
    VDS selectedServer = getServers().getSelectedItem();
    if (selectedServer != null) {
        AsyncDataProvider.getInstance().getUnusedBricksFromServer(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                List<StorageDevice> bricks = (List<StorageDevice>) returnValue;
                List<String> brickDirectories = new ArrayList<String>();
                for (StorageDevice brick : bricks) {
                    String mountPoint = brick.getMountPoint();
                    if (mountPoint != null && !mountPoint.isEmpty()) {
                        // Gluster requires a directory under the mount point, not the mount point itself as a brick
                        // directory. So adding a directory with name of the brick under the mount point.
                        // $NON-NLS-1$
                        brickDirectories.add(mountPoint + mountPoint.substring(mountPoint.lastIndexOf("/")));
                    }
                }
                getBricksFromServer().setItems(brickDirectories);
            }
        }), selectedServer.getId());
    }
}
#end_block

#method_before
private void createBrick() {
    if (getWindow() != null) {
        return;
    }
    VDS host = getEntity();
    if (host == null) {
        return;
    }
    final CreateBrickModel lvModel = new CreateBrickModel();
    lvModel.setTitle(ConstantsManager.getInstance().getConstants().createBrick());
    lvModel.setHelpTag(HelpTag.create_brick);
    // $NON-NLS-1$
    lvModel.setHashName("create_brick");
    lvModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    setWindow(lvModel);
    AsyncQuery asyncQueryForDeviceList = new AsyncQuery();
    asyncQueryForDeviceList.setModel(lvModel);
    asyncQueryForDeviceList.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            lvModel.stopProgress();
            CreateBrickModel lvModel = (CreateBrickModel) model;
            List<StorageDevice> devices = (List<StorageDevice>) returnValue;
            final List<StorageDevice> eligibleDevices = new ArrayList<>();
            for (StorageDevice device : devices) {
                if (device.getCanCreateBrick()) {
                    eligibleDevices.add(device);
                }
            }
            lvModel.getStorageDevices().setItems(eligibleDevices);
            if (getSelectedItems() != null) {
                lvModel.setSelectedDevices(getSelectedItems());
            }
        }
    };
    AsyncDataProvider.getInstance().getStorageDevices(asyncQueryForDeviceList, host.getId());
    AsyncQuery asyncQueryForDefaultMountPoint = new AsyncQuery();
    asyncQueryForDefaultMountPoint.setModel(lvModel);
    asyncQueryForDefaultMountPoint.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            lvModel.stopProgress();
            CreateBrickModel lvModel = (CreateBrickModel) model;
            String defaultMountPoint = (String) returnValue;
            lvModel.getDefaultMountFolder().setEntity(defaultMountPoint);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.DefaultGlusterBrickMountPoint, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), asyncQueryForDefaultMountPoint);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onCreateBrick", this);
    lvModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("closeWindow", this);
    lvModel.getCommands().add(cancelCommand);
}
#method_after
private void createBrick() {
    if (getWindow() != null) {
        return;
    }
    VDS host = getEntity();
    if (host == null) {
        return;
    }
    final CreateBrickModel lvModel = new CreateBrickModel();
    lvModel.setTitle(ConstantsManager.getInstance().getConstants().createBrick());
    lvModel.setHelpTag(HelpTag.create_brick);
    // $NON-NLS-1$
    lvModel.setHashName("create_brick");
    lvModel.startProgress(ConstantsManager.getInstance().getConstants().fetchingDataMessage());
    setWindow(lvModel);
    List<StorageDevice> selectedDevices = getSelectedItems();
    lvModel.getStorageDevices().setItems(selectedDevices);
    lvModel.setSelectedDevices(selectedDevices);
    AsyncQuery asyncQueryForDefaultMountPoint = new AsyncQuery();
    asyncQueryForDefaultMountPoint.setModel(lvModel);
    asyncQueryForDefaultMountPoint.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            lvModel.stopProgress();
            CreateBrickModel lvModel = (CreateBrickModel) model;
            String defaultMountPoint = (String) returnValue;
            lvModel.getDefaultMountFolder().setEntity(defaultMountPoint);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.DefaultGlusterBrickMountPoint, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), asyncQueryForDefaultMountPoint);
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onCreateBrick", this);
    lvModel.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("closeWindow", this);
    lvModel.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void updateActionAvailability() {
    VDS vds = getEntity();
    boolean createBrickAllowed = false;
    boolean syncStorageDeviceAllowed = false;
    if (vds != null && vds.getStatus() == VDSStatus.Up) {
        syncStorageDeviceAllowed = true;
        createBrickAllowed = !getItems().isEmpty() && canCreateBrick();
        if (createBrickAllowed && !getSelectedItems().isEmpty()) {
            for (StorageDevice device : getSelectedItems()) {
                if (device.getCanCreateBrick()) {
                    createBrickAllowed = false;
                    break;
                }
            }
        }
    }
    getSyncStorageDevicesCommand().setIsExecutionAllowed(syncStorageDeviceAllowed);
    getCreateBrickCommand().setIsExecutionAllowed(createBrickAllowed);
}
#method_after
private void updateActionAvailability() {
    VDS vds = getEntity();
    if (vds != null && vds.getStatus() == VDSStatus.Up) {
        getSyncStorageDevicesCommand().setIsExecutionAllowed(true);
        getCreateBrickCommand().setIsExecutionAllowed(canCreateBrick());
    } else {
        getSyncStorageDevicesCommand().setIsExecutionAllowed(false);
        getCreateBrickCommand().setIsExecutionAllowed(false);
    }
}
#end_block

#method_before
private boolean canCreateBrick() {
    for (StorageDevice device : getItems()) {
        if (device.getCanCreateBrick()) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean canCreateBrick() {
    boolean canCreateBrick = false;
    List<StorageDevice> selectedDevices = getSelectedItems();
    if (selectedDevices != null) {
        for (StorageDevice device : selectedDevices) {
            if (device.getCanCreateBrick()) {
                canCreateBrick = true;
            } else {
                canCreateBrick = false;
                break;
            }
        }
    }
    return canCreateBrick;
}
#end_block

#method_before
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<GlusterBrickEntity>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails != null && volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<GlusterBrickEntity>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<GlusterBrickEntity>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false, true));
    return result.getSucceeded() ? (GlusterVolumeAdvancedDetails) result.getReturnValue() : null;
}
#method_after
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false, true));
    // false. But still we have the brick status details and we can update the brick status without any issue.
    return (GlusterVolumeAdvancedDetails) result.getReturnValue();
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    // forceRemove not used in gluster API
    RequestBuilder rBuilder;
    if (forceRemove) {
        rBuilder = new RequestBuilder("GlusterVolume.removeBrickForce");
    } else {
        rBuilder = new RequestBuilder("GlusterVolume.removeBrickStart");
    }
    JsonRpcRequest request = rBuilder.withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!GlusterFeatureSupported.glusterGeoReplication(getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEO_REP_NOT_SUPPORTED);
    }
    slaveHost = getSlaveHost();
    if (slaveHost == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (slaveHost.getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP, String.format("$%1$s %2$s", "VdsName", slaveHost.getName()));
    }
    slaveVolume = getSlaveVolume();
    if (slaveVolume == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID);
    }
    if (slaveVolume.getStatus() != GlusterStatus.UP) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
    }
    if (!areAllRemoteServersUp()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_REMOTE_HOSTS_ARE_NOT_ACCESSIBLE);
    }
    GlusterGeoRepSession geoRepSession = getGeoRepDao().getGeoRepSession(getGlusterVolumeId(), getSlaveHost().getHostName(), getParameters().getSlaveVolumeName());
    if (geoRepSession != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_GEOREP_SESSION_ALREADY_CREATED);
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!GlusterFeatureSupported.glusterGeoReplication(getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEO_REP_NOT_SUPPORTED);
    }
    slaveHost = getSlaveHost();
    if (slaveHost == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (slaveHost.getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP, String.format("$%1$s %2$s", "VdsName", slaveHost.getName()));
    }
    slaveVolume = getSlaveVolume();
    if (slaveVolume == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID);
    }
    if (slaveVolume.getStatus() != GlusterStatus.UP) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
    }
    if (!areAllRemoteServersUp()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_REMOTE_HOSTS_ARE_NOT_ACCESSIBLE);
    }
    GlusterGeoRepSession geoRepSession = getGeoRepDao().getGeoRepSession(getGlusterVolumeId(), slaveHost.getId(), getParameters().getSlaveVolumeName());
    if (geoRepSession != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_GEOREP_SESSION_ALREADY_CREATED);
    }
    return super.canDoAction();
}
#end_block

#method_before
private boolean createGeoRepSession() {
    GlusterVolumeGeoRepSessionVDSParameters params = new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGlusterVolumeName(), getSlaveHost().getHostName(), getParameters().getSlaveVolumeName(), getParameters().getUserName(), getParameters().isForce());
    VDSReturnValue createSessionReturnValue = runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, params);
    if (createSessionReturnValue.getSucceeded()) {
        setSucceeded(true);
        return true;
    } else {
        setSucceeded(false);
        handleVdsError(AuditLogType.GLUSTER_GEOREP_SESSION_CREATE_FAILED, createSessionReturnValue.getVdsError().getMessage());
        return false;
    }
}
#method_after
private boolean createGeoRepSession() {
    GlusterVolumeGeoRepSessionVDSParameters params = new GlusterVolumeGeoRepSessionVDSParameters(upServer.getId(), getGlusterVolumeName(), slaveHost.getHostName(), getParameters().getSlaveVolumeName(), getParameters().getUserName(), getParameters().isForce());
    VDSReturnValue createSessionReturnValue = runVdsCommand(VDSCommandType.CreateGlusterVolumeGeoRepSession, params);
    if (createSessionReturnValue.getSucceeded()) {
        setSucceeded(true);
        return true;
    } else {
        setSucceeded(false);
        handleVdsError(AuditLogType.GLUSTER_GEOREP_SESSION_CREATE_FAILED, createSessionReturnValue.getVdsError().getMessage());
        return false;
    }
}
#end_block

#method_before
protected GlusterGeoRepSession getGeoRepSession() {
    if (geoRepSession == null) {
        if (getParameters().getGeoRepSessionId() != null) {
            geoRepSession = getGlusterGeoRepDao().getById(getParameters().getGeoRepSessionId());
        } else {
            geoRepSession = getGlusterGeoRepDao().getGeoRepSession(getGlusterVolumeId(), getVdsDAO().get(getParameters().getSlaveHostId()).getName(), getParameters().getSlaveVolumeName());
        }
    }
    return geoRepSession;
}
#method_after
protected GlusterGeoRepSession getGeoRepSession() {
    if (geoRepSession == null) {
        if (getParameters().getGeoRepSessionId() != null) {
            geoRepSession = getGlusterGeoRepDao().getById(getParameters().getGeoRepSessionId());
        } else {
            geoRepSession = getGlusterGeoRepDao().getGeoRepSession(getGlusterVolumeId(), getParameters().getSlaveHostId(), getParameters().getSlaveVolumeName());
        }
    }
    return geoRepSession;
}
#end_block

#method_before
@Test
public void commandSucceeds() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(String.class), any(String.class));
    doReturn(vds).when(command).getSlaveHost();
    assertTrue(command.canDoAction());
}
#method_after
@Test
public void commandSucceeds() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(Guid.class), any(String.class));
    doReturn(vds).when(command).getSlaveHost();
    assertTrue(command.canDoAction());
}
#end_block

#method_before
@Test
public void commandFailsSlaveVolumeNotMonitoredByOvirt() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(null).when(command).getSlaveVolume();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(vds).when(command).getSlaveHost();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(String.class), any(String.class));
    assertFalse(command.canDoAction());
}
#method_after
@Test
public void commandFailsSlaveVolumeNotMonitoredByOvirt() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(null).when(command).getSlaveVolume();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(vds).when(command).getSlaveHost();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(Guid.class), any(String.class));
    assertFalse(command.canDoAction());
}
#end_block

#method_before
@Test
public void commandFailsSessionExists() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(vds).when(command).getSlaveHost();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(new GlusterGeoRepSession()).when(geoRepDao).getGeoRepSession(any(Guid.class), any(String.class), any(String.class));
    assertFalse(command.canDoAction());
}
#method_after
@Test
public void commandFailsSessionExists() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(vds).when(command).getSlaveHost();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(new GlusterGeoRepSession()).when(geoRepDao).getGeoRepSession(any(Guid.class), any(Guid.class), any(String.class));
    assertFalse(command.canDoAction());
}
#end_block

#method_before
@Test
public void commandFailsVersionNotSupported() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(Guid.newGuid(), slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(vds).when(command).getUpServer();
    doReturn(vds).when(command).getSlaveHost();
    doReturn(NOT_SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(String.class), any(String.class));
    assertFalse(command.canDoAction());
}
#method_after
@Test
public void commandFailsVersionNotSupported() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(Guid.newGuid(), slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(vds).when(command).getUpServer();
    doReturn(vds).when(command).getSlaveHost();
    doReturn(NOT_SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(Guid.class), any(String.class));
    assertFalse(command.canDoAction());
}
#end_block

#method_before
@Test
public void commandFailsSlaveHostInvalid() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(vds).when(command).getUpServer();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(String.class), any(String.class));
    doReturn(null).when(command).getSlaveHost();
    assertFalse(command.canDoAction());
}
#method_after
@Test
public void commandFailsSlaveHostInvalid() {
    command = spy(new CreateGlusterVolumeGeoRepSessionCommand(new GlusterVolumeGeoRepSessionParameters(masterVolumeId, slaveVolumeName, Guid.newGuid(), null, null, false)));
    prepareMocks();
    doReturn(vds).when(command).getUpServer();
    doReturn(SUPPORTED_VERSION).when(vdsGroup).getCompatibilityVersion();
    doReturn(volume).when(command).getSlaveVolume();
    doReturn(null).when(geoRepDao).getGeoRepSession(any(Guid.class), any(Guid.class), any(String.class));
    doReturn(null).when(command).getSlaveHost();
    assertFalse(command.canDoAction());
}
#end_block

#method_before
public void initialize() {
    if (Config.<Boolean>getValue(ConfigValues.BackupCheckPeriodInHours)) {
        log.info("Start initializing {}", getClass().getSimpleName());
        Integer backupCheckPeriodInHours = Config.<Integer>getValue(ConfigValues.BackupCheckPeriodInHours);
        // disable feature if value is negative
        if (backupCheckPeriodInHours > 0) {
            SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "backupCheck", new Class[] {}, new Object[] {}, backupCheckPeriodInHours, backupCheckPeriodInHours, TimeUnit.HOURS);
            log.info("Finished initializing {}", getClass().getSimpleName());
        }
    }
}
#method_after
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    Integer backupCheckPeriodInHours = Config.<Integer>getValue(ConfigValues.BackupCheckPeriodInHours);
    // disable feature if value is negative
    if (backupCheckPeriodInHours > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "backupCheck", new Class[] {}, new Object[] {}, backupCheckPeriodInHours, backupCheckPeriodInHours, TimeUnit.HOURS);
        log.info("Finished initializing {}", getClass().getSimpleName());
    }
}
#end_block

#method_before
private void doBackupCheck() {
    final int DAY_IN_MILLISEC = 60 * 60 * 24 * 1000;
    AuditLogableBase alert = new AuditLogableBase();
    // try to get last backup record
    EngineBackupHistory lastBackup = DbFacade.getInstance().getEngineBackupHistoryDAO().getLastSuccessfulEngineBackup(DB);
    if (lastBackup == null) {
        auditLogDirector.log(alert, AuditLogType.ENGINE_NO_BACKUP);
    } else {
        // check time elapsed from last backup
        if (Config.<Boolean>getValue(ConfigValues.BackupAlertPeriodInDays)) {
            Integer backupAlertPeriodInDays = Config.<Integer>getValue(ConfigValues.BackupAlertPeriodInDays);
            Date dt = lastBackup.getDoneAt();
            long diffInDays = (Calendar.getInstance().getTimeInMillis() - dt.getTime()) / DAY_IN_MILLISEC;
            if (diffInDays > backupAlertPeriodInDays) {
                alert.addCustomValue("Date", lastBackup.getDoneAt().toString());
                auditLogDirector.log(alert, AuditLogType.ENGINE_NO_WARM_BACKUP);
            }
        }
    }
}
#method_after
private void doBackupCheck() {
    AuditLogableBase alert = new AuditLogableBase();
    // try to get last backup record
    EngineBackupLog lastBackup = engineBackupLogDao.getLastSuccessfulEngineBackup(ENGINE_DB_ID);
    if (lastBackup == null) {
        auditLogDirector.log(alert, AuditLogType.ENGINE_NO_BACKUP);
    } else {
        // check time elapsed from last backup
        Integer backupAlertPeriodInDays = Config.<Integer>getValue(ConfigValues.BackupAlertPeriodInDays);
        Date lastBackupDate = lastBackup.getDoneAt();
        long diffInDays = (Calendar.getInstance().getTimeInMillis() - lastBackupDate.getTime()) / TimeUnit.DAYS.toMillis(1);
        if (diffInDays > backupAlertPeriodInDays) {
            alert.addCustomValue("Date", lastBackupDate.toString());
            auditLogDirector.log(alert, AuditLogType.ENGINE_NO_WARM_BACKUP);
        }
    }
}
#end_block

#method_before
@Override
protected StorageDomain map(org.ovirt.engine.core.common.businessentities.StorageDomain entity, StorageDomain template) {
    StorageDomain model = super.map(entity, template);
    // Mapping the connection properties only in case it is a non-filtered session
    if (!isFiltered()) {
        switch(entity.getStorageType()) {
            case ISCSI:
                mapVolumeGroupIscsi(model, entity);
                break;
            case FCP:
                mapVolumeGroupFcp(model, entity);
                break;
            case NFS:
                mapNFSProperties(model, entity);
            case LOCALFS:
            case POSIXFS:
            case GLUSTERFS:
                mapFileDomain(model, entity);
                break;
        }
    }
    return model;
}
#method_after
@Override
protected StorageDomain map(org.ovirt.engine.core.common.businessentities.StorageDomain entity, StorageDomain template) {
    StorageDomain model = super.map(entity, template);
    // Mapping the connection properties only in case it is a non-filtered session
    if (!isFiltered()) {
        switch(entity.getStorageType()) {
            case ISCSI:
                mapVolumeGroupIscsi(model, entity);
                break;
            case FCP:
                mapVolumeGroupFcp(model, entity);
                break;
            case NFS:
            case LOCALFS:
            case POSIXFS:
            case GLUSTERFS:
                mapFileDomain(model, entity);
                break;
        }
    }
    return model;
}
#end_block

#method_before
protected void mapFileDomain(StorageDomain model, org.ovirt.engine.core.common.businessentities.StorageDomain entity) {
    final Storage storage = model.getStorage();
    StorageServerConnections cnx = getStorageServerConnection(entity.getStorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
}
#method_after
protected void mapFileDomain(StorageDomain model, org.ovirt.engine.core.common.businessentities.StorageDomain entity) {
    final Storage storage = model.getStorage();
    StorageServerConnections cnx = getStorageServerConnection(entity.getStorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        storage.setAddress(parts[0]);
        storage.setPath(parts[1]);
    } else {
        storage.setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    if (entity.getStorageType() == StorageType.NFS) {
        if (cnx.getNfsRetrans() != null) {
            storage.setNfsRetrans(cnx.getNfsRetrans().intValue());
        }
        if (cnx.getNfsTimeo() != null) {
            storage.setNfsTimeo(cnx.getNfsTimeo().intValue());
        }
        if (cnx.getNfsVersion() != null) {
            storage.setNfsVersion(StorageDomainMapper.map(cnx.getNfsVersion(), null));
        }
    }
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageServerConnections.class, to = org.ovirt.engine.api.model.StorageConnection.class)
public static StorageConnection map(StorageServerConnections entity, StorageConnection template) {
    StorageConnection model = template != null ? template : new StorageConnection();
    model.setId(entity.getid());
    model.setType(map(entity.getstorage_type(), null));
    if (entity.getstorage_type() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI) {
        model.setAddress(entity.getconnection());
        model.setPort(Integer.parseInt(entity.getport()));
        model.setUsername(entity.getuser_name());
        model.setTarget(entity.getiqn());
    }
    if (entity.getstorage_type().isFileDomain()) {
        setPath(entity, model);
    }
    if (entity.getstorage_type().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.NFS)) {
        if (entity.getNfsVersion() != null) {
            model.setNfsVersion(entity.getNfsVersion().toString());
        }
        if (entity.getNfsRetrans() != null) {
            model.setNfsRetrans(entity.getNfsRetrans().intValue());
        }
        if (entity.getNfsTimeo() != null) {
            model.setNfsTimeo(entity.getNfsTimeo().intValue());
        }
        if (entity.getMountOptions() != null) {
            model.setMountOptions(entity.getMountOptions());
        }
    } else if (entity.getstorage_type().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.POSIXFS) || entity.getstorage_type().equals(StorageType.GLUSTERFS)) {
        model.setMountOptions(entity.getMountOptions());
        model.setVfsType(entity.getVfsType());
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.StorageServerConnections.class, to = org.ovirt.engine.api.model.StorageConnection.class)
public static StorageConnection map(StorageServerConnections entity, StorageConnection template) {
    StorageConnection model = template != null ? template : new StorageConnection();
    model.setId(entity.getid());
    model.setType(map(entity.getstorage_type(), null));
    if (entity.getstorage_type() == org.ovirt.engine.core.common.businessentities.storage.StorageType.ISCSI) {
        model.setAddress(entity.getconnection());
        model.setPort(Integer.parseInt(entity.getport()));
        model.setUsername(entity.getuser_name());
        model.setTarget(entity.getiqn());
    }
    if (entity.getstorage_type().isFileDomain()) {
        setPath(entity, model);
    }
    if (entity.getstorage_type().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.NFS)) {
        if (entity.getNfsVersion() != null) {
            model.setNfsVersion(entity.getNfsVersion().toString());
        }
        if (entity.getNfsRetrans() != null) {
            model.setNfsRetrans(entity.getNfsRetrans().intValue());
        }
        if (entity.getNfsTimeo() != null) {
            model.setNfsTimeo(entity.getNfsTimeo().intValue());
        }
        if (entity.getMountOptions() != null) {
            model.setMountOptions(entity.getMountOptions());
        }
    } else if (entity.getstorage_type().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.POSIXFS) || entity.getstorage_type().equals(org.ovirt.engine.core.common.businessentities.storage.StorageType.GLUSTERFS)) {
        model.setMountOptions(entity.getMountOptions());
        model.setVfsType(entity.getVfsType());
    }
    return model;
}
#end_block

#method_before
protected List<FenceProxySourceType> getFenceProxySources() {
    List<FenceProxySourceType> fenceProxySources = fencedHost.getFenceProxySources();
    if (fenceProxySources == null || fenceProxySources.isEmpty()) {
        fenceProxySources = getDefaultFenceProxySources();
    }
    return fenceProxySources;
}
#method_after
protected List<FenceProxySourceType> getFenceProxySources() {
    List<FenceProxySourceType> fenceProxySources = fencedHost.getFenceProxySources();
    if (CollectionUtils.isEmpty(fenceProxySources)) {
        fenceProxySources = getDefaultFenceProxySources();
    }
    return fenceProxySources;
}
#end_block

#method_before
private List<FenceProxySourceType> getFenceProxySources() {
    List<FenceProxySourceType> fenceProxySources = fencedHost.getFenceProxySources();
    if (fenceProxySources == null || fenceProxySources.isEmpty()) {
        fenceProxySources = FenceProxySourceTypeHelper.parseFromString(Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences));
    }
    return fenceProxySources;
}
#method_after
private List<FenceProxySourceType> getFenceProxySources() {
    List<FenceProxySourceType> fenceProxySources = fencedHost.getFenceProxySources();
    if (CollectionUtils.isEmpty(fenceProxySources)) {
        fenceProxySources = FenceProxySourceTypeHelper.parseFromString(Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences));
    }
    return fenceProxySources;
}
#end_block

#method_before
public void setVdsName(String value) {
    vdsStatic.setVdsName(value);
}
#method_after
public void setVdsName(String value) {
    vdsStatic.setName(value);
}
#end_block

#method_before
private List<FenceProxySourceType> getFenceProxySources() {
    List<FenceProxySourceType> fenceProxySources = _vds.getFenceProxySources();
    if (fenceProxySources == null || fenceProxySources.isEmpty()) {
        fenceProxySources = FenceProxySourceTypeHelper.parseFromString(Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences));
    }
    return fenceProxySources;
}
#method_after
private List<FenceProxySourceType> getFenceProxySources() {
    List<FenceProxySourceType> fenceProxySources = _vds.getFenceProxySources();
    if (CollectionUtils.isEmpty(fenceProxySources)) {
        fenceProxySources = FenceProxySourceTypeHelper.parseFromString(Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences));
    }
    return fenceProxySources;
}
#end_block

#method_before
public void setVdsName(String value) {
    vdsStatic.setVdsName(value);
}
#method_after
public void setVdsName(String value) {
    vdsStatic.setName(value);
}
#end_block

#method_before
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    return entity;
}
#method_after
@Override
public VdsStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    VdsStatic entity = new VdsStatic();
    entity.setHostName(rs.getString("host_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setUniqueID(rs.getString("vds_unique_id"));
    entity.setPort(rs.getInt("port"));
    entity.setProtocol(VdsProtocol.fromValue(rs.getInt("protocol")));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setVdsGroupId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_group_id")));
    entity.setId(Guid.createGuidFromStringDefaultEmpty(rs.getString("vds_id")));
    entity.setName(rs.getString("vds_name"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setPmEnabled(rs.getBoolean("pm_enabled"));
    entity.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(rs.getString("pm_proxy_preferences")));
    entity.setPmKdumpDetection(rs.getBoolean("pm_detect_kdump"));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setHostProviderId(getGuid(rs, "host_provider_id"));
    return entity;
}
#end_block

#method_before
public UICommand getResetEmulatedMachineCommand() {
    return privateResetEmulatedMachineCommand;
}
#method_after
public UICommand getResetEmulatedMachineCommand() {
    return resetEmulatedMachineCommand;
}
#end_block

#method_before
private void setResetEmulatedMachineCommand(UICommand value) {
    privateResetEmulatedMachineCommand = value;
}
#method_after
private void setResetEmulatedMachineCommand(UICommand value) {
    resetEmulatedMachineCommand = value;
}
#end_block

#method_before
protected Object[] getSelectedKeys() {
    if (getSelectedItems() == null) {
        return new Object[0];
    } else {
        ArrayList<Object> items = new ArrayList<Object>();
        for (Object i : getSelectedItems()) {
            items.add(((VDSGroup) i).getId());
        }
        return items.toArray(new Object[] {});
    }
}
#method_after
protected Object[] getSelectedKeys() {
    if (getSelectedItems() == null) {
        return new Object[0];
    } else {
        ArrayList<Object> items = new ArrayList<>();
        for (VDSGroup vdsGroup : getSelectedItems()) {
            items.add(vdsGroup.getId());
        }
        return items.toArray(new Object[] {});
    }
}
#end_block

#method_before
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        VDSGroup cluster = (VDSGroup) getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel clusterListModel = (ClusterListModel) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((VDSGroup) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#method_after
public void guide() {
    ClusterGuideModel model = new ClusterGuideModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterGuideMeTitle());
    model.setHelpTag(HelpTag.new_cluster___guide_me);
    // $NON-NLS-1$
    model.setHashName("new_cluster_-_guide_me");
    if (getGuideContext() == null) {
        VDSGroup cluster = getSelectedItem();
        setGuideContext(cluster.getId());
    }
    AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> clusterListModel = (ClusterListModel<Void>) target;
            ClusterGuideModel model = (ClusterGuideModel) clusterListModel.getWindow();
            model.setEntity((VDSGroup) returnValue);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", clusterListModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().configureLaterTitle());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    }), (Guid) getGuideContext());
}
#end_block

#method_before
private void setDetailList(final ClusterGeneralModel clusterGeneralModel, final ClusterNetworkListModel clusterNetworkListModel, final ClusterHostListModel clusterHostListModel, final PermissionListModel<ClusterListModel> permissionListModel) {
    List<EntityModel> list = new ArrayList<EntityModel>();
    list.add(clusterGeneralModel);
    list.add(clusterNetworkListModel);
    list.add(clusterHostListModel);
    list.add(clusterVmListModel);
    list.add(clusterServiceModel);
    list.add(clusterGlusterHookListModel);
    list.add(cpuProfileListModel);
    list.add(permissionListModel);
    list.add(affinityGroupListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final ClusterGeneralModel clusterGeneralModel, final ClusterNetworkListModel clusterNetworkListModel, final ClusterHostListModel clusterHostListModel, final PermissionListModel<VDSGroup> permissionListModel) {
    List<HasEntity<VDSGroup>> list = new ArrayList<>();
    list.add(clusterGeneralModel);
    list.add(clusterNetworkListModel);
    list.add(clusterHostListModel);
    list.add(clusterVmListModel);
    list.add(clusterServiceModel);
    list.add(clusterGlusterHookListModel);
    list.add(cpuProfileListModel);
    list.add(permissionListModel);
    list.add(affinityGroupListModel);
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = (VDSGroup) getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getCompatibilityVersion()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getCompatibilityVersion()));
    getAffinityGroupListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getCpuProfileListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService() && Boolean.TRUE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuQosSupported, vdsGroup.getCompatibilityVersion().getValue())));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDSGroup vdsGroup = getSelectedItem();
    getClusterVmListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getClusterServiceModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterVolumeServicesSupported(vdsGroup.getCompatibilityVersion()));
    getClusterGlusterHookListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsGlusterService() && GlusterFeaturesUtil.isGlusterHookSupported(vdsGroup.getCompatibilityVersion()));
    getAffinityGroupListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService());
    getCpuProfileListModel().setIsAvailable(vdsGroup != null && vdsGroup.supportsVirtService() && Boolean.TRUE.equals(AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CpuQosSupported, vdsGroup.getCompatibilityVersion().getValue())));
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel clModel = (ClusterListModel) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            cModel.getDataCenter().setItems(dataCenters);
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(selectDataCenter.getId())));
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("OnSave", clModel);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
            tempVar.setIsDefault(true);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = new UICommand("Cancel", clModel);
            tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            tempVar2.setIsCancel(true);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrDefault(dataCenters, new DataCenterPredicate(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    model.setHelpTag(HelpTag.remove_cluster);
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    model.setHelpTag(HelpTag.remove_cluster);
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    ArrayList<String> list = new ArrayList<>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void resetEmulatedMachine() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineMessage());
    model.setHelpTag(HelpTag.reset_emulated_machine_cluster);
    // $NON-NLS-1$
    model.setHashName("reset_cluster_emulated_machine");
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup vdsGroup : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(vdsGroup.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand applyCommand = new UICommand("OnResetClusterEmulatedMachine", this);
    applyCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    applyCommand.setIsDefault(true);
    model.getCommands().add(applyCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
public void resetEmulatedMachine() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineTitle());
    model.setMessage(ConstantsManager.getInstance().getConstants().resetClusterEmulatedMachineMessage());
    model.setHelpTag(HelpTag.reset_emulated_machine_cluster);
    // $NON-NLS-1$
    model.setHashName("reset_cluster_emulated_machine");
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup vdsGroup : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(vdsGroup.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createDefaultOkUiCommand("OnResetClusterEmulatedMachine", this));
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
public void onResetClusterEmulatedMachine() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object vdsGroup : getSelectedItems()) {
        VdsGroupOperationParameters currentParam = new VdsGroupOperationParameters(((VDSGroup) vdsGroup));
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVdsGroup, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
public void onResetClusterEmulatedMachine() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (VDSGroup vdsGroup : getSelectedItems()) {
        ManagementNetworkOnClusterOperationParameters currentParam = new ManagementNetworkOnClusterOperationParameters(((VDSGroup) vdsGroup));
        currentParam.setForceResetEmulatedMachine(true);
        prms.add(currentParam);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.UpdateVdsGroup, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            model.stopProgress();
            cancel();
        }
    });
}
#end_block

#method_before
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object a : getSelectedItems()) {
        prms.add(new VdsGroupParametersBase(((VDSGroup) a).getId()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVdsGroup, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
public void onRemove() {
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object a : getSelectedItems()) {
        prms.add(new VdsGroupParametersBase(((VDSGroup) a).getId()));
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.RemoveVdsGroup, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
public void onSave() {
    ClusterModel model = (ClusterModel) getWindow();
    boolean validateCpu = (model.getIsNew() && model.getEnableOvirtService().getEntity()) || (model.getIsEdit() && ((VDSGroup) getSelectedItem()).getCpuName() != null);
    if (!model.validate(validateCpu)) {
        return;
    } else if (model.getIsNew()) {
        onPreSaveInternal(model);
    } else {
        onSaveConfirmCV(model);
    }
}
#method_after
public void onSave() {
    ClusterModel model = (ClusterModel) getWindow();
    boolean validateCpu = (model.getIsNew() && model.getEnableOvirtService().getEntity()) || (model.getIsEdit() && getSelectedItem().getCpuName() != null);
    if (!model.validate(validateCpu)) {
        return;
    } else if (model.getIsNew()) {
        onPreSaveInternal(model);
    } else {
        onSaveConfirmCV(model);
    }
}
#end_block

#method_before
private void onSaveConfirmCV(ClusterModel model) {
    if (!model.getVersion().getSelectedItem().equals(((VDSGroup) getSelectedItem()).getCompatibilityVersion())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        confirmModel.setHelpTag(HelpTag.change_cluster_compatibility_version);
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
        checkForNonResponsiveHosts(confirmModel);
    } else {
        onSaveConfirmCpuThreads();
    }
}
#method_after
private void onSaveConfirmCV(ClusterModel model) {
    if (!model.getVersion().getSelectedItem().equals(getSelectedItem().getCompatibilityVersion())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        confirmModel.setHelpTag(HelpTag.change_cluster_compatibility_version);
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSaveConfirmCpuThreads", this);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
        getConfirmWindow().getCommands().add(tempVar2);
        checkForNonResponsiveHosts(confirmModel);
    } else {
        onSaveConfirmCpuThreads();
    }
}
#end_block

#method_before
private void onSaveConfirmCpuThreads() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    // CPU thread support is being turned off either explicitly or via version change
    if (!model.getVersionSupportsCpuThreads().getEntity() && model.getCountThreadsAsCores().getEntity() && ((VDSGroup) getSelectedItem()).getCountThreadsAsCores()) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().disableClusterCpuThreadSupportTitle());
        confirmModel.setHelpTag(HelpTag.disable_cpu_thread_support);
        // $NON-NLS-1$
        confirmModel.setHashName("disable_cpu_thread_support");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCpuThreadSupportMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuLevel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveConfirmCpuLevel();
    }
}
#method_after
private void onSaveConfirmCpuThreads() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    // CPU thread support is being turned off either explicitly or via version change
    if (!model.getVersionSupportsCpuThreads().getEntity() && model.getCountThreadsAsCores().getEntity() && getSelectedItem().getCountThreadsAsCores()) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().disableClusterCpuThreadSupportTitle());
        confirmModel.setHelpTag(HelpTag.disable_cpu_thread_support);
        // $NON-NLS-1$
        confirmModel.setHashName("disable_cpu_thread_support");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCpuThreadSupportMsg());
        // $NON-NLS-1$
        UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSaveConfirmCpuLevel", this);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveConfirmCpuLevel();
    }
}
#end_block

#method_before
private void onSaveConfirmCpuLevel() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(model);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            Integer activeVms = (Integer) result;
            ServerCpu vdsCpu = getVdsGroupServerCpu(clusterModel, (VDSGroup) getSelectedItem());
            if (activeVms > 0 && vdsCpu != null && clusterModel.getCPU().getSelectedItem().getLevel() < vdsCpu.getLevel()) {
                cpuLevelConfirmationWindow();
            } else {
                onSaveInternal();
            }
        }
    };
    AsyncDataProvider.getInstance().getNumberOfActiveVmsInCluster(_asyncQuery, ((VDSGroup) getSelectedItem()).getId());
}
#method_after
private void onSaveConfirmCpuLevel() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(model);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            Integer activeVms = (Integer) result;
            ServerCpu vdsCpu = getVdsGroupServerCpu(clusterModel, getSelectedItem());
            if (activeVms > 0 && vdsCpu != null && clusterModel.getCPU().getSelectedItem().getLevel() < vdsCpu.getLevel()) {
                cpuLevelConfirmationWindow();
            } else {
                onSaveInternal();
            }
        }
    };
    AsyncDataProvider.getInstance().getNumberOfActiveVmsInCluster(_asyncQuery, getSelectedItem().getId());
}
#end_block

#method_before
private void cpuLevelConfirmationWindow() {
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeCpuLevel());
    confirmModel.setHelpTag(HelpTag.change_cpu_level);
    // $NON-NLS-1$
    confirmModel.setHashName("change_cpu_level");
    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().changeCpuLevelConfirmation());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSaveInternal", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    getConfirmWindow().getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("CancelConfirmation", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    getConfirmWindow().getCommands().add(tempVar2);
}
#method_after
private void cpuLevelConfirmationWindow() {
    ConfirmationModel confirmModel = new ConfirmationModel();
    setConfirmWindow(confirmModel);
    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeCpuLevel());
    confirmModel.setHelpTag(HelpTag.change_cpu_level);
    // $NON-NLS-1$
    confirmModel.setHashName("change_cpu_level");
    confirmModel.setMessage(ConstantsManager.getInstance().getConstants().changeCpuLevelConfirmation());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSaveInternal", this);
    getConfirmWindow().getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirmation", this);
    getConfirmWindow().getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    Frontend.getInstance().runAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<EntityModel<HostDetailModel>>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<HostDetailModel>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getInstance().getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().startProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            getWindow().stopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(Frontend.getInstance().getAppErrorsTranslator().translateErrorTextSingle(returnValue.getExceptionString()));
                return;
            }
            Map<String, String> hostMap = returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel<HostDetailModel>> list = new ArrayList<>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel<HostDetailModel> entityModel = new EntityModel<>(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.getInstance().getGlusterHosts(aQuery, clusterModel.getGlusterHostAddress().getEntity(), clusterModel.getGlusterHostPassword().getEntity(), clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
private void onGlusterHostsWithoutFingerprint(Map<String, String> hostMap, ClusterModel clusterModel) {
    ArrayList<String> problematicHosts = new ArrayList<String>();
    for (Map.Entry<String, String> host : hostMap.entrySet()) {
        if (// $//$NON-NLS-1$
        host.getValue() == null || host.getValue().equals("")) {
            problematicHosts.add(host.getKey());
        }
    }
    clusterModel.setMessage(ConstantsManager.getInstance().getMessages().unreachableGlusterHosts(problematicHosts));
}
#method_after
private void onGlusterHostsWithoutFingerprint(Map<String, String> hostMap, ClusterModel clusterModel) {
    ArrayList<String> problematicHosts = new ArrayList<>();
    for (Map.Entry<String, String> host : hostMap.entrySet()) {
        if (// $//$NON-NLS-1$
        host.getValue() == null || host.getValue().equals("")) {
            problematicHosts.add(host.getKey());
        }
    }
    clusterModel.setMessage(ConstantsManager.getInstance().getMessages().unreachableGlusterHosts(problematicHosts));
}
#end_block

#method_before
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel<HostDetailModel>> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = new UICommand("OnSaveHosts", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    hostsModel.getCommands().add(command);
}
#method_after
private void importClusterHosts(ClusterModel clusterModel, ArrayList<EntityModel<HostDetailModel>> hostList) {
    setWindow(null);
    getAddMultipleHostsCommand().execute();
    final MultipleHostsModel hostsModel = new MultipleHostsModel();
    setWindow(hostsModel);
    hostsModel.setTitle(ConstantsManager.getInstance().getConstants().addMultipleHostsTitle());
    hostsModel.setHelpTag(HelpTag.add_hosts);
    // $NON-NLS-1$
    hostsModel.setHashName("add_hosts");
    hostsModel.setClusterModel(clusterModel);
    hostsModel.getHosts().setItems(hostList);
    // $NON-NLS-1$
    UICommand command = UICommand.createOkUiCommand("OnSaveHosts", this);
    hostsModel.getCommands().add(command);
    // $NON-NLS-1$
    hostsModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<VdcActionParametersBase>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#method_after
private void addHosts(final MultipleHostsModel hostsModel) {
    hostsModel.startProgress(null);
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object object : hostsModel.getHosts().getItems()) {
        HostDetailModel hostDetailModel = (HostDetailModel) ((EntityModel) object).getEntity();
        VDS host = new VDS();
        host.setVdsName(hostDetailModel.getName());
        host.setHostName(hostDetailModel.getAddress());
        host.setSshKeyFingerprint(hostDetailModel.getFingerprint());
        host.setPort(54321);
        // TODO: get from UI, till then using defaults.
        host.setSshPort(22);
        // $NON-NLS-1$
        host.setSshUsername("root");
        host.setVdsGroupId(hostsModel.getClusterModel().getClusterId());
        host.setPmEnabled(false);
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setPassword(hostDetailModel.getPassword());
        parameters.setOverrideFirewall(hostsModel.isConfigureFirewall());
        parameters.setRebootAfterInstallation(hostsModel.getClusterModel().getEnableOvirtService().getIsSelected());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AddVds, parametersList, true, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            hostsModel.stopProgress();
            boolean isAllCanDoPassed = true;
            for (VdcReturnValueBase returnValueBase : result.getReturnValue()) {
                isAllCanDoPassed = isAllCanDoPassed && returnValueBase.getCanDoAction();
                if (!isAllCanDoPassed) {
                    break;
                }
            }
            if (isAllCanDoPassed) {
                cancel();
            }
        }
    }, null);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(((VDSGroup) getSelectedItem()).getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel model = (ClusterListModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            if (foundNRHosts) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#method_after
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(getSelectedItem().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel<Void> model = (ClusterListModel<Void>) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            if (foundNRHosts) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VDSGroup, ClusterListModel> getClusterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<DefaultConfirmationPopupPresenterWidget> resetEmulatedMachineConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<MultipleHostsPopupPresenterWidget> addMultipleHostsPopupProvider, final Provider<ClusterListModel> clusterProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VDSGroup, ClusterListModel> result = new MainTabModelProvider<VDSGroup, ClusterListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMultipleHostsCommand()) {
                return addMultipleHostsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResetEmulatedMachineCommand()) {
                return resetEmulatedMachineConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(clusterProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VDSGroup, ClusterListModel<Void>> getClusterListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<ClusterPopupPresenterWidget> popupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<MultipleHostsPopupPresenterWidget> addMultipleHostsPopupProvider, final Provider<ClusterListModel<Void>> clusterProvider, final Provider<CommonModel> commonModelProvider) {
    MainTabModelProvider<VDSGroup, ClusterListModel<Void>> result = new MainTabModelProvider<VDSGroup, ClusterListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getAddMultipleHostsCommand()) {
                return addMultipleHostsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResetEmulatedMachineCommand()) {
                return defaultConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(clusterProvider);
    return result;
}
#end_block

#method_before
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<ClusterListModel, ClusterGeneralModel> getClusterGeneralProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<MultipleHostsPopupPresenterWidget> multipleHostsProvider, final Provider<DetachGlusterHostsPopupPresenterWidget> detachHostsProvider, final Provider<ManageGlusterSwiftPopupPresenterWidget> manageGlusterSwiftProvider, final Provider<ClusterListModel> clusterProvider, final Provider<ClusterGeneralModel> detailProvider) {
    DetailTabModelProvider<ClusterListModel, ClusterGeneralModel> result = new DetailTabModelProvider<ClusterListModel, ClusterGeneralModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterGeneralModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getImportNewGlusterHostsCommand()) {
                return multipleHostsProvider.get();
            } else if (lastExecutedCommand == getModel().getDetachNewGlusterHostsCommand()) {
                return detachHostsProvider.get();
            } else if (lastExecutedCommand == getModel().getManageGlusterSwiftCommand()) {
                return manageGlusterSwiftProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setModelProvider(detailProvider);
    result.setMainModelProvider(clusterProvider);
    return result;
}
#method_after
// Form Detail Models
@Provides
@Singleton
public DetailModelProvider<ClusterListModel<Void>, ClusterGeneralModel> getClusterGeneralProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<MultipleHostsPopupPresenterWidget> multipleHostsProvider, final Provider<DetachGlusterHostsPopupPresenterWidget> detachHostsProvider, final Provider<ManageGlusterSwiftPopupPresenterWidget> manageGlusterSwiftProvider, final Provider<ClusterListModel<Void>> clusterProvider, final Provider<ClusterGeneralModel> detailProvider) {
    DetailTabModelProvider<ClusterListModel<Void>, ClusterGeneralModel> result = new DetailTabModelProvider<ClusterListModel<Void>, ClusterGeneralModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterGeneralModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getImportNewGlusterHostsCommand()) {
                return multipleHostsProvider.get();
            } else if (lastExecutedCommand == getModel().getDetachNewGlusterHostsCommand()) {
                return detachHostsProvider.get();
            } else if (lastExecutedCommand == getModel().getManageGlusterSwiftCommand()) {
                return manageGlusterSwiftProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setModelProvider(detailProvider);
    result.setMainModelProvider(clusterProvider);
    return result;
}
#end_block

#method_before
// Search-able Detail Models
@Provides
@Singleton
public SearchableDetailModelProvider<Network, ClusterListModel, ClusterNetworkListModel> getClusterNetworkListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NewClusterNetworkPopupPresenterWidget> popupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider, final Provider<ClusterListModel> mainModelProvider, final Provider<ClusterNetworkListModel> modelProvider) {
    SearchableDetailTabModelProvider<Network, ClusterListModel, ClusterNetworkListModel> result = new SearchableDetailTabModelProvider<Network, ClusterListModel, ClusterNetworkListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewNetworkCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setModelProvider(modelProvider);
    result.setMainModelProvider(mainModelProvider);
    return result;
}
#method_after
// Search-able Detail Models
@Provides
@Singleton
public SearchableDetailModelProvider<Network, ClusterListModel<Void>, ClusterNetworkListModel> getClusterNetworkListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<NewClusterNetworkPopupPresenterWidget> popupProvider, final Provider<ClusterManageNetworkPopupPresenterWidget> managePopupProvider, final Provider<ClusterListModel<Void>> mainModelProvider, final Provider<ClusterNetworkListModel> modelProvider) {
    SearchableDetailTabModelProvider<Network, ClusterListModel<Void>, ClusterNetworkListModel> result = new SearchableDetailTabModelProvider<Network, ClusterListModel<Void>, ClusterNetworkListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterNetworkListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewNetworkCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getManageCommand()) {
                return managePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setModelProvider(modelProvider);
    result.setMainModelProvider(mainModelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterHookEntity, ClusterListModel, ClusterGlusterHookListModel> getClusterGlusterHookListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<DefaultConfirmationPopupPresenterWidget> confirmPopupProvider, final Provider<GlusterHookContentPopupPresenterWidget> contentPopupProvider, final Provider<GlusterHookResolveConflictsPopupPresenterWidget> resolveConflictsPopupProvider, final Provider<ClusterListModel> mainModelProvider, final Provider<ClusterGlusterHookListModel> modelProvider) {
    SearchableDetailTabModelProvider<GlusterHookEntity, ClusterListModel, ClusterGlusterHookListModel> result = new SearchableDetailTabModelProvider<GlusterHookEntity, ClusterListModel, ClusterGlusterHookListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterGlusterHookListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getViewHookCommand()) {
                return contentPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResolveConflictsCommand()) {
                return resolveConflictsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterGlusterHookListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getDisableHookCommand()) {
                return confirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterHookEntity, ClusterListModel<Void>, ClusterGlusterHookListModel> getClusterGlusterHookListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<DefaultConfirmationPopupPresenterWidget> confirmPopupProvider, final Provider<GlusterHookContentPopupPresenterWidget> contentPopupProvider, final Provider<GlusterHookResolveConflictsPopupPresenterWidget> resolveConflictsPopupProvider, final Provider<ClusterListModel<Void>> mainModelProvider, final Provider<ClusterGlusterHookListModel> modelProvider) {
    SearchableDetailTabModelProvider<GlusterHookEntity, ClusterListModel<Void>, ClusterGlusterHookListModel> result = new SearchableDetailTabModelProvider<GlusterHookEntity, ClusterListModel<Void>, ClusterGlusterHookListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterGlusterHookListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getViewHookCommand()) {
                return contentPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getResolveConflictsCommand()) {
                return resolveConflictsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterGlusterHookListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getDisableHookCommand()) {
                return confirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<AffinityGroup, ClusterListModel, ClusterAffinityGroupListModel> getAffinityGroupListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AffinityGroupPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ClusterListModel> mainModelProvider, final Provider<ClusterAffinityGroupListModel> modelProvider) {
    SearchableDetailTabModelProvider<AffinityGroup, ClusterListModel, ClusterAffinityGroupListModel> result = new SearchableDetailTabModelProvider<AffinityGroup, ClusterListModel, ClusterAffinityGroupListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterAffinityGroupListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterAffinityGroupListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<AffinityGroup, ClusterListModel<Void>, ClusterAffinityGroupListModel> getAffinityGroupListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AffinityGroupPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ClusterListModel<Void>> mainModelProvider, final Provider<ClusterAffinityGroupListModel> modelProvider) {
    SearchableDetailTabModelProvider<AffinityGroup, ClusterListModel<Void>, ClusterAffinityGroupListModel> result = new SearchableDetailTabModelProvider<AffinityGroup, ClusterListModel<Void>, ClusterAffinityGroupListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(ClusterAffinityGroupListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(ClusterAffinityGroupListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel> getStorageCpuProfileListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuProfilePopupPresenterWidget> profilePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ClusterListModel> mainModelProvider, final Provider<CpuProfileListModel> modelProvider) {
    SearchableDetailTabModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel> result = new SearchableDetailTabModelProvider<CpuProfile, ClusterListModel, CpuProfileListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return profilePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<CpuProfile, ClusterListModel<Void>, CpuProfileListModel> getStorageCpuProfileListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<CpuProfilePopupPresenterWidget> profilePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ClusterListModel<Void>> mainModelProvider, final Provider<CpuProfileListModel> modelProvider) {
    SearchableDetailTabModelProvider<CpuProfile, ClusterListModel<Void>, CpuProfileListModel> result = new SearchableDetailTabModelProvider<CpuProfile, ClusterListModel<Void>, CpuProfileListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewCommand() || lastExecutedCommand == getModel().getEditCommand()) {
                return profilePopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(CpuProfileListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                // $NON-NLS-1$
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ClusterListModel.class).in(Singleton.class);
    bind(ClusterGeneralModel.class).in(Singleton.class);
    bind(ClusterHostListModel.class).in(Singleton.class);
    bind(ClusterNetworkListModel.class).in(Singleton.class);
    bind(ClusterVmListModel.class).in(Singleton.class);
    bind(ClusterServiceModel.class).in(Singleton.class);
    bind(ClusterGlusterHookListModel.class).in(Singleton.class);
    bind(ClusterAffinityGroupListModel.class).in(Singleton.class);
    bind(CpuProfileListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<ClusterListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<CpuProfileListModel>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<ClusterListModel, ClusterServiceModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ClusterListModel, ClusterServiceModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VDS, ClusterListModel, ClusterHostListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VDS, ClusterListModel, ClusterHostListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VM, ClusterListModel, ClusterVmListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VM, ClusterListModel, ClusterVmListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, ClusterListModel, PermissionListModel<ClusterListModel>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<ClusterListModel>>() {
    }).in(Singleton.class);
    // Cpu Profile permission list model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permissions, CpuProfileListModel, PermissionListModel<CpuProfileListModel>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<CpuProfileListModel>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<ClusterListModel<Void>>() {
    }).in(Singleton.class);
    bind(ClusterGeneralModel.class).in(Singleton.class);
    bind(ClusterHostListModel.class).in(Singleton.class);
    bind(ClusterNetworkListModel.class).in(Singleton.class);
    bind(ClusterVmListModel.class).in(Singleton.class);
    bind(ClusterServiceModel.class).in(Singleton.class);
    bind(ClusterGlusterHookListModel.class).in(Singleton.class);
    bind(ClusterAffinityGroupListModel.class).in(Singleton.class);
    bind(CpuProfileListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VDSGroup>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<CpuProfile>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<ClusterListModel<Void>, ClusterServiceModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ClusterListModel<Void>, ClusterServiceModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<VDS, ClusterListModel<Void>, ClusterHostListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VDS, ClusterListModel<Void>, ClusterHostListModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VM, ClusterListModel<Void>, ClusterVmListModel>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VM, ClusterListModel<Void>, ClusterVmListModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, ClusterListModel<Void>, PermissionListModel<VDSGroup>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VDSGroup, ClusterListModel<Void>>>() {
    }).in(Singleton.class);
    // Cpu Profile permission list model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, CpuProfileListModel, PermissionListModel<CpuProfile>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<CpuProfile, CpuProfileListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getVdsGroup().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getVdsGroupId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getVdsGroup().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getVdsGroup().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDAO().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        // when moving the cluster back into a DC, need to add its management network
        Network managementNetwork = getNetworkDAO().getByNameAndDataCenter(NetworkUtils.getEngineNetwork(), getVdsGroup().getStoragePoolId());
        getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true));
    }
    alertIfFencingDisabled();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getVdsGroup().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getVdsGroupId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getVdsGroup().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getVdsGroup().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDAO().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (isAddedToStoragePool) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDAO().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Cluster incoming, VDSGroup entity) {
    return new VdsGroupOperationParameters(map(incoming, entity));
}
#method_after
@Override
public VdcActionParametersBase getParameters(Cluster incoming, VDSGroup entity) {
    final VDSGroup cluster = map(incoming, entity);
    final ManagementNetworkOnClusterOperationParameters managementNetworkOnClusterOperationParameters;
    final Guid dcId = getDataCenterId(cluster);
    if (dcId == null) {
        managementNetworkOnClusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster);
    } else {
        final Guid managementNetworkId = managementNetworkFinder.getManagementNetworkId(incoming, dcId);
        managementNetworkOnClusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetworkId);
    }
    return managementNetworkOnClusterOperationParameters;
}
#end_block

#method_before
@Override
protected Cluster doPopulate(Cluster model, VDSGroup entity) {
    return model;
}
#method_after
@Override
protected Cluster doPopulate(Cluster cluster, VDSGroup entity) {
    return parent.doPopulate(cluster, entity);
}
#end_block

#method_before
@Override
public Response resetEmulatedMachine(Action action) {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(guid));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        VdsGroupOperationParameters param = new VdsGroupOperationParameters((VDSGroup) result.getReturnValue());
        param.setForceResetEmulatedMachine(true);
        return doAction(VdcActionType.UpdateVdsGroup, param, action);
    } else {
        throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity("Couldn't locate a cluster with the specified id.").build());
    }
}
#method_after
@Override
public Response resetEmulatedMachine(Action action) {
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(guid));
    if (result != null && result.getSucceeded() && result.getReturnValue() != null) {
        ManagementNetworkOnClusterOperationParameters param = new ManagementNetworkOnClusterOperationParameters((VDSGroup) result.getReturnValue());
        param.setForceResetEmulatedMachine(true);
        return doAction(VdcActionType.UpdateVdsGroup, param, action);
    } else {
        throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
    }
}
#end_block

#method_before
void initTable(final ApplicationResources resources, final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VDSGroup> nameColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(ClusterConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameCluster(), "150px");
    CommentColumn<VDSGroup> commentColumn = new CommentColumn<VDSGroup>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDSGroup> dataCenterColumn = new TextColumnWithTooltip<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getStoragePoolName();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dataCenterColumn, constants.dcCluster(), "150px");
    }
    TextColumnWithTooltip<VDSGroup> versionColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getCompatibilityVersion().getValue();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "150px");
    TextColumnWithTooltip<VDSGroup> descColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable(ClusterConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionCluster(), "300px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDSGroup> cpuTypeColumn = new TextColumnWithTooltip<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getCpuName();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(cpuTypeColumn, constants.cpuTypeCluster(), "150px");
    }
    TextColumnWithTooltip<VDSGroup> hostCountColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null) {
                return "";
            }
            return object.getGroupHostsAndVms().getHosts() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostCountColumn, constants.hostCount(), "150px");
    TextColumnWithTooltip<VDSGroup> vmCountColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null) {
                return "";
            }
            return object.getGroupHostsAndVms().getVms() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(vmCountColumn, constants.vmCount(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.newCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.editCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.removeCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability(constants);
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability(constants);
            }
        });
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VDSGroup>(constants.guideMeCluster(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.resetClusterEmulatedMachine(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getResetEmulatedMachineCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    AbstractTextColumn<VDSGroup> nameColumn = new AbstractTextColumn<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable(ClusterConditionFieldAutoCompleter.NAME);
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameCluster(), "150px");
    CommentColumn<VDSGroup> commentColumn = new CommentColumn<VDSGroup>();
    getTable().addColumnWithHtmlHeader(commentColumn, SafeHtmlUtils.fromSafeConstant(constants.commentLabel()), // $NON-NLS-1$
    "75px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDSGroup> dataCenterColumn = new AbstractTextColumn<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getStoragePoolName();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dataCenterColumn, constants.dcCluster(), "150px");
    }
    AbstractTextColumn<VDSGroup> versionColumn = new AbstractTextColumn<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getCompatibilityVersion().getValue();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "150px");
    AbstractTextColumn<VDSGroup> descColumn = new AbstractTextColumn<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getDescription();
        }
    };
    descColumn.makeSortable(ClusterConditionFieldAutoCompleter.DESCRIPTION);
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionCluster(), "300px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        AbstractTextColumn<VDSGroup> cpuTypeColumn = new AbstractTextColumn<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getCpuName();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(cpuTypeColumn, constants.cpuTypeCluster(), "150px");
    }
    AbstractTextColumn<VDSGroup> hostCountColumn = new AbstractTextColumn<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null) {
                // $NON-NLS-1$
                return "";
            }
            // $NON-NLS-1$
            return object.getGroupHostsAndVms().getHosts() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostCountColumn, constants.hostCount(), "150px");
    AbstractTextColumn<VDSGroup> vmCountColumn = new AbstractTextColumn<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null) {
                // $NON-NLS-1$
                return "";
            }
            // $NON-NLS-1$
            return object.getGroupHostsAndVms().getVms() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(vmCountColumn, constants.vmCount(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.newCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.editCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.removeCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        updateReportsAvailability();
    } else {
        getMainModel().getReportsAvailabilityEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                updateReportsAvailability();
            }
        });
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VDSGroup>(constants.guideMeCluster(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.resetClusterEmulatedMachine(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getResetEmulatedMachineCommand();
        }
    });
}
#end_block

#method_before
public void updateReportsAvailability(ApplicationConstants constants) {
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDSGroup>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Cluster", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDSGroup>(constants.showReportCluster(), resourceSubActions));
        }
    }
}
#method_after
public void updateReportsAvailability() {
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDSGroup>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Cluster", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDSGroup>(constants.showReportCluster(), resourceSubActions));
        }
    }
}
#end_block

#method_before
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationVdsId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), null, getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#method_after
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationVdsId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult vmNotHavingPassthroughVnics() {
    for (VM vm : vms) {
        List<VmNetworkInterface> vnics = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        List<VmNetworkInterface> passthroughVnics = LinqUtils.filter(vnics, new org.ovirt.engine.core.utils.linq.Predicate<VmNetworkInterface>() {

            public boolean eval(VmNetworkInterface vnic) {
                return vnic.isPassthrough();
            }
        });
        Collection<String> replacements = ReplacementUtils.replaceWithNameable("interfaces", passthroughVnics);
        replacements.add(String.format("$vmName %s", vm.getName()));
        return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_OF_PASSTHROUGH_VNICS_IS_NOT_SUPPORTED, replacements.toArray(new String[] {})).unless(passthroughVnics.isEmpty());
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmNotHavingPassthroughVnics() {
    for (VM vm : vms) {
        List<VmNetworkInterface> vnics = getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        List<VmNetworkInterface> passthroughVnics = LinqUtils.filter(vnics, new org.ovirt.engine.core.utils.linq.Predicate<VmNetworkInterface>() {

            public boolean eval(VmNetworkInterface vnic) {
                return vnic.isPassthrough();
            }
        });
        Collection<String> replacements = ReplacementUtils.replaceWithNameable("interfaces", passthroughVnics);
        replacements.add(String.format("$vmName %s", vm.getName()));
        if (!passthroughVnics.isEmpty()) {
            return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_OF_PASSTHROUGH_VNICS_IS_NOT_SUPPORTED, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult typeMatchesProfile() {
    boolean profilePassthrough = getVnicProfile() != null && getVnicProfile().isPassthrough();
    boolean typePassthrough = VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(nic.getType()));
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VM_INTERFACE_TYPE_NOT_MATCH_PROFILE).when(profilePassthrough ^ typePassthrough);
}
#method_after
public ValidationResult typeMatchesProfile() {
    boolean profilePassthrough = getVnicProfile() != null && getVnicProfile().isPassthrough();
    boolean typePassthrough = VmInterfaceType.pciPassthrough == VmInterfaceType.forValue(nic.getType());
    return ValidationResult.failWith(VdcBllMessages.ACTION_TYPE_FAILED_VM_INTERFACE_TYPE_NOT_MATCH_PROFILE).when(profilePassthrough ^ typePassthrough);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<VmNic>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getOsId(), getVdsGroup().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getVmTemplate().getId()), VmDeviceUtils.hasWatchdog(getVmTemplate().getId()), VmDeviceUtils.isBalloonEnabled(getVmTemplate().getId()), VmDeviceUtils.isSoundDeviceEnabled(getVmTemplate().getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
        Version clusterCompatibilityVersion = getVdsGroup().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        if (!validate(nicValidator.linkedOnlyIfSupported()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<VmNic>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getOsId(), getVdsGroup().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getVmTemplate().getId()), VmDeviceUtils.hasWatchdog(getVmTemplate().getId()), VmDeviceUtils.isBalloonEnabled(getVmTemplate().getId()), VmDeviceUtils.isSoundDeviceEnabled(getVmTemplate().getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
        Version clusterCompatibilityVersion = getVdsGroup().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        return validate(nicValidator.linkedOnlyIfSupported()) && validate(nicValidator.isCompatibleWithOs()) && validate(nicValidator.emptyNetworkValid()) && validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId())) && validate(nicValidator.typeMatchesProfile()) && validate(nicValidator.passthroughIsLinked());
    }
    return true;
}
#end_block

#method_before
private void restoreSnapshot() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().confirmRestoreSnapshot(getEntity().getName()));
    model.setHelpTag(HelpTag.volume_restore_snapshot_confirmation);
    // $NON-NLS-1$
    model.setHashName("volume_restore_snapshot_confirmation");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmVolumeSnapshotRestoreMesage());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onRestoreSnapshot", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#method_after
private void restoreSnapshot() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().confirmRestoreSnapshot(getEntity().getName()));
    model.setHelpTag(HelpTag.volume_restore_snapshot_confirmation);
    // $NON-NLS-1$
    model.setHashName("volume_restore_snapshot_confirmation");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmVolumeSnapshotRestoreWithStopMessage());
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onRestoreSnapshot", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("cancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
@Test
public void testAttributesConversion() {
    final String booleanName = "booleanAttr";
    final boolean booleanValue = true;
    final String booleanArrayName = "booleanArrayAttr";
    final boolean[] booleanArrayValue = { true, false };
    final String byteName = "byteAttr";
    final byte byteValue = 1;
    final String byteArrayName = "byteArrayAttr";
    final byte[] byteArrayValue = { 2, 3 };
    final String charName = "charAttr";
    final char charValue = 'a';
    final String charArrayName = "charArrayAttr";
    final char[] charArrayValue = { 'b', 'c' };
    final String doubleName = "doubleAttr";
    final double doubleValue = 0.1d;
    final String doubleArrayName = "doubleArrayAttr";
    final double[] doubleArrayValue = { 0.2d, 0.3d };
    final String floatName = "floatAttr";
    final float floatValue = 0.5f;
    final String floatArrayName = "floatArrayAttr";
    final float[] floatArrayValue = { 0.6f, 0.7f };
    final String intName = "intAttr";
    final int intValue = 100;
    final String intArrayName = "intArrayAttr";
    final int[] intArrayValue = { 110, 120 };
    final String longName = "longAttr";
    final long longValue = 1000L;
    final String longArrayName = "longArrayAttr";
    final long[] longArrayValue = { 1001L, 1002L };
    final String objectName = "objectAttr";
    final Object objectValue = new BigDecimal("123.45");
    final String objectArrayName = "objectArrayAttr";
    final Object[] objectArrayValue = { new BigDecimal("56.7"), new Date() };
    final String shortName = "shortAttr";
    final short shortValue = 10;
    final String shortArrayName = "shortArrayAttr";
    final short[] shortArrayValue = { 11, 12 };
    final String passwordName = "password";
    final String passwordValue = "qwerty";
    final String nullPasswordName = "nullPassword";
    final String nullPasswordValue = null;
    final String nullName = null;
    final String nullValue = null;
    final String nullArrayName = "nullArray";
    final Object[] nullArrayValue = null;
    final String nullCollectionName = "nullCollection";
    final Collection nullCollectionValue = null;
    final String emptyCollectionName = "emptyCollection";
    final Collection emptyCollectionValue = Collections.emptyList();
    final String collectionName = "collection";
    final Collection collectionValue = Arrays.asList("item1", "item2");
    final String nullMapName = "nullMap";
    final Collection nullMapValue = null;
    final String emptyMapName = "emptyMap";
    final Map emptyMapValue = Collections.emptyMap();
    final String mapName = "map";
    final Map<String, String> mapValue = new HashMap<>();
    mapValue.put("key1", "value1");
    mapValue.put("key2", "value2");
    String expected = ToStringBuilder.ATTRIBUTES_LIST_PREFIX + createFirstAttributeOutput(booleanName, String.valueOf(booleanValue)) + createAttributeOutput(booleanArrayName, Arrays.toString(booleanArrayValue)) + createAttributeOutput(byteName, String.valueOf(byteValue)) + createAttributeOutput(byteArrayName, Arrays.toString(byteArrayValue)) + createAttributeOutput(charName, String.valueOf(charValue)) + createAttributeOutput(charArrayName, Arrays.toString(charArrayValue)) + createAttributeOutput(doubleName, String.valueOf(doubleValue)) + createAttributeOutput(doubleArrayName, Arrays.toString(doubleArrayValue)) + createAttributeOutput(floatName, String.valueOf(floatValue)) + createAttributeOutput(floatArrayName, Arrays.toString(floatArrayValue)) + createAttributeOutput(intName, String.valueOf(intValue)) + createAttributeOutput(intArrayName, Arrays.toString(intArrayValue)) + createAttributeOutput(longName, String.valueOf(longValue)) + createAttributeOutput(longArrayName, Arrays.toString(longArrayValue)) + createAttributeOutput(objectName, String.valueOf(objectValue)) + createAttributeOutput(objectArrayName, Arrays.toString(objectArrayValue)) + createAttributeOutput(shortName, String.valueOf(shortValue)) + createAttributeOutput(shortArrayName, Arrays.toString(shortArrayValue)) + createAttributeOutput(nullName, String.valueOf(nullValue)) + createAttributeOutput(nullArrayName, Arrays.toString(nullArrayValue)) + createAttributeOutput(passwordName, ToStringBuilder.FILTERED_CONTENT) + createAttributeOutput(nullPasswordName, nullPasswordValue) + createAttributeOutput(nullCollectionName, null) + createAttributeOutput(emptyCollectionName, Arrays.toString(emptyCollectionValue.toArray())) + createAttributeOutput(collectionName, Arrays.toString(collectionValue.toArray())) + createAttributeOutput(nullMapName, null) + createAttributeOutput(emptyMapName, Arrays.toString(emptyMapValue.entrySet().toArray())) + createAttributeOutput(mapName, Arrays.toString(mapValue.entrySet().toArray())) + ToStringBuilder.ATTRIBUTES_LIST_SUFFIX;
    System.out.println("ToString: " + expected);
    assertEquals(expected, ToStringBuilder.forInstance(null).append(booleanName, booleanValue).append(booleanArrayName, booleanArrayValue).append(byteName, byteValue).append(byteArrayName, byteArrayValue).append(charName, charValue).append(charArrayName, charArrayValue).append(doubleName, doubleValue).append(doubleArrayName, doubleArrayValue).append(floatName, floatValue).append(floatArrayName, floatArrayValue).append(intName, intValue).append(intArrayName, intArrayValue).append(longName, longValue).append(longArrayName, longArrayValue).append(objectName, objectValue).append(objectArrayName, objectArrayValue).append(shortName, shortValue).append(shortArrayName, shortArrayValue).append(nullName, nullValue).append(nullArrayName, nullArrayValue).appendFiltered(passwordName, passwordValue).appendFiltered(nullPasswordName, nullPasswordValue).append(nullCollectionName, nullCollectionValue).append(emptyCollectionName, emptyCollectionValue).append(collectionName, collectionValue).append(nullMapName, nullMapValue).append(emptyMapName, emptyMapValue).append(mapName, mapValue).build());
}
#method_after
@Test
public void testAttributesConversion() {
    final String booleanName = "booleanAttr";
    final boolean booleanValue = true;
    final String booleanArrayName = "booleanArrayAttr";
    final boolean[] booleanArrayValue = { true, false };
    final String byteName = "byteAttr";
    final byte byteValue = 1;
    final String byteArrayName = "byteArrayAttr";
    final byte[] byteArrayValue = { 2, 3 };
    final String charName = "charAttr";
    final char charValue = 'a';
    final String charArrayName = "charArrayAttr";
    final char[] charArrayValue = { 'b', 'c' };
    final String doubleName = "doubleAttr";
    final double doubleValue = 0.1d;
    final String doubleArrayName = "doubleArrayAttr";
    final double[] doubleArrayValue = { 0.2d, 0.3d };
    final String floatName = "floatAttr";
    final float floatValue = 0.5f;
    final String floatArrayName = "floatArrayAttr";
    final float[] floatArrayValue = { 0.6f, 0.7f };
    final String intName = "intAttr";
    final int intValue = 100;
    final String intArrayName = "intArrayAttr";
    final int[] intArrayValue = { 110, 120 };
    final String longName = "longAttr";
    final long longValue = 1000L;
    final String longArrayName = "longArrayAttr";
    final long[] longArrayValue = { 1001L, 1002L };
    final String objectName = "objectAttr";
    final Object objectValue = new BigDecimal("123.45");
    final String objectArrayName = "objectArrayAttr";
    final Object[] objectArrayValue = { new BigDecimal("56.7"), new Date() };
    final String shortName = "shortAttr";
    final short shortValue = 10;
    final String shortArrayName = "shortArrayAttr";
    final short[] shortArrayValue = { 11, 12 };
    final String passwordName = "password";
    final String passwordValue = "qwerty";
    final String nullPasswordName = "nullPassword";
    final String nullPasswordValue = null;
    final String nullName = null;
    final String nullValue = null;
    final String nullArrayName = "nullArray";
    final Object[] nullArrayValue = null;
    final String nullCollectionName = "nullCollection";
    final Collection<Object> nullCollectionValue = null;
    final String emptyCollectionName = "emptyCollection";
    final Collection<Object> emptyCollectionValue = Collections.emptyList();
    final String collectionName = "collection";
    final Collection<String> collectionValue = Arrays.asList("item1", "item2");
    final String nullMapName = "nullMap";
    final Map<Object, Object> nullMapValue = null;
    final String emptyMapName = "emptyMap";
    final Map<Object, Object> emptyMapValue = Collections.emptyMap();
    final String mapName = "map";
    final Map<String, String> mapValue = new HashMap<>();
    mapValue.put("key1", "value1");
    mapValue.put("key2", "value2");
    String expected = ToStringBuilder.ATTRIBUTES_LIST_PREFIX + createFirstAttributeOutput(booleanName, String.valueOf(booleanValue)) + createAttributeOutput(booleanArrayName, Arrays.toString(booleanArrayValue)) + createAttributeOutput(byteName, String.valueOf(byteValue)) + createAttributeOutput(byteArrayName, Arrays.toString(byteArrayValue)) + createAttributeOutput(charName, String.valueOf(charValue)) + createAttributeOutput(charArrayName, Arrays.toString(charArrayValue)) + createAttributeOutput(doubleName, String.valueOf(doubleValue)) + createAttributeOutput(doubleArrayName, Arrays.toString(doubleArrayValue)) + createAttributeOutput(floatName, String.valueOf(floatValue)) + createAttributeOutput(floatArrayName, Arrays.toString(floatArrayValue)) + createAttributeOutput(intName, String.valueOf(intValue)) + createAttributeOutput(intArrayName, Arrays.toString(intArrayValue)) + createAttributeOutput(longName, String.valueOf(longValue)) + createAttributeOutput(longArrayName, Arrays.toString(longArrayValue)) + createAttributeOutput(objectName, String.valueOf(objectValue)) + createAttributeOutput(objectArrayName, Arrays.toString(objectArrayValue)) + createAttributeOutput(shortName, String.valueOf(shortValue)) + createAttributeOutput(shortArrayName, Arrays.toString(shortArrayValue)) + createAttributeOutput(nullName, String.valueOf(nullValue)) + createAttributeOutput(nullArrayName, Arrays.toString(nullArrayValue)) + createAttributeOutput(passwordName, ToStringBuilder.FILTERED_CONTENT) + createAttributeOutput(nullPasswordName, nullPasswordValue) + createAttributeOutput(nullCollectionName, null) + createAttributeOutput(emptyCollectionName, Arrays.toString(emptyCollectionValue.toArray())) + createAttributeOutput(collectionName, Arrays.toString(collectionValue.toArray())) + createAttributeOutput(nullMapName, null) + createAttributeOutput(emptyMapName, Arrays.toString(emptyMapValue.entrySet().toArray())) + createAttributeOutput(mapName, Arrays.toString(mapValue.entrySet().toArray())) + ToStringBuilder.ATTRIBUTES_LIST_SUFFIX;
    System.out.println("ToString: " + expected);
    assertEquals(expected, ToStringBuilder.forInstance(null).append(booleanName, booleanValue).append(booleanArrayName, booleanArrayValue).append(byteName, byteValue).append(byteArrayName, byteArrayValue).append(charName, charValue).append(charArrayName, charArrayValue).append(doubleName, doubleValue).append(doubleArrayName, doubleArrayValue).append(floatName, floatValue).append(floatArrayName, floatArrayValue).append(intName, intValue).append(intArrayName, intArrayValue).append(longName, longValue).append(longArrayName, longArrayValue).append(objectName, objectValue).append(objectArrayName, objectArrayValue).append(shortName, shortValue).append(shortArrayName, shortArrayValue).append(nullName, nullValue).append(nullArrayName, nullArrayValue).appendFiltered(passwordName, passwordValue).appendFiltered(nullPasswordName, nullPasswordValue).append(nullCollectionName, nullCollectionValue).append(emptyCollectionName, emptyCollectionValue).append(collectionName, collectionValue).append(nullMapName, nullMapValue).append(emptyMapName, emptyMapValue).append(mapName, mapValue).build());
}
#end_block

#method_before
public static ToStringBuilder forClass(Class clazz) {
    return new ToStringBuilder(clazz);
}
#method_after
public static ToStringBuilder forClass(Class<?> clazz) {
    return new ToStringBuilder(clazz);
}
#end_block

#method_before
public ToStringBuilder append(final String name, final Map value) {
    append(name, value == null ? null : value.entrySet());
    return this;
}
#method_after
public <T> ToStringBuilder append(final String name, final Collection<T> value) {
    appendAttribute(name, value == null ? null : Arrays.toString(value.toArray()));
    return this;
}
#end_block

#method_before
private void appendClassName(Class clazz) {
    if (clazz != null) {
        buffer.append(clazz.getSimpleName());
        buffer.append(CLASS_NAME_SUFFIX);
    }
}
#method_after
private void appendClassName(Class<?> clazz) {
    if (clazz != null) {
        buffer.append(clazz.getSimpleName());
        buffer.append(CLASS_NAME_SUFFIX);
    }
}
#end_block

#method_before
private void UpdateTotalDiskSize() {
    Integer available = getStorageDynamicData().getAvailableDiskSize();
    Integer used = getStorageDynamicData().getUsedDiskSize();
    if (available != null && used != null) {
        setTotalDiskSize(available + used);
    } else {
        // GREGM prevents NPEs
        setTotalDiskSize(null);
    }
}
#method_after
private void UpdateTotalDiskSize() {
    Integer available = getStorageDynamicData().getAvailableDiskSize();
    Integer used = getStorageDynamicData().getUsedDiskSize();
    if (available != null && used != null) {
        setTotalDiskSize(available + used);
    } else {
        setTotalDiskSize(null);
    }
}
#end_block

#method_before
private static Long retrieveIsoFileSize(Map.Entry<String, Map<String, Object>> fileStats) {
    try {
        return Long.valueOf((String) fileStats.getValue().get(VdsProperties.size));
    } catch (RuntimeException e) {
        // Illegal number or null are treated as not available,
        // handling exception in UI will be much more complicated.
        log.error("File's '{}' size is illegal number: {}", fileStats.getKey(), e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#method_after
private static Long retrieveIsoFileSize(Map.Entry<String, Map<String, Object>> fileStats) {
    try {
        Object fileSize = fileStats.getValue().get(VdsProperties.size);
        if (fileSize == null) {
            return null;
        }
        return Long.valueOf((String) fileStats.getValue().get(VdsProperties.size));
    } catch (RuntimeException e) {
        // Illegal number or null are treated as not available,
        // handling exception in UI will be much more complicated.
        log.error("File's '{}' size is illegal number: {}", fileStats.getKey(), e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
private void createDefaultFileStats(Object[] fileNames) {
    Map<String, Object> defaultFileStats = new HashMap<>();
    defaultFileStats.put(VdsProperties.size, null);
    for (int i = 0; i < fileNames.length; i++) {
        fileStats.put((String) fileNames[i], defaultFileStats);
    }
}
#method_after
private void createDefaultFileStats(Object[] fileNames) {
    for (int i = 0; i < fileNames.length; i++) {
        fileStats.put((String) fileNames[i], Collections.<String, Object>emptyMap());
    }
}
#end_block

#method_before
@Test
public void testSave() {
    // Fetch the file from cache table
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(listOfRepoFiles.isEmpty(), true);
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    assertSame(listOfRepoFiles.isEmpty(), false);
}
#method_after
@Test
public void testSave() {
    // Fetch the file from cache table
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertTrue(listOfRepoFiles.isEmpty());
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    assertFalse(listOfRepoFiles.isEmpty());
}
#end_block

#method_before
@Test
public void testRemove() {
    // Should get one iso file
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.ISO);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#method_after
@Test
public void testRemove() {
    // Should get one iso file
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertFalse(listOfRepoFiles.isEmpty());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.ISO);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertTrue(listOfRepoFiles.isEmpty());
}
#end_block

#method_before
@Test
public void testRemoveByRemoveIsoDomain() {
    // Should get one iso file
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    // Test remove Iso
    StorageDomainDAO storageDomainDao = dbFacade.getStorageDomainDao();
    storageDomainDao.remove(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#method_after
@Test
public void testRemoveByRemoveIsoDomain() {
    // Should get one iso file
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertFalse(listOfRepoFiles.isEmpty());
    // Test remove Iso
    StorageDomainDAO storageDomainDao = dbFacade.getStorageDomainDao();
    storageDomainDao.remove(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3);
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertTrue(listOfRepoFiles.isEmpty());
}
#end_block

#method_before
@Test
public void testFetchAllIsoDomainInSystemNoDuplicate() {
    // Should get one iso file
    List<RepoImage> listOfAllIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    // Should get only 4 files, 3 file types from one shared storage domain.
    // plus one empty file of the storage pool with no Iso at all.
    assertSame(listOfAllIsoFiles.size(), 4);
}
#method_after
@Test
public void testFetchAllIsoDomainInSystemNoDuplicate() {
    // Should get one iso file
    List<RepoImage> listOfAllIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    // Should get only 4 files, 3 file types from one shared storage domain.
    // plus one empty file of the storage pool with no Iso at all.
    assertEquals(4, listOfAllIsoFiles.size());
}
#end_block

#method_before
@Test
public void testFileTypeWhenFetchAllIsoDomainInSystem() {
    // Should get one iso file
    List<RepoImage> listOfAllIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<ImageFileType> SharedStorageDomainFileType = new ArrayList<ImageFileType>();
    List<ImageFileType> EmptyStorageDomainFileType = new ArrayList<ImageFileType>();
    for (RepoImage fileMD : listOfAllIsoFiles) {
        Guid repoDomainId = fileMD.getRepoDomainId();
        if (repoDomainId.equals(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3)) {
            // Should have three types of files.
            SharedStorageDomainFileType.add(fileMD.getFileType());
        } else if (repoDomainId.equals(FixturesTool.STORAGE_DOAMIN_NFS_ISO)) {
            // Should have only one type (UNKNOWN)
            EmptyStorageDomainFileType.add(fileMD.getFileType());
        }
    }
    // Start the check
    // the shared storage domain, should have three types of files.
    assertEquals(SharedStorageDomainFileType.size(), 3);
    assertEquals(SharedStorageDomainFileType.contains(ImageFileType.Unknown), true);
    assertEquals(SharedStorageDomainFileType.contains(ImageFileType.ISO), true);
    assertEquals(SharedStorageDomainFileType.contains(ImageFileType.Floppy), true);
    // The empty storage domain, should not have files, but should be fetched, since we want to refresh it.
    assertEquals(EmptyStorageDomainFileType.size(), 1);
    assertEquals(EmptyStorageDomainFileType.contains(ImageFileType.Unknown), true);
}
#method_after
@Test
public void testFileTypeWhenFetchAllIsoDomainInSystem() {
    // Should get one iso file
    List<RepoImage> listOfAllIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<ImageFileType> SharedStorageDomainFileType = new ArrayList<>();
    List<ImageFileType> EmptyStorageDomainFileType = new ArrayList<>();
    for (RepoImage fileMD : listOfAllIsoFiles) {
        Guid repoDomainId = fileMD.getRepoDomainId();
        if (repoDomainId.equals(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3)) {
            // Should have three types of files.
            SharedStorageDomainFileType.add(fileMD.getFileType());
        } else if (repoDomainId.equals(FixturesTool.STORAGE_DOAMIN_NFS_ISO)) {
            // Should have only one type (UNKNOWN)
            EmptyStorageDomainFileType.add(fileMD.getFileType());
        }
    }
    // Start the check
    // the shared storage domain, should have three types of files.
    assertEquals(3, SharedStorageDomainFileType.size());
    assertTrue(SharedStorageDomainFileType.contains(ImageFileType.Unknown));
    assertTrue(SharedStorageDomainFileType.contains(ImageFileType.ISO));
    assertTrue(SharedStorageDomainFileType.contains(ImageFileType.Floppy));
    // The empty storage domain, should not have files, but should be fetched, since we want to refresh it.
    assertEquals(1, EmptyStorageDomainFileType.size());
    assertTrue(EmptyStorageDomainFileType.contains(ImageFileType.Unknown));
}
#end_block

#method_before
@Test
public void testFetchAllIsoDomainOldestFile() {
    List<RepoImage> listOfIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<RepoImage> listOfFloppyFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.Floppy);
    long minLastRefreshed = 9999999999999L;
    for (RepoImage fileMD : listOfFloppyFiles) {
        long fileLastRefreshed = fileMD.getLastRefreshed();
        if (fileLastRefreshed < minLastRefreshed) {
            minLastRefreshed = fileLastRefreshed;
        }
    }
    // Check if fetched the oldest file when fetching all repository files.
    boolean isValid = true;
    for (RepoImage fileMetaData : listOfIsoFiles) {
        if (fileMetaData.getFileType() == ImageFileType.Floppy) {
            if (fileMetaData.getLastRefreshed() > minLastRefreshed) {
                isValid = false;
            }
        }
    }
    assertEquals(isValid, true);
}
#method_after
@Test
public void testFetchAllIsoDomainOldestFile() {
    List<RepoImage> listOfIsoFiles = repoFileMetaDataDao.getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    List<RepoImage> listOfFloppyFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.SHARED_ISO_STORAGE_DOAMIN_FOR_SP2_AND_SP3, ImageFileType.Floppy);
    long minLastRefreshed = 9999999999999L;
    for (RepoImage fileMD : listOfFloppyFiles) {
        long fileLastRefreshed = fileMD.getLastRefreshed();
        if (fileLastRefreshed < minLastRefreshed) {
            minLastRefreshed = fileLastRefreshed;
        }
    }
    // Check if fetched the oldest file when fetching all repository files.
    boolean isValid = true;
    for (RepoImage fileMetaData : listOfIsoFiles) {
        if (fileMetaData.getFileType() == ImageFileType.Floppy) {
            if (fileMetaData.getLastRefreshed() > minLastRefreshed) {
                isValid = false;
            }
        }
    }
    assertTrue(isValid);
}
#end_block

#method_before
@Test
public void testInsertRepoFileAndFetchItAgain() {
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(true, !listOfRepoFiles.isEmpty());
    assertEquals(listOfRepoFiles.get(0).getRepoImageId(), newRepoFileMap.getRepoImageId());
    assertSame(true, listOfRepoFiles.get(0).getLastRefreshed() == newRepoFileMap.getLastRefreshed());
    assertSame(true, listOfRepoFiles.get(0).getSize().equals(newRepoFileMap.getSize()));
    assertSame(true, listOfRepoFiles.get(0).getRepoDomainId().equals(newRepoFileMap.getRepoDomainId()));
}
#method_after
@Test
public void testInsertRepoFileAndFetchItAgain() {
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertFalse(listOfRepoFiles.isEmpty());
    assertEquals(listOfRepoFiles.get(0).getRepoImageId(), newRepoFileMap.getRepoImageId());
    assertEquals(listOfRepoFiles.get(0).getLastRefreshed(), newRepoFileMap.getLastRefreshed());
    assertEquals(listOfRepoFiles.get(0).getSize(), newRepoFileMap.getSize());
    assertEquals(listOfRepoFiles.get(0).getRepoDomainId(), newRepoFileMap.getRepoDomainId());
}
#end_block

#method_before
@Test
public void testUpdateRepoFileByRemoveAndInsert() {
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the file from cache table
    List<RepoImage> listOfRepoFiles = getActiveIsoDomain();
    // Get first file and update its String
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    RepoImage repoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    String oldRepoImageId = repoFile.getRepoImageId();
    newRepoFileMap.setRepoImageId("updatedFileName" + newRepoFileMap.getRepoImageId());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    // Add the new updated file into the cache table.
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the updated File.
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertNotSame(true, listOfRepoFiles.isEmpty());
    RepoImage newRepoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    // Check if not same file name as in the old file.
    assertNotSame(oldRepoImageId, newRepoFile.getRepoImageId());
}
#method_after
@Test
public void testUpdateRepoFileByRemoveAndInsert() {
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the file from cache table
    List<RepoImage> listOfRepoFiles = getActiveIsoDomain();
    // Get first file and update its String
    assertNotNull(listOfRepoFiles);
    assertFalse(listOfRepoFiles.isEmpty());
    RepoImage repoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    String oldRepoImageId = repoFile.getRepoImageId();
    newRepoFileMap.setRepoImageId("updatedFileName" + newRepoFileMap.getRepoImageId());
    // Remove the file from cache table
    repoFileMetaDataDao.removeRepoDomainFileList(FixturesTool.STORAGE_DOAMIN_NFS_ISO, ImageFileType.ISO);
    // Add the new updated file into the cache table.
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    // Fetch the updated File.
    listOfRepoFiles = getActiveIsoDomain();
    assertNotNull(listOfRepoFiles);
    assertFalse(listOfRepoFiles.isEmpty());
    RepoImage newRepoFile = listOfRepoFiles.get(0);
    assertNotNull(repoFile);
    // Check if not same file name as in the old file.
    assertNotSame(oldRepoImageId, newRepoFile.getRepoImageId());
}
#end_block

#method_before
@Test
public void testPrimaryKeyValidation() {
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    try {
        repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    } catch (Exception e) {
        // Should enter here since its a violation of primary key
        assertTrue(true);
    }
}
#method_after
@Test(expected = DuplicateKeyException.class)
public void testPrimaryKeyValidation() {
    RepoImage newRepoFileMap = getNewIsoRepoFile();
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
    assertTrue("Able to insert new file once", true);
    // Should enter here since its a violation of primary key
    repoFileMetaDataDao.addRepoFileMap(newRepoFileMap);
}
#end_block

#method_before
@Test
public void testFetchNotExistingRepoFileListById() {
    Guid falseGuid = new Guid("11111111-1111-1111-1111-111111111111");
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(falseGuid, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertSame(true, listOfRepoFiles.isEmpty());
}
#method_after
@Test
public void testFetchNotExistingRepoFileListById() {
    Guid falseGuid = new Guid("11111111-1111-1111-1111-111111111111");
    List<RepoImage> listOfRepoFiles = repoFileMetaDataDao.getRepoListForStorageDomain(falseGuid, ImageFileType.ISO);
    assertNotNull(listOfRepoFiles);
    assertTrue(listOfRepoFiles.isEmpty());
}
#end_block

#method_before
private static RepoImage getNewIsoRepoFile() {
    RepoImage newRepoFileMap = new RepoImage();
    newRepoFileMap.setFileType(ImageFileType.ISO);
    newRepoFileMap.setRepoImageId("isoDomain.iso");
    newRepoFileMap.setLastRefreshed(System.currentTimeMillis());
    newRepoFileMap.setSize(0);
    newRepoFileMap.setDateCreated(null);
    newRepoFileMap.setRepoDomainId(FixturesTool.STORAGE_DOAMIN_NFS_ISO);
    return newRepoFileMap;
}
#method_after
private static RepoImage getNewIsoRepoFile() {
    RepoImage newRepoFileMap = new RepoImage();
    newRepoFileMap.setFileType(ImageFileType.ISO);
    newRepoFileMap.setRepoImageId("isoDomain.iso");
    newRepoFileMap.setLastRefreshed(System.currentTimeMillis());
    newRepoFileMap.setSize(null);
    newRepoFileMap.setDateCreated(null);
    newRepoFileMap.setRepoDomainId(FixturesTool.STORAGE_DOAMIN_NFS_ISO);
    return newRepoFileMap;
}
#end_block

#method_before
private List<String> getHotKeysAsList() {
    List<String> result = new LinkedList<String>();
    if (!StringHelper.isNullOrEmpty(getReleaseCursorHotKey())) {
        // $NON-NLS-1$
        result.add("release-cursor=" + getReleaseCursorHotKey());
    }
    if (!StringHelper.isNullOrEmpty(getToggleFullscreenHotKey())) {
        // $NON-NLS-1$
        result.add("toggle-fullscreen=" + getToggleFullscreenHotKey());
    }
    if (isRemapCtrlAltDel() && !StringHelper.isNullOrEmpty(getSecureAttentionMapping())) {
        // $NON-NLS-1$
        result.add("secure-attention=" + getSecureAttentionMapping());
    }
    return result;
}
#method_after
private List<String> getHotKeysAsList() {
    List<String> result = new LinkedList<String>();
    ConsoleOptions options = getOptions();
    if (!StringHelper.isNullOrEmpty(options.getReleaseCursorHotKey())) {
        // $NON-NLS-1$
        result.add("release-cursor=" + options.getReleaseCursorHotKey());
    }
    if (!StringHelper.isNullOrEmpty(options.getToggleFullscreenHotKey())) {
        // $NON-NLS-1$
        result.add("toggle-fullscreen=" + options.getToggleFullscreenHotKey());
    }
    if (options.isRemapCtrlAltDelete()) {
        // $NON-NLS-1$
        result.add("secure-attention=" + ConsoleOptions.SECURE_ATTENTION_MAPPING);
    }
    return result;
}
#end_block

#method_before
public void setConsoleClientMode(ClientConsoleMode consoleMode) {
    ConsoleUtils consoleUtils = (ConsoleUtils) TypeResolver.getInstance().resolve(ConsoleUtils.class);
    this.consoleMode = consoleMode;
    switch(consoleMode) {
        case Native:
            setspice((ISpice) TypeResolver.getInstance().resolve(ISpiceNative.class));
            break;
        case Plugin:
            setspice((ISpice) TypeResolver.getInstance().resolve(ISpicePlugin.class));
            break;
        case Html5:
            if (consoleUtils.webBasedClientsSupported()) {
                setspice((ISpice) TypeResolver.getInstance().resolve(ISpiceHtml5.class));
            } else {
                // $NON-NLS-1$
                getLogger().debug("Cannot select SPICE-HTML5.");
                setDefaultConsoleMode();
            }
            break;
        default:
            setDefaultConsoleMode();
            break;
    }
    getConfigurator().configure(getspice());
    if (!getspice().getConnectedEvent().getListeners().contains(this)) {
        getspice().getConnectedEvent().addListener(this);
    }
    if (getEntity() != null) {
        boolean isSpiceProxyDefined = consoleUtils.isSpiceProxyDefined(getEntity());
        getspice().setSpiceProxyEnabled(isSpiceProxyDefined);
    }
}
#method_after
public void setConsoleClientMode(ClientConsoleMode consoleMode) {
    ConsoleUtils consoleUtils = (ConsoleUtils) TypeResolver.getInstance().resolve(ConsoleUtils.class);
    this.consoleMode = consoleMode;
    switch(consoleMode) {
        case Native:
            setspice((ISpice) TypeResolver.getInstance().resolve(ISpiceNative.class));
            break;
        case Plugin:
            setspice((ISpice) TypeResolver.getInstance().resolve(ISpicePlugin.class));
            break;
        case Html5:
            if (consoleUtils.webBasedClientsSupported()) {
                setspice((ISpice) TypeResolver.getInstance().resolve(ISpiceHtml5.class));
            } else {
                // $NON-NLS-1$
                getLogger().debug("Cannot select SPICE-HTML5.");
                setDefaultConsoleMode();
            }
            break;
        default:
            setDefaultConsoleMode();
            break;
    }
    getConfigurator().configure(getspice());
    if (!getspice().getConnectedEvent().getListeners().contains(this)) {
        getspice().getConnectedEvent().addListener(this);
    }
    if (getEntity() != null) {
        boolean isSpiceProxyDefined = consoleUtils.isSpiceProxyDefined(getEntity());
        getspice().getOptions().setSpiceProxyEnabled(isSpiceProxyDefined);
    }
}
#end_block

#method_before
@Override
protected void connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().debug("Connecting to Spice console...");
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            Window.alert("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!AsyncDataProvider.getInstance().isWindowsOsType(getEntity().getVmOsId()) || !getEntity().getHasSpiceDriver()) {
            getspice().setWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#method_after
@Override
protected void connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().debug("Connecting to Spice console...");
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!AsyncDataProvider.getInstance().isWindowsOsType(getEntity().getVmOsId()) || !getEntity().getHasSpiceDriver()) {
            getspice().getOptions().setWanOptionsEnabled(false);
        }
        UICommand invokeConsoleCommand = new UICommand("invokeConsoleCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                invokeConsole();
            }
        });
        executeCommandWithConsoleSafenessWarning(invokeConsoleCommand);
    }
}
#end_block

#method_before
private void executeQuery(final VM vm) {
    AsyncQuery _asyncQuery0 = new AsyncQuery();
    _asyncQuery0.setModel(this);
    _asyncQuery0.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model0, Object result0) {
            SpiceConsoleModel thisSpiceConsoleModel = (SpiceConsoleModel) model0;
            VM thisVm = thisSpiceConsoleModel.getEntity();
            StorageDomain isoDomain = null;
            if (result0 != null) {
                isoDomain = (StorageDomain) result0;
            }
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetVdsCertificateSubjectByVmId);
            queryTypeList.add(VdcQueryType.GetCACertificate);
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SSLEnabled, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.CipherSuite, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceSecureChannels, thisVm.getVdsGroupCompatibilityVersion().toString()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.EnableSpiceRootCertificateValidation, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()));
            parametersList.add(new IdQueryParameters(thisVm.getId()));
            parametersList.add(new VdcQueryParametersBase());
            if (isoDomain != null) {
                queryTypeList.add(VdcQueryType.GetImagesListByStoragePoolId);
                GetImagesListByStoragePoolIdParameters getIsoParams = new GetImagesListByStoragePoolIdParameters(vm.getStoragePoolId(), ImageFileType.ISO);
                parametersList.add(getIsoParams);
            }
            Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, thisSpiceConsoleModel);
        }
    };
    AsyncDataProvider.getInstance().getIsoDomainByDataCenterId(_asyncQuery0, vm.getStoragePoolId());
}
#method_after
private void executeQuery(final VM vm) {
    final AsyncQuery imagesListQuery = new AsyncQuery();
    imagesListQuery.setModel(this);
    imagesListQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<RepoImage> repoImages = ((VdcQueryReturnValue) returnValue).getReturnValue();
            ((SpiceConsoleModel) model).invokeClient(repoImages);
        }
    };
    AsyncQuery isoDomainQuery = new AsyncQuery();
    isoDomainQuery.setModel(this);
    isoDomainQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            StorageDomain isoDomain = (StorageDomain) result;
            if (isoDomain != null) {
                GetImagesListByStoragePoolIdParameters getIsoParams = new GetImagesListByStoragePoolIdParameters(vm.getStoragePoolId(), ImageFileType.ISO);
                Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, getIsoParams, imagesListQuery);
            } else {
                ((SpiceConsoleModel) model).invokeClient(null);
            }
        }
    };
    AsyncDataProvider.getInstance().getIsoDomainByDataCenterId(isoDomainQuery, vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void onBootstrap() {
    // Handle UI logout requests
    user.setLogoutHandler(this);
    // Initialize UiCommon infrastructure
    initUiCommon();
    initFrontend();
    initLoginModel();
    // Check if the user should be logged in automatically
    AutoLoginData autoLoginData = AutoLoginData.instance();
    if (autoLoginData != null) {
        handleAutoLogin(autoLoginData);
    }
    // Check for Engine user session timeout configuration
    EngineSessionTimeoutData engineSessionTimeoutData = EngineSessionTimeoutData.instance();
    if (engineSessionTimeoutData != null) {
        restApiSessionManager.setSessionTimeout(engineSessionTimeoutData.getValue());
    }
}
#method_after
@Override
public void onBootstrap() {
    // Handle UI logout requests
    user.setLogoutHandler(this);
    // Initialize UiCommon infrastructure
    initUiCommon();
    initFrontend();
    initLoginModel();
    // Check if the user should be logged in automatically
    AutoLoginData autoLoginData = AutoLoginData.instance();
    if (autoLoginData != null) {
        handleAutoLogin(autoLoginData);
    }
    // Check for Engine user session timeout configuration
    EngineSessionTimeoutData engineSessionTimeoutData = EngineSessionTimeoutData.instance();
    if (engineSessionTimeoutData != null) {
        restApiSessionManager.setSessionTimeout(engineSessionTimeoutData.getSessionTimeout());
        restApiSessionManager.setHardLimit(engineSessionTimeoutData.getSessionHardLimit());
    }
}
#end_block

#method_before
protected String getClientTitle() {
    String releaseCursorKeys = getReleaseCursorKeys();
    String releaseCursorKeysTranslated = AsyncDataProvider.getInstance().getComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    // $NON-NLS-1$
    String releaseCursorMsg = "";
    if (!StringHelper.isNullOrEmpty(releaseCursorKeysTranslated)) {
        releaseCursorMsg = " - " + // $NON-NLS-1$
        ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated);
    }
    // $NON-NLS-1$
    return getEntity().getName() + ":%d" + releaseCursorMsg;
}
#method_after
protected String getClientTitle() {
    AsyncDataProvider asyncDataProvider = AsyncDataProvider.getInstance();
    String releaseCursorKeys = (String) asyncDataProvider.getConfigValuePreConverted(ConfigurationValues.ConsoleReleaseCursorKeys);
    String releaseCursorKeysTranslated = asyncDataProvider.getComplexValueFromSpiceRedKeysResource(// $NON-NLS-1$
    (releaseCursorKeys != null) ? releaseCursorKeys : "shift+f12");
    // $NON-NLS-1$
    String releaseCursorMsg = "";
    if (!StringHelper.isNullOrEmpty(releaseCursorKeysTranslated)) {
        releaseCursorMsg = " - " + // $NON-NLS-1$
        ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated);
    }
    // $NON-NLS-1$
    return getEntity().getName() + ":%d" + releaseCursorMsg;
}
#end_block

#method_before
protected void setForeignMenuData(HasForeignMenuData nativeImpl, String engineCertificate) {
    nativeImpl.setEngineHost(Window.Location.getHost());
    nativeImpl.setVmId(getEntity().getId());
    nativeImpl.setTrustStore(engineCertificate);
    nativeImpl.setAdmin(Frontend.getInstance().getLoggedInUser().isAdmin());
}
#method_after
protected void setForeignMenuData(HasForeignMenuData nativeImpl) {
    nativeImpl.setEngineHost(Window.Location.getHost());
    nativeImpl.setVmId(getEntity().getId());
    nativeImpl.setAdmin(Frontend.getInstance().getLoggedInUser().isAdmin());
}
#end_block

#method_before
@Override
protected void onLogin(UserPortalLoginModel loginModel) {
    // Instead of performing login now, request update for "IsENGINEUser" property
    loginModel.updateIsENGINEUser(loginModel.getLoggedUser());
}
#method_after
@Override
protected void onLogin(UserPortalLoginModel loginModel) {
    super.onLogin(loginModel);
    // Instead of performing login now, request update for "IsENGINEUser" property
    loginModel.updateIsENGINEUser(loginModel.getLoggedUser());
}
#end_block

#method_before
@Override
protected void connect() {
    if (getEntity() == null || getEntity().getRunOnVds() == null) {
        return;
    }
    // $NON-NLS-1$
    getLogger().debug("VNC console info...");
    UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            setVmTicket();
        }
    });
    executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
}
#method_after
@Override
protected void connect() {
    if (getEntity() == null || getEntity().getRunOnVds() == null) {
        return;
    }
    // $NON-NLS-1$
    getLogger().debug("VNC console info...");
    UICommand invokeConsoleCommand = new UICommand("invokeConsoleCommand", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand uiCommand) {
            invokeConsole();
        }
    });
    executeCommandWithConsoleSafenessWarning(invokeConsoleCommand);
}
#end_block

#method_before
@Override
protected void onLogin(final LoginModel loginModel) {
    // Initialize reports
    ReportInit.getInstance().init();
    // Update Reports availability after reports xml has been retrieved
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateReportsAvailability();
        }
    });
    performLogin(loginModel);
}
#method_after
@Override
protected void onLogin(final LoginModel loginModel) {
    super.onLogin(loginModel);
    // Initialize reports
    ReportInit.getInstance().init();
    // Update Reports availability after reports xml has been retrieved
    ReportInit.getInstance().getReportsInitEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateReportsAvailability();
        }
    });
    performLogin(loginModel);
}
#end_block

#method_before
@Override
public void onEngineSessionRefreshed(EngineSessionRefreshedEvent event) {
    if (restApiSessionId != null) {
        refreshRestApiSession = true;
    }
}
#method_after
@Override
public void onEngineSessionRefreshed(EngineSessionRefreshedEvent event) {
    if (restApiSessionId != null && (restApiLoginTimePlusHardLimit == null || new Date().before(restApiLoginTimePlusHardLimit))) {
        refreshRestApiSession = true;
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        String ssoToken = (String) request.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (ssoToken != null) {
            request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(ssoToken));
        }
    }
    // Set attribute for engineSessionTimeout object
    Integer engineSessionTimeout = getEngineSessionTimeout(getEngineSessionId(request));
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(engineSessionTimeout));
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), // $NON-NLS-1$
    ",")));
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        String ssoToken = (String) request.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (ssoToken != null) {
            request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(ssoToken));
        }
    }
    // Set attribute for engineSessionTimeout object
    request.setAttribute(ATTR_ENGINE_SESSION_TIMEOUT, getEngineSessionTimeoutObject(getUserSessionTimeout(), getUserSessionHardTimeout()));
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
protected ObjectNode getEngineSessionTimeoutObject(Integer engineSessionTimeout) {
    ObjectNode obj = createObjectNode();
    // $NON-NLS-1$
    obj.put("value", String.valueOf(engineSessionTimeout));
    return obj;
}
#method_after
protected ObjectNode getEngineSessionTimeoutObject(Integer engineSessionTimeout, Integer userSessionHardLimit) {
    ObjectNode obj = createObjectNode();
    // $NON-NLS-1$
    obj.put("sessionTimeout", String.valueOf(engineSessionTimeout));
    // $NON-NLS-1$
    obj.put("sessionHardLimit", String.valueOf(userSessionHardLimit));
    return obj;
}
#end_block

#method_before
@Override
public void invokeClient() {
    WebClientConsoleInvoker invoker = new WebClientConsoleInvoker(CLIENT_PAGE, getConfig(), getVncHost(), getVncPort(), getTicket(), false);
    invoker.invokeClient();
}
#method_after
@Override
public void invokeClient() {
    WebClientConsoleInvoker invoker = new WebClientConsoleInvoker(CLIENT_PAGE, getConfig(), getOptions().getHost(), getOptions().getPort(), getOptions().getTicket(), false);
    invoker.invokeClient();
}
#end_block

#method_before
protected WebsocketProxyConfig getConfig() {
    if (config != null) {
        config = new WebsocketProxyConfig((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy), getVncHost());
    }
    return config;
}
#method_after
protected WebsocketProxyConfig getConfig() {
    if (config != null) {
        config = new WebsocketProxyConfig((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy), getOptions().getHost());
    }
    return config;
}
#end_block

#method_before
protected WebsocketProxyConfig getConfig() {
    if (config == null) {
        config = new WebsocketProxyConfig((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy), getHost());
    }
    return config;
}
#method_after
protected WebsocketProxyConfig getConfig() {
    if (config == null) {
        config = new WebsocketProxyConfig((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy), getOptions().getHost());
    }
    return config;
}
#end_block

#method_before
@Test
public void testDoGet_ExtraAttributes_WithoutUserInfoObject() throws IOException, ServletException {
    doReturn(mockApplicationModeObject).when(testServlet).getApplicationModeObject(any(Integer.class));
    doReturn(mockPluginDefinitionsArray).when(testServlet).getPluginDefinitionsArray(anyListOf(PluginData.class));
    doReturn(mockEngineSessionTimeoutObject).when(testServlet).getEngineSessionTimeoutObject(any(Integer.class));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute(WebAdminHostPageServlet.ATTR_APPLICATION_MODE, mockApplicationModeObject);
    verify(mockRequest).setAttribute(WebAdminHostPageServlet.ATTR_PLUGIN_DEFS, mockPluginDefinitionsArray);
    verify(mockRequest).setAttribute(WebAdminHostPageServlet.ATTR_ENGINE_SESSION_TIMEOUT, mockEngineSessionTimeoutObject);
}
#method_after
@Test
public void testDoGet_ExtraAttributes_WithoutUserInfoObject() throws IOException, ServletException {
    doReturn(mockApplicationModeObject).when(testServlet).getApplicationModeObject(any(Integer.class));
    doReturn(mockPluginDefinitionsArray).when(testServlet).getPluginDefinitionsArray(anyListOf(PluginData.class));
    doReturn(mockEngineSessionTimeoutObject).when(testServlet).getEngineSessionTimeoutObject(any(Integer.class), any(Integer.class));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute(WebAdminHostPageServlet.ATTR_APPLICATION_MODE, mockApplicationModeObject);
    verify(mockRequest).setAttribute(WebAdminHostPageServlet.ATTR_PLUGIN_DEFS, mockPluginDefinitionsArray);
    verify(mockRequest).setAttribute(WebAdminHostPageServlet.ATTR_ENGINE_SESSION_TIMEOUT, mockEngineSessionTimeoutObject);
}
#end_block

#method_before
@Override
public void invokeClient() {
    // $NON-NLS-1$
    StringBuilder configBuilder = new StringBuilder("[virt-viewer]");
    // $NON-NLS-1$
    configBuilder.append("\ntype=vnc").append("\nhost=").append(// $NON-NLS-1$
    getVncHost()).append("\nport=").append(// $NON-NLS-1$
    getVncPort()).append("\npassword=").append(// $NON-NLS-1$
    getTicket()).append("\n# Password is valid for ").append(getTicketValiditySeconds()).append(// $$NON-NLS-1$NON-NLS-2$
    " seconds.").append(// $NON-NLS-1$
    "\ndelete-this-file=1").append("\ntitle=").append(// $NON-NLS-1$
    getTitle());
    if (!StringHelper.isNullOrEmpty(getToggleFullscreenHotKey())) {
        // $NON-NLS-1$
        configBuilder.append("\ntoggle-fullscreen=").append(getToggleFullscreenHotKey());
    }
    if (!StringHelper.isNullOrEmpty(getReleaseCursorHotKey())) {
        // $NON-NLS-1$
        configBuilder.append("\nrelease-cursor=").append(getReleaseCursorHotKey());
    }
    if (isRemapCtrlAltDelete() && !StringHelper.isNullOrEmpty(getSecureAttentionMapping())) {
        // $NON-NLS-1$
        configBuilder.append("\nsecure-attention=").append(getSecureAttentionMapping());
    }
    writeOVirtSection(configBuilder);
    // $NON-NLS-1$ $NON-NLS-2$
    ConsoleModel.makeConsoleConfigRequest("console.vv", "application/x-virt-viewer; charset=UTF-8", configBuilder.toString());
}
#method_after
@Override
public void invokeClient() {
    AsyncQuery callback = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            // todo avoid code duplication with spice
            StringBuilder configBuilder = new StringBuilder((String) ((VdcQueryReturnValue) returnValue).getReturnValue());
            writeOVirtSection(configBuilder);
            // $NON-NLS-1$
            ConsoleModel.makeConsoleConfigRequest(// $NON-NLS-1$
            "console.vv", // $NON-NLS-1$
            "application/x-virt-viewer; charset=UTF-8", configBuilder.toString());
        }
    });
    Frontend.getInstance().runQuery(VdcQueryType.GetConsoleDescriptorFile, new ConsoleOptionsParams(getOptions()), callback);
}
#end_block

#method_before
private void attach() {
    if (getWindow() != null) {
        return;
    }
    setattachCandidateDatacenters(new ArrayList<EntityModel>());
    setAttachMultiple(getEntity().getStorageDomainType() == StorageDomainType.ISO);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageDataCenterListModel listModel = (StorageDataCenterListModel) target;
            listModel.setavailableDatacenters((ArrayList<StoragePool>) returnValue);
            for (StoragePool dataCenter : listModel.getavailableDatacenters()) {
                switch(getEntity().getStorageDomainType()) {
                    case Master:
                    case Data:
                        boolean addDatacenter = (dataCenter.getStatus() == StoragePoolStatus.Uninitialized || dataCenter.getStatus() == StoragePoolStatus.Up) && (dataCenter.getStoragePoolFormatType() == null || dataCenter.getStoragePoolFormatType() == getEntity().getStorageStaticData().getStorageFormat() && dataCenter.isLocal() == (getEntity().getStorageType() == StorageType.LOCALFS));
                        addToAttachCandidateDatacenters(dataCenter, addDatacenter);
                        break;
                    case ISO:
                        AsyncDataProvider.getInstance().getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { listModel, dataCenter }, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object target1, Object returnValue1) {
                                Object[] array1 = (Object[]) target1;
                                StorageDataCenterListModel listModel1 = (StorageDataCenterListModel) array1[0];
                                StoragePool dataCenter1 = (StoragePool) array1[1];
                                boolean addDatacenter1 = dataCenter1.getStatus() == StoragePoolStatus.Up && returnValue1 == null;
                                listModel1.addToAttachCandidateDatacenters(dataCenter1, addDatacenter1);
                            }
                        }), dataCenter.getId());
                        break;
                    case ImportExport:
                        AsyncDataProvider.getInstance().getExportDomainByDataCenterId(new AsyncQuery(new Object[] { listModel, dataCenter }, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object target2, Object returnValue2) {
                                Object[] array2 = (Object[]) target2;
                                StorageDataCenterListModel listModel2 = (StorageDataCenterListModel) array2[0];
                                StoragePool dataCenter2 = (StoragePool) array2[1];
                                boolean addDatacenter2 = dataCenter2.getStatus() == StoragePoolStatus.Up && returnValue2 == null;
                                listModel2.addToAttachCandidateDatacenters(dataCenter2, addDatacenter2);
                            }
                        }), dataCenter.getId());
                        break;
                }
            }
        }
    }));
}
#method_after
private void attach() {
    if (getWindow() != null) {
        return;
    }
    setattachCandidateDatacenters(new ArrayList<EntityModel>());
    setAttachMultiple(getEntity().getStorageDomainType() == StorageDomainType.ISO);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            StorageDataCenterListModel listModel = (StorageDataCenterListModel) target;
            listModel.setavailableDatacenters((ArrayList<StoragePool>) returnValue);
            boolean addDatacenter = false;
            for (StoragePool dataCenter : listModel.getavailableDatacenters()) {
                switch(getEntity().getStorageDomainType()) {
                    case Master:
                    case Data:
                        addDatacenter = (dataCenter.getStatus() == StoragePoolStatus.Uninitialized || dataCenter.getStatus() == StoragePoolStatus.Up) && (dataCenter.getStoragePoolFormatType() == null || dataCenter.getStoragePoolFormatType() == getEntity().getStorageStaticData().getStorageFormat() && dataCenter.isLocal() == (getEntity().getStorageType() == StorageType.LOCALFS));
                        addToAttachCandidateDatacenters(dataCenter, addDatacenter);
                        break;
                    case Volume:
                        boolean isCinderSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.CinderProviderSupported, dataCenter.getCompatibilityVersion().toString());
                        addDatacenter = isCinderSupported && dataCenter.getStatus() == StoragePoolStatus.Up;
                        addToAttachCandidateDatacenters(dataCenter, addDatacenter);
                        break;
                    case ISO:
                        AsyncDataProvider.getInstance().getIsoDomainByDataCenterId(new AsyncQuery(new Object[] { listModel, dataCenter }, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object target1, Object returnValue1) {
                                Object[] array1 = (Object[]) target1;
                                StorageDataCenterListModel listModel1 = (StorageDataCenterListModel) array1[0];
                                StoragePool dataCenter1 = (StoragePool) array1[1];
                                boolean addDatacenter1 = dataCenter1.getStatus() == StoragePoolStatus.Up && returnValue1 == null;
                                listModel1.addToAttachCandidateDatacenters(dataCenter1, addDatacenter1);
                            }
                        }), dataCenter.getId());
                        break;
                    case ImportExport:
                        AsyncDataProvider.getInstance().getExportDomainByDataCenterId(new AsyncQuery(new Object[] { listModel, dataCenter }, new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object target2, Object returnValue2) {
                                Object[] array2 = (Object[]) target2;
                                StorageDataCenterListModel listModel2 = (StorageDataCenterListModel) array2[0];
                                StoragePool dataCenter2 = (StoragePool) array2[1];
                                boolean addDatacenter2 = dataCenter2.getStatus() == StoragePoolStatus.Up && returnValue2 == null;
                                listModel2.addToAttachCandidateDatacenters(dataCenter2, addDatacenter2);
                            }
                        }), dataCenter.getId());
                        break;
                }
            }
        }
    }));
}
#end_block

#method_before
public void postAttachInit(ArrayList<EntityModel> datacenters) {
    ListModel model = new ListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().attachToDataCenterTitle());
    if (getEntity() != null) {
        switch(getEntity().getStorageDomainType()) {
            case ISO:
                setHelpTag(HelpTag.attach_iso_library);
                break;
            case Data:
                setHelpTag(HelpTag.attach_storage);
                break;
            case ImportExport:
                setHelpTag(HelpTag.attach_export_domain);
                break;
        }
    }
    model.setItems(datacenters);
    if (datacenters.isEmpty()) {
        model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoDataCenterStorageDomainAttachedMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("Cancel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
        tempVar.setIsDefault(true);
        tempVar.setIsCancel(true);
        model.getCommands().add(tempVar);
    } else {
        model.setSelectedItem(datacenters.get(0));
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createDefaultOkUiCommand("OnAttach", this);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = UICommand.createCancelUiCommand("Cancel", this);
        model.getCommands().add(tempVar3);
    }
}
#method_after
public void postAttachInit(ArrayList<EntityModel> datacenters) {
    ListModel model = new ListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().attachToDataCenterTitle());
    if (getEntity() != null) {
        switch(getEntity().getStorageDomainType()) {
            case ISO:
                setHelpTag(HelpTag.attach_iso_library);
                break;
            case Data:
                setHelpTag(HelpTag.attach_storage);
                break;
            case ImportExport:
                setHelpTag(HelpTag.attach_export_domain);
                break;
        }
    }
    if (datacenters.isEmpty()) {
        model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoDataCenterStorageDomainAttachedMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("Cancel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
        tempVar.setIsDefault(true);
        tempVar.setIsCancel(true);
        model.getCommands().add(tempVar);
    } else {
        model.setItems(datacenters, datacenters.get(0));
        // $NON-NLS-1$
        UICommand tempVar2 = UICommand.createDefaultOkUiCommand("OnAttach", this);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = UICommand.createCancelUiCommand("Cancel", this);
        model.getCommands().add(tempVar3);
    }
}
#end_block

#method_before
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new BrickStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterBrickEntity> serverColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getServerName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(serverColumn, constants.serverVolumeBrick(), "300px");
    TextColumnWithTooltip<GlusterBrickEntity> directoryColumn = new TextColumnWithTooltip<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getBrickDirectory();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(directoryColumn, constants.brickDirectoryVolumeBrick(), "400px");
    getTable().addColumn(new PercentColumn<GlusterBrickEntity>() {

        @Override
        protected Integer getProgressValue(GlusterBrickEntity object) {
            if (object.getBrickProperties() == null) {
                return 0;
            }
            BrickProperties brickProperties = object.getBrickProperties();
            return (int) (((brickProperties.getTotalSize() - brickProperties.getFreeSize()) / (brickProperties.getTotalSize())) * 100);
        }

        @Override
        protected String getProgressText(GlusterBrickEntity object) {
            Integer progressValue = getProgressValue(object);
            // $NON-NLS-1$ //$NON-NLS-2$
            return progressValue != null ? progressValue + "%" : "?";
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new VolumeActivityColumn<GlusterBrickEntity>(getActivityCell(constants)), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.addBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.removeBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.replaceBrickBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getReplaceBrickCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.advancedDetailsBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBrickAdvancedDetailsCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    BrickStatusColumn brickStatusColumn = new BrickStatusColumn();
    brickStatusColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(brickStatusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterBrickEntity> serverColumn = new AbstractTextColumn<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getServerName();
        }
    };
    serverColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(serverColumn, constants.serverVolumeBrick(), "300px");
    AbstractTextColumn<GlusterBrickEntity> directoryColumn = new AbstractTextColumn<GlusterBrickEntity>() {

        @Override
        public String getValue(GlusterBrickEntity brick) {
            return brick.getQualifiedName();
        }
    };
    directoryColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(directoryColumn, constants.brickDirectoryVolumeBrick(), "400px");
    getTable().addColumn(new Column<GlusterBrickEntity, BrickProperties>(new BrickCapacityCell()) {

        @Override
        public BrickProperties getValue(GlusterBrickEntity object) {
            return object.getBrickProperties();
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new VolumeActivityColumn<GlusterBrickEntity>(getActivityCell()), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.addBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getAddBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.removeBricksBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRemoveBricksCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.replaceBrickBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getReplaceBrickCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterBrickEntity>(constants.advancedDetailsBrick()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getBrickAdvancedDetailsCommand();
        }
    });
}
#end_block

#method_before
private VolumeActivityCompositeCell<GlusterTaskSupport> getActivityCell(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    VolumeActivityCompositeCell<GlusterTaskSupport> activityCell = new VolumeActivityCompositeCell<GlusterTaskSupport>(list) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return super.isVisible(value) && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    return activityCell;
}
#method_after
private VolumeActivityCompositeCell<GlusterTaskSupport> getActivityCell() {
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu();
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    VolumeActivityCompositeCell<GlusterTaskSupport> activityCell = new VolumeActivityCompositeCell<GlusterTaskSupport>(list) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return super.isVisible(value) && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    return activityCell;
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
@Override
public String render(T size) {
    Pair<SizeUnit, Double> sizeWithUnits = SizeConverter.autoConvert(size.longValue(), SizeUnit.BYTES);
    // $NON-NLS-1$
    return size != null ? formatSize(sizeWithUnits.getSecond()) + " " + sizeWithUnits.getFirst() : constants.notAvailableLabel();
}
#method_after
@Override
public String render(T size) {
    if (size != null) {
        Pair<SizeUnit, Double> sizeWithUnits = SizeConverter.autoConvert(size.longValue(), SizeUnit.BYTES);
        // $NON-NLS-1$
        return formatSize(sizeWithUnits.getSecond()) + " " + sizeWithUnits.getFirst();
    } else {
        return constants.notAvailableLabel();
    }
}
#end_block

#method_before
private void updatePropeties() {
    if (getEntity() == null) {
        return;
    }
    GlusterVolumeEntity entity = (GlusterVolumeEntity) getEntity();
    setName(entity.getName());
    setVolumeId(entity.getId() != null ? entity.getId().toString() : null);
    setVolumeType(entity.getVolumeType() != null ? entity.getVolumeType().toString() : null);
    setReplicaCount(entity.getReplicaCount() != null ? Integer.toString(entity.getReplicaCount()) : null);
    setStripeCount(entity.getStripeCount() != null ? Integer.toString(entity.getStripeCount()) : null);
    setNumOfBricks(entity.getBricks() != null ? Integer.toString(entity.getBricks().size()) : null);
    setTransportTypes(entity.getTransportTypes());
    setVolumeFreeCapacity(entity.getAdvancedDetails() != null ? entity.getAdvancedDetails().getCapacityInfo().getFreeSize() : null);
    setVolumeTotalCapacity(entity.getAdvancedDetails() != null ? entity.getAdvancedDetails().getCapacityInfo().getTotalSize() : null);
    setVolumeUsedCapacity(entity.getAdvancedDetails() != null ? entity.getAdvancedDetails().getCapacityInfo().getUsedSize() : null);
}
#method_after
private void updatePropeties() {
    if (getEntity() == null) {
        return;
    }
    GlusterVolumeEntity entity = getEntity();
    setName(entity.getName());
    setVolumeId(entity.getId() != null ? entity.getId().toString() : null);
    setVolumeType(entity.getVolumeType() != null ? entity.getVolumeType().toString() : null);
    setReplicaCount(entity.getReplicaCount() != null ? Integer.toString(entity.getReplicaCount()) : null);
    setStripeCount(entity.getStripeCount() != null ? Integer.toString(entity.getStripeCount()) : null);
    setDisperseCount(entity.getDisperseCount() != null ? Integer.toString(entity.getDisperseCount()) : null);
    setRedundancyCount(entity.getRedundancyCount() != null ? Integer.toString(entity.getRedundancyCount()) : null);
    setNumOfBricks(entity.getBricks() != null ? Integer.toString(entity.getBricks().size()) : null);
    setTransportTypes(entity.getTransportTypes());
    setSnapMaxLimit(entity.getSnapMaxLimit() != null ? entity.getSnapMaxLimit().toString() : null);
    if (entity.getAdvancedDetails() != null && entity.getAdvancedDetails().getCapacityInfo() != null) {
        setVolumeFreeCapacity(entity.getAdvancedDetails().getCapacityInfo().getFreeSize());
        setVolumeTotalCapacity(entity.getAdvancedDetails().getCapacityInfo().getTotalSize());
        setVolumeUsedCapacity(entity.getAdvancedDetails().getCapacityInfo().getUsedSize());
    } else {
        setVolumeFreeCapacity(null);
        setVolumeTotalCapacity(null);
        setVolumeUsedCapacity(null);
    }
}
#end_block

#method_before
public void setVolumeFreeCapacity(Long volumeFreeCpcity) {
    this.volumeFreeCapacity = volumeFreeCpcity;
}
#method_after
public void setVolumeFreeCapacity(Long volumeFreeCapacity) {
    this.volumeFreeCapacity = volumeFreeCapacity;
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    VolumeCapacityRefreshCell refreshCell = new VolumeCapacityRefreshCell();
    class VolumeRefreshButtonDefinition extends WebAdminButtonDefinition<GlusterVolumeEntity> {

        public VolumeRefreshButtonDefinition(String title) {
            super(title);
        }

        @Override
        public void onClick(List<GlusterVolumeEntity> selectedItems) {
            getMainModel().setCurrentEntity(selectedItems.get(0));
            super.onClick(selectedItems);
        }

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRefreshVolumeCapcity();
        }
    }
    VolumeRefreshButtonDefinition buttonDefinition = new VolumeRefreshButtonDefinition(constants.volumeCapacity());
    refreshCell.setButtonDefinition(buttonDefinition);
    List<HasCell<GlusterVolumeEntity, ?>> volumeCapacityCompositeList = new ArrayList<HasCell<GlusterVolumeEntity, ?>>();
    Column<GlusterVolumeEntity, GlusterVolumeEntity> capacityColumn = new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    };
    capacityColumn.setHorizontalAlignment(HorizontalAlignmentConstant.startOf(Direction.LTR));
    volumeCapacityCompositeList.add(capacityColumn);
    Column<GlusterVolumeEntity, GlusterVolumeEntity> capacityClockColumn = new Column<GlusterVolumeEntity, GlusterVolumeEntity>(refreshCell) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    };
    capacityClockColumn.setHorizontalAlignment(HorizontalAlignmentConstant.endOf(Direction.LTR));
    volumeCapacityCompositeList.add(capacityClockColumn);
    // $NON-NLS-1$;
    getTable().addColumn(new CompositeVolumeCapacityColumn<GlusterVolumeEntity>(volumeCapacityCompositeList), constants.volumeCapacity(), "250px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable(new Comparator<GlusterVolumeEntity>() {

        @Override
        public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) {
            return GlusterVolumeUtils.getVolumeStatus(o1).ordinal() - GlusterVolumeUtils.getVolumeStatus(o2).ordinal();
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterVolumeEntity> nameColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> clusterColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> volumeTypeColumn = new AbstractEnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu();
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu();
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    Column<GlusterVolumeEntity, GlusterVolumeEntity> capacityColumn = new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(capacityColumn, constants.volumeCapacity(), "100px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotCountColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotsCount().toString();
        }
    };
    snapshotCountColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotCountColumn, constants.noOfSnapshotsLabel(), "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotScheduledColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotScheduled().toString();
        }
    };
    snapshotScheduledColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotScheduledColumn, constants.snapshotScheduledLabel(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeSnapshotMainTabTitle(), getVolumeSnapshotMenu(), CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.geoReplicationMainTabTitle(), getGeoRepCreateMenu(constants), CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
@Override
public void setMainTabSelectedItem(GlusterVolumeEntity selectedItem) {
    driver.edit(getDetailModel());
    replicaFormItem.setIsAvailable(selectedItem.getVolumeType().isReplicatedType());
    stripeFormItem.setIsAvailable(selectedItem.getVolumeType().isStripedType());
    ArrayList<TextBoxLabelBase<Long>> volumeCapacityDetails = new ArrayList<TextBoxLabelBase<Long>>(Arrays.asList(volumeTotalCapacity, volumeUsedCapacity, volumeFreeCapacity));
    volumeCapacityDetailsLabel.setValue(volumeCapacityDetails);
    formBuilder.update(getDetailModel());
}
#method_after
@Override
public void setMainTabSelectedItem(GlusterVolumeEntity selectedItem) {
    driver.edit(getDetailModel());
    replicaFormItem.setIsAvailable(selectedItem.getVolumeType().isReplicatedType());
    stripeFormItem.setIsAvailable(selectedItem.getVolumeType().isStripedType());
    disperseCount.setVisible(selectedItem.getVolumeType().isDispersedType());
    redundancyCount.setVisible(selectedItem.getVolumeType().isDispersedType());
    ArrayList<TextBoxLabelBase<Long>> volumeCapacityDetails = new ArrayList<TextBoxLabelBase<Long>>(Arrays.asList(volumeTotalCapacity, volumeUsedCapacity, volumeFreeCapacity));
    volumeCapacityDetailsLabel.setValue(volumeCapacityDetails);
    formBuilder.update(getDetailModel());
}
#end_block

#method_before
private void translateVolumeType(GlusterVolumeEntity volumeEntity) {
    Translator translator = EnumTranslator.create(GlusterVolumeType.class);
    if (translator.containsKey(volumeEntity.getVolumeType())) {
        getDetailModel().setVolumeTypeSilently(translator.get(volumeEntity.getVolumeType()));
    }
}
#method_after
private void translateVolumeType(GlusterVolumeEntity volumeEntity) {
    EnumTranslator translator = EnumTranslator.getInstance();
    if (translator.containsKey(volumeEntity.getVolumeType())) {
        getDetailModel().setVolumeTypeSilently(translator.translate(volumeEntity.getVolumeType()));
    }
}
#end_block

#method_before
public static boolean isVmTemplateImagesReady(VmTemplate vmTemplate, Guid storageDomainId, List<String> reasons, boolean checkImagesExists, boolean checkLocked, boolean checkIllegal, boolean checkStorageDomain, List<DiskImage> providedVmtImages) {
    boolean returnValue = true;
    List<DiskImage> vmtImages = providedVmtImages;
    if (checkStorageDomain) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, vmTemplate.getStoragePoolId()));
        ValidationResult res = storageDomainValidator.isDomainExistAndActive();
        returnValue = res.isValid();
        if (!returnValue) {
            reasons.add(res.getMessage().toString());
            for (String varReplacement : res.getVariableReplacements()) {
                reasons.add(varReplacement);
            }
        }
    }
    if (returnValue && checkImagesExists) {
        if (vmtImages == null) {
            vmtImages = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmTemplate.getId()), false, false, true);
        }
        if (vmtImages.size() > 0 && !ImagesHandler.isImagesExists(vmtImages, vmtImages.get(0).getStoragePoolId())) {
            reasons.add(VdcBllMessages.TEMPLATE_IMAGE_NOT_EXIST.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkLocked) {
        if (vmTemplate.getStatus() == VmTemplateStatus.Locked) {
            returnValue = false;
        } else {
            if (vmtImages != null) {
                for (DiskImage image : vmtImages) {
                    if (image.getImageStatus() == ImageStatus.LOCKED) {
                        returnValue = false;
                        break;
                    }
                }
            }
        }
        if (!returnValue) {
            reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
        }
    }
    if (returnValue && checkIllegal && (vmTemplate.getStatus() == VmTemplateStatus.Illegal)) {
        returnValue = false;
        reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_ILLEGAL.toString());
    }
    return returnValue;
}
#method_after
public static boolean isVmTemplateImagesReady(VmTemplate vmTemplate, Guid storageDomainId, List<String> reasons, boolean checkImagesExists, boolean checkLocked, boolean checkIllegal, boolean checkStorageDomain, List<DiskImage> providedVmtImages) {
    boolean returnValue = true;
    List<DiskImage> vmtImages = providedVmtImages;
    if (checkStorageDomain) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, vmTemplate.getStoragePoolId()));
        ValidationResult res = storageDomainValidator.isDomainExistAndActive();
        returnValue = res.isValid();
        if (!returnValue) {
            reasons.add(res.getMessage().toString());
            reasons.addAll(res.getVariableReplacements());
        }
    }
    if (returnValue && checkImagesExists) {
        if (vmtImages == null) {
            vmtImages = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmTemplate.getId()), false, false, true);
        }
        if (vmtImages.size() > 0 && !ImagesHandler.isImagesExists(vmtImages, vmtImages.get(0).getStoragePoolId())) {
            reasons.add(VdcBllMessages.TEMPLATE_IMAGE_NOT_EXIST.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkLocked) {
        if (vmTemplate.getStatus() == VmTemplateStatus.Locked) {
            returnValue = false;
        } else {
            if (vmtImages != null) {
                for (DiskImage image : vmtImages) {
                    if (image.getImageStatus() == ImageStatus.LOCKED) {
                        returnValue = false;
                        break;
                    }
                }
            }
        }
        if (!returnValue) {
            reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
        }
    }
    if (returnValue && checkIllegal && (vmTemplate.getStatus() == VmTemplateStatus.Illegal)) {
        returnValue = false;
        reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_ILLEGAL.toString());
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetDiskHotpluggableInterfacesMap:
            setReturnValue(osRepository.getDiskHotpluggableInterfacesMap());
            break;
        case GetOsArchitectures:
            setReturnValue(osRepository.getOsArchitectures());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDisplayTypes:
            setReturnValue(osRepository.getDisplayTypes());
            break;
        case HasNicHotplugSupport:
            setReturnValue(Boolean.valueOf(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion())));
            break;
        case GetFloppySupport:
            setReturnValue(osRepository.isFloppySupported(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskInterfaces:
            setReturnValue(osRepository.getDiskInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskHotpluggableInterfaces:
            setReturnValue(osRepository.getDiskHotpluggableInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetVmWatchdogTypes:
            setReturnValue(osRepository.getVmWatchdogTypes(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDefaultOSes:
            setReturnValue(osRepository.getDefaultOSes());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetDiskHotpluggableInterfacesMap:
            setReturnValue(osRepository.getDiskHotpluggableInterfacesMap());
            break;
        case GetOsArchitectures:
            setReturnValue(osRepository.getOsArchitectures());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDisplayTypes:
            setReturnValue(osRepository.getGraphicsAndDisplays());
            break;
        case GetBalloonSupportMap:
            setReturnValue(osRepository.getBalloonSupportMap());
            break;
        case IsBalloonEnabled:
            setReturnValue(osRepository.isBalloonEnabled(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetFloppySupport:
            setReturnValue(osRepository.isFloppySupported(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskInterfaces:
            setReturnValue(osRepository.getDiskInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDiskHotpluggableInterfaces:
            setReturnValue(osRepository.getDiskHotpluggableInterfaces(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetVmWatchdogTypes:
            setReturnValue(osRepository.getVmWatchdogTypes(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetDefaultOSes:
            setReturnValue(osRepository.getDefaultOSes());
    }
}
#end_block

#method_before
public static String getDefaultConfigurationVersion() {
    return _defaultConfigurationVersion;
}
#method_after
public String getDefaultConfigurationVersion() {
    return _defaultConfigurationVersion;
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = (HashMap<ArchitectureType, Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#method_after
public Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#end_block

#method_before
public static Boolean getNicHotplugSupport(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getNicHotplugSupportMap().containsKey(pair)) {
        return getNicHotplugSupportMap().get(pair);
    }
    return false;
}
#method_after
public Boolean getNicHotplugSupport(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getNicHotplugSupportMap().containsKey(pair)) {
        return getNicHotplugSupportMap().get(pair);
    }
    return false;
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#method_after
public Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#end_block

#method_before
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#method_after
public Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#end_block

#method_before
public static void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#method_after
public void getIsoDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                for (StorageDomain domain : storageDomains) {
                    if (domain.getStorageDomainType() == StorageDomainType.ISO) {
                        return domain;
                    }
                }
            }
            return null;
        }
    };
    IdQueryParameters getIsoParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getIsoParams, aQuery);
}
#end_block

#method_before
public static void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#method_after
public void getExportDomainByDataCenterId(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
            for (StorageDomain domain : storageDomains) {
                if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
                    return domain;
                }
            }
            return null;
        }
    };
    IdQueryParameters getExportParams = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, getExportParams, aQuery);
}
#end_block

#method_before
public static void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId) {
    getIrsImageList(aQuery, storagePoolId, false);
}
#end_block

#method_before
public static void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#method_after
public void getIrsImageList(AsyncQuery aQuery, Guid storagePoolId, boolean forceRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    GetImagesListByStoragePoolIdParameters parameters = new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.ISO);
    parameters.setForceRefresh(forceRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, parameters, aQuery);
}
#end_block

#method_before
public static void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#method_after
public void getFloppyImageList(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<RepoImage> repoList = (ArrayList<RepoImage>) source;
                ArrayList<String> fileNameList = new ArrayList<String>();
                for (RepoImage repoImage : repoList) {
                    fileNameList.add(repoImage.getRepoImageId());
                }
                Collections.sort(fileNameList, String.CASE_INSENSITIVE_ORDER);
                return fileNameList;
            }
            return new ArrayList<String>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetImagesListByStoragePoolId, new GetImagesListByStoragePoolIdParameters(storagePoolId, ImageFileType.Floppy), aQuery);
}
#end_block

#method_before
public static void isClusterEmpty(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean Convert(Object source, AsyncQuery _asyncQuery) {
            return (Boolean) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsClusterEmpty, new IdQueryParameters(id), aQuery);
}
#method_after
public void isClusterEmpty(AsyncQuery aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.IsClusterEmpty, aQuery, clusterId);
}
#end_block

#method_before
public static void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType Convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostArchitecture(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<ArchitectureType>() {

        @Override
        public ArchitectureType Convert(Object source, AsyncQuery _asyncQuery) {
            return (ArchitectureType) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostArchitecture, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#method_after
public void getClusterById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupById, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#method_after
public void getClusterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Cluster: name=" + name + " sortby name", SearchType.Cluster), aQuery);
}
#end_block

#method_before
public static void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#method_after
public void getPoolById(AsyncQuery aQuery, Guid poolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmPoolById, new IdQueryParameters(poolId), aQuery);
}
#end_block

#method_before
public static void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmById(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$
    new SearchParameters("DataCenter: sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public static void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#method_after
public void getDataCenterByClusterServiceList(AsyncQuery aQuery, boolean supportsVirtService, boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            // sort data centers
            final ArrayList<StoragePool> storagePoolList = (ArrayList<StoragePool>) source;
            Collections.sort(storagePoolList, new NameableComparator());
            return source;
        }
    };
    final GetStoragePoolsByClusterServiceParameters parameters = new GetStoragePoolsByClusterServiceParameters();
    parameters.setSupportsVirtService(supportsVirtService);
    parameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByClusterService, parameters, aQuery);
}
#end_block

#method_before
public static void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#method_after
public void getDataCenterListByName(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("DataCenter: name=" + name + " sortby name", SearchType.StoragePool), aQuery);
}
#end_block

#method_before
public static void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSpiceUsbAutoShare(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SpiceUsbAutoShare, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt(((Integer) source).intValue()) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANColorDepth(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? WanColorDepth.fromInt(((Integer) source).intValue()) : WanColorDepth.depth16;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANColorDepth, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WANDisableEffects>();
            }
            List<WANDisableEffects> res = new ArrayList<WANDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WANDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getWANDisableEffects(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<WanDisableEffects>();
            }
            List<WanDisableEffects> res = new ArrayList<WanDisableEffects>();
            String fromDb = (String) source;
            for (String value : fromDb.split(",")) {
                // $NON-NLS-1$
                if (value == null) {
                    continue;
                }
                String trimmedValue = value.trim();
                if ("".equals(trimmedValue)) {
                    continue;
                }
                res.add(WanDisableEffects.fromString(trimmedValue));
            }
            return res;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.WANDisableEffects, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmsInPool(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1000;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVmsInPool, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmSockets(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmSockets);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfVmCpus(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfVmCpus);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getMaxNumOfCPUsPerSocket(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.MaxNumOfCpuPerSocket);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<VDSGroup> filterByArchitecture(List<VDSGroup> clusters, ArchitectureType targetArchitecture) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture().equals(targetArchitecture)) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public static List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#method_after
public List<VDSGroup> filterClustersWithoutArchitecture(List<VDSGroup> clusters) {
    List<VDSGroup> filteredClusters = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getArchitecture() != ArchitectureType.undefined) {
            filteredClusters.add(cluster);
        }
    }
    return filteredClusters;
}
#end_block

#method_before
public static void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getClusterByServiceList(AsyncQuery aQuery, Guid dataCenterId, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDSGroup>();
            }
            final ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
            return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsGroupsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<String>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<VmDevice>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterListByService(AsyncQuery aQuery, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = getClusterByServiceList((ArrayList<VDSGroup>) source, supportsVirtService, supportsGlusterService);
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getClusterList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                Collections.sort(list, new NameableComparator());
                return list;
            }
            return new ArrayList<VDSGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsGroups, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#method_after
public void getTemplateDiskList(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<DiskImage>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesDisks, new IdQueryParameters(templateId), aQuery);
}
#end_block

#method_before
public static int getRoundedPriority(int priority, int maxPriority) {
    int medium = maxPriority / 2;
    int[] levels = new int[] { 1, medium, maxPriority };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#method_after
public int getRoundedPriority(int priority, int maxPriority) {
    int medium = maxPriority / 2;
    int[] levels = new int[] { 1, medium, maxPriority };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#end_block

#method_before
public static void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getTemplateListByDataCenter(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new TemplateConverter();
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new IdQueryParameters(storageId), aQuery);
}
#method_after
public void getTemplateListByStorage(AsyncQuery aQuery, Guid storageId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VmTemplate> list = new ArrayList<VmTemplate>();
            if (source != null) {
                for (VmTemplate template : (ArrayList<VmTemplate>) source) {
                    if (template.getStatus() == VmTemplateStatus.OK) {
                        list.add(template);
                    }
                }
                Collections.sort(list, new NameableComparator());
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplatesFromStorageDomain, new IdQueryParameters(storageId), aQuery);
}
#end_block

#method_before
public static ArrayList<VmTemplate> filterTemplatesByArchitecture(List<VmTemplate> list, ArchitectureType architecture) {
    ArrayList<VmTemplate> filteredList = new ArrayList<VmTemplate>();
    for (VmTemplate template : list) {
        if (template.getId().equals(Guid.Empty) || template.getClusterArch().equals(architecture)) {
            filteredList.add(template);
        }
    }
    return filteredList;
}
#method_after
public ArrayList<VmTemplate> filterTemplatesByArchitecture(List<VmTemplate> list, ArchitectureType architecture) {
    ArrayList<VmTemplate> filteredList = new ArrayList<VmTemplate>();
    for (VmTemplate template : list) {
        if (template.getId().equals(Guid.Empty) || template.getClusterArch().equals(architecture)) {
            filteredList.add(template);
        }
    }
    return filteredList;
}
#end_block

#method_before
public static void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<Integer>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNumOfMonitorList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Integer> nums = new ArrayList<Integer>();
            if (source != null) {
                Iterable numEnumerable = (Iterable) source;
                Iterator numIterator = numEnumerable.iterator();
                while (numIterator.hasNext()) {
                    nums.add(Integer.parseInt(numIterator.next().toString()));
                }
            }
            return nums;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.ValidNumOfMonitors, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getStorageDomainList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByStoragePoolId, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getMaxVmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return 100;
            }
            return source;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getHostById(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsByVdsId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#method_after
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((List<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#end_block

#method_before
public static void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#method_after
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return Linq.<VDS>cast((List<?>) source);
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#end_block

#method_before
public static void getVmDiskList(AsyncQuery aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<DiskImage>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid vmId, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<DiskImage>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(vmId);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, params, aQuery);
}
#end_block

#method_before
public static HashMap<Integer, String> getOsUniqueOsNames() {
    return uniqueOsNames;
}
#method_after
public HashMap<Integer, String> getOsUniqueOsNames() {
    return uniqueOsNames;
}
#end_block

#method_before
public static void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#method_after
public void getRoleList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Role>) source : new ArrayList<Role>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRoles, new MultilevelAdministrationsQueriesParameters(), aQuery);
}
#end_block

#method_before
public static void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getStorageDomainById(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageDomain) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainById, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public static VolumeFormat getDiskVolumeFormat(VolumeType volumeType, StorageType storageType) {
    if (storageType.isFileDomain()) {
        return VolumeFormat.RAW;
    } else if (storageType.isBlockDomain()) {
        switch(volumeType) {
            case Sparse:
                return VolumeFormat.COW;
            case Preallocated:
                return VolumeFormat.RAW;
            default:
                return VolumeFormat.Unassigned;
        }
    } else {
        return VolumeFormat.Unassigned;
    }
}
#method_after
public VolumeFormat getDiskVolumeFormat(VolumeType volumeType, StorageType storageType) {
    if (storageType.isFileDomain()) {
        return VolumeFormat.RAW;
    } else if (storageType.isBlockDomain()) {
        switch(volumeType) {
            case Sparse:
                return VolumeFormat.COW;
            case Preallocated:
                return VolumeFormat.RAW;
            default:
                return VolumeFormat.Unassigned;
        }
    } else {
        return VolumeFormat.Unassigned;
    }
}
#end_block

#method_before
public static void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getClusterNetworkList(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<Network>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> Convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#method_after
public void getAllNetworkQos(Guid dcId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<List<NetworkQoS>>() {

        @Override
        public List<NetworkQoS> Convert(Object returnValue, AsyncQuery asyncQuery) {
            List<NetworkQoS> qosList = returnValue == null ? new ArrayList<NetworkQoS>() : (List<NetworkQoS>) returnValue;
            qosList.add(0, NetworkQoSModel.EMPTY_QOS);
            return qosList;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworkQosByStoragePoolId, new IdQueryParameters(dcId), query);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> Convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<String>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#method_after
public void getNetworkLabelsByDataCenterId(Guid dataCenterId, AsyncQuery query) {
    query.converterCallback = new IAsyncConverter<SortedSet<String>>() {

        @Override
        public SortedSet<String> Convert(Object returnValue, AsyncQuery asyncQuery) {
            SortedSet<String> sortedSet = new TreeSet<String>(new LexoNumericComparator());
            sortedSet.addAll((Collection<String>) returnValue);
            return sortedSet;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworkLabelsByDataCenterId, new IdQueryParameters(dataCenterId), query);
}
#end_block

#method_before
public static void getWatchdogByVmId(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getWatchdogByVmId(AsyncQuery aQuery, Guid vmId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#method_after
public void getTemplateById(AsyncQuery aQuery, Guid templateId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(templateId), aQuery);
}
#end_block

#method_before
public static void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void countAllTemplates(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmTemplateCount, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#method_after
public void getHostList(AsyncQuery aQuery) {
    getHostListByStatus(aQuery, null);
}
#end_block

#method_before
public static void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getHostListByStatus(AsyncQuery aQuery, VDSStatus status) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((Iterable) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: " + (status == null ? "" : ("status=" + status.name())), SearchType.VDS);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#method_after
public void getHostsForStorageOperation(AsyncQuery aQuery, Guid storagePoolId, boolean localFsOnly) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return source;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetHostsForStorageOperation, new GetHostsForStorageOperationParameters(storagePoolId, localFsOnly), aQuery);
}
#end_block

#method_before
public static void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getVolumeList(AsyncQuery aQuery, String clusterName) {
    if ((ApplicationModeHelper.getUiMode().getValue() & ApplicationMode.GlusterOnly.getValue()) == 0) {
        aQuery.asyncCallback.onSuccess(aQuery.model, new ArrayList<GlusterVolumeEntity>());
        return;
    }
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<GlusterVolumeEntity> list = (ArrayList<GlusterVolumeEntity>) source;
                return list;
            }
            return new ArrayList<GlusterVolumeEntity>();
        }
    };
    SearchParameters searchParameters;
    searchParameters = // $NON-NLS-1$
    clusterName == null ? // $NON-NLS-1$
    new SearchParameters("Volumes:", SearchType.GlusterVolume) : // $NON-NLS-1$
    new SearchParameters("Volumes: cluster.name=" + clusterName, SearchType.GlusterVolume);
    searchParameters.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterVolumeOptionInfoList(AsyncQuery aQuery, Guid clusterId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeOptionsInfo, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#method_after
public void getHostFingerprint(AsyncQuery aQuery, String hostAddress) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHKeyFingerprint, new ServerParameters(hostAddress), aQuery);
}
#end_block

#method_before
public static void getHostPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getHostPublicKey(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetServerSSHPublicKey, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static void getGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#method_after
public void getGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServersForImport, parameters, aQuery);
}
#end_block

#method_before
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, Guid volumeId, Guid brickId) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volumeId, brickId, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public void getGlusterVolumeBrickDetails(AsyncQuery aQuery, Guid clusterId, Guid volumeId, Guid brickId) {
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, volumeId, brickId, true);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#method_after
public void getGlusterHostsNewlyAdded(AsyncQuery aQuery, Guid clusterId, boolean isFingerprintRequired) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAddedGlusterServers, new AddedGlusterServersParameters(clusterId, isFingerprintRequired), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && ((List) source).size() > 0) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#method_after
public void getGlusterHooks(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterHookEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHooks, new GlusterParameters(clusterId), aQuery);
}
#end_block

#method_before
public static void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#method_after
public void getGlusterBricksForServer(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterBrickEntity>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeBricksByServerId, new IdQueryParameters(serverId), aQuery);
}
#end_block

#method_before
public static void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#method_after
public void getGlusterHook(AsyncQuery aQuery, Guid hookId, boolean includeServerHooks) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookById, new GlusterHookQueryParameters(hookId, includeServerHooks), aQuery);
}
#end_block

#method_before
public static void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#method_after
public void getGlusterHookContent(AsyncQuery aQuery, Guid hookId, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? source : "";
        }
    };
    GlusterHookContentQueryParameters parameters = new GlusterHookContentQueryParameters(hookId);
    parameters.setGlusterServerId(serverId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterHookContent, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServices(AsyncQuery aQuery, Guid serverId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByServerId, new GlusterServiceQueryParameters(serverId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getClusterGlusterSwiftService(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                List<GlusterClusterService> serviceList = (List<GlusterClusterService>) source;
                if (!serviceList.isEmpty()) {
                    return serviceList.get(0);
                }
                return null;
            } else {
                return source;
            }
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterClusterServiceByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#method_after
public void getGlusterSwiftServerServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new ArrayList<GlusterServerService>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterServerServicesByClusterId, new GlusterServiceQueryParameters(clusterId, ServiceType.GLUSTER_SWIFT), aQuery);
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#method_after
public void getGlusterRemoveBricksStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId, List<GlusterBrickEntity> bricks) {
    aQuery.setHandleFailure(true);
    GlusterVolumeRemoveBricksQueriesParameters parameters = new GlusterVolumeRemoveBricksQueriesParameters(clusterId, volumeId, bricks);
    Frontend.getInstance().runQuery(VdcQueryType.GetGlusterVolumeRemoveBricksStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getRpmVersion(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion);
    tempVar.setVersion(getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getRpmVersion(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion);
    tempVar.setVersion(getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void getUserMessageOfTheDayViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserMessageOfTheDay, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getUserMessageOfTheDayViaPublic(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            // $NON-NLS-1$
            return source != null ? (String) source : "";
        }
    };
    Frontend.getInstance().runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.UserMessageOfTheDay, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getSearchResultsLimit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 100;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.SearchResultsLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase(), aQuery);
}
#method_after
public Map<Version, Map<String, String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public static void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permission>) source : new ArrayList<Permission>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public static void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#method_after
public void getRoleActionGroupsByRoleId(AsyncQuery aQuery, Guid roleId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ActionGroup>) source : new ArrayList<ActionGroup>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRoleActionGroupsByRoleId, new IdQueryParameters(roleId), aQuery);
}
#end_block

#method_before
public static void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isTemplateNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmTemlateWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#method_after
public void isVmNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? !((Boolean) source).booleanValue() : false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmWithSameNameExist, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#method_after
public void getDataCentersWithPermittedActionOnClusters(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<StoragePool>();
            }
            return source;
        }
    };
    GetDataCentersWithPermittedActionOnClustersParameters getDataCentersWithPermittedActionOnClustersParameters = new GetDataCentersWithPermittedActionOnClustersParameters();
    getDataCentersWithPermittedActionOnClustersParameters.setActionGroup(actionGroup);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsVirtService(supportsVirtService);
    getDataCentersWithPermittedActionOnClustersParameters.setSupportsGlusterService(supportsGlusterService);
    Frontend.getInstance().runQuery(VdcQueryType.GetDataCentersWithPermittedActionOnClusters, getDataCentersWithPermittedActionOnClustersParameters, aQuery);
}
#end_block

#method_before
public static void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#method_after
public void getClustersWithPermittedAction(AsyncQuery aQuery, ActionGroup actionGroup, final boolean supportsVirtService, final boolean supportsGlusterService) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDSGroup> list = (ArrayList<VDSGroup>) source;
                return getClusterByServiceList(list, supportsVirtService, supportsGlusterService);
            }
            return new ArrayList<VDSGroup>();
        }
    };
    GetEntitiesWithPermittedActionParameters getEntitiesWithPermittedActionParameters = new GetEntitiesWithPermittedActionParameters();
    getEntitiesWithPermittedActionParameters.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetClustersWithPermittedAction, getEntitiesWithPermittedActionParameters, aQuery);
}
#end_block

#method_before
public static void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#method_after
public void getAllVmTemplates(AsyncQuery aQuery, final boolean refresh) {
    aQuery.converterCallback = new TemplateConverter();
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(refresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmTemplates, params, aQuery);
}
#end_block

#method_before
public static void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#method_after
public void getStorageConnectionById(AsyncQuery aQuery, String id, boolean isRefresh) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (StorageServerConnections) source : null;
        }
    };
    StorageServerConnectionQueryParametersBase params = new StorageServerConnectionQueryParametersBase(id);
    params.setRefresh(isRefresh);
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageServerConnectionById, params, aQuery);
}
#end_block

#method_before
public static void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#method_after
public void getDataCentersByStorageDomain(AsyncQuery aQuery, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StoragePool>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), aQuery);
}
#end_block

#method_before
public static void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#method_after
public void getDataCenterVersions(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Version>();
            } else {
                ArrayList<Version> list = (ArrayList<Version>) source;
                Collections.sort(list);
                return list;
            }
        }
    };
    IdQueryParameters tempVar = new IdQueryParameters(dataCenterId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAvailableClusterVersionsByStoragePool, tempVar, aQuery);
}
#end_block

#method_before
public static void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getDataCenterMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StoragePoolNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterServerMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommitForServers, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getClusterDesktopMemoryOverCommit(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.MaxVdsMemOverCommit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getAllowClusterWithVirtGlusterEnabled(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Boolean.TRUE;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.AllowClusterWithVirtGlusterEnabled, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#method_after
public void getCPUList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<ServerCpu>) source : new ArrayList<ServerCpu>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllServerCpuList, new GetAllServerCpuListParameters(version), aQuery);
}
#end_block

#method_before
public static void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    tempVar.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void getPmTypeList(AsyncQuery aQuery, Version version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<String> list = new ArrayList<String>();
            if (source != null) {
                // $NON-NLS-1$
                String[] array = ((String) source).split("[,]", -1);
                for (String item : array) {
                    list.add(item);
                }
            }
            return list;
        }
    };
    GetConfigurationValueParameters param = new GetConfigurationValueParameters(ConfigurationValues.VdsFenceType);
    param.setVersion(version != null ? version.toString() : getDefaultConfigurationVersion());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceConfigurationValue, param, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#method_after
public void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.getInstance().runQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public void getNetworkList(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllNetworks, new IdQueryParameters(dataCenterId), aQuery);
}
#end_block

#method_before
public static void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<StorageDomain>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getISOStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> allStorageDomains = (ArrayList<StorageDomain>) source;
                ArrayList<StorageDomain> isoStorageDomains = new ArrayList<StorageDomain>();
                for (StorageDomain storageDomain : allStorageDomains) {
                    if (storageDomain.getStorageDomainType() == StorageDomainType.ISO) {
                        isoStorageDomains.add(storageDomain);
                    }
                }
                return isoStorageDomains;
            }
            return new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getStorageDomainList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : new ArrayList<StorageDomain>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Storage:", SearchType.StorageDomain);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (ArrayList<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#method_after
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (List<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#end_block

#method_before
public static void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#method_after
public void getStorageDomainsByConnection(AsyncQuery aQuery, Guid storagePoolId, String connectionPath) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    GetStorageDomainsByConnectionParameters param = new GetStorageDomainsByConnectionParameters();
    param.setConnection(connectionPath);
    if (storagePoolId != null) {
        param.setStoragePoolId(storagePoolId);
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetStorageDomainsByConnection, param, aQuery);
}
#end_block

#method_before
public static void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#method_after
public void getExistingStorageDomainList(AsyncQuery aQuery, Guid hostId, StorageDomainType domainType, StorageType storageType, String path) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<StorageDomain>) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, path), aQuery);
}
#end_block

#method_before
public static void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getStorageDomainMaxNameLength(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 1;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.StorageDomainNameSizeLimit, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#method_after
public void isStorageDomainNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) source;
                return storageDomains.isEmpty();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$
    SearchParameters(// $NON-NLS-1$
    "Storage: name=" + name, SearchType.StorageDomain), aQuery);
}
#end_block

#method_before
public static void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#method_after
public void getNetworkConnectivityCheckTimeoutInSeconds(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 120;
        }
    };
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.NetworkConnectivityCheckTimeoutInSeconds, getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
public static void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#method_after
public void getMaxSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 10);
}
#end_block

#method_before
public static void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#method_after
public void getDefaultSpmPriority(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Integer) source).intValue() : 0;
        }
    };
    // GetConfigFromCache(
    // new GetConfigurationValueParameters(ConfigurationValues.HighUtilizationForPowerSave,
    // getDefaultConfigurationVersion()),
    // aQuery);
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), 5);
}
#end_block

#method_before
public static void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#method_after
public void getDefaultPmProxyPreferences(AsyncQuery query) {
    getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.FenceProxyDefaultPreferences, getDefaultConfigurationVersion()), query);
}
#end_block

#method_before
public static void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#method_after
public void getRootTag(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                Tags tag = (Tags) source;
                Tags root = new Tags(tag.getdescription(), tag.getparent_id(), tag.getIsReadonly(), tag.gettag_id(), tag.gettag_name());
                if (tag.getChildren() != null) {
                    fillTagsRecursive(root, tag.getChildren());
                }
                return root;
            }
            return new Tags();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetRootTag, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
private static void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<Tags>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.gettype() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#method_after
private void setAttachedTagsConverter(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<Tags> ret = new ArrayList<Tags>();
                for (Tags tags : (ArrayList<Tags>) source) {
                    if (tags.gettype() == TagsType.GeneralTag) {
                        ret.add(tags);
                    }
                }
                return ret;
            }
            return new Tags();
        }
    };
}
#end_block

#method_before
public static void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToVm(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVmId, new GetTagsByVmIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUser(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserId, new GetTagsByUserIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToUserGroup(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByUserGroupId, new GetTagsByUserGroupIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#method_after
public void getAttachedTagsToHost(AsyncQuery aQuery, Guid id) {
    setAttachedTagsConverter(aQuery);
    Frontend.getInstance().runQuery(VdcQueryType.GetTagsByVdsId, new GetTagsByVdsIdParameters(id.toString()), aQuery);
}
#end_block

#method_before
public static void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#method_after
public void getoVirtISOsList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<RpmVersion>((ArrayList<RpmVersion>) source) : new ArrayList<RpmVersion>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetoVirtISOs, new VdsIdParametersBase(id), aQuery);
}
#end_block

#method_before
public static void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#method_after
public void getLunsByVgId(AsyncQuery aQuery, String vgId, Guid vdsId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<LUNs>) source : new ArrayList<LUNs>();
        }
    };
    GetLunsByVgIdParameters params = new GetLunsByVgIdParameters(vgId, vdsId);
    Frontend.getInstance().runQuery(VdcQueryType.GetLunsByVgId, params, aQuery);
}
#end_block

#method_before
public static void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public void getAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.getInstance().runQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Collections.emptyList();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#end_block

#method_before
public static void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName, Integer maxCount) {
    SearchParameters searchParameters = // $NON-NLS-1$ //$NON-NLS-2$
    new SearchParameters("Host: cluster = " + clusterName + " and status = up", SearchType.VDS);
    if (maxCount != null) {
        searchParameters.setMaxCount(maxCount);
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParameters, aQuery);
}
#end_block

#method_before
public static void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmNicList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? new ArrayList<VmNetworkInterface>((ArrayList<VmNetworkInterface>) source) : new ArrayList<VmNetworkInterface>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmSnapshotList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Snapshot>) source : new ArrayList<Snapshot>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmsRunningOnOrMigratingToVds(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VM>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsRunningOnOrMigratingToVds, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#method_after
public void getVmDiskList(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<Disk> list = new ArrayList<Disk>();
            if (source != null) {
                Iterable listEnumerable = (Iterable) source;
                Iterator listIterator = listEnumerable.iterator();
                while (listIterator.hasNext()) {
                    list.add((Disk) listIterator.next());
                }
            }
            return list;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(id), aQuery);
}
#end_block

#method_before
public static void getVmList(AsyncQuery aQuery, String poolName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: pool=" + poolName, SearchType.VM), aQuery);
}
#method_after
public void getVmList(AsyncQuery aQuery, String poolName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: pool=" + poolName, SearchType.VM), aQuery);
}
#end_block

#method_before
public static void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#method_after
public void getVmListByClusterName(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VM> vms = Linq.<VM>cast((ArrayList<IVdcQueryable>) source);
            return vms;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters("Vms: cluster=" + clusterName, SearchType.VM), // $NON-NLS-1$
    aQuery);
}
#end_block

#method_before
public static void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#method_after
public void getDiskList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<DiskImage>) source : new ArrayList<DiskImage>();
        }
    };
    // $NON-NLS-1$
    SearchParameters searchParams = new SearchParameters("Disks:", SearchType.Disk);
    searchParams.setMaxCount(9999);
    Frontend.getInstance().runQuery(VdcQueryType.Search, searchParams, aQuery);
}
#end_block

#method_before
public static void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getNextAvailableDiskAliasNameByVMId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetNextAvailableDiskAliasNameByVMId, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#method_after
public void isPoolNameUnique(AsyncQuery aQuery, String name) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !(Boolean) source;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsVmPoolWithSameNameExists, new NameQueryParameters(name), aQuery);
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId), aQuery);
}
#method_after
public void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#end_block

#method_before
public static void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#method_after
public void getPermittedStorageDomainsByStoragePoolId(AsyncQuery aQuery, Guid dataCenterId, ActionGroup actionGroup) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new java.util.ArrayList<StorageDomain>();
            }
            return source;
        }
    };
    GetPermittedStorageDomainsByStoragePoolIdParameters params = new GetPermittedStorageDomainsByStoragePoolIdParameters();
    params.setStoragePoolId(dataCenterId);
    params.setActionGroup(actionGroup);
    Frontend.getInstance().runQuery(VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, params, aQuery);
}
#end_block

#method_before
public static void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public static void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#method_after
public void getStorageConnectionsByDataCenterIdAndStorageType(AsyncQuery aQuery, Guid storagePoolId, StorageType storageType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GetConnectionsByDataCenterAndStorageTypeParameters params = new GetConnectionsByDataCenterAndStorageTypeParameters(storagePoolId, storageType);
    Frontend.getInstance().runQuery(VdcQueryType.GetConnectionsByDataCenterAndStorageType, params, aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase(), aQuery);
    }
}
#method_after
public void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
private static boolean isCommandCompatible(VdcActionType vdcActionType, Version cluster, Version dc) {
    if (cachedCommandsCompatibilityVersions == null || cluster == null || dc == null) {
        return false;
    }
    CommandVersionsInfo commandVersionsInfo = cachedCommandsCompatibilityVersions.get(vdcActionType);
    if (commandVersionsInfo == null) {
        return false;
    }
    Version clusterCompatibility = commandVersionsInfo.getClusterVersion();
    Version dcCompatibility = commandVersionsInfo.getStoragePoolVersion();
    return (clusterCompatibility.compareTo(cluster) <= 0) && (dcCompatibility.compareTo(dc) <= 0);
}
#method_after
private boolean isCommandCompatible(VdcActionType vdcActionType, Version cluster, Version dc) {
    if (cachedCommandsCompatibilityVersions == null || cluster == null || dc == null) {
        return false;
    }
    CommandVersionsInfo commandVersionsInfo = cachedCommandsCompatibilityVersions.get(vdcActionType);
    if (commandVersionsInfo == null) {
        return false;
    }
    Version clusterCompatibility = commandVersionsInfo.getClusterVersion();
    Version dcCompatibility = commandVersionsInfo.getStoragePoolVersion();
    return (clusterCompatibility.compareTo(cluster) <= 0) && (dcCompatibility.compareTo(dc) <= 0);
}
#end_block

#method_before
public static CommandVersionsInfo getCommandVersionsInfo(VdcActionType vdcActionType) {
    if (cachedCommandsCompatibilityVersions == null) {
        return null;
    }
    return cachedCommandsCompatibilityVersions.get(vdcActionType);
}
#method_after
public CommandVersionsInfo getCommandVersionsInfo(VdcActionType vdcActionType) {
    if (cachedCommandsCompatibilityVersions == null) {
        return null;
    }
    return cachedCommandsCompatibilityVersions.get(vdcActionType);
}
#end_block

#method_before
private static void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public static Object getConfigValuePreConverted(ConfigurationValues configValue, String version) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return cachedConfigValuesPreConvert.get(key);
}
#method_after
public Object getConfigValuePreConverted(ConfigurationValues configValue, String version) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return cachedConfigValuesPreConvert.get(key);
}
#end_block

#method_before
public static Object getConfigValuePreConverted(ConfigurationValues configValue) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, getDefaultConfigurationVersion());
    return cachedConfigValuesPreConvert.get(key);
}
#method_after
public Object getConfigValuePreConverted(ConfigurationValues configValue) {
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, getDefaultConfigurationVersion());
    return cachedConfigValuesPreConvert.get(key);
}
#end_block

#method_before
public static Object getConfigValue(ConfigurationValues configValue, String version, IAsyncConverter converter) {
    if (converter == null) {
        return null;
    }
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return converter.Convert(cachedConfigValuesPreConvert.get(key), null);
}
#method_after
public Object getConfigValue(ConfigurationValues configValue, String version, IAsyncConverter converter) {
    if (converter == null) {
        return null;
    }
    KeyValuePairCompat<ConfigurationValues, String> key = new KeyValuePairCompat<ConfigurationValues, String>(configValue, version);
    return converter.Convert(cachedConfigValuesPreConvert.get(key), null);
}
#end_block

#method_before
public static void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<ConfigurationValues, String>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.Convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#method_after
public void getConfigFromCache(GetConfigurationValueParameters parameters, AsyncQuery aQuery) {
    // cache key
    final KeyValuePairCompat<ConfigurationValues, String> config_key = new KeyValuePairCompat<ConfigurationValues, String>(parameters.getConfigValue(), parameters.getVersion());
    Object returnValue = null;
    if (cachedConfigValues.containsKey(config_key)) {
        // cache hit
        returnValue = cachedConfigValues.get(config_key);
    } else // and call asyncCallback's onSuccess
    if (cachedConfigValuesPreConvert.containsKey(config_key)) {
        returnValue = cachedConfigValuesPreConvert.get(config_key);
        // run converter
        if (aQuery.converterCallback != null) {
            returnValue = aQuery.converterCallback.Convert(returnValue, aQuery);
        }
        if (returnValue != null) {
            cachedConfigValues.put(config_key, returnValue);
        }
    }
    aQuery.asyncCallback.onSuccess(aQuery.getModel(), returnValue);
}
#end_block

#method_before
public static void getConfigFromCache(ConfigurationValues configValue, String version, AsyncQuery aQuery) {
    GetConfigurationValueParameters parameters = new GetConfigurationValueParameters(configValue, version);
    getConfigFromCache(parameters, aQuery);
}
#method_after
public void getConfigFromCache(ConfigurationValues configValue, String version, AsyncQuery aQuery) {
    GetConfigurationValueParameters parameters = new GetConfigurationValueParameters(configValue, version);
    getConfigFromCache(parameters, aQuery);
}
#end_block

#method_before
public static ArrayList<QuotaEnforcementTypeEnum> getQuotaEnforcmentTypes() {
    return new ArrayList<QuotaEnforcementTypeEnum>(Arrays.asList(new QuotaEnforcementTypeEnum[] { QuotaEnforcementTypeEnum.DISABLED, QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT, QuotaEnforcementTypeEnum.HARD_ENFORCEMENT }));
}
#method_after
public ArrayList<QuotaEnforcementTypeEnum> getQuotaEnforcmentTypes() {
    return new ArrayList<QuotaEnforcementTypeEnum>(Arrays.asList(new QuotaEnforcementTypeEnum[] { QuotaEnforcementTypeEnum.DISABLED, QuotaEnforcementTypeEnum.SOFT_ENFORCEMENT, QuotaEnforcementTypeEnum.HARD_ENFORCEMENT }));
}
#end_block

#method_before
public static void clearCache() {
    cachedConfigValues.clear();
}
#method_after
public void clearCache() {
    cachedConfigValues.clear();
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private static void getVlanParentInterface(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVlanParent, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private void getVlanParentInterface(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVlanParent, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            if (siblingVlanInterfaces.size() > 0) {
                return true;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
public static void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#method_after
public void getExternalProviderHostList(AsyncQuery aQuery, Guid providerId, boolean filterOutExistingHosts, String searchFilter) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VDS>();
            }
            return source;
        }
    };
    GetHostListFromExternalProviderParameters params = new GetHostListFromExternalProviderParameters();
    params.setFilterOutExistingHosts(filterOutExistingHosts);
    params.setProviderId(providerId);
    params.setSearchFilter(searchFilter);
    Frontend.getInstance().runQuery(VdcQueryType.GetHostListFromExternalProvider, params, aQuery);
}
#end_block

#method_before
public static void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#method_after
public void getAllProviders(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            Collections.sort((List<Provider>) source, new NameableComparator());
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), aQuery);
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#method_after
public void getAllNetworkProviders(AsyncQuery query) {
    getAllProvidersByProvidedEntity(query, VdcObjectType.Network);
}
#end_block

#method_before
public static void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#method_after
public void getAllProvidersByType(AsyncQuery aQuery, ProviderType providerType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<Provider>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(providerType), aQuery);
}
#end_block

#method_before
public static void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return Collections.<CertificateInfo>emptyList();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
private static void getAllChildVlanInterfaces(Guid vdsID, List<VdsNetworkInterface> ifaces, IFrontendMultipleQueryAsyncCallback callback) {
    ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    for (final VdsNetworkInterface iface : ifaces) {
        queryTypeList.add(VdcQueryType.GetAllChildVlanInterfaces);
        parametersList.add(new InterfaceAndIdQueryParameters(vdsID, iface));
    }
    Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, callback);
}
#method_after
private void getAllChildVlanInterfaces(Guid vdsID, List<VdsNetworkInterface> ifaces, IFrontendMultipleQueryAsyncCallback callback) {
    ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
    ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
    for (final VdsNetworkInterface iface : ifaces) {
        queryTypeList.add(VdcQueryType.GetAllChildVlanInterfaces);
        parametersList.add(new InterfaceAndIdQueryParameters(vdsID, iface));
    }
    Frontend.getInstance().runMultipleQueries(queryTypeList, parametersList, callback);
}
#end_block

#method_before
public static void isSupportBridgesReportByVDSM(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.SupportBridgesReportByVDSM);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#method_after
public void isSupportBridgesReportByVDSM(AsyncQuery aQuery, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? ((Boolean) source).booleanValue() : true;
        }
    };
    GetConfigurationValueParameters tempVar = new GetConfigurationValueParameters(ConfigurationValues.SupportBridgesReportByVDSM);
    tempVar.setVersion(version);
    getConfigFromCache(tempVar, aQuery);
}
#end_block

#method_before
public static void fillTagsRecursive(Tags tagToFill, List<Tags> children) {
    ArrayList<Tags> list = new ArrayList<Tags>();
    for (Tags tag : children) {
        // tags child = new tags(tag.description, tag.parent_id, tag.IsReadonly, tag.tag_id, tag.tag_name);
        if (tag.gettype() == TagsType.GeneralTag) {
            list.add(tag);
            if (tag.getChildren() != null) {
                fillTagsRecursive(tag, tag.getChildren());
            }
        }
    }
    tagToFill.setChildren(list);
}
#method_after
public void fillTagsRecursive(Tags tagToFill, List<Tags> children) {
    ArrayList<Tags> list = new ArrayList<Tags>();
    for (Tags tag : children) {
        // tags child = new tags(tag.description, tag.parent_id, tag.IsReadonly, tag.tag_id, tag.tag_name);
        if (tag.gettype() == TagsType.GeneralTag) {
            list.add(tag);
            if (tag.getChildren() != null) {
                fillTagsRecursive(tag, tag.getChildren());
            }
        }
    }
    tagToFill.setChildren(list);
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> getEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public ArrayList<EventNotificationEntity> getEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static Map<EventNotificationEntity, HashSet<AuditLogType>> getAvailableNotificationEvents() {
    return VdcEventNotificationUtils.getNotificationEvents();
}
#method_after
public Map<EventNotificationEntity, HashSet<AuditLogType>> getAvailableNotificationEvents() {
    return VdcEventNotificationUtils.getNotificationEvents();
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType() {
    return VmInterfaceType.pv;
}
#method_after
public VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#method_after
public boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static int getClusterDefaultMemoryOverCommit() {
    return 100;
}
#method_after
public int getClusterDefaultMemoryOverCommit() {
    return 100;
}
#end_block

#method_before
public static boolean getClusterDefaultCountThreadsAsCores() {
    return false;
}
#method_after
public boolean getClusterDefaultCountThreadsAsCores() {
    return false;
}
#end_block

#method_before
public static ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#method_after
public ArrayList<VolumeType> getVolumeTypeList() {
    return new ArrayList<VolumeType>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated, VolumeType.Sparse }));
}
#end_block

#method_before
public static ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<StorageType>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#method_after
public ArrayList<StorageType> getStorageTypeList() {
    return new ArrayList<StorageType>(Arrays.asList(new StorageType[] { StorageType.ISCSI, StorageType.FCP }));
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#method_after
public ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public String getNewNicName(Collection<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static String getComplexValueFromSpiceRedKeysResource(String complexValue) {
    if (StringHelper.isNullOrEmpty(complexValue)) {
        // $NON-NLS-1$
        return "";
    }
    ArrayList<String> values = new ArrayList<String>();
    for (String s : complexValue.split("[+]", -1)) {
        // $NON-NLS-1$
        try {
            String value = SpiceConstantsManager.getInstance().getSpiceRedKeys().getString(// $NON-NLS-1$ //$NON-NLS-2$
            s.replaceAll("-", "_"));
            values.add(value);
        } catch (MissingResourceException e) {
            values.add(s);
        }
    }
    // $NON-NLS-1$
    return StringHelper.join("+", values.toArray(new String[] {}));
}
#method_after
public String getComplexValueFromSpiceRedKeysResource(String complexValue) {
    if (StringHelper.isNullOrEmpty(complexValue)) {
        // $NON-NLS-1$
        return "";
    }
    ArrayList<String> values = new ArrayList<String>();
    for (String s : complexValue.split("[+]", -1)) {
        // $NON-NLS-1$
        try {
            String value = SpiceConstantsManager.getInstance().getSpiceRedKeys().getString(// $NON-NLS-1$ //$NON-NLS-2$
            s.replaceAll("-", "_"));
            values.add(value);
        } catch (MissingResourceException e) {
            values.add(s);
        }
    }
    // $NON-NLS-1$
    return StringHelper.join("+", values.toArray(new String[] {}));
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public <T extends Guid> T getEntityGuid(BusinessEntity<T> entity) {
    return entity.getId();
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public Guid getEntityGuid(Object entity) {
    if (entity instanceof BusinessEntity) {
        // BusinessEntity can have lot of different ID types, but from this context it cannot be determined.
        Object id = ((BusinessEntity<?>) entity).getId();
        // check whether result can be casted to Guid, otherwise continue with explicit rules.
        if (id instanceof Guid) {
            return (Guid) id;
        }
    }
    if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else {
        return Guid.Empty;
    }
}
#end_block

#method_before
public static boolean isWindowsOsType(Integer osType) {
    // can be null as a consequence of setItems on ListModel
    if (osType == null) {
        return false;
    }
    return windowsOsIds.contains(osType);
}
#method_after
public boolean isWindowsOsType(Integer osType) {
    // can be null as a consequence of setItems on ListModel
    if (osType == null) {
        return false;
    }
    return windowsOsIds.contains(osType);
}
#end_block

#method_before
public static boolean isLinuxOsType(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return false;
    }
    return linuxOsIds.contains(osId);
}
#method_after
public boolean isLinuxOsType(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return false;
    }
    return linuxOsIds.contains(osId);
}
#end_block

#method_before
public static void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#method_after
public void initWindowsOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            windowsOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetWindowsOss), callback);
}
#end_block

#method_before
public static void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#method_after
public void initLinuxOsTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            linuxOsIds = (ArrayList<Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetLinuxOss), callback);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            HashMap<Integer, String> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            String defaultValue = result.get(DEFAULT_OS_ID);
            osNames = new MapWithDefaults<Integer, String>(result, defaultValue);
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
private static void initOsIds() {
    osIds = new ArrayList<Integer>(osNames.keySet());
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
}
#method_after
private void initOsIds() {
    osIds = new ArrayList<Integer>(osNames.keySet());
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = (HashMap<Integer, ArchitectureType>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
public static boolean osNameExists(Integer osId) {
    return osNames.keySet().contains(osId);
}
#method_after
public boolean osNameExists(Integer osId) {
    return osNames.keySet().contains(osId);
}
#end_block

#method_before
public static String getOsName(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return "";
    }
    return osNames.get(osId);
}
#method_after
public String getOsName(Integer osId) {
    // can be null as a consequence of setItems on ListModel
    if (osId == null) {
        return "";
    }
    return osNames.get(osId);
}
#end_block

#method_before
public static boolean hasSpiceSupport(int osId, Version version) {
    return getDisplayTypes(osId, version).contains(DisplayType.qxl);
}
#method_after
public boolean hasSpiceSupport(int osId, Version version) {
    for (Pair<GraphicsType, DisplayType> graphicsDisplayPair : getGraphicsAndDisplays(osId, version)) {
        if (graphicsDisplayPair.getFirst() == GraphicsType.SPICE) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Integer, Map<Version, List<DisplayType>>> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            displayTypes = new MapWithDefaults<Integer, Map<Version, List<DisplayType>>>(result, result.get(DEFAULT_OS_ID));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            graphicsAndDisplays = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
public static List<Integer> getOsIds(ArchitectureType architectureType) {
    List<Integer> osIds = new ArrayList<Integer>();
    for (Entry<Integer, ArchitectureType> entry : osArchitectures.entrySet()) {
        if (entry.getValue() == architectureType) {
            osIds.add(entry.getKey());
        }
    }
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
    return osIds;
}
#method_after
public List<Integer> getOsIds(ArchitectureType architectureType) {
    List<Integer> osIds = new ArrayList<Integer>();
    for (Entry<Integer, ArchitectureType> entry : osArchitectures.entrySet()) {
        if (entry.getValue() == architectureType) {
            osIds.add(entry.getKey());
        }
    }
    Collections.sort(osIds, new Comparator<Integer>() {

        @Override
        public int compare(Integer o1, Integer o2) {
            return osNames.get(o1).compareTo(osNames.get(o2));
        }
    });
    return osIds;
}
#end_block

#method_before
public static void getOsMaxRam(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetMaxOsRam, osId, version), asyncQuery);
}
#method_after
public void getOsMaxRam(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetMaxOsRam, osId, version), asyncQuery);
}
#end_block

#method_before
public static void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#method_after
public void getVmWatchdogTypes(int osId, Version version, AsyncQuery asyncQuery) {
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetVmWatchdogTypes, osId, version), asyncQuery);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
public static String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#method_after
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#end_block

#method_before
public static int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#method_after
public int getMaxVmPriority() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.VmPriorityMaxValue, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static int roundPriority(int priority) {
    int max = getMaxVmPriority();
    int medium = max / 2;
    int[] levels = new int[] { 1, medium, max };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#method_after
public int roundPriority(int priority) {
    int max = getMaxVmPriority();
    int medium = max / 2;
    int[] levels = new int[] { 1, medium, max };
    for (int i = 0; i < levels.length; i++) {
        int lengthToLess = levels[i] - priority;
        int lengthToMore = levels[i + 1] - priority;
        if (lengthToMore < 0) {
            continue;
        }
        return Math.abs(lengthToLess) < lengthToMore ? levels[i] : levels[i + 1];
    }
    return 0;
}
#end_block

#method_before
public static void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#method_after
public void getVnicProfilesByNetworkId(AsyncQuery aQuery, Guid networkId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VnicProfileView>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByNetworkId, new IdQueryParameters(networkId), aQuery);
}
#end_block

#method_before
public static void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#method_after
public void getVnicProfilesByDcId(AsyncQuery aQuery, Guid dcId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return new ArrayList<VnicProfileView>();
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetVnicProfilesByDataCenterId, new IdQueryParameters(dcId), aQuery);
}
#end_block

#method_before
public static void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#method_after
public void getNumberOfActiveVmsInCluster(AsyncQuery aQuery, Guid clusterId) {
    // do not replace a converter = just add if none provided
    if (aQuery.converterCallback == null) {
        aQuery.converterCallback = new IAsyncConverter() {

            @Override
            public Object Convert(Object source, AsyncQuery _asyncQuery) {
                if (source == null) {
                    return Integer.valueOf(0);
                }
                return source;
            }
        };
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetNumberOfActiveVmsInVdsGroupByVdsGroupId, new IdQueryParameters(clusterId), aQuery);
}
#end_block

#method_before
private static ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
public ArrayList<VDSGroup> getClusterByServiceList(List<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#end_block

#method_before
public static String priorityToString(int value) {
    int roundedPriority = AsyncDataProvider.roundPriority(value);
    if (roundedPriority == 1) {
        return ConstantsManager.getInstance().getConstants().vmLowPriority();
    } else if (roundedPriority == AsyncDataProvider.getMaxVmPriority() / 2) {
        return ConstantsManager.getInstance().getConstants().vmMediumPriority();
    } else if (roundedPriority == AsyncDataProvider.getMaxVmPriority()) {
        return ConstantsManager.getInstance().getConstants().vmHighPriority();
    } else {
        return ConstantsManager.getInstance().getConstants().vmUnknownPriority();
    }
}
#method_after
public String priorityToString(int value) {
    int roundedPriority = roundPriority(value);
    if (roundedPriority == 1) {
        return ConstantsManager.getInstance().getConstants().vmLowPriority();
    } else if (roundedPriority == getMaxVmPriority() / 2) {
        return ConstantsManager.getInstance().getConstants().vmMediumPriority();
    } else if (roundedPriority == getMaxVmPriority()) {
        return ConstantsManager.getInstance().getConstants().vmHighPriority();
    } else {
        return ConstantsManager.getInstance().getConstants().vmUnknownPriority();
    }
}
#end_block

#method_before
public static void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#method_after
public void getExternalNetworkMap(AsyncQuery aQuery, Guid providerId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new HashMap<Network, Set<Guid>>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllExternalNetworksOnProvider, new IdQueryParameters(providerId), aQuery);
}
#end_block

#method_before
public static Integer getMaxVmNameLengthWin() {
    Integer maxVmNameLengthWindows = (Integer) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthWindows);
    if (maxVmNameLengthWindows == null) {
        return 15;
    }
    return maxVmNameLengthWindows;
}
#method_after
public Integer getMaxVmNameLengthWin() {
    Integer maxVmNameLengthWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthWindows);
    if (maxVmNameLengthWindows == null) {
        return 15;
    }
    return maxVmNameLengthWindows;
}
#end_block

#method_before
public static Integer getMaxVmNameLengthNonWin() {
    Integer maxVmNameLengthNonWindows = (Integer) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthNonWindows);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#method_after
public Integer getMaxVmNameLengthNonWin() {
    Integer maxVmNameLengthNonWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLengthNonWindows);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#end_block

#method_before
public static int getOptimizeSchedulerForSpeedPendingRequests() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SpeedOptimizationSchedulingThreshold, getDefaultConfigurationVersion());
}
#method_after
public int getOptimizeSchedulerForSpeedPendingRequests() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SpeedOptimizationSchedulingThreshold, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static boolean getScheudulingAllowOverbookingSupported() {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SchedulerAllowOverBooking, getDefaultConfigurationVersion());
}
#method_after
public boolean getScheudulingAllowOverbookingSupported() {
    return (Boolean) getConfigValuePreConverted(ConfigurationValues.SchedulerAllowOverBooking, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static int getSchedulerAllowOverbookingPendingRequestsThreshold() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SchedulerOverBookingThreshold, getDefaultConfigurationVersion());
}
#method_after
public int getSchedulerAllowOverbookingPendingRequestsThreshold() {
    return (Integer) getConfigValuePreConverted(ConfigurationValues.SchedulerOverBookingThreshold, getDefaultConfigurationVersion());
}
#end_block

#method_before
public static Integer getDefaultOs(ArchitectureType architectureType) {
    return defaultOSes.get(architectureType);
}
#method_after
public Integer getDefaultOs(ArchitectureType architectureType) {
    return defaultOSes.get(architectureType);
}
#end_block

#method_before
public static boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public EntityModel getAttachFloppy() {
    return privateAttachFloppy;
}
#method_after
public EntityModel<Boolean> getAttachFloppy() {
    return privateAttachFloppy;
}
#end_block

#method_before
private void setAttachFloppy(EntityModel value) {
    privateAttachFloppy = value;
}
#method_after
private void setAttachFloppy(EntityModel<Boolean> value) {
    privateAttachFloppy = value;
}
#end_block

#method_before
public ListModel getFloppyImage() {
    return privateFloppyImage;
}
#method_after
public ListModel<String> getFloppyImage() {
    return privateFloppyImage;
}
#end_block

#method_before
private void setFloppyImage(ListModel value) {
    privateFloppyImage = value;
}
#method_after
private void setFloppyImage(ListModel<String> value) {
    privateFloppyImage = value;
}
#end_block

#method_before
public EntityModel getAttachIso() {
    return privateAttachIso;
}
#method_after
public EntityModel<Boolean> getAttachIso() {
    return privateAttachIso;
}
#end_block

#method_before
private void setAttachIso(EntityModel value) {
    privateAttachIso = value;
}
#method_after
private void setAttachIso(EntityModel<Boolean> value) {
    privateAttachIso = value;
}
#end_block

#method_before
public ListModel getIsoImage() {
    return privateIsoImage;
}
#method_after
public ListModel<String> getIsoImage() {
    return privateIsoImage;
}
#end_block

#method_before
private void setIsoImage(ListModel value) {
    privateIsoImage = value;
}
#method_after
private void setIsoImage(ListModel<String> value) {
    privateIsoImage = value;
}
#end_block

#method_before
public ListModel getDisplayProtocol() {
    return privateDisplayProtocol;
}
#method_after
public ListModel<EntityModel<DisplayType>> getDisplayProtocol() {
    return privateDisplayProtocol;
}
#end_block

#method_before
private void setDisplayProtocol(ListModel value) {
    privateDisplayProtocol = value;
}
#method_after
private void setDisplayProtocol(ListModel<EntityModel<DisplayType>> value) {
    privateDisplayProtocol = value;
}
#end_block

#method_before
public EntityModel getInitrd_path() {
    return privateInitrd_path;
}
#method_after
public EntityModel<String> getInitrd_path() {
    return privateInitrd_path;
}
#end_block

#method_before
private void setInitrd_path(EntityModel value) {
    privateInitrd_path = value;
}
#method_after
private void setInitrd_path(EntityModel<String> value) {
    privateInitrd_path = value;
}
#end_block

#method_before
public EntityModel getKernel_path() {
    return privateKernel_path;
}
#method_after
public EntityModel<String> getKernel_path() {
    return privateKernel_path;
}
#end_block

#method_before
private void setKernel_path(EntityModel value) {
    privateKernel_path = value;
}
#method_after
private void setKernel_path(EntityModel<String> value) {
    privateKernel_path = value;
}
#end_block

#method_before
public EntityModel getKernel_parameters() {
    return privateKernel_parameters;
}
#method_after
public EntityModel<String> getKernel_parameters() {
    return privateKernel_parameters;
}
#end_block

#method_before
private void setKernel_parameters(EntityModel value) {
    privateKernel_parameters = value;
}
#method_after
private void setKernel_parameters(EntityModel<String> value) {
    privateKernel_parameters = value;
}
#end_block

#method_before
public ListModel getSysPrepDomainName() {
    return privateSysPrepDomainName;
}
#method_after
public ListModel<String> getSysPrepDomainName() {
    return privateSysPrepDomainName;
}
#end_block

#method_before
private void setSysPrepDomainName(ListModel value) {
    privateSysPrepDomainName = value;
}
#method_after
private void setSysPrepDomainName(ListModel<String> value) {
    privateSysPrepDomainName = value;
}
#end_block

#method_before
public EntityModel getSysPrepSelectedDomainName() {
    return privateSysPrepSelectedDomainName;
}
#method_after
public EntityModel<String> getSysPrepSelectedDomainName() {
    return privateSysPrepSelectedDomainName;
}
#end_block

#method_before
private void setSysPrepSelectedDomainName(EntityModel value) {
    privateSysPrepSelectedDomainName = value;
}
#method_after
private void setSysPrepSelectedDomainName(EntityModel<String> value) {
    privateSysPrepSelectedDomainName = value;
}
#end_block

#method_before
public EntityModel getSysPrepUserName() {
    return privateSysPrepUserName;
}
#method_after
public EntityModel<String> getSysPrepUserName() {
    return privateSysPrepUserName;
}
#end_block

#method_before
private void setSysPrepUserName(EntityModel value) {
    privateSysPrepUserName = value;
}
#method_after
private void setSysPrepUserName(EntityModel<String> value) {
    privateSysPrepUserName = value;
}
#end_block

#method_before
public EntityModel getSysPrepPassword() {
    return privateSysPrepPassword;
}
#method_after
public EntityModel<String> getSysPrepPassword() {
    return privateSysPrepPassword;
}
#end_block

#method_before
private void setSysPrepPassword(EntityModel value) {
    privateSysPrepPassword = value;
}
#method_after
private void setSysPrepPassword(EntityModel<String> value) {
    privateSysPrepPassword = value;
}
#end_block

#method_before
public EntityModel getUseAlternateCredentials() {
    return privateUseAlternateCredentials;
}
#method_after
public EntityModel<Boolean> getUseAlternateCredentials() {
    return privateUseAlternateCredentials;
}
#end_block

#method_before
private void setUseAlternateCredentials(EntityModel value) {
    privateUseAlternateCredentials = value;
}
#method_after
private void setUseAlternateCredentials(EntityModel<Boolean> value) {
    privateUseAlternateCredentials = value;
}
#end_block

#method_before
public EntityModel getIsSysprepEnabled() {
    return privateIsSysprepEnabled;
}
#method_after
public EntityModel<Boolean> getIsSysprepEnabled() {
    return privateIsSysprepEnabled;
}
#end_block

#method_before
private void setIsSysprepEnabled(EntityModel value) {
    privateIsSysprepEnabled = value;
}
#method_after
private void setIsSysprepEnabled(EntityModel<Boolean> value) {
    privateIsSysprepEnabled = value;
}
#end_block

#method_before
public EntityModel getIsSysprepPossible() {
    return privateIsSysprepPossible;
}
#method_after
public EntityModel<Boolean> getIsSysprepPossible() {
    return privateIsSysprepPossible;
}
#end_block

#method_before
private void setIsSysprepPossible(EntityModel value) {
    privateIsSysprepPossible = value;
}
#method_after
private void setIsSysprepPossible(EntityModel<Boolean> value) {
    privateIsSysprepPossible = value;
}
#end_block

#method_before
public EntityModel getIsVmFirstRun() {
    return privateIsVmFirstRun;
}
#method_after
public EntityModel<Boolean> getIsVmFirstRun() {
    return privateIsVmFirstRun;
}
#end_block

#method_before
private void setIsVmFirstRun(EntityModel value) {
    privateIsVmFirstRun = value;
}
#method_after
private void setIsVmFirstRun(EntityModel<Boolean> value) {
    privateIsVmFirstRun = value;
}
#end_block

#method_before
public EntityModel getIsLinuxOptionsAvailable() {
    return privateIsLinuxOptionsAvailable;
}
#method_after
public EntityModel<Boolean> getIsLinuxOptionsAvailable() {
    return privateIsLinuxOptionsAvailable;
}
#end_block

#method_before
private void setIsLinuxOptionsAvailable(EntityModel value) {
    privateIsLinuxOptionsAvailable = value;
}
#method_after
private void setIsLinuxOptionsAvailable(EntityModel<Boolean> value) {
    privateIsLinuxOptionsAvailable = value;
}
#end_block

#method_before
public EntityModel getIsCloudInitEnabled() {
    return privateIsCloudInitEnabled;
}
#method_after
public EntityModel<Boolean> getIsCloudInitEnabled() {
    return privateIsCloudInitEnabled;
}
#end_block

#method_before
private void setIsCloudInitEnabled(EntityModel value) {
    privateIsCloudInitEnabled = value;
}
#method_after
private void setIsCloudInitEnabled(EntityModel<Boolean> value) {
    privateIsCloudInitEnabled = value;
}
#end_block

#method_before
public EntityModel getIsCloudInitPossible() {
    return privateIsCloudInitPossible;
}
#method_after
public EntityModel<Boolean> getIsCloudInitPossible() {
    return privateIsCloudInitPossible;
}
#end_block

#method_before
private void setIsCloudInitPossible(EntityModel value) {
    privateIsCloudInitPossible = value;
}
#method_after
private void setIsCloudInitPossible(EntityModel<Boolean> value) {
    privateIsCloudInitPossible = value;
}
#end_block

#method_before
public EntityModel getRunAndPause() {
    return privateRunAndPause;
}
#method_after
public EntityModel<Boolean> getRunAndPause() {
    return privateRunAndPause;
}
#end_block

#method_before
public void setRunAndPause(EntityModel value) {
    privateRunAndPause = value;
}
#method_after
public void setRunAndPause(EntityModel<Boolean> value) {
    privateRunAndPause = value;
}
#end_block

#method_before
public EntityModel getRunAsStateless() {
    return privateRunAsStateless;
}
#method_after
public EntityModel<Boolean> getRunAsStateless() {
    return privateRunAsStateless;
}
#end_block

#method_before
public void setRunAsStateless(EntityModel value) {
    privateRunAsStateless = value;
}
#method_after
public void setRunAsStateless(EntityModel<Boolean> value) {
    privateRunAsStateless = value;
}
#end_block

#method_before
public EntityModel getDisplayConsole_Vnc_IsSelected() {
    return privateDisplayConsole_Vnc_IsSelected;
}
#method_after
public EntityModel<Boolean> getDisplayConsole_Vnc_IsSelected() {
    return privateDisplayConsole_Vnc_IsSelected;
}
#end_block

#method_before
public void setDisplayConsole_Vnc_IsSelected(EntityModel value) {
    privateDisplayConsole_Vnc_IsSelected = value;
}
#method_after
public void setDisplayConsole_Vnc_IsSelected(EntityModel<Boolean> value) {
    privateDisplayConsole_Vnc_IsSelected = value;
}
#end_block

#method_before
public EntityModel getDisplayConsole_Spice_IsSelected() {
    return privateDisplayConsole_Spice_IsSelected;
}
#method_after
public EntityModel<Boolean> getDisplayConsole_Spice_IsSelected() {
    return privateDisplayConsole_Spice_IsSelected;
}
#end_block

#method_before
public void setDisplayConsole_Spice_IsSelected(EntityModel value) {
    privateDisplayConsole_Spice_IsSelected = value;
}
#method_after
public void setDisplayConsole_Spice_IsSelected(EntityModel<Boolean> value) {
    privateDisplayConsole_Spice_IsSelected = value;
}
#end_block

#method_before
public ListModel getDefaultHost() {
    return defaultHost;
}
#method_after
public ListModel<VDS> getDefaultHost() {
    return defaultHost;
}
#end_block

#method_before
private void setDefaultHost(ListModel value) {
    this.defaultHost = value;
}
#method_after
private void setDefaultHost(ListModel<VDS> value) {
    this.defaultHost = value;
}
#end_block

#method_before
public EntityModel getIsAutoAssign() {
    return isAutoAssign;
}
#method_after
public EntityModel<Boolean> getIsAutoAssign() {
    return isAutoAssign;
}
#end_block

#method_before
public void setIsAutoAssign(EntityModel value) {
    this.isAutoAssign = value;
}
#method_after
public void setIsAutoAssign(EntityModel<Boolean> value) {
    this.isAutoAssign = value;
}
#end_block

#method_before
// The "sysprep" option was moved from a standalone check box to a
// pseudo floppy disk image. In order not to change the back-end
// interface, the Reinitialize variable was changed to a read-only
// property and its value is based on the selected floppy image.
// A similar comparison is done for cloud-init iso images, so the
public InitializationType getInitializationType() {
    if (getAttachFloppy().getEntity() != null && (Boolean) getAttachFloppy().getEntity() && "[sysprep]".equals(getFloppyImage().getSelectedItem())) {
        // $NON-NLS-1$
        return InitializationType.Sysprep;
    } else if (getIsCloudInitEnabled().getEntity() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        return InitializationType.CloudInit;
    } else {
        return InitializationType.None;
    }
}
#method_after
// The "sysprep" option was moved from a standalone check box to a
// pseudo floppy disk image. In order not to change the back-end
// interface, the Reinitialize variable was changed to a read-only
// property and its value is based on the selected floppy image.
// A similar comparison is done for cloud-init iso images, so the
public InitializationType getInitializationType() {
    if (getAttachFloppy().getEntity() != null && getAttachFloppy().getEntity() && "[sysprep]".equals(getFloppyImage().getSelectedItem())) {
        // $NON-NLS-1$
        return InitializationType.Sysprep;
    } else if (getIsCloudInitEnabled().getEntity() != null && getIsCloudInitEnabled().getEntity()) {
        return InitializationType.CloudInit;
    } else {
        return InitializationType.None;
    }
}
#end_block

#method_before
public String getFloppyImagePath() {
    if ((Boolean) getAttachFloppy().getEntity()) {
        return getInitializationType() == InitializationType.Sysprep ? "" : // $NON-NLS-1$
        (String) getFloppyImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#method_after
public String getFloppyImagePath() {
    if (getAttachFloppy().getEntity()) {
        return getInitializationType() == InitializationType.Sysprep ? "" : // $NON-NLS-1$
        getFloppyImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#end_block

#method_before
public String getIsoImagePath() {
    if ((Boolean) getAttachIso().getEntity()) {
        return (String) getIsoImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#method_after
public String getIsoImagePath() {
    if (getAttachIso().getEntity()) {
        return getIsoImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    AsyncDataProvider.isFloppySupported(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            RunOnceModel model = (RunOnceModel) target;
            Boolean isFloppySupported = (Boolean) returnValue;
            if (!isFloppySupported.booleanValue()) {
                getAttachFloppy().setIsAvailable(false);
                getFloppyImage().setIsAvailable(false);
            }
        }
    }), vm.getOs(), vm.getVdsGroupCompatibilityVersion());
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    updateDomainList();
    updateSystemTabLists();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
    AsyncDataProvider.isFloppySupported(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isFloppySupported = (Boolean) returnValue;
            if (!isFloppySupported.booleanValue()) {
                getAttachFloppy().setIsAvailable(false);
                getFloppyImage().setIsAvailable(false);
            }
        }
    }), vm.getOs(), vm.getVdsGroupCompatibilityVersion());
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    params.getRunOnceGraphics().add(Boolean.TRUE.equals(getDisplayConsole_Vnc_IsSelected().getEntity()) ? GraphicsType.VNC : GraphicsType.SPICE);
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    String selectedEmulatedMachine = getEmulatedMachine().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedEmulatedMachine)) {
        params.setCustomEmulatedMachine(selectedEmulatedMachine);
    }
    String selectedCustomCpu = getCustomCpu().getSelectedItem();
    if (!StringHelper.isNullOrEmpty(selectedCustomCpu)) {
        params.setCustomCpuName(selectedCustomCpu);
    }
    params.setSpiceFileTransferEnabled(getSpiceFileTransferEnabled().getEntity());
    params.setSpiceCopyPasteEnabled(getSpiceCopyPasteEnabled().getEntity());
    return params;
}
#end_block

#method_before
protected void updateFloppyImages() {
    AsyncDataProvider.getFloppyImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VM selectedVM = (VM) vm;
            List<String> images = (List<String>) returnValue;
            if (AsyncDataProvider.isWindowsOsType(selectedVM.getVmOsId())) {
                // Add a pseudo floppy disk image used for Windows' sysprep.
                if (!selectedVM.isInitialized()) {
                    // $NON-NLS-1$
                    images.add(0, "[sysprep]");
                    getAttachFloppy().setEntity(true);
                } else {
                    // $NON-NLS-1$
                    images.add("[sysprep]");
                }
            }
            getFloppyImage().setItems(images);
            if (getFloppyImage().getIsChangable() && getFloppyImage().getSelectedItem() == null) {
                getFloppyImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    }), vm.getStoragePoolId());
}
#method_after
protected void updateFloppyImages() {
    AsyncDataProvider.getInstance().getFloppyImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VM selectedVM = vm;
            List<String> images = (List<String>) returnValue;
            if (AsyncDataProvider.getInstance().isWindowsOsType(selectedVM.getVmOsId())) {
                // Add a pseudo floppy disk image used for Windows' sysprep.
                if (!selectedVM.isInitialized()) {
                    // $NON-NLS-1$
                    images.add(0, "[sysprep]");
                    getAttachFloppy().setEntity(true);
                } else {
                    // $NON-NLS-1$
                    images.add("[sysprep]");
                }
            }
            getFloppyImage().setItems(images);
            if (getFloppyImage().getIsChangable() && getFloppyImage().getSelectedItem() == null) {
                getFloppyImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    }), vm.getStoragePoolId());
}
#end_block

#method_before
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = (ArrayList<Disk>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#method_after
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#end_block

#method_before
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = (Collection<VmNetworkInterface>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !((List<VmNetworkInterface>) pluggedNics).isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#method_after
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !pluggedNics.isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#end_block

#method_before
private void updateDisplayProtocols() {
    boolean isVncSelected = vm.getDefaultDisplayType() == DisplayType.vnc;
    getDisplayConsole_Vnc_IsSelected().setEntity(isVncSelected);
    getDisplayConsole_Spice_IsSelected().setEntity(!isVncSelected);
}
#method_after
private void updateDisplayProtocols() {
    Frontend.getInstance().runQuery(VdcQueryType.GetGraphicsDevices, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            boolean selectVnc = false;
            List<GraphicsDevice> graphicsDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (graphicsDevices.size() == 1 && graphicsDevices.get(0).getGraphicsType() == GraphicsType.VNC) {
                selectVnc = true;
            }
            getDisplayConsole_Vnc_IsSelected().setEntity(selectVnc);
            getDisplayConsole_Spice_IsSelected().setEntity(!selectVnc);
        }
    }));
}
#end_block

#method_before
public void updateIsoList(boolean forceRefresh) {
    AsyncDataProvider.getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            getIsoImage().setItems(images);
            if (getIsoImage().getIsChangable() && getIsoImage().getSelectedItem() == null) {
                getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    }), vm.getStoragePoolId(), forceRefresh);
}
#method_after
public void updateIsoList(boolean forceRefresh) {
    AsyncDataProvider.getInstance().getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            final String lastSelectedIso = getIsoImage().getSelectedItem();
            getIsoImage().setItems(images);
            if (getIsoImage().getIsChangable()) {
                // try to preselect last image
                if (lastSelectedIso != null && images.contains(lastSelectedIso)) {
                    getIsoImage().setSelectedItem(lastSelectedIso);
                } else {
                    getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
                }
            }
        }
    }), vm.getStoragePoolId(), forceRefresh);
}
#end_block

#method_before
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> domains = (List<String>) returnValue;
            String oldDomain = (String) getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }), true);
}
#method_after
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getInstance().getAAAProfilesList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> domains = (List<String>) returnValue;
            String oldDomain = getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }));
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
            getSpiceFileTransferEnabled().setIsChangable(false);
            getSpiceCopyPasteEnabled().setIsChangable(false);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
            getSpiceFileTransferEnabled().setIsChangable(true);
            getSpiceCopyPasteEnabled().setIsChangable(true);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable((Boolean) getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable((Boolean) getAttachIso().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable(getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable(getAttachIso().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable((Boolean) getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable(getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = (Boolean) getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable((Boolean) getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable((Boolean) getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
}
#method_after
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable(getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable(getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
}
#end_block

#method_before
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#method_after
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if (getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#end_block

#method_before
public boolean validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && (Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid;
}
#method_after
public boolean validate() {
    getIsoImage().setIsValid(true);
    if (getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if (getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid();
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    if (command == runOnceCommand) {
        if (validate()) {
            onRunOnce();
        }
    } else if (command == cancelCommand) {
        commandTarget.executeCommand(command);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == runOnceCommand) {
        if (validate()) {
            onRunOnce();
        }
    } else if (command == cancelCommand) {
        commandTarget.executeCommand(command);
    }
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    List<String> layouts = (List<String>) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    List<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#method_after
private void initVncKeyboardLayout() {
    List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    List<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#end_block

#method_before
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    }
    return validateVmProperties(vm, messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, getVmDisks(), runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
}
#method_after
public boolean canRunVm(List<String> messages, StoragePool storagePool, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVds, VDSGroup vdsGroup) {
    if (vm.getStatus() == VMStatus.Paused) {
        // as the rest of the checks were already checked before
        return validate(validateVdsStatus(vm), messages);
    } else if (vm.getStatus() == VMStatus.Suspended) {
        return validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
    }
    return validateVmProperties(vm, runVmParam.getCustomProperties(), messages) && validate(validateBootSequence(vm, runVmParam.getBootSequence(), getVmDisks(), activeIsoDomainId), messages) && validate(validateDisplayType(), messages) && validate(new VmValidator(vm).vmNotLocked(), messages) && validate(getSnapshotValidator().vmNotDuringSnapshot(vm.getId()), messages) && validate(validateVmStatusUsingMatrix(vm), messages) && validate(validateStoragePoolUp(vm, storagePool, getVmImageDisks()), messages) && validate(validateIsoPath(vm, runVmParam.getDiskPath(), runVmParam.getFloppyPath(), activeIsoDomainId), messages) && validate(vmDuringInitialization(vm), messages) && validate(validateStatelessVm(vm, runVmParam.getRunAsStateless()), messages) && validate(validateFloppy(), messages) && validate(validateStorageDomains(vm, isInternalExecution, getVmImageDisks()), messages) && validate(validateImagesForRunVm(vm, getVmImageDisks()), messages) && validate(validateMemorySize(vm), messages) && SchedulingManager.getInstance().canSchedule(vdsGroup, vm, vdsBlackList, vdsWhiteList, destVds, messages);
}
#end_block

#method_before
protected boolean validateVmProperties(VM vm, List<String> messages) {
    List<ValidationError> validationErrors = getVmPropertiesUtils().validateVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, messages);
        return false;
    }
    return true;
}
#method_after
protected boolean validateVmProperties(VM vm, String runOnceCustomProperties, List<String> messages) {
    String customProperties = runOnceCustomProperties != null ? runOnceCustomProperties : vm.getCustomProperties();
    return getVmPropertiesUtils().validateVmProperties(vm.getVdsGroupCompatibilityVersion(), customProperties, messages);
}
#end_block

#method_before
protected ValidationResult validateBootSequence(VM vm, BootSequence bootSequence, List<Disk> vmDisks, Guid activeIsoDomainId) {
    BootSequence boot_sequence = (bootSequence != null) ? bootSequence : vm.getDefaultBootSequence();
    // HD and no other boot devices are configured
    if (boot_sequence == BootSequence.C && vmDisks.isEmpty()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK);
    }
    // pool/ISO inactive - you cannot run this VM
    if (boot_sequence == BootSequence.CD && activeIsoDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    // vm has network, otherwise the vm cannot be run in vdsm
    if (boot_sequence == BootSequence.N && getVmNicDao().getAllForVm(vm.getId()).isEmpty()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateBootSequence(VM vm, BootSequence runOnceBootSequence, List<Disk> vmDisks, Guid activeIsoDomainId) {
    BootSequence bootSequence = runOnceBootSequence != null ? runOnceBootSequence : vm.getDefaultBootSequence();
    // HD and no other boot devices are configured
    if (bootSequence == BootSequence.C && vmDisks.isEmpty()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK);
    }
    // pool/ISO inactive - you cannot run this VM
    if (bootSequence == BootSequence.CD && activeIsoDomainId == null) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    // vm has network, otherwise the vm cannot be run in vdsm
    if (bootSequence == BootSequence.N && getVmNicDao().getAllForVm(vm.getId()).isEmpty()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult validateStatelessVm(VM vm, List<Disk> plugDisks, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots(vm, plugDisks);
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateStatelessVm(VM vm, Boolean stateless) {
    // if the VM is not stateless, there is nothing to check
    if (stateless != null ? !stateless : !vm.isStateless()) {
        return ValidationResult.VALID;
    }
    ValidationResult previewValidation = getSnapshotValidator().vmNotInPreview(vm.getId());
    if (!previewValidation.isValid()) {
        return previewValidation;
    }
    // if the VM itself is stateless or run once as stateless
    if (vm.isAutoStartup()) {
        return new ValidationResult(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA);
    }
    ValidationResult hasSpaceValidation = hasSpaceForSnapshots();
    if (!hasSpaceValidation.isValid()) {
        return hasSpaceValidation;
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
protected ValidationResult hasSpaceForSnapshots(VM vm, List<Disk> plugDisks) {
    Integer minSnapshotSize = Config.<Integer>getValue(ConfigValues.InitStorageSparseSizeInGB);
    Map<StorageDomain, Integer> mapStorageDomainsToNumOfDisks = mapStorageDomainsToNumOfDisks(vm, plugDisks);
    for (Entry<StorageDomain, Integer> e : mapStorageDomainsToNumOfDisks.entrySet()) {
        ValidationResult validationResult = new StorageDomainValidator(e.getKey()).isDomainHasSpaceForRequest(minSnapshotSize * e.getValue());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult hasSpaceForSnapshots() {
    Set<Guid> sdIds = ImagesHandler.getAllStorageIdsForImageIds(getVmImageDisks());
    MultipleStorageDomainsValidator msdValidator = getStorageDomainsValidator(sdIds);
    ValidationResult retVal = msdValidator.allDomainsWithinThresholds();
    if (retVal == ValidationResult.VALID) {
        return msdValidator.allDomainsHaveSpaceForNewDisks(getVmImageDisks());
    }
    return retVal;
}
#end_block

#method_before
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<String>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#method_after
protected ValidationResult validateInterfacesAttachedToClusterNetworks(VM vm, final Set<String> clusterNetworkNames, final Set<String> interfaceNetworkNames) {
    Set<String> result = new HashSet<>(interfaceNetworkNames);
    result.removeAll(clusterNetworkNames);
    if (FeatureSupported.networkLinking(vm.getVdsGroupCompatibilityVersion())) {
        result.remove(null);
    }
    // aren't attached to the cluster
    return result.isEmpty() ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_NOT_IN_CLUSTER, String.format("$networks %1$s", StringUtils.join(result, ",")));
}
#end_block

#method_before
// /////////////////////
// / Utility methods ///
// /////////////////////
protected boolean validate(ValidationResult validationResult, List<String> message) {
    if (!validationResult.isValid()) {
        message.add(validationResult.getMessage().name());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                message.add(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
// /////////////////////
// / Utility methods ///
// /////////////////////
protected boolean validate(ValidationResult validationResult, List<String> message) {
    if (!validationResult.isValid()) {
        message.add(validationResult.getMessage().name());
        for (String variableReplacement : validationResult.getVariableReplacements()) {
            message.add(variableReplacement);
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().getGlusterStorageDeviceList();
    proceedProxyReturnValue();
    setReturnValue(result.getStorageDevices());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    result = getBroker().glusterStorageDeviceList();
    proceedProxyReturnValue();
    setReturnValue(result.getStorageDevices());
}
#end_block

#method_before
public GlusterVolumeSnapshotInfoReturnForXmlRpc glusterSnapshotInfo(Guid clusterId, String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterSnapshotInfo("", volumeName);
        GlusterVolumeSnapshotInfoReturnForXmlRpc wrapper = new GlusterVolumeSnapshotInfoReturnForXmlRpc(clusterId, xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeSnapshotInfoReturnForXmlRpc glusterSnapshotInfo(Guid clusterId, String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterSnapshotInfo("", volumeName);
        GlusterVolumeSnapshotInfoReturnForXmlRpc wrapper = new GlusterVolumeSnapshotInfoReturnForXmlRpc(clusterId, xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    try {
        return new OneUuidReturnForXmlRpc(vdsServer.glusterSnapshotCreate(volumeName, snapshotName, description, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeSnapshotCreateReturnForXmlRpc glusterSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    try {
        return new GlusterVolumeSnapshotCreateReturnForXmlRpc(vdsServer.glusterSnapshotCreate(volumeName, snapshotName, description, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private void updateHeartbeatPolicy(boolean isheartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setHeartbeat(isheartbeat);
    client.setClientRetryPolicy(policy);
}
#method_after
private void updateHeartbeatPolicy(boolean isHeartbeat) {
    RetryPolicy policy = client.getClientRetryPolicy();
    policy.setIncomingHeartbeat(isHeartbeat);
    policy.setOutgoingHeartbeat(isHeartbeat);
    client.setClientRetryPolicy(policy);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("key", configKey).withParameter("value", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("key", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDelete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("description", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeSnapshotCreateReturnForXmlRpc glusterSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("option", configName).withParameter("value", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("option", configName).withParameter("value", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
public void perform() {
    try {
        refreshExistingVmJobList();
        refreshVmStats();
        afterVMsRefreshTreatment();
    } finally {
        unlockVmsManager();
    }
}
#method_after
public void perform() {
    try {
        refreshExistingVmJobList();
        refreshVmStats();
        afterVMsRefreshTreatment();
        vdsManager.vmsMonitoringInitFinished();
    } finally {
        unlockVmsManager();
    }
}
#end_block

#method_before
@Override
public Permission mapRow(ResultSet rs, int rowNum) throws SQLException {
    Permission entity = new Permission();
    entity.setAdElementId(getGuidDefaultEmpty(rs, "ad_element_id"));
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setRoleId(getGuidDefaultEmpty(rs, "role_id"));
    entity.setObjectId(getGuidDefaultEmpty(rs, "object_id"));
    entity.setObjectType(VdcObjectType.forValue(rs.getInt(("object_type_id"))));
    entity.setRoleName(rs.getString("role_name"));
    entity.setObjectName(rs.getString("object_name"));
    entity.setOwnerName(rs.getString("owner_name"));
    entity.setNamespace(rs.getString("namespace"));
    entity.setAuthz(rs.getString("authz"));
    entity.setRoleType(RoleType.getById(rs.getInt("role_type")));
    return entity;
}
#method_after
@Override
public Permission mapRow(ResultSet rs, int rowNum) throws SQLException {
    Permission entity = new Permission();
    entity.setAdElementId(getGuidDefaultEmpty(rs, "ad_element_id"));
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setRoleId(getGuidDefaultEmpty(rs, "role_id"));
    entity.setObjectId(getGuidDefaultEmpty(rs, "object_id"));
    entity.setObjectType(VdcObjectType.forValue(rs.getInt(("object_type_id"))));
    entity.setRoleName(rs.getString("role_name"));
    entity.setObjectName(rs.getString("object_name"));
    entity.setOwnerName(rs.getString("owner_name"));
    entity.setNamespace(rs.getString("namespace"));
    entity.setAuthz(rs.getString("authz"));
    entity.setRoleType(RoleType.getById(rs.getInt("role_type")));
    entity.setCreationDate(rs.getLong("creation_date"));
    return entity;
}
#end_block

#method_before
private EngineSessionParameterSource getEngineSessionParameterSource(EngineSession session) {
    return new EngineSessionParameterSource(dialect, session);
}
#method_after
private EngineSessionParameterSource getEngineSessionParameterSource(EngineSession session) {
    return new EngineSessionParameterSource(getDialect(), session);
}
#end_block

#method_before
@Override
public List<EngineSession> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, EngineSessionRowMapper.instance);
}
#method_after
@Override
public List<EngineSession> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, EngineSessionRowMapper.instance);
}
#end_block

#method_before
@Override
public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
    DiskImage entity = super.mapRow(rs, rowNum);
    mapEntity(rs, entity);
    return entity;
}
#method_after
@Override
public DiskImage mapRow(ResultSet rs, int rowNum) throws SQLException {
    DiskImage entity = null;
    DiskStorageType diskStorageType = DiskStorageType.forValue(rs.getInt("disk_storage_type"));
    switch(diskStorageType) {
        case IMAGE:
            entity = super.mapRow(rs, rowNum);
            mapEntity(rs, entity);
            break;
        case CINDER:
            entity = CinderDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
    }
    return entity;
}
#end_block

#method_before
@PostConstruct
void init() {
    log.info("Initializing the DbFacade");
    dbFacadeLocator.configure(this);
    instance = this;
}
#method_after
private void init() {
    log.info("Initializing the DbFacade");
    dbFacadeLocator.configure(this);
    instance = this;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public <T extends DAO> T getDao(Class<T> daoType) {
    for (DAO dao : daos) {
        if (daoType.isAssignableFrom(dao.getClass())) {
            initBaseDAO((BaseDAODbFacade) dao);
            return (T) dao;
        }
    }
    log.error("Can't find dao for " + daoType);
    return null;
}
#method_after
@SuppressWarnings("unchecked")
private <T extends DAO> T getDao(Class<T> daoType) {
    for (DAO dao : daos) {
        if (daoType.isAssignableFrom(dao.getClass())) {
            return (T) dao;
        }
    }
    log.error("Can't find dao for " + daoType);
    return null;
}
#end_block

#method_before
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<MapSqlParameterSource>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#method_after
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(BaseDisk entity) {
    return createIdParameterMapper(entity.getId()).addValue("disk_alias", entity.getDiskAlias()).addValue("disk_description", entity.getDiskDescription()).addValue("disk_interface", EnumUtils.nameOrNull(entity.getDiskInterface())).addValue("wipe_after_delete", entity.isWipeAfterDelete()).addValue("propagate_errors", EnumUtils.nameOrNull(entity.getPropagateErrors())).addValue("shareable", entity.isShareable()).addValue("boot", entity.isBoot()).addValue("sgio", entity.getSgio()).addValue("alignment", entity.getAlignment()).addValue("last_alignment_scan", entity.getLastAlignmentScan());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(BaseDisk entity) {
    return createIdParameterMapper(entity.getId()).addValue("disk_alias", entity.getDiskAlias()).addValue("disk_description", entity.getDiskDescription()).addValue("disk_interface", EnumUtils.nameOrNull(entity.getDiskInterface())).addValue("wipe_after_delete", entity.isWipeAfterDelete()).addValue("propagate_errors", EnumUtils.nameOrNull(entity.getPropagateErrors())).addValue("shareable", entity.isShareable()).addValue("boot", entity.isBoot()).addValue("sgio", entity.getSgio()).addValue("alignment", entity.getAlignment()).addValue("last_alignment_scan", entity.getLastAlignmentScan()).addValue("disk_storage_type", entity.getDiskStorageType()).addValue("cinder_volume_type", entity.getCinderVolumeType());
}
#end_block

#method_before
@Override
public boolean isMemBalloonEnabled(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", vmId);
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("isMemBalloonEnabled").execute(parameterSource);
    String resultKey = dialect.getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Boolean) dbResults.get(resultKey)).booleanValue() : false;
}
#method_after
@Override
public boolean isMemBalloonEnabled(Guid vmId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vm_id", vmId);
    Map<String, Object> dbResults = new SimpleJdbcCall(getJdbcTemplate()).withFunctionName("isMemBalloonEnabled").execute(parameterSource);
    String resultKey = getDialect().getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Boolean) dbResults.get(resultKey)).booleanValue() : false;
}
#end_block

#method_before
@Override
protected RowMapper<HostNicVfsConfig> createEntityRowMapper() {
    return HostNicVfsConfigRowMapper.INSTANCE;
}
#method_after
@Override
protected RowMapper<HostNicVfsConfig> createEntityRowMapper() {
    return nicVfsConfigRowMapper;
}
#end_block

#method_before
@Override
public HostNicVfsConfig mapRow(ResultSet rs, int index) throws SQLException {
    HostNicVfsConfig entity = new HostNicVfsConfig();
    entity.setId(getGuid(rs, "id"));
    entity.setNicId(getGuid(rs, "nic_id"));
    entity.setAllNetworksAllowed(rs.getBoolean("is_all_networks_allowed"));
    return entity;
}
#method_after
@Override
public HostNicVfsConfig mapRow(ResultSet rs, int index) throws SQLException {
    HostNicVfsConfig entity = new HostNicVfsConfig();
    entity.setId(getGuid(rs, "id"));
    entity.setNicId(getGuid(rs, "nic_id"));
    entity.setAllNetworksAllowed(rs.getBoolean("is_all_networks_allowed"));
    fillNetworksAndLabelsDataOnConfig(entity);
    return entity;
}
#end_block

#method_before
private AsyncTaskParameterSource getTaskParameterSource(AsyncTask task) {
    return new AsyncTaskParameterSource(dialect, task);
}
#method_after
private AsyncTaskParameterSource getTaskParameterSource(AsyncTask task) {
    return new AsyncTaskParameterSource(getDialect(), task);
}
#end_block

#method_before
public List<Provider<?>> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, ProviderRowMapper.INSTANCE);
}
#method_after
public List<Provider<?>> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, ProviderRowMapper.INSTANCE);
}
#end_block

#method_before
@Override
public List<VM> getAllUsingQuery(String query) {
    return jdbcTemplate.query(query, VMRowMapper.instance);
}
#method_after
@Override
public List<VM> getAllUsingQuery(String query) {
    return getJdbcTemplate().query(query, VMRowMapper.instance);
}
#end_block

#method_before
@BeforeClass
public static void initTestCase() throws Exception {
    if (dataSource == null) {
        dataSource = createDataSource();
        ejbRule.mockResource(ContainerManagedResourceType.DATA_SOURCE, dataSource);
        dataset = initDataSet();
        // load data from fixtures to DB
        DatabaseOperation.CLEAN_INSERT.execute(getConnection(), dataset);
        SimpleNamingContextBuilder builder = new SimpleNamingContextBuilder();
        builder.bind("java:/ENGINEDataSource", dataSource);
        builder.activate();
    }
}
#method_after
@BeforeClass
public static void initTestCase() throws Exception {
    if (dataSource == null) {
        dataSource = createDataSource();
        ejbRule.mockResource(ContainerManagedResourceType.DATA_SOURCE, dataSource);
        final IDataSet dataset = initDataSet();
        // load data from fixtures to DB
        DatabaseOperation.CLEAN_INSERT.execute(getConnection(), dataset);
        SimpleNamingContextBuilder builder = new SimpleNamingContextBuilder();
        builder.bind("java:/ENGINEDataSource", dataSource);
        builder.activate();
    }
}
#end_block

#method_before
@Override
public List<VmPool> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, VmPoolFullRowMapper.instance);
}
#method_after
@Override
public List<VmPool> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, VmPoolFullRowMapper.instance);
}
#end_block

#method_before
@Override
public List<ClusterPolicy> getAll() {
    List<ClusterPolicy> clusterPolicies = super.getAll();
    Map<Guid, ClusterPolicy> map = new HashMap<Guid, ClusterPolicy>();
    for (ClusterPolicy clusterPolicy : clusterPolicies) {
        map.put(clusterPolicy.getId(), clusterPolicy);
    }
    List<ClusterPolicyUnit> clusterPolicyUnits = getCallsHandler().executeReadList("GetAllFromClusterPolicyUnits", createClusterPolicyUnitRowMapper(), getCustomMapSqlParameterSource());
    fillClusterPolicy(map, clusterPolicyUnits);
    return clusterPolicies;
}
#method_after
@Override
public List<ClusterPolicy> getAll() {
    List<ClusterPolicy> clusterPolicies = super.getAll();
    Map<Guid, ClusterPolicy> map = new HashMap<>();
    for (ClusterPolicy clusterPolicy : clusterPolicies) {
        map.put(clusterPolicy.getId(), clusterPolicy);
    }
    List<ClusterPolicyUnit> clusterPolicyUnits = getCallsHandler().executeReadList("GetAllFromClusterPolicyUnits", createClusterPolicyUnitRowMapper(), getCustomMapSqlParameterSource());
    fillClusterPolicy(map, clusterPolicyUnits);
    return clusterPolicies;
}
#end_block

#method_before
private void fillClusterPolicy(Map<Guid, ClusterPolicy> map, List<ClusterPolicyUnit> clusterPolicyUnits) {
    Map<Guid, PolicyUnit> policyUnitMap = new HashMap<Guid, PolicyUnit>();
    for (PolicyUnit policyUnit : dbFacade.getPolicyUnitDao().getAll()) {
        policyUnitMap.put(policyUnit.getId(), policyUnit);
    }
    for (ClusterPolicyUnit clusterPolicyUnit : clusterPolicyUnits) {
        ClusterPolicy clusterPolicy = map.get(clusterPolicyUnit.getClusterPolicyId());
        if (policyUnitMap.get(clusterPolicyUnit.getPolicyUnitId()).getPolicyUnitType() == PolicyUnitType.FILTER) {
            if (clusterPolicy.getFilters() == null) {
                clusterPolicy.setFilters(new ArrayList<Guid>());
            }
            clusterPolicy.getFilters().add(clusterPolicyUnit.getPolicyUnitId());
            if (clusterPolicyUnit.getFilterSequence() != 0) {
                if (clusterPolicy.getFilterPositionMap() == null) {
                    clusterPolicy.setFilterPositionMap(new HashMap<Guid, Integer>());
                }
                clusterPolicy.getFilterPositionMap().put(clusterPolicyUnit.getPolicyUnitId(), clusterPolicyUnit.getFilterSequence());
            }
        }
        if (policyUnitMap.get(clusterPolicyUnit.getPolicyUnitId()).getPolicyUnitType() == PolicyUnitType.WEIGHT) {
            if (clusterPolicy.getFunctions() == null) {
                clusterPolicy.setFunctions(new ArrayList<Pair<Guid, Integer>>());
            }
            clusterPolicy.getFunctions().add(new Pair<Guid, Integer>(clusterPolicyUnit.getPolicyUnitId(), clusterPolicyUnit.getFactor()));
        }
        if (policyUnitMap.get(clusterPolicyUnit.getPolicyUnitId()).getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
            clusterPolicy.setBalance(clusterPolicyUnit.getPolicyUnitId());
        }
    }
}
#method_after
private void fillClusterPolicy(Map<Guid, ClusterPolicy> map, List<ClusterPolicyUnit> clusterPolicyUnits) {
    Map<Guid, PolicyUnit> policyUnitMap = new HashMap<Guid, PolicyUnit>();
    for (PolicyUnit policyUnit : policyUnitDao.getAll()) {
        policyUnitMap.put(policyUnit.getId(), policyUnit);
    }
    for (ClusterPolicyUnit clusterPolicyUnit : clusterPolicyUnits) {
        ClusterPolicy clusterPolicy = map.get(clusterPolicyUnit.getClusterPolicyId());
        if (policyUnitMap.get(clusterPolicyUnit.getPolicyUnitId()).getPolicyUnitType() == PolicyUnitType.FILTER) {
            if (clusterPolicy.getFilters() == null) {
                clusterPolicy.setFilters(new ArrayList<Guid>());
            }
            clusterPolicy.getFilters().add(clusterPolicyUnit.getPolicyUnitId());
            if (clusterPolicyUnit.getFilterSequence() != 0) {
                if (clusterPolicy.getFilterPositionMap() == null) {
                    clusterPolicy.setFilterPositionMap(new HashMap<Guid, Integer>());
                }
                clusterPolicy.getFilterPositionMap().put(clusterPolicyUnit.getPolicyUnitId(), clusterPolicyUnit.getFilterSequence());
            }
        }
        if (policyUnitMap.get(clusterPolicyUnit.getPolicyUnitId()).getPolicyUnitType() == PolicyUnitType.WEIGHT) {
            if (clusterPolicy.getFunctions() == null) {
                clusterPolicy.setFunctions(new ArrayList<Pair<Guid, Integer>>());
            }
            clusterPolicy.getFunctions().add(new Pair<Guid, Integer>(clusterPolicyUnit.getPolicyUnitId(), clusterPolicyUnit.getFactor()));
        }
        if (policyUnitMap.get(clusterPolicyUnit.getPolicyUnitId()).getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
            clusterPolicy.setBalance(clusterPolicyUnit.getPolicyUnitId());
        }
    }
}
#end_block

#method_before
private void persistQosChanges(VdsNetworkInterface entity) {
    HostNetworkQosDao qosDao = DbFacade.getInstance().getHostNetworkQosDao();
    Guid id = entity.getId();
    HostNetworkQos oldQos = qosDao.get(id);
    HostNetworkQos qos = entity.getQos();
    if (qos == null) {
        if (oldQos != null) {
            qosDao.remove(id);
        }
    } else {
        qos.setId(id);
        if (oldQos == null) {
            qosDao.save(qos);
        } else if (!qos.equals(oldQos)) {
            qosDao.update(qos);
        }
    }
}
#method_after
private void persistQosChanges(VdsNetworkInterface entity) {
    Guid id = entity.getId();
    HostNetworkQos oldQos = hostNetworkQosDao.get(id);
    HostNetworkQos qos = entity.getQos();
    if (qos == null) {
        if (oldQos != null) {
            hostNetworkQosDao.remove(id);
        }
    } else {
        qos.setId(id);
        if (oldQos == null) {
            hostNetworkQosDao.save(qos);
        } else if (!qos.equals(oldQos)) {
            hostNetworkQosDao.update(qos);
        }
    }
}
#end_block

#method_before
@Override
public void removeInterfaceFromVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    DbFacade.getInstance().getNetworkQosDao().remove(id);
    getCallsHandler().executeModification("Deletevds_interface", parameterSource);
}
#method_after
@Override
public void removeInterfaceFromVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("id", id);
    networkQosDao.remove(id);
    getCallsHandler().executeModification("Deletevds_interface", parameterSource);
}
#end_block

#method_before
@Override
public List<NetworkView> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, NetworkViewRowMapper.instance);
}
#method_after
@Override
public List<NetworkView> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, NetworkViewRowMapper.instance);
}
#end_block

#method_before
@Override
public List<DbGroup> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, DbGroupRowMapper.instance);
}
#method_after
@Override
public List<DbGroup> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, DbGroupRowMapper.instance);
}
#end_block

#method_before
@Override
public List<GlusterVolumeSnapshotSchedule> getAllWithQuery(String query) {
    List<GlusterVolumeSnapshotSchedule> schedules = jdbcTemplate.query(query, snapshotScheduleRowMapper);
    return schedules;
}
#method_after
@Override
public List<GlusterVolumeSnapshotSchedule> getAllWithQuery(String query) {
    List<GlusterVolumeSnapshotSchedule> schedules = getJdbcTemplate().query(query, snapshotScheduleRowMapper);
    return schedules;
}
#end_block

#method_before
@Override
public List<StoragePool> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, mapper);
}
#method_after
@Override
public List<StoragePool> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, mapper);
}
#end_block

#method_before
@Override
public void save(VdsStatic vds) {
    Guid id = vds.getId();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.newGuid();
        vds.setId(id);
    }
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("InsertVdsStatic").execute(getInsertOrUpdateParams(vds));
}
#method_after
@Override
public void save(VdsStatic vds) {
    Guid id = vds.getId();
    if (Guid.isNullOrEmpty(id)) {
        id = Guid.newGuid();
        vds.setId(id);
    }
    new SimpleJdbcCall(getJdbcTemplate()).withProcedureName("InsertVdsStatic").execute(getInsertOrUpdateParams(vds));
}
#end_block

#method_before
@Override
public List<AuditLog> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, auditLogRowMapper);
}
#method_after
@Override
public List<AuditLog> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, auditLogRowMapper);
}
#end_block

#method_before
@Override
public int getTimeToWaitForNextPmOp(String vdsName, String event) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_name", vdsName).addValue("event", event).addValue("wait_for_sec", Config.getValue(ConfigValues.FenceQuietTimeBetweenOperationsInSec));
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("get_seconds_to_wait_before_pm_operation").execute(parameterSource);
    String resultKey = DbFacade.getInstance().getDbEngineDialect().getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Integer) dbResults.get(resultKey)).intValue() : 0;
}
#method_after
@Override
public int getTimeToWaitForNextPmOp(String vdsName, String event) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_name", vdsName).addValue("event", event).addValue("wait_for_sec", Config.getValue(ConfigValues.FenceQuietTimeBetweenOperationsInSec));
    Map<String, Object> dbResults = new SimpleJdbcCall(getJdbcTemplate()).withFunctionName("get_seconds_to_wait_before_pm_operation").execute(parameterSource);
    String resultKey = dbEngineDialect.getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Integer) dbResults.get(resultKey)).intValue() : 0;
}
#end_block

#method_before
@Override
public List<VmTemplate> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, VMTemplateRowMapper.instance);
}
#method_after
@Override
public List<VmTemplate> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, VMTemplateRowMapper.instance);
}
#end_block

#method_before
protected CustomMapSqlParameterSource getCustomMapSqlParameterSource() {
    return new CustomMapSqlParameterSource(dialect);
}
#method_after
protected CustomMapSqlParameterSource getCustomMapSqlParameterSource() {
    return new CustomMapSqlParameterSource(getDialect());
}
#end_block

#method_before
protected SimpleJdbcCallsHandler getCallsHandler() {
    return dbFacade.getCallsHandler();
}
#method_after
protected SimpleJdbcCallsHandler getCallsHandler() {
    return callsHandler;
}
#end_block

#method_before
@Override
public List<GlusterVolumeSnapshotEntity> getAllWithQuery(String query) {
    List<GlusterVolumeSnapshotEntity> snapshots = jdbcTemplate.query(query, snapshotRowMapper);
    return snapshots;
}
#method_after
@Override
public List<GlusterVolumeSnapshotEntity> getAllWithQuery(String query) {
    List<GlusterVolumeSnapshotEntity> snapshots = getJdbcTemplate().query(query, snapshotRowMapper);
    return snapshots;
}
#end_block

#method_before
@Override
public List<StorageDomain> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, StorageDomainRowMapper.instance);
}
#method_after
@Override
public List<StorageDomain> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, StorageDomainRowMapper.instance);
}
#end_block

#method_before
@Override
public List<GlusterVolumeEntity> getAllWithQuery(String query) {
    List<GlusterVolumeEntity> volumes = jdbcTemplate.query(query, volumeRowMapper);
    fetchRelatedEntities(volumes);
    return volumes;
}
#method_after
@Override
public List<GlusterVolumeEntity> getAllWithQuery(String query) {
    List<GlusterVolumeEntity> volumes = getJdbcTemplate().query(query, volumeRowMapper);
    fetchRelatedEntities(volumes);
    return volumes;
}
#end_block

#method_before
private void insertVolumeBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getVolumeId() == null) {
            brick.setVolumeId(volume.getId());
        }
        dbFacade.getGlusterBrickDao().save(brick);
    }
}
#method_after
private void insertVolumeBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getVolumeId() == null) {
            brick.setVolumeId(volume.getId());
        }
        glusterBrickDao.save(brick);
    }
}
#end_block

#method_before
private void insertVolumeOptions(GlusterVolumeEntity volume) {
    Collection<GlusterVolumeOptionEntity> options = volume.getOptions();
    for (GlusterVolumeOptionEntity option : options) {
        if (option.getVolumeId() == null) {
            option.setVolumeId(volume.getId());
        }
        dbFacade.getGlusterOptionDao().save(option);
    }
}
#method_after
private void insertVolumeOptions(GlusterVolumeEntity volume) {
    Collection<GlusterVolumeOptionEntity> options = volume.getOptions();
    for (GlusterVolumeOptionEntity option : options) {
        if (option.getVolumeId() == null) {
            option.setVolumeId(volume.getId());
        }
        glusterOptionDao.save(option);
    }
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        GlusterVolumeAdvancedDetails advancedDetails = fetchAdvancedDatails(volume.getId());
        if (advancedDetails != null) {
            volume.setAdvancedDetails(advancedDetails);
        }
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
        GlusterVolumeSnapshotConfig config = dbFacade.getGlusterVolumeSnapshotConfigDao().getConfigByVolumeIdAndName(volume.getClusterId(), volume.getId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        if (config == null || StringUtils.isEmpty(config.getParamValue())) {
            config = dbFacade.getGlusterVolumeSnapshotConfigDao().getConfigByClusterIdAndName(volume.getClusterId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        }
        volume.setSnapMaxLimit(config != null ? Integer.valueOf(config.getParamValue()) : 0);
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setOptions(glusterOptionDao.getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<>(getTransportTypesOfVolume(volume.getId())));
        GlusterVolumeAdvancedDetails advancedDetails = fetchAdvancedDatails(volume.getId());
        if (advancedDetails != null) {
            volume.setAdvancedDetails(advancedDetails);
        }
        GlusterAsyncTask asyncTask = getAsyncTaskOfVolume(volume.getId());
        if (asyncTask != null) {
            volume.setAsyncTask(asyncTask);
        }
        List<GlusterBrickEntity> bricks = glusterBrickDao.getBricksOfVolume(volume.getId());
        if (volume.getAsyncTask() != null && volume.getAsyncTask().getTaskId() != null) {
            for (GlusterBrickEntity brick : bricks) {
                if (brick.getAsyncTask() != null && brick.getAsyncTask().getTaskId() != null && brick.getAsyncTask().getTaskId().equals(volume.getAsyncTask().getTaskId())) {
                    brick.setAsyncTask(volume.getAsyncTask());
                }
            }
        }
        volume.setBricks(bricks);
        GlusterVolumeSnapshotConfig config = glusterVolumeSnapshotConfigDao.getConfigByVolumeIdAndName(volume.getClusterId(), volume.getId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        if (config == null || StringUtils.isEmpty(config.getParamValue())) {
            config = glusterVolumeSnapshotConfigDao.getConfigByClusterIdAndName(volume.getClusterId(), GlusterConstants.VOLUME_SNAPSHOT_MAX_HARD_LIMIT);
        }
        volume.setSnapMaxLimit(config != null ? Integer.valueOf(config.getParamValue()) : 0);
    }
}
#end_block

#method_before
@Override
public List<VDSGroup> getAllWithQuery(String query) {
    List<VDSGroup> groups = jdbcTemplate.query(query, VdsGroupRowMapper.instance);
    try {
        // The UI requires the host and vm count
        return getHostsAndVmsForClusters(groups);
    } catch (Exception e) {
        log.error("Can't load host and vm count for cluster. Query is '{}'. Error: {}", query, e.getMessage());
        log.debug("Excpetion", e);
    }
    return groups;
}
#method_after
@Override
public List<VDSGroup> getAllWithQuery(String query) {
    List<VDSGroup> groups = getJdbcTemplate().query(query, VdsGroupRowMapper.instance);
    try {
        // The UI requires the host and vm count
        return getHostsAndVmsForClusters(groups);
    } catch (Exception e) {
        log.error("Can't load host and vm count for cluster. Query is '{}'. Error: {}", query, e.getMessage());
        log.debug("Excpetion", e);
    }
    return groups;
}
#end_block

#method_before
protected List<VDSGroup> getHostsAndVmsForClusters(List<VDSGroup> vdsGroups) throws Exception {
    Map<Guid, VDSGroup> groupsById = new HashMap<>();
    for (VDSGroup vdsGroup : vdsGroups) {
        groupsById.put(vdsGroup.getId(), vdsGroup);
    }
    Connection c = jdbcTemplate.getDataSource().getConnection();
    Array groups = c.createArrayOf("uuid", groupsById.keySet().toArray());
    List<VDSGroupHostsAndVMs> dataList = getCallsHandler().executeReadList("GetHostsAndVmsForClusters", VDSGroupHostsAndVMsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_ids", groups));
    c.close();
    for (VDSGroupHostsAndVMs groupDetail : dataList) {
        groupsById.get(groupDetail.getVdsGroupId()).setGroupHostsAndVms(groupDetail);
    }
    // in the right order.
    return vdsGroups;
}
#method_after
protected List<VDSGroup> getHostsAndVmsForClusters(List<VDSGroup> vdsGroups) throws Exception {
    Map<Guid, VDSGroup> groupsById = new HashMap<>();
    for (VDSGroup vdsGroup : vdsGroups) {
        groupsById.put(vdsGroup.getId(), vdsGroup);
    }
    Connection c = getJdbcTemplate().getDataSource().getConnection();
    Array groups = c.createArrayOf("uuid", groupsById.keySet().toArray());
    List<VDSGroupHostsAndVMs> dataList = getCallsHandler().executeReadList("GetHostsAndVmsForClusters", VDSGroupHostsAndVMsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_ids", groups));
    c.close();
    for (VDSGroupHostsAndVMs groupDetail : dataList) {
        groupsById.get(groupDetail.getVdsGroupId()).setGroupHostsAndVms(groupDetail);
    }
    // in the right order.
    return vdsGroups;
}
#end_block

#method_before
@Override
public List<Quota> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, getQuotaMetaDataFromResultSet());
}
#method_after
@Override
public List<Quota> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, getQuotaMetaDataFromResultSet());
}
#end_block

#method_before
@Override
public boolean isQuotaInUse(Quota quota) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("quota_id", quota.getId());
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("IsQuotaInUse").execute(parameterSource);
    String resultKey = dialect.getFunctionReturnKey();
    return dbResults.get(resultKey) != null && (Boolean) dbResults.get(resultKey);
}
#method_after
@Override
public boolean isQuotaInUse(Quota quota) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("quota_id", quota.getId());
    Map<String, Object> dbResults = new SimpleJdbcCall(getJdbcTemplate()).withFunctionName("IsQuotaInUse").execute(parameterSource);
    String resultKey = getDialect().getFunctionReturnKey();
    return dbResults.get(resultKey) != null && (Boolean) dbResults.get(resultKey);
}
#end_block

#method_before
@Override
public List<GlusterServerService> getAllWithQuery(String query) {
    return new SimpleJdbcTemplate(jdbcTemplate).query(query, serviceRowMapper);
}
#method_after
@Override
public List<GlusterServerService> getAllWithQuery(String query) {
    return new SimpleJdbcTemplate(getJdbcTemplate()).query(query, serviceRowMapper);
}
#end_block

#method_before
@Override
public List<DbUser> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, DbUserRowMapper.instance);
}
#method_after
@Override
public List<DbUser> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, DbUserRowMapper.instance);
}
#end_block

#method_before
@Override
public void save(DbUser user) {
    setIdIfNeeded(user);
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("InsertUser").execute(new DbUserMapSqlParameterSource(user));
}
#method_after
@Override
public void save(DbUser user) {
    setIdIfNeeded(user);
    new SimpleJdbcCall(getJdbcTemplate()).withProcedureName("InsertUser").execute(new DbUserMapSqlParameterSource(user));
}
#end_block

#method_before
@Override
public void saveOrUpdate(DbUser user) {
    setIdIfNeeded(user);
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("InsertOrUpdateUser").execute(new DbUserMapSqlParameterSource(user));
}
#method_after
@Override
public void saveOrUpdate(DbUser user) {
    setIdIfNeeded(user);
    new SimpleJdbcCall(getJdbcTemplate()).withProcedureName("InsertOrUpdateUser").execute(new DbUserMapSqlParameterSource(user));
}
#end_block

#method_before
@Override
@SuppressWarnings("deprecation")
public List<GlusterHookEntity> getAllWithQuery(String query) {
    List<GlusterHookEntity> glusterHooks = jdbcTemplate.query(query, glusterHookRowMapper);
    return glusterHooks;
}
#method_after
@Override
@SuppressWarnings("deprecation")
public List<GlusterHookEntity> getAllWithQuery(String query) {
    List<GlusterHookEntity> glusterHooks = getJdbcTemplate().query(query, glusterHookRowMapper);
    return glusterHooks;
}
#end_block

#method_before
@Override
public List<Disk> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, DiskRowMapper.instance);
}
#method_after
@Override
public List<Disk> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, DiskRowMapper.instance);
}
#end_block

#method_before
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = null;
    DiskStorageType diskStorageType = DiskStorageType.forValue(rs.getInt("disk_storage_type"));
    switch(diskStorageType) {
        case IMAGE:
            disk = DiskImageRowMapper.instance.mapRow(rs, rowNum);
            break;
        case LUN:
            disk = LunDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
    }
    return disk;
}
#method_after
@Override
public Disk mapRow(ResultSet rs, int rowNum) throws SQLException {
    Disk disk = null;
    DiskStorageType diskStorageType = DiskStorageType.forValue(rs.getInt("disk_storage_type"));
    switch(diskStorageType) {
        case IMAGE:
            disk = DiskImageRowMapper.instance.mapRow(rs, rowNum);
            break;
        case LUN:
            disk = LunDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
        case CINDER:
            disk = CinderDiskRowMapper.instance.mapRow(rs, rowNum);
            break;
    }
    return disk;
}
#end_block

#method_before
@Override
public List<VDS> getAllWithQuery(String query) {
    List<VDS> vdsList = jdbcTemplate.query(query, VdsRowMapper.instance);
    return uniteAgents(vdsList);
}
#method_after
@Override
public List<VDS> getAllWithQuery(String query) {
    List<VDS> vdsList = getJdbcTemplate().query(query, VdsRowMapper.instance);
    return uniteAgents(vdsList);
}
#end_block

#method_before
@Override
public List<GlusterVolumeSnapshotConfig> getAllWithQuery(String query) {
    List<GlusterVolumeSnapshotConfig> configs = jdbcTemplate.query(query, snapshotConfigRowMapper);
    return configs;
}
#method_after
@Override
public List<GlusterVolumeSnapshotConfig> getAllWithQuery(String query) {
    List<GlusterVolumeSnapshotConfig> configs = getJdbcTemplate().query(query, snapshotConfigRowMapper);
    return configs;
}
#end_block

#method_before
protected List<JsonNode> readJsonFiles(File configPath) {
    List<JsonNode> nodes = new ArrayList<JsonNode>();
    List<String> jsonFiles = getJsonFiles(configPath);
    for (String jsonFile : jsonFiles) {
        File file = new File(configPath, jsonFile);
        if (file.exists() && file.canRead()) {
            BufferedReader reader = null;
            try {
                reader = new BufferedReader(new FileReader(file.getAbsolutePath()));
                nodes.add(mapper.readTree(reader));
                log.info("Successfully read CSH mapping file '{}'", file.getAbsolutePath());
            } catch (IOException e) {
                // $NON-NLS-1$
                log.error(// $NON-NLS-1$
                "Exception parsing documentation mapping file '{}': {}", file.getAbsolutePath(), e.getMessage());
                // $NON-NLS-1$
                log.error("Exception: ", e);
            } finally {
                try {
                    reader.close();
                } catch (IOException e) {
                    // $NON-NLS-1$
                    log.error("Couldn't close CSH mapping file", e);
                }
            }
        }
    }
    return nodes;
}
#method_after
protected List<JsonNode> readJsonFiles(File configPath) {
    List<JsonNode> nodes = new ArrayList<JsonNode>();
    List<String> jsonFiles = getJsonFiles(configPath);
    for (String jsonFile : jsonFiles) {
        File file = new File(configPath, jsonFile);
        if (file.exists() && file.canRead()) {
            try (BufferedReader reader = new BufferedReader(new FileReader(file.getAbsolutePath()))) {
                nodes.add(mapper.readTree(reader));
                // $NON-NLS-1$
                log.info("Successfully read CSH mapping file '{}'", file.getAbsolutePath());
            } catch (IOException e) {
                // $NON-NLS-1$
                log.error(// $NON-NLS-1$
                "Exception parsing documentation mapping file '{}': {}", file.getAbsolutePath(), e.getMessage());
                // $NON-NLS-1$
                log.error("Exception: ", e);
            }
        }
    }
    return nodes;
}
#end_block

#method_before
protected List<String> getLocales(File manualDir) {
    List<String> locales = new ArrayList<>();
    if (!manualDir.exists() || !manualDir.canRead()) {
        // $NON-NLS-1$
        log.error("manual directory doesn't exist: " + manualDir);
        return locales;
    }
    for (File dir : manualDir.listFiles()) {
        if (dir.isDirectory() && dir.canRead()) {
            String name = dir.getName();
            // fancy locale name detection
            if (name.length() == 5 && name.indexOf("-") == 2) {
                // $NON-NLS-1$
                locales.add(name);
            }
        }
    }
    return locales;
}
#method_after
protected List<String> getLocales(File manualDir) {
    List<String> locales = new ArrayList<>();
    if (!manualDir.exists() || !manualDir.canRead()) {
        // $NON-NLS-1$
        log.info("Context-sensitive help is not installed. Manual directory doesn't exist: " + manualDir);
        return locales;
    }
    for (File dir : manualDir.listFiles()) {
        if (dir.isDirectory() && dir.canRead()) {
            String name = dir.getName();
            Matcher m = LOCALE_PATTERN.matcher(name);
            if (m.matches()) {
                locales.add(name);
            }
        }
    }
    return locales;
}
#end_block

#method_before
protected void openDocumentation(T model) {
    String helpTag = model.getHelpTag().name;
    String documentationPath = ContextSensitiveHelpManager.getPath(helpTag);
    String cshBase = model.getConfigurator().getDocsBaseUrl();
    // $NON-NLS-1$
    WebUtils.openUrlInNewWindow(// $NON-NLS-1$
    "_blank", // $NON-NLS-1$
    cshBase + documentationPath, WebUtils.OPTION_SCROLLBARS);
}
#method_after
protected void openDocumentation(T model) {
    String helpTag = model.getHelpTag().name;
    String docPath = ContextSensitiveHelpManager.getPath(helpTag);
    String docBase = model.getConfigurator().getDocsBaseUrl();
    // $NON-NLS-1$
    WebUtils.openUrlInNewWindow("_blank", docBase + docPath, WebUtils.OPTION_SCROLLBARS);
}
#end_block

#method_before
private void updateWANDisableEffects(final ISpice spice) {
    AsyncDataProvider.getInstance().getWANDisableEffects(new AsyncQuery(this, new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object target, Object returnValue) {
            spice.setWANDisableEffects((List<WANDisableEffects>) returnValue);
        }
    }));
}
#method_after
private void updateWANDisableEffects(final ISpice spice) {
    AsyncDataProvider.getInstance().getWANDisableEffects(new AsyncQuery(this, new INewAsyncCallback() {

        @SuppressWarnings("unchecked")
        @Override
        public void onSuccess(Object target, Object returnValue) {
            spice.getOptions().setWanDisableEffects((List<WanDisableEffects>) returnValue);
        }
    }));
}
#end_block

#method_before
private void updateWanColorDepthOptions(final ISpice spice) {
    AsyncDataProvider.getInstance().getWANColorDepth(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            spice.setWANColorDepth((WanColorDepth) returnValue);
        }
    }));
}
#method_after
private void updateWanColorDepthOptions(final ISpice spice) {
    AsyncDataProvider.getInstance().getWANColorDepth(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            spice.getOptions().setWanColorDepth((WanColorDepth) returnValue);
        }
    }));
}
#end_block

#method_before
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    spice.setWANDisableEffects(new ArrayList<WANDisableEffects>());
    spice.setWanOptionsEnabled(false);
}
#method_after
@Override
public void configure(ISpice spice) {
    super.configure(spice);
    spice.getOptions().setWanDisableEffects(new ArrayList<WanDisableEffects>());
    spice.getOptions().setWanOptionsEnabled(false);
}
#end_block

#method_before
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ //$NON-NLS-2$ $NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#method_after
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ //$NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#end_block

#method_before
public void configure(ISpice spice) {
    spice.setDesiredVersion(getSpiceVersion());
    spice.setCurrentVersion(getSpiceVersion());
    spice.setAdminConsole(getSpiceAdminConsole());
    spice.setFullScreen(getSpiceFullScreen());
    spice.setSpiceBaseURL(getSpiceBaseURL());
    spice.setUsbFilter(getUsbFilter());
    updateSpiceUsbAutoShare(spice);
    if (!isInitialized) {
        updateIsUsbEnabled();
        isInitialized = true;
    }
}
#method_after
public void configure(ISpice spice) {
    if (spice instanceof ISpicePlugin) {
        ((ISpicePlugin) spice).setPluginVersion(getSpiceVersion());
        ((ISpicePlugin) spice).setSpiceBaseURL(getSpiceBaseURL());
    }
    spice.getOptions().setAdminConsole(getSpiceAdminConsole());
    spice.getOptions().setFullScreen(getSpiceFullScreen());
    spice.getOptions().setUsbFilter(getUsbFilter());
    updateSpiceUsbAutoShare(spice);
}
#end_block

#method_before
private void updateSpiceUsbAutoShare(final ISpice spice) {
    AsyncDataProvider.getInstance().getSpiceUsbAutoShare(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            spice.setUsbAutoShare((Boolean) returnValue);
        }
    }));
}
#method_after
private void updateSpiceUsbAutoShare(final ISpice spice) {
    AsyncDataProvider.getInstance().getSpiceUsbAutoShare(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            spice.getOptions().setUsbAutoShare((Boolean) returnValue);
        }
    }));
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (isDiskImage()) {
        DiskImage oldDiskImage = (DiskImage) getOldDisk();
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        long diskExtendingDiff = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        if (emptyOldQuota || differentNewQuota) {
            list.add(generateQuotaConsumeParameters(newDiskImage, newDiskImage.getSizeInGigabytes()));
        } else if (diskExtendingDiff != 0) {
            list.add(generateQuotaConsumeParameters(newDiskImage, diskExtendingDiff));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getStorageIds().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    if (isDiskImage()) {
        DiskImage oldDiskImage = (DiskImage) getOldDisk();
        DiskImage newDiskImage = (DiskImage) getNewDisk();
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        long diskExtendingDiff = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        if (emptyOldQuota || differentNewQuota) {
            list.add(generateQuotaConsumeParameters(newDiskImage, newDiskImage.getSizeInGigabytes()));
        } else if (diskExtendingDiff > 0L) {
            list.add(generateQuotaConsumeParameters(newDiskImage, diskExtendingDiff));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getStorageIds().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Test
public void testExtendingDiskWithQuota() {
    Guid quotaId = Guid.newGuid();
    DiskImage oldDiskImage = createDiskImage();
    oldDiskImage.setQuotaId(quotaId);
    oldDiskImage.setSize(getBytesByGB(3));
    DiskImage newDiskImage = createDiskImage();
    newDiskImage.setQuotaId(quotaId);
    newDiskImage.setSize(getBytesByGB(5));
    UpdateVmDiskParameters parameters = new UpdateVmDiskParameters(vmId, diskImageGuid, newDiskImage);
    long diskExtendingDiffInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDiskImage);
    initializeCommand(parameters);
    QuotaStorageConsumptionParameter consumptionParameter = (QuotaStorageConsumptionParameter) command.getQuotaStorageConsumptionParameters().get(0);
    assertTrue(consumptionParameter.getRequestedStorageGB() == diskExtendingDiffInGB);
}
#method_after
@Test
public void testExtendingDiskWithQuota() {
    Guid quotaId = Guid.newGuid();
    DiskImage oldDiskImage = createDiskImage();
    oldDiskImage.setQuotaId(quotaId);
    oldDiskImage.setSize(SizeConverter.convert(3, SizeConverter.SizeUnit.GB, SizeConverter.SizeUnit.BYTES).longValue());
    DiskImage newDiskImage = createDiskImage();
    newDiskImage.setQuotaId(quotaId);
    newDiskImage.setSize(SizeConverter.convert(5, SizeConverter.SizeUnit.GB, SizeConverter.SizeUnit.BYTES).longValue());
    UpdateVmDiskParameters parameters = new UpdateVmDiskParameters(vmId, diskImageGuid, newDiskImage);
    long diskExtendingDiffInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
    when(diskDao.get(diskImageGuid)).thenReturn(oldDiskImage);
    initializeCommand(parameters);
    QuotaStorageConsumptionParameter consumptionParameter = (QuotaStorageConsumptionParameter) command.getQuotaStorageConsumptionParameters().get(0);
    assertEquals(consumptionParameter.getRequestedStorageGB().longValue(), diskExtendingDiffInGB);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("SSH Soft Fencing will not be executed on host '{}' ({}) since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (isHostPoweredOff()) {
        // do not try to soft-fence if Host is reported as Down via PM
        getReturnValue().setSucceeded(false);
    } else {
        VdsValidator validator = new VdsValidator(getVds());
        if (validator.shouldVdsBeFenced()) {
            boolean result = executeSshSoftFencingCommand(getVds().getVdsGroupCompatibilityVersion().toString());
            if (result) {
                // SSH Soft Fencing executed successfully, check if host become Up
                result = checkIfHostBecomeUp();
            }
            getReturnValue().setSucceeded(result);
        } else {
            setCommandShouldBeLogged(false);
            log.info("SSH Soft Fencing will not be executed on host '{}' ({}) since it's status is ok.", getVdsName(), getVdsId());
            getReturnValue().setSucceeded(false);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.info("SSH Soft Fencing will not be executed on host '{}' ({}) since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    if (new HostFenceActionExecutor(getVds()).isHostPoweredOff()) {
        // do not try to soft-fence if Host is reported as Down via PM
        getReturnValue().setSucceeded(false);
    } else {
        VdsValidator validator = new VdsValidator(getVds());
        if (validator.shouldVdsBeFenced()) {
            boolean result = executeSshSoftFencingCommand(getVds().getVdsGroupCompatibilityVersion().toString());
            if (result) {
                // SSH Soft Fencing executed successfully, check if host become Up
                result = checkIfHostBecomeUp();
            }
            getReturnValue().setSucceeded(result);
        } else {
            setCommandShouldBeLogged(false);
            log.info("SSH Soft Fencing will not be executed on host '{}' ({}) since it's status is ok.", getVdsName(), getVdsId());
            getReturnValue().setSucceeded(false);
        }
    }
}
#end_block

#method_before
private boolean isHealthy(FenceAgent agent, VDS host) {
    return new HostFenceActionExecutor(host).fence(FenceActionType.STATUS, agent).getStatus() == Status.SUCCESS;
}
#method_after
private boolean isHealthy(FenceAgent agent, VDS host) {
    return new HostFenceActionExecutor(host).getFenceAgentStatus(agent).getStatus() == Status.SUCCESS;
}
#end_block

#method_before
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<FenceVdsActionParameters>(new FenceVdsActionParameters(host.getId(), FenceActionType.STATUS));
        if (isHostPoweredOff(host)) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#method_after
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<FenceVdsActionParameters>(new FenceVdsActionParameters(host.getId(), FenceActionType.STATUS));
        if (new HostFenceActionExecutor(host).isHostPoweredOff()) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#end_block

#method_before
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetFenceAgentStatusParameters param = new GetFenceAgentStatusParameters();
    FenceAgent agent = new FenceAgent();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    agent.setOrder(isPrimary ? 1 : 2);
    agent.setIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    agent.setType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    agent.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    agent.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    agent.setPort(isPrimary ? getPmPrimaryPortAsInteger() : getPmSecondaryPortAsIngeter());
    agent.setOptionsMap(isPrimary ? getPmOptionsMap() : getPmSecondaryOptionsMap());
    param.setAgent(agent);
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setPmProxyPreferences(getPmProxyPreferences());
    param.setHostName(getHost().getEntity());
    param.setVdsGroupId(cluster.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceAgentStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue result = (VdcQueryReturnValue) returnValue;
            if (result.getSucceeded()) {
                setMessage(ConstantsManager.getInstance().getConstants().testSuccessful());
            } else {
                if (result.getReturnValue() == null) {
                    setMessage(ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg());
                } else {
                    setMessage(ConstantsManager.getInstance().getConstants().testFailedWithErrorMsg() + result.getReturnValue());
                }
            }
            getTestCommand().setIsExecutionAllowed(true);
        }
    }, true));
}
#method_after
public void test() {
    boolean isPrimary = isPmPrimarySelected();
    getCluster().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    validatePmModels(isPrimary);
    if (isPrimary && (!getManagementIp().getIsValid() || !getPmUserName().getIsValid() || !getPmPassword().getIsValid() || !getPmType().getIsValid() || !getPmPort().getIsValid() || !getPmOptions().getIsValid())) {
        return;
    }
    if (!isPrimary && (!getPmSecondaryIp().getIsValid() || !getPmSecondaryUserName().getIsValid() || !getPmSecondaryPassword().getIsValid() || !getPmSecondaryType().getIsValid() || !getPmSecondaryPort().getIsValid() || !getPmSecondaryOptions().getIsValid())) {
        return;
    }
    setMessage(ConstantsManager.getInstance().getConstants().testingInProgressItWillTakeFewSecondsPleaseWaitMsg());
    getTestCommand().setIsExecutionAllowed(false);
    VDSGroup cluster = getCluster().getSelectedItem();
    GetFenceAgentStatusParameters param = new GetFenceAgentStatusParameters();
    FenceAgent agent = new FenceAgent();
    if (getHostId() != null) {
        param.setVdsId(getHostId());
    }
    agent.setOrder(isPrimary ? 1 : 2);
    agent.setIp(isPrimary ? getManagementIp().getEntity() : getPmSecondaryIp().getEntity());
    agent.setType(isPrimary ? getPmType().getSelectedItem() : getPmSecondaryType().getSelectedItem());
    agent.setUser(isPrimary ? getPmUserName().getEntity() : getPmSecondaryUserName().getEntity());
    agent.setPassword(isPrimary ? getPmPassword().getEntity() : getPmSecondaryPassword().getEntity());
    agent.setPort(isPrimary ? getPmPrimaryPortAsInteger() : getPmSecondaryPortAsIngeter());
    agent.setOptionsMap(isPrimary ? getPmOptionsMap() : getPmSecondaryOptionsMap());
    param.setAgent(agent);
    param.setStoragePoolId(cluster.getStoragePoolId() != null ? cluster.getStoragePoolId() : Guid.Empty);
    param.setPmProxyPreferences(getPmProxyPreferences());
    param.setVdsName(getName().getEntity());
    param.setHostName(getHost().getEntity());
    param.setVdsGroupId(cluster.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetFenceAgentStatus, param, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnObj;
            String msg;
            if (returnValue == null) {
                msg = ConstantsManager.getInstance().getConstants().testFailedUnknownErrorMsg();
            } else {
                FenceOperationResult result = returnValue.getReturnValue();
                if (result.getStatus() == FenceOperationResult.Status.SUCCESS) {
                    msg = ConstantsManager.getInstance().getMessages().testSuccessfulWithPowerStatus(result.getPowerStatus() == PowerStatus.ON ? ConstantsManager.getInstance().getConstants().powerOn() : ConstantsManager.getInstance().getConstants().powerOff());
                } else {
                    msg = ConstantsManager.getInstance().getMessages().testFailedWithErrorMsg(result.getMessage());
                }
            }
            setMessage(msg);
            getTestCommand().setIsExecutionAllowed(true);
        }
    }, true));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    HostFenceActionExecutor executor = new HostFenceActionExecutor(getHost());
    FenceOperationResult result = executor.fence(FenceActionType.STATUS, getParameters().getAgent());
    getQueryReturnValue().setSucceeded(result.getStatus() == Status.SUCCESS);
    getQueryReturnValue().setReturnValue(result.getMessage());
}
#method_after
@Override
protected void executeQueryCommand() {
    HostFenceActionExecutor executor = new HostFenceActionExecutor(getHost());
    FenceOperationResult result = executor.getFenceAgentStatus(getParameters().getAgent());
    getQueryReturnValue().setSucceeded(result.getStatus() == Status.SUCCESS);
    getQueryReturnValue().setReturnValue(result);
}
#end_block

#method_before
private VDS getHost() {
    Guid id = getParameters().getVdsId();
    VDS vds = new VDS();
    vds.setId(id != null ? id : Guid.Empty);
    vds.setHostName(getParameters().getHostName());
    vds.setStoragePoolId(getParameters().getStoragePoolId());
    vds.setVdsGroupId(getParameters().getVdsGroupId());
    vds.setPmProxyPreferences(getParameters().getPmProxyPreferences());
    return vds;
}
#method_after
private VDS getHost() {
    Guid id = getParameters().getVdsId();
    VDS vds = new VDS();
    vds.setId(id != null ? id : Guid.Empty);
    vds.setVdsName(getParameters().getVdsName());
    vds.setHostName(getParameters().getHostName());
    vds.setVdsGroupId(getParameters().getVdsGroupId());
    vds.setStoragePoolId(getParameters().getStoragePoolId());
    vds.setPmProxyPreferences(getParameters().getPmProxyPreferences());
    return vds;
}
#end_block

#method_before
@Test
public void successfulFenceWith1stSuccess() {
    mockFenceAgents();
    // result of fence action invoked on 1st sequential agent
    mockFenceResult(agentExecutor1, new FenceOperationResult(Status.SUCCESS, HostPowerStatus.ON));
    // result of fence action invoked on 2nd sequential agent - set it to error, so we verify that it's not used
    mockFenceResult(agentExecutor2, new FenceOperationResult(Status.ERROR, HostPowerStatus.UNKNOWN));
    FenceOperationResult result = executor.fence(FenceActionType.STATUS);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.ON, result.getPowerStatus());
}
#method_after
@Test
public void successfulFenceWith1stSuccess() {
    mockFenceAgents();
    // result of fence action invoked on 1st sequential agent
    mockFenceResult(agentExecutor1, new FenceOperationResult(Status.SUCCESS, PowerStatus.ON));
    // result of fence action invoked on 2nd sequential agent - set it to error, so we verify that it's not used
    mockFenceResult(agentExecutor2, new FenceOperationResult(Status.ERROR, PowerStatus.UNKNOWN));
    FenceOperationResult result = executor.fence(FenceActionType.STATUS);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.ON, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void successfulFenceWith1stError2ndSuccess() {
    mockFenceAgents();
    // result of fence action invoked on 1st sequential agent
    mockFenceResult(agentExecutor1, new FenceOperationResult(Status.ERROR, HostPowerStatus.UNKNOWN));
    // result of fence action invoked on 2nd sequential agent
    mockFenceResult(agentExecutor2, new FenceOperationResult(Status.SUCCESS, HostPowerStatus.ON));
    FenceOperationResult result = executor.fence(FenceActionType.STATUS);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.ON, result.getPowerStatus());
}
#method_after
@Test
public void successfulFenceWith1stError2ndSuccess() {
    mockFenceAgents();
    // result of fence action invoked on 1st sequential agent
    mockFenceResult(agentExecutor1, new FenceOperationResult(Status.ERROR, PowerStatus.UNKNOWN));
    // result of fence action invoked on 2nd sequential agent
    mockFenceResult(agentExecutor2, new FenceOperationResult(Status.SUCCESS, PowerStatus.ON));
    FenceOperationResult result = executor.fence(FenceActionType.STATUS);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.ON, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void failedFenceWithAllError() {
    mockFenceAgents();
    // result of fence action invoked on 1st sequential agent
    mockFenceResult(agentExecutor1, new FenceOperationResult(Status.ERROR, HostPowerStatus.UNKNOWN));
    // result of fence action invoked on 2nd sequential agent
    mockFenceResult(agentExecutor2, new FenceOperationResult(Status.ERROR, HostPowerStatus.UNKNOWN));
    FenceOperationResult result = executor.fence(FenceActionType.STATUS);
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void failedFenceWithAllError() {
    mockFenceAgents();
    // result of fence action invoked on 1st sequential agent
    mockFenceResult(agentExecutor1, new FenceOperationResult(Status.ERROR, PowerStatus.UNKNOWN));
    // result of fence action invoked on 2nd sequential agent
    mockFenceResult(agentExecutor2, new FenceOperationResult(Status.ERROR, PowerStatus.UNKNOWN));
    FenceOperationResult result = executor.fence(FenceActionType.STATUS);
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
public FenceOperationResult fence(FenceActionType fenceAction) {
    if (fencedHost.getFenceAgents() == null || fencedHost.getFenceAgents().isEmpty()) {
        return new FenceOperationResult(Status.ERROR, HostPowerStatus.UNKNOWN, String.format("Invalid fence agents defined for host '%s'.", fencedHost.getHostName()));
    }
    return fence(fenceAction, fencedHost.getFenceAgents());
}
#method_after
public FenceOperationResult fence(FenceActionType fenceAction) {
    if (fencedHost.getFenceAgents() == null || fencedHost.getFenceAgents().isEmpty()) {
        return new FenceOperationResult(Status.ERROR, PowerStatus.UNKNOWN, String.format("Invalid fence agents defined for host '%s'.", fencedHost.getHostName()));
    }
    return fence(fenceAction, fencedHost.getFenceAgents());
}
#end_block

#method_before
@Before
public void setup() {
    mockVds();
    executor = spy(new FenceAgentExecutor(vds, new FencingPolicy()));
    doReturn(resourceManager).when(executor).getResourceManager();
    doReturn(proxyLocator).when(executor).getProxyLocator();
    doReturn(realAgent).when(executor).createRealAgent(any(FenceAgent.class), any(VDS.class));
}
#method_after
@Before
public void setup() {
    mockVds();
    executor = spy(new FenceAgentExecutor(vds, new FencingPolicy()));
    doReturn(resourceManager).when(executor).getResourceManager();
    doReturn(proxyLocator).when(executor).getProxyLocator();
    doReturn(auditLogDirector).when(executor).getAuditLogDirector();
    doReturn(realAgent).when(executor).createRealAgent(any(FenceAgent.class), any(VDS.class));
}
#end_block

#method_before
@Test
public void successfulFence() {
    FenceOperationResult fenceVdsResult = new FenceOperationResult(Status.SUCCESS);
    mockFenceVdsResult(fenceVdsResult, null);
    mockProxyHost();
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.SUCCESS, result.getStatus());
}
#method_after
@Test
public void successfulFence() {
    FenceOperationResult fenceVdsResult = new FenceOperationResult(Status.SUCCESS);
    mockFenceVdsResult(fenceVdsResult, null);
    mockProxyHost();
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.SUCCESS, result.getStatus());
    verifyAuditFenceExecutionStart(1);
}
#end_block

#method_before
@Test
public void successfulFenceWithDifferentProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.SUCCESS);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(true);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.SUCCESS, result.getStatus());
    verify(proxyLocator).findProxyHost(true, PROXY_HOST_ID);
}
#method_after
@Test
public void successfulFenceWithDifferentProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.SUCCESS);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(true);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.SUCCESS, result.getStatus());
    verifyAuditFenceExecutionStart(2);
    verifyAuditFenceExecutionFailure(1);
}
#end_block

#method_before
@Test
public void successfulFenceWithSameProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.SUCCESS);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(false);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.SUCCESS, result.getStatus());
    verify(proxyLocator).findProxyHost(true, PROXY_HOST_ID);
}
#method_after
@Test
public void successfulFenceWithSameProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.SUCCESS);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(false);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.SUCCESS, result.getStatus());
    verifyAttemptToFindDifferentProxy();
    verifyAuditFenceExecutionStart(2);
    verifyAuditFenceExecutionFailure(1);
}
#end_block

#method_before
@Test
public void failedFenceWithDifferentProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.ERROR);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(true);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.ERROR, result.getStatus());
    verify(proxyLocator).findProxyHost(true, PROXY_HOST_ID);
}
#method_after
@Test
public void failedFenceWithDifferentProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.ERROR);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(true);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.ERROR, result.getStatus());
    verifyAttemptToFindDifferentProxy();
    verifyAuditFenceExecutionFailure(2);
}
#end_block

#method_before
@Test
public void failedFenceWithSameProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.ERROR);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(false);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.ERROR, result.getStatus());
    verify(proxyLocator).findProxyHost(true, PROXY_HOST_ID);
}
#method_after
@Test
public void failedFenceWithSameProxyRetry() {
    FenceOperationResult fenceVdsResult1 = new FenceOperationResult(Status.ERROR);
    FenceOperationResult fenceVdsResult2 = new FenceOperationResult(Status.ERROR);
    mockFenceVdsResult(fenceVdsResult1, fenceVdsResult2);
    mockProxyHost(false);
    FenceOperationResult result = executor.fence(FenceActionType.START, createAgent());
    assertEquals(Status.ERROR, result.getStatus());
    verifyAttemptToFindDifferentProxy();
    verifyAuditFenceExecutionFailure(2);
}
#end_block

#method_before
public FenceOperationResult fence(FenceActionType action, FenceAgent agent) {
    FenceOperationResult result;
    VDS proxyHost = getProxyLocator().findProxyHost(isRetryEnabled(action));
    if (proxyHost == null) {
        return new FenceOperationResult(Status.ERROR, HostPowerStatus.UNKNOWN, String.format("Failed to run Power Management command on Host '%s', no proxy was found", fencedHost.getHostName()));
    }
    try {
        result = runFenceAction(action, agent, proxyHost);
        if (result.getStatus() == Status.ERROR) {
            log.warn("Fence operation failed with proxy host '{}', trying another proxy", proxyHost.getHostName());
            VDS alternativeProxy = getProxyLocator().findProxyHost(isRetryEnabled(action), proxyHost.getId());
            if (alternativeProxy != null) {
                result = runFenceAction(action, agent, alternativeProxy);
            } else {
                log.warn("Failed to find another proxy to re-run failed fence operation, " + "retrying with the same proxy '{}'", proxyHost.getHostName());
                result = runFenceAction(action, agent, proxyHost);
            }
        }
    } catch (VdcBLLException e) {
        log.debug("Exception", e);
        result = new FenceOperationResult(FenceOperationResult.Status.ERROR, HostPowerStatus.UNKNOWN, e.getMessage());
    }
    return result;
}
#method_after
public FenceOperationResult fence(FenceActionType action, FenceAgent agent) {
    FenceOperationResult result;
    VDS proxyHost = getProxyLocator().findProxyHost(isRetryEnabled(action));
    if (proxyHost == null) {
        return new FenceOperationResult(Status.ERROR, PowerStatus.UNKNOWN, String.format("Failed to run fence action on host '%s', no proxy was found", fencedHost.getHostName()));
    }
    try {
        result = executeFenceAction(action, agent, proxyHost);
        if (result.getStatus() == Status.ERROR) {
            log.warn("Fence action failed using proxy host '{}', trying another proxy", proxyHost.getHostName());
            VDS alternativeProxy = getProxyLocator().findProxyHost(isRetryEnabled(action), proxyHost.getId());
            if (alternativeProxy != null) {
                result = executeFenceAction(action, agent, alternativeProxy);
            } else {
                log.warn("Failed to find another proxy to re-run failed fence action, " + "retrying with the same proxy '{}'", proxyHost.getHostName());
                result = executeFenceAction(action, agent, proxyHost);
            }
        }
    } catch (VdcBLLException e) {
        log.debug("Exception", e);
        result = new FenceOperationResult(FenceOperationResult.Status.ERROR, PowerStatus.UNKNOWN, e.getMessage());
    }
    return result;
}
#end_block

#method_before
public HostPowerStatus getPowerStatus() {
    return powerStatus;
}
#method_after
public PowerStatus getPowerStatus() {
    return powerStatus;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(getClass().getName());
    sb.append("={status='");
    sb.append(getStatus());
    sb.append("', powerStatus='");
    sb.append(getPowerStatus());
    sb.append("', message='");
    sb.append(getMessage() == null ? "" : getMessage());
    sb.append("'}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("status", getStatus()).append("powerStatus", getPowerStatus()).append("message", getMessage()).build();
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    // ignore starting already started host or stopping already stopped host.
    if (getParameters().getAction() == FenceActionType.STATUS || !isAlreadyInRequestedStatus()) {
        _result = fenceNode(getParameters().getAction(), getParameters().getAction() != FenceActionType.STATUS);
        FenceOperationResult actionResult = new FenceOperationResult(getParameters().getAction(), _result.mStatus.mCode, _result.mStatus.mMessage, _result.power, _result.operationStatus);
        setReturnValue(actionResult);
        getVDSReturnValue().setSucceeded(actionResult.getStatus() != Status.ERROR);
        if (getParameters().getAction() == FenceActionType.STATUS && actionResult.getPowerStatus() == HostPowerStatus.UNKNOWN && !getParameters().getTargetVdsID().equals(Guid.Empty)) {
            alertPowerManagementStatusFailed(actionResult.getMessage());
        }
    } else {
        // start/stop action was skipped, host is already turned on/off
        alertActionSkippedAlreadyInStatus();
        getVDSReturnValue().setSucceeded(true);
        setReturnValue(new FenceOperationResult(Status.SKIPPED_ALREADY_IN_STATUS, HostPowerStatus.UNKNOWN));
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    // ignore starting already started host or stopping already stopped host.
    if (getParameters().getAction() == FenceActionType.STATUS || !isAlreadyInRequestedStatus()) {
        FenceStatusReturnForXmlRpc result = fenceNode(getParameters().getAction());
        FenceOperationResult actionResult = new FenceOperationResult(getParameters().getAction(), result.mStatus.mCode, result.mStatus.mMessage, result.power, result.operationStatus);
        setReturnValue(actionResult);
        getVDSReturnValue().setSucceeded(actionResult.getStatus() != Status.ERROR);
        if (getParameters().getAction() == FenceActionType.STATUS && actionResult.getPowerStatus() == PowerStatus.UNKNOWN && !getParameters().getTargetVdsID().equals(Guid.Empty)) {
            alertPowerManagementStatusFailed(actionResult.getMessage());
        }
    } else {
        // start/stop action was skipped, host is already turned on/off
        alertActionSkippedAlreadyInStatus();
        getVDSReturnValue().setSucceeded(true);
        setReturnValue(new FenceOperationResult(Status.SKIPPED_ALREADY_IN_STATUS, PowerStatus.UNKNOWN));
    }
}
#end_block

#method_before
private boolean isAlreadyInRequestedStatus() {
    _result = fenceNode(FenceActionType.STATUS, false);
    FenceOperationResult actionResult = new FenceOperationResult(FenceActionType.STATUS, _result.mStatus.mCode, _result.mStatus.mMessage, _result.power, _result.operationStatus);
    return actionResult.getStatus() == Status.SUCCESS && actionResult.getPowerStatus() == getRequestedPowerStatus(getParameters().getAction());
}
#method_after
private boolean isAlreadyInRequestedStatus() {
    FenceStatusReturnForXmlRpc result = fenceNode(FenceActionType.STATUS);
    FenceOperationResult actionResult = new FenceOperationResult(FenceActionType.STATUS, result.mStatus.mCode, result.mStatus.mMessage, result.power, result.operationStatus);
    return actionResult.getStatus() == Status.SUCCESS && actionResult.getPowerStatus() == getRequestedPowerStatus(getParameters().getAction());
}
#end_block

#method_before
protected HostPowerStatus getRequestedPowerStatus(FenceActionType fenceAction) {
    return fenceAction == FenceActionType.START ? HostPowerStatus.ON : HostPowerStatus.OFF;
}
#method_after
protected PowerStatus getRequestedPowerStatus(FenceActionType fenceAction) {
    return fenceAction == FenceActionType.START ? PowerStatus.ON : PowerStatus.OFF;
}
#end_block

#method_before
protected FenceStatusReturnForXmlRpc fenceNode(FenceActionType fenceAction, boolean applyFencingPolicy) {
    return getBroker().fenceNode(getParameters().getFenceAgent().getIp(), getParameters().getFenceAgent().getPort() == null ? "" : getParameters().getFenceAgent().getPort().toString(), getParameters().getFenceAgent().getType(), getParameters().getFenceAgent().getUser(), getParameters().getFenceAgent().getPassword(), fenceAction.getValue(), "", getParameters().getFenceAgent().getOptions(), applyFencingPolicy ? getParameters().getFencingPolicyParams() : null);
}
#method_after
protected FenceStatusReturnForXmlRpc fenceNode(FenceActionType fenceAction) {
    FenceAgent agent = getParameters().getFenceAgent();
    return getBroker().fenceNode(agent.getIp(), agent.getPort() == null ? "" : agent.getPort().toString(), agent.getType(), agent.getUser(), agent.getPassword(), fenceAction.getValue(), "", agent.getOptions(), getParameters().getAction() != FenceActionType.STATUS ? getParameters().getFencingPolicyParams() : null);
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return _result.mStatus != null ? _result.mStatus : new StatusForXmlRpc();
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    StatusForXmlRpc status = new StatusForXmlRpc();
    FenceOperationResult result = (FenceOperationResult) getReturnValue();
    if (result == null) {
        // unexpected error happened
        status.mCode = 1;
        status.mMessage = "";
    } else {
        // status result from action result
        status.mCode = result.getStatus() == Status.ERROR ? 1 : 0;
        status.mMessage = result.getMessage();
    }
    return status;
}
#end_block

#method_before
@Test
public void successfulStatusOn() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STATUS, 0, null, "on", null);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.ON, result.getPowerStatus());
}
#method_after
@Test
public void successfulStatusOn() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STATUS, 0, null, "on", null);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.ON, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void successfulStatusOff() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STATUS, 0, null, "off", null);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.OFF, result.getPowerStatus());
}
#method_after
@Test
public void successfulStatusOff() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STATUS, 0, null, "off", null);
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.OFF, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void failedStatus() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STATUS, 1, null, "unknown", null);
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void failedStatus() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STATUS, 1, null, "unknown", null);
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void successfulStop() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STOP, 0, null, null, "initiated");
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void successfulStop() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STOP, 0, null, null, "initiated");
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void failedStop() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STOP, 1, null, null, "initiated");
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void failedStop() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STOP, 1, null, null, "initiated");
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void skippedDueToPolicyStop() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STOP, 0, null, null, "skipped");
    assertEquals(Status.SKIPPED_DUE_TO_POLICY, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void skippedDueToPolicyStop() {
    FenceOperationResult result = new FenceOperationResult(FenceActionType.STOP, 0, null, null, "skipped");
    assertEquals(Status.SKIPPED_DUE_TO_POLICY, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void successfulGetStatus() {
    String agentMessage = "Test succeeded: on";
    setupCommand(setupCommandParams(FenceActionType.STATUS));
    setupBrokerResult(createBrokerResultMap(0, agentMessage, "on", null));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.ON, result.getPowerStatus());
    assertEquals(agentMessage, result.getMessage());
}
#method_after
@Test
public void successfulGetStatus() {
    String agentMessage = "Test succeeded: on";
    setupCommand(setupCommandParams(FenceActionType.STATUS));
    setupBrokerResult(createBrokerResultMap(0, agentMessage, "on", null));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.ON, result.getPowerStatus());
    assertEquals(agentMessage, result.getMessage());
}
#end_block

#method_before
@Test
public void failedGetStatus() {
    String agentMessage = "Test failed, status unknown";
    setupCommand(setupCommandParams(FenceActionType.STATUS));
    setupBrokerResult(createBrokerResultMap(1, agentMessage, "unknown", null));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
    assertEquals(agentMessage, result.getMessage());
}
#method_after
@Test
public void failedGetStatus() {
    String agentMessage = "Test failed, status unknown";
    setupCommand(setupCommandParams(FenceActionType.STATUS));
    setupBrokerResult(createBrokerResultMap(1, agentMessage, "unknown", null));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.ERROR, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
    assertEquals(agentMessage, result.getMessage());
}
#end_block

#method_before
@Test
public void stopHostWhichIsPoweredDown() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(0, "", "off", null));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SKIPPED_ALREADY_IN_STATUS, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void stopHostWhichIsPoweredDown() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(0, "", "off", null));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SKIPPED_ALREADY_IN_STATUS, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void stopHostWhichIsPoweredUp() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(0, "", "on", null), // result of actual STOP action
    createBrokerResultMap(0, "", "unknown", "initiated"));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void stopHostWhichIsPoweredUp() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(0, "", "on", null), // result of actual STOP action
    createBrokerResultMap(0, "", "unknown", "initiated"));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void stopHostWithUnknownPowerStatus() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(1, "", "unknown", null), // result of actual STOP action
    createBrokerResultMap(0, "", "unknown", "initiated"));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void stopHostWithUnknownPowerStatus() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(1, "", "unknown", null), // result of actual STOP action
    createBrokerResultMap(0, "", "unknown", "initiated"));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SUCCESS, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Test
public void stopHostSkippedDueToFencingPolicy() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(0, "", "on", null), // result of actual STOP action
    createBrokerResultMap(0, "", "unknown", "skipped"));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SKIPPED_DUE_TO_POLICY, result.getStatus());
    assertEquals(HostPowerStatus.UNKNOWN, result.getPowerStatus());
}
#method_after
@Test
public void stopHostSkippedDueToFencingPolicy() {
    setupCommand(setupCommandParams(FenceActionType.STOP));
    setupBrokerResult(// result of STATUS action executed prior to STOP action
    createBrokerResultMap(0, "", "on", null), // result of actual STOP action
    createBrokerResultMap(0, "", "unknown", "skipped"));
    command.execute();
    FenceOperationResult result = (FenceOperationResult) command.getVDSReturnValue().getReturnValue();
    assertEquals(Status.SKIPPED_DUE_TO_POLICY, result.getStatus());
    assertEquals(PowerStatus.UNKNOWN, result.getPowerStatus());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    // ignore starting already started host or stopping already stopped host.
    if (getParameters().getAction() == FenceActionType.STATUS || !isAlreadyInRequestedStatus()) {
        _result = fenceNode(getParameters().getAction(), getParameters().getAction() != FenceActionType.STATUS);
        getVDSReturnValue().setSucceeded(false);
        if (getParameters().getAction() == FenceActionType.STATUS && _result.power != null) {
            String stat = _result.power.toLowerCase();
            String msg = _result.mStatus.mMessage;
            if ("on".equals(stat) || "off".equals(stat)) {
                getVDSReturnValue().setSucceeded(true);
            } else {
                if (!getParameters().getTargetVdsID().equals(Guid.Empty)) {
                    alertPowerManagementStatusFailed(msg);
                }
            }
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(stat, msg);
            setReturnValue(fenceStatusReturnValue);
        } else {
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(_result.operationStatus, _result.mStatus.mMessage != null ? _result.mStatus.mMessage : "");
            setReturnValue(fenceStatusReturnValue);
            getVDSReturnValue().setSucceeded(_result.mStatus.mCode == 0);
        }
    } else {
        // start/stop action was skipped, host is already turned on/off
        alertActionSkippedAlreadyInStatus();
        getVDSReturnValue().setSucceeded(true);
        setReturnValue(new FenceStatusReturnValue(FenceStatusReturnValue.SKIPPED_DUE_TO_STATUS, ""));
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    // ignore starting already started host or stopping already stopped host.
    if (getParameters().getAction() == FenceActionType.STATUS || !isAlreadyInRequestedStatus()) {
        _result = fenceNode(getParameters().getAction());
        getVDSReturnValue().setSucceeded(false);
        if (getParameters().getAction() == FenceActionType.STATUS && _result.power != null) {
            String stat = _result.power.toLowerCase();
            String msg = _result.mStatus.mMessage;
            if ("on".equals(stat) || "off".equals(stat)) {
                getVDSReturnValue().setSucceeded(true);
            } else {
                if (!getParameters().getTargetVdsID().equals(Guid.Empty)) {
                    alertPowerManagementStatusFailed(msg);
                }
            }
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(stat, msg);
            setReturnValue(fenceStatusReturnValue);
        } else {
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(_result.operationStatus, _result.mStatus.mMessage != null ? _result.mStatus.mMessage : "");
            setReturnValue(fenceStatusReturnValue);
            getVDSReturnValue().setSucceeded(_result.mStatus.mCode == 0);
        }
    } else {
        // start/stop action was skipped, host is already turned on/off
        alertActionSkippedAlreadyInStatus();
        getVDSReturnValue().setSucceeded(true);
        setReturnValue(new FenceStatusReturnValue(FenceStatusReturnValue.SKIPPED_DUE_TO_STATUS, ""));
    }
}
#end_block

#method_before
protected void alertPowerManagementStatusFailed(String reason) {
    AuditLogableBase alert = new AuditLogableBase();
    alert.setVdsId(getParameters().getTargetVdsID());
    alert.addCustomValue("Reason", reason);
    AlertDirector.Alert(alert, AuditLogType.VDS_ALERT_FENCE_TEST_FAILED);
}
#method_after
protected void alertPowerManagementStatusFailed(String reason) {
    AuditLogableBase alert = new AuditLogableBase();
    alert.setVdsId(getParameters().getTargetVdsID());
    alert.addCustomValue("Reason", reason);
    auditLogDirector.log(alert, AuditLogType.VDS_ALERT_FENCE_TEST_FAILED);
}
#end_block

#method_before
protected void alertActionSkippedAlreadyInStatus() {
    AuditLogableBase auditLogable = new AuditLogableBase();
    auditLogable.addCustomValue("HostName", getTargetVds().getName());
    auditLogable.addCustomValue("AgentStatus", getParameters().getAction().getValue());
    auditLogable.addCustomValue("Operation", getParameters().getAction().toString());
    AuditLogDirector.log(auditLogable, AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS);
}
#method_after
protected void alertActionSkippedAlreadyInStatus() {
    AuditLogableBase auditLogable = new AuditLogableBase();
    auditLogable.addCustomValue("HostName", getTargetVds().getName());
    auditLogable.addCustomValue("AgentStatus", getParameters().getAction().getValue());
    auditLogable.addCustomValue("Operation", getParameters().getAction().toString());
    auditLogDirector.log(auditLogable, AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS);
}
#end_block

#method_before
private boolean isAlreadyInRequestedStatus() {
    boolean ret = false;
    FenceActionType action = getParameters().getAction();
    _result = fenceNode(FenceActionType.STATUS, false);
    if (_result.power != null) {
        String powerStatus = _result.power.toLowerCase();
        if ((action == FenceActionType.START && powerStatus.equals("on")) || action == FenceActionType.STOP && powerStatus.equals("off"))
            ret = true;
    }
    return ret;
}
#method_after
private boolean isAlreadyInRequestedStatus() {
    boolean ret = false;
    FenceActionType action = getParameters().getAction();
    _result = fenceNode(FenceActionType.STATUS);
    if (_result.power != null) {
        String powerStatus = _result.power.toLowerCase();
        if ((action == FenceActionType.START && powerStatus.equals("on")) || action == FenceActionType.STOP && powerStatus.equals("off"))
            ret = true;
    }
    return ret;
}
#end_block

#method_before
protected FenceStatusReturnForXmlRpc fenceNode(FenceActionType actionType, boolean applyFencingPolicy) {
    return getBroker().fenceNode(getParameters().getFenceAgent().getIp(), getParameters().getFenceAgent().getPort() == null ? "" : getParameters().getFenceAgent().getPort().toString(), getParameters().getFenceAgent().getType(), getParameters().getFenceAgent().getUser(), getParameters().getFenceAgent().getPassword(), actionType.getValue(), "", getVdsFenceOptions(getParameters().getFenceAgent().getType(), getParameters().getFenceAgent().getOptions(), getProxyVds().getVdsGroupCompatibilityVersion().toString()), applyFencingPolicy ? convertFencingPolicy() : null);
}
#method_after
protected FenceStatusReturnForXmlRpc fenceNode(FenceActionType fenceAction) {
    FenceAgent agent = getParameters().getFenceAgent();
    return getBroker().fenceNode(agent.getIp(), agent.getPort() == null ? "" : agent.getPort().toString(), agent.getType(), agent.getUser(), agent.getPassword(), fenceAction.getValue(), "", getVdsFenceOptions(agent.getType(), agent.getOptions(), getProxyVds().getVdsGroupCompatibilityVersion().toString()), getParameters().getAction() != FenceActionType.STATUS ? convertFencingPolicy() : null);
}
#end_block

#method_before
public VDSFenceReturnValue fence(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    VDSReturnValue result = null;
    try {
        if (action == FenceActionType.RESTART || action == FenceActionType.STOP) {
            stopSPM(action);
        }
        result = runFenceAction(action, agent, proxyHost);
        // if fence failed, retry with another proxy.
        if (!result.getSucceeded()) {
            log.warn("Fence operation failed with proxy host {}, trying another proxy...", proxyHost.getId());
            boolean withRetries = action != FenceActionType.STATUS;
            VDS alternativeProxy = proxyLocator.findProxyHost(withRetries, proxyHost.getId());
            if (alternativeProxy != null) {
                result = runFenceAction(action, agent, alternativeProxy);
            } else {
                log.warn("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                AuditLogDirector.log(getAuditParams(action, agent, proxyHost), AuditLogType.FENCE_OPERATION_FAILED_USING_PROXY);
                result = runFenceAction(action, agent, proxyHost);
            }
        }
    } catch (VdcBLLException e) {
        result = new VDSReturnValue();
        result.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        result.setExceptionString(e.getMessage());
        result.setSucceeded(false);
    }
    VDSFenceReturnValue returnVal = new VDSFenceReturnValue(result);
    returnVal.setFenceAgentUsed(agent);
    // skipping due to policy
    returnVal.setSucceeded(result.getSucceeded() || returnVal.isSkippedDueToPolicy());
    return returnVal;
}
#method_after
public VDSFenceReturnValue fence(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    VDSReturnValue result = null;
    try {
        if (action == FenceActionType.RESTART || action == FenceActionType.STOP) {
            stopSPM(action);
        }
        result = runFenceAction(action, agent, proxyHost);
        // if fence failed, retry with another proxy.
        if (!result.getSucceeded()) {
            log.warn("Fence operation failed with proxy host {}, trying another proxy...", proxyHost.getId());
            boolean withRetries = action != FenceActionType.STATUS;
            VDS alternativeProxy = proxyLocator.findProxyHost(withRetries, proxyHost.getId());
            if (alternativeProxy != null) {
                result = runFenceAction(action, agent, alternativeProxy);
            } else {
                log.warn("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                new AuditLogDirector().log(getAuditParams(action, agent, proxyHost), AuditLogType.FENCE_OPERATION_FAILED_USING_PROXY);
                result = runFenceAction(action, agent, proxyHost);
            }
        }
    } catch (VdcBLLException e) {
        result = new VDSReturnValue();
        result.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        result.setExceptionString(e.getMessage());
        result.setSucceeded(false);
    }
    VDSFenceReturnValue returnVal = new VDSFenceReturnValue(result);
    returnVal.setFenceAgentUsed(agent);
    // skipping due to policy
    returnVal.setSucceeded(result.getSucceeded() || returnVal.isSkippedDueToPolicy());
    return returnVal;
}
#end_block

#method_before
private VDSReturnValue runFenceAction(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    auditFenceAction(action, agent, proxyHost);
    return getBackend().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHost.getId(), _vds.getId(), agent, action, fencingPolicy));
}
#method_after
private VDSReturnValue runFenceAction(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    auditFenceAction(action, agent, proxyHost);
    FenceAgent realAgent = new FenceAgent(agent);
    realAgent.setType(VdsFenceOptions.getRealAgent(agent.getType()));
    realAgent.setOptions(getOptions(agent));
    return getBackend().getResourceManager().RunVdsCommand(VDSCommandType.FenceVds, new FenceVdsVDSCommandParameters(proxyHost.getId(), _vds.getId(), realAgent, action, fencingPolicy));
}
#end_block

#method_before
private void auditFenceAction(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    log.info("Executing <{}> Power Management command, Proxy Host:{}, " + "Agent:{}, Agent Type:{}, Target Host:{}, Management IP:{}, User:{}, Options:{}, Fencing policy:{}", action, getNameOrId(proxyHost), agent.getId(), VdsFenceOptions.getRealAgent(agent.getType()), getNameOrId(_vds), agent.getIp(), agent.getUser(), getOptions(agent), fencingPolicy);
    AuditLogableBase logable = getAuditParams(action, agent, proxyHost);
    AuditLogDirector.log(logable, AuditLogType.FENCE_USING_AGENT_AND_PROXY_HOST);
}
#method_after
private void auditFenceAction(FenceActionType action, FenceAgent agent, VDS proxyHost) {
    log.info("Executing <{}> Power Management command: Proxy Host:{}, Target Host:{}, Agent:{}, Fencing policy:{}", action, getNameOrId(proxyHost), getNameOrId(_vds), agent, fencingPolicy);
    AuditLogableBase logable = getAuditParams(action, agent, proxyHost);
    new AuditLogDirector().log(logable, AuditLogType.FENCE_USING_AGENT_AND_PROXY_HOST);
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("%s, targetVdsId = %s, action = %s, ip = %s, port = %s, type = %s, user = %s, " + "password = ***, options = '%s', policy = '%s'", super.toString(), getTargetVdsID(), getAction(), getFenceAgent().getIp(), getFenceAgent().getPort(), getFenceAgent().getType(), getFenceAgent().getUser(), getFenceAgent().getOptions(), getFencingPolicy());
}
#method_after
@Override
public String toString() {
    return String.format("%s, targetVdsId = %s, action = %s, agent = '%s', policy = '%s'", super.toString(), getTargetVdsID(), getAction(), getFenceAgent(), getFencingPolicy());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    // ignore starting already started host or stopping already stopped host.
    if (getParameters().getAction() == FenceActionType.STATUS || !isAlreadyInRequestedStatus()) {
        _result = fenceNode(getParameters().getAction(), getParameters().getAction() != FenceActionType.STATUS);
        getVDSReturnValue().setSucceeded(false);
        if (getParameters().getAction() == FenceActionType.STATUS && _result.power != null) {
            String stat = _result.power.toLowerCase();
            String msg = _result.mStatus.mMessage;
            if ("on".equals(stat) || "off".equals(stat)) {
                getVDSReturnValue().setSucceeded(true);
            } else {
                if (!getParameters().getTargetVdsID().equals(Guid.Empty)) {
                    alertPowerManagementStatusFailed(msg);
                }
            }
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(stat, msg);
            setReturnValue(fenceStatusReturnValue);
        } else {
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(_result.operationStatus, _result.mStatus.mMessage != null ? _result.mStatus.mMessage : "");
            setReturnValue(fenceStatusReturnValue);
            getVDSReturnValue().setSucceeded(_result.mStatus.mCode == 0);
        }
    } else {
        // start/stop action was skipped, host is already turned on/off
        alertActionSkippedAlreadyInStatus();
        getVDSReturnValue().setSucceeded(true);
        setReturnValue(new FenceStatusReturnValue(FenceStatusReturnValue.SKIPPED_DUE_TO_STATUS, ""));
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    // ignore starting already started host or stopping already stopped host.
    if (getParameters().getAction() == FenceActionType.STATUS || !isAlreadyInRequestedStatus()) {
        _result = fenceNode(getParameters().getAction());
        getVDSReturnValue().setSucceeded(false);
        if (getParameters().getAction() == FenceActionType.STATUS && _result.power != null) {
            String stat = _result.power.toLowerCase();
            String msg = _result.mStatus.mMessage;
            if ("on".equals(stat) || "off".equals(stat)) {
                getVDSReturnValue().setSucceeded(true);
            } else {
                if (!getParameters().getTargetVdsID().equals(Guid.Empty)) {
                    alertPowerManagementStatusFailed(msg);
                }
            }
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(stat, msg);
            setReturnValue(fenceStatusReturnValue);
        } else {
            FenceStatusReturnValue fenceStatusReturnValue = new FenceStatusReturnValue(_result.operationStatus, _result.mStatus.mMessage != null ? _result.mStatus.mMessage : "");
            setReturnValue(fenceStatusReturnValue);
            getVDSReturnValue().setSucceeded(_result.mStatus.mCode == 0);
        }
    } else {
        // start/stop action was skipped, host is already turned on/off
        alertActionSkippedAlreadyInStatus();
        getVDSReturnValue().setSucceeded(true);
        setReturnValue(new FenceStatusReturnValue(FenceStatusReturnValue.SKIPPED_DUE_TO_STATUS, ""));
    }
}
#end_block

#method_before
private boolean isAlreadyInRequestedStatus() {
    boolean ret = false;
    FenceActionType action = getParameters().getAction();
    _result = fenceNode(FenceActionType.STATUS, false);
    if (_result.power != null) {
        String powerStatus = _result.power.toLowerCase();
        if ((action == FenceActionType.START && powerStatus.equals("on")) || action == FenceActionType.STOP && powerStatus.equals("off"))
            ret = true;
    }
    return ret;
}
#method_after
private boolean isAlreadyInRequestedStatus() {
    boolean ret = false;
    FenceActionType action = getParameters().getAction();
    _result = fenceNode(FenceActionType.STATUS);
    if (_result.power != null) {
        String powerStatus = _result.power.toLowerCase();
        if ((action == FenceActionType.START && powerStatus.equals("on")) || action == FenceActionType.STOP && powerStatus.equals("off"))
            ret = true;
    }
    return ret;
}
#end_block

#method_before
protected FenceStatusReturnForXmlRpc fenceNode(FenceActionType actionType, boolean applyFencingPolicy) {
    return getBroker().fenceNode(getParameters().getIp(), getParameters().getPort() == null ? "" : getParameters().getPort(), getParameters().getType(), getParameters().getUser(), getParameters().getPassword(), actionType.getValue(), "", getVdsFenceOptions(getParameters().getType(), getParameters().getOptions(), getProxyVds().getVdsGroupCompatibilityVersion().toString()), applyFencingPolicy ? convertFencingPolicy() : null);
}
#method_after
protected FenceStatusReturnForXmlRpc fenceNode(FenceActionType fenceAction) {
    return getBroker().fenceNode(getParameters().getIp(), getParameters().getPort() == null ? "" : getParameters().getPort(), getParameters().getType(), getParameters().getUser(), getParameters().getPassword(), fenceAction.getValue(), "", getVdsFenceOptions(getParameters().getType(), getParameters().getOptions(), getProxyVds().getVdsGroupCompatibilityVersion().toString()), getParameters().getAction() != FenceActionType.STATUS ? convertFencingPolicy() : null);
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(getClass().getName());
    sb.append("={id='");
    sb.append(getId());
    sb.append("', hostId='");
    sb.append(getHostId());
    sb.append("', order='");
    sb.append(getOrder());
    sb.append("', type='");
    sb.append(getType());
    sb.append("', ip='");
    sb.append(getIp());
    sb.append("', port='");
    sb.append(getPort());
    sb.append("', user='");
    sb.append(getUser());
    sb.append("', password='");
    sb.append(getPassword() == null || getPassword().length() < 1 ? "" : "***");
    sb.append("', encryptOptions='");
    sb.append(getEncryptOptions());
    sb.append("', options='");
    sb.append(getOptions());
    sb.append("'}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("hostId", getHostId()).append("order", getOrder()).append("type", getType()).append("ip", getIp()).append("port", getPort()).append("user", getUser()).appendFiltered("password", getPassword()).append("encryptOptions", getEncryptOptions()).append("options", getOptions()).build();
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder(getClass().getName());
    sb.append("={id='");
    sb.append(getId());
    sb.append("', hostId='");
    sb.append(getHostId());
    sb.append("', order='");
    sb.append(getOrder());
    sb.append("', type='");
    sb.append(getType());
    sb.append("', ip='");
    sb.append(getIp());
    sb.append("', port='");
    sb.append(getPort());
    sb.append("', user='");
    sb.append(getUser());
    sb.append("', password='");
    sb.append(getPassword() == null || getPassword().length() < 1 ? "" : "***");
    sb.append("', encryptOptions='");
    sb.append(getEncryptOptions());
    sb.append("', options='");
    sb.append(getOptions());
    sb.append("'}");
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", getId()).append("hostId", getHostId()).append("order", getOrder()).append("type", getType()).append("ip", getIp()).append("port", getPort()).append("user", getUser()).appendFiltered("password", getPassword()).append("encryptOptions", getEncryptOptions()).append("options", getOptions()).build();
}
#end_block

#method_before
private void logEventForUser(String userName, AuditLogType auditLogType) {
    AuditLogableBase msg = new AuditLogableBase();
    msg.setUserName(userName);
    AuditLogDirector.log(msg, auditLogType);
}
#method_after
private void logEventForUser(String userName, AuditLogType auditLogType) {
    AuditLogableBase msg = new AuditLogableBase();
    msg.setUserName(userName);
    auditLogDirector.log(msg, auditLogType);
}
#end_block

#method_before
protected void logAutheticationFailure() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setUserName(getUserName());
    AuditLogDirector.log(logable, AuditLogType.USER_VDC_LOGIN_FAILED);
}
#method_after
protected void logAutheticationFailure() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.setUserName(getUserName());
    auditLogDirector.log(logable, AuditLogType.USER_VDC_LOGIN_FAILED);
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(UserPortalLoginModel loginModel) {
    AsyncDataProvider.getInstance().getPermissionsByAdElementId(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Permissions> permissions = (ArrayList<Permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (Permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveryoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveryoneVnicProfileUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveryoneVnicProfileUserPermission(Permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.vnicProfileUser.asGuid());
        }

        private boolean isEveryoneUserPortalBasedVmPermission(Permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(Permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(UserPortalLoginModel loginModel) {
    AsyncDataProvider.getInstance().getPermissionsByAdElementId(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<Permission> permissions = (ArrayList<Permission>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (Permission permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveryoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveryoneVnicProfileUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getRoleId())) {
                    roleIdList.add(permission.getRoleId());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveryoneVnicProfileUserPermission(Permission permission) {
            return permission.getAdElementId().equals(ApplicationGuids.everyone.asGuid()) && permission.getRoleId().equals(ApplicationGuids.vnicProfileUser.asGuid());
        }

        private boolean isEveryoneUserPortalBasedVmPermission(Permission permission) {
            return permission.getAdElementId().equals(ApplicationGuids.everyone.asGuid()) && permission.getRoleId().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(Permission permission) {
            return permission.getAdElementId().equals(ApplicationGuids.everyone.asGuid()) && permission.getRoleId().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#end_block

#method_before
public void clearErrorMessages() {
    errorMessagePanel.clear();
    errorMessagePanel.setVisible(false);
}
#method_after
public void clearErrorMessages() {
    IsWidget errorIconWidget = errorMessagePanel.getWidget(0);
    errorMessagePanel.clear();
    errorMessagePanel.add(errorIconWidget);
    errorMessagePanel.setVisible(false);
}
#end_block

#method_before
public void perform() {
    try {
        refreshExistingVmJobList();
        refreshVmStats();
        afterVMsRefreshTreatment();
        vdsManager.vmsMonitotingInitFinished();
    } finally {
        unlockVmsManager();
    }
}
#method_after
public void perform() {
    try {
        refreshExistingVmJobList();
        refreshVmStats();
        afterVMsRefreshTreatment();
        vdsManager.vmsMonitoringInitFinished();
    } finally {
        unlockVmsManager();
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {id=").append(getId()).append(", vdsId=").append(getVdsId()).append(", macAddress=").append(getMacAddress()).append(", networkName=").append(getNetworkName()).append(", baseInterface=").append(getBaseInterface()).append(", vlanId=").append(getVlanId()).append(", bonded=").append(getBonded()).append(", bondName=").append(getBondName()).append(", bondOptions=").append(getBondOptions()).append(", bootProtocol=").append(getBootProtocol()).append(", address=").append(getAddress()).append(", subnet=").append(getSubnet()).append(", gateway=").append(getGateway()).append(", mtu=").append(getMtu()).append(", bridged=").append(isBridged()).append(", speed=").append(getSpeed()).append(", type=").append(getType()).append(", networkImplementationDetails=").append(getNetworkImplementationDetails()).append(", qos=").append(getQos()).append(" qosOverridden=").append(isQosOverridden()).append(", labels=").append(getLabels()).append(", customProperties=").append(getCustomProperties()).append("}");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(getName()).append(" {");
    Map<String, Object> attributes = constructStringAttributes();
    if (attributes != null && !attributes.isEmpty()) {
        Iterator<Entry<String, Object>> i = attributes.entrySet().iterator();
        appendEntry(builder, i.next());
        while (i.hasNext()) {
            builder.append(", ");
            appendEntry(builder, i.next());
        }
    }
    builder.append("}");
    return builder.toString();
}
#end_block

#method_before
@Override
public boolean isValid(String mask, ConstraintValidatorContext context) {
    if (mask.isEmpty()) {
        return true;
    }
    boolean isMaskFormatValid = isMaskFormatValid(mask);
    AConstraint.AConstraintArgsFormatValue args = new AConstraint.AConstraintArgsFormatValue(isMaskFormatValid, isMaskFormatValid ? isMaskValid(mask) : false, VdcBllMessages.UPDATE_NETWORK_ADDR_IN_SUBNET_BAD_FORMAT.name(), VdcBllMessages.UPDATE_NETWORK_ADDR_IN_SUBNET_BAD_VALUE.name());
    // $NON-NLS-1$
    return AConstraint.getInstance().isValid(args, context, "mask");
}
#method_after
@Override
public boolean isValid(String mask, ConstraintValidatorContext context) {
    if (mask == null || mask.isEmpty()) {
        return true;
    }
    boolean maskFormatValidation = isMaskFormatValid(mask);
    ValidatorConstraintArgsFormatValue args = new ValidatorConstraintArgsFormatValue(maskFormatValidation, maskFormatValidation ? isMaskValid(mask) : false, VdcBllMessages.UPDATE_NETWORK_ADDR_IN_SUBNET_BAD_FORMAT.name(), VdcBllMessages.UPDATE_NETWORK_ADDR_IN_SUBNET_BAD_VALUE.name());
    // $NON-NLS-1$
    return ValidatorConstraint.getInstance().isValid(args, context, "mask");
}
#end_block

#method_before
protected String getSubnetBadFormatMessage() {
    return ConstantsManager.getInstance().getConstants().thisFieldMustContainSubnetFormatAsNetmaskOrPrefixMsg();
}
#method_after
protected String getSubnetBadFormatMessage() {
    return isPrefixAllowed ? getBadPrefixOrNetmaskFormatMessage() : getBadNetmaskFormatMessage();
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    // This validation must be applied to a String
    assert value == null || value instanceof String;
    String mask = (String) value;
    ValidationResult result = new ValidationResult();
    if (!MaskValidator.getInstance().isMaskFormatValid(mask)) {
        return failWith(result, getSubnetBadFormatMessage());
    } else if (!MaskValidator.getInstance().isMaskValid(mask)) {
        return failWith(result, getInvalidNetmaskMessage());
    }
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    // $NON-NLS-1$
    assert value == null || value instanceof String : "This validation must be run on a String!";
    String mask = (String) value;
    if (getMaskValidator().isValidNetmaskFormat(mask)) {
        if (!getMaskValidator().isNetmaskValid(mask)) {
            return failWith(getInvalidMask());
        }
    } else {
        if (isPrefixAllowed) {
            if (!getMaskValidator().isPrefixValid(mask)) {
                return failWith(getBadPrefixOrNetmaskFormatMessage());
            }
        } else {
            return failWith(getBadNetmaskFormatMessage());
        }
    }
    return new ValidationResult();
}
#end_block

#method_before
private ValidationResult failWith(ValidationResult result, String errorMessage) {
    result.setSuccess(false);
    result.setReasons(Arrays.asList(errorMessage));
    return result;
}
#method_after
private ValidationResult failWith(String errorMessage) {
    return new ValidationResult(false, Arrays.asList(errorMessage));
}
#end_block

#method_before
@Test
public void checkValidMask() {
    // $NON-NLS-1$
    assertEquals("Failed to validate mask: " + mask, isValidMask, validation.validate(mask).getSuccess());
}
#method_after
@Test
public void checkValidMask() {
    SubnetMaskValidation underTest = createUnderTest(isPrefixAllowed);
    // $NON-NLS-1$
    assertEquals("Failed to validate mask: " + mask, isMaskValid, underTest.validate(mask).getSuccess());
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return Arrays.asList(new Object[][] { // $NON-NLS-1$
    { null, false }, // $NON-NLS-1$
    { "a.a.a.a", false }, // $NON-NLS-1$
    { "255.255.0", false }, // $NON-NLS-1$
    { "255.255.0.0.0", false }, // $NON-NLS-1$
    { "255.255.0.0.", false }, // $NON-NLS-1$
    { "255.255.0.1", false }, // $NON-NLS-1$
    { "255.0.255.0", false }, // $NON-NLS-1$
    { "255.0.0.255", false }, // $NON-NLS-1$
    { "224.0.255.0", false }, // $NON-NLS-1$
    { "255.255.0.0", true }, // $NON-NLS-1$
    { "255.255.255.255", true }, // $NON-NLS-1$
    { "31 ", false }, // $NON-NLS-1$
    { "33", false }, // $NON-NLS-1$
    { "31/", false }, // $NON-NLS-1$
    { "31*", false }, // $NON-NLS-1$
    { "//31 ", false }, // $NON-NLS-1$
    { "31", true } });
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return Arrays.asList(new Object[][] { // $NON-NLS-1$
    { null, false, true }, // $NON-NLS-1$
    { "", false, true }, // $NON-NLS-1$
    { "a.a.a.a", false, true }, // $NON-NLS-1$
    { "255.255.0", false, true }, // $NON-NLS-1$
    { "255.255.0.0.0", false, true }, // $NON-NLS-1$
    { "255.255.0.0.", false, true }, // $NON-NLS-1$ /* note extra space */
    { "31 ", false, true }, // $NON-NLS-1$ /* note extra space */
    { "31 ", false, false }, // $NON-NLS-1$ /*note extra space*/
    { "/31 ", false, true }, // $NON-NLS-1$
    { "31/", false, true }, // $NON-NLS-1$
    { "31*", false, true }, // $NON-NLS-1$
    { "//31 ", false, true }, // $NON-NLS-1$
    { "33", false, true }, // $NON-NLS-1$
    { "33", false, false }, // $NON-NLS-1$
    { "/33", false, true }, // $NON-NLS-1$
    { "01", false, true }, // $NON-NLS-1$
    { "01/", false, true }, // $NON-NLS-1$
    { "255.255.0.1", false, true }, // $NON-NLS-1$
    { "255.255.0.1", false, false }, // $NON-NLS-1$
    { "255.0.255.0", false, true }, // $NON-NLS-1$
    { "224.0.255.0", false, true }, // $NON-NLS-1$
    { "255.0.0.255", false, true }, // $NON-NLS-1$
    { "255.255.0.0", true, true }, // $NON-NLS-1$
    { "255.255.0.0", true, false }, // $NON-NLS-1$
    { "255.255.255.255", true, true }, // $NON-NLS-1$
    { "31", true, true }, // $NON-NLS-1$
    { "/31", true, true }, // $NON-NLS-1$
    { "2", true, true }, // $NON-NLS-1$
    { "/2", true, true }, // $NON-NLS-1$
    { "31", false, false }, // $NON-NLS-1$
    { "/31", false, false }, // $NON-NLS-1$
    { "2", false, false }, // $NON-NLS-1$
    { "/2", false, false } });
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(opts);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    HostNetworkQosDao qosDao = getDbFacade().getHostNetworkQosDao();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getVdsGroupCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    boolean defaultRouteSupported = supportedClusterVersionsAvailable && FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet));
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        if (hostNetworkQosSupported && NetworkUtils.qosConfiguredOnInterface(iface, network)) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(opts);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (defaultRouteSupported && managementNetworkUtil.isManagementNetwork(network.getId(), host.getVdsGroupId()) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
public static MaskValidator getInstance() {
    return validator;
}
#method_after
public static MaskValidator getInstance() {
    return INSTANCE;
}
#end_block

#method_before
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    return Arrays.asList(new Object[][] { // $NON-NLS-1$
    { null, false, false }, // $NON-NLS-1$
    { "a.a.a.a", false, false }, // $NON-NLS-1$
    { "255.255.0", false, false }, // $NON-NLS-1$
    { "255.255.0.0.0", false, false }, // $NON-NLS-1$
    { "255.255.0.0.", false, false }, // $NON-NLS-1$
    { "255.255.0.1", true, false }, // $NON-NLS-1$
    { "255.0.255.0", true, false }, // $NON-NLS-1$
    { "255.0.0.255", true, false }, // $NON-NLS-1$
    { "224.0.255.0", true, false }, // $NON-NLS-1$
    { "255.255.0.0", true, true }, // $NON-NLS-1$
    { "255.255.255.255", true, true }, // $NON-NLS-1$
    { "31 ", false, false }, // $NON-NLS-1$
    { "33", false, false }, // $NON-NLS-1$
    { "31/", false, false }, // $NON-NLS-1$
    { "31*", false, false }, // $NON-NLS-1$
    { "//31 ", false, false }, // $NON-NLS-1$
    { "31", true, true } });
}
#method_after
@Parameterized.Parameters
public static Collection<Object[]> namesParams() {
    Random random = new Random();
    return Arrays.asList(new Object[][] { // $NON-NLS-1$
    { null, false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "a.a.a.a", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "255.255.0", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "255.255.0.0.0", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "255.255.0.0.", false, random.nextBoolean(), false }, // $NON-NLS-1$ /*note extra space*/
    { "31 ", false, random.nextBoolean(), false }, // $NON-NLS-1$ /*note extra space*/
    { "/31 ", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "31/", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "31*", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "//31 ", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "33", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "/33", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "01", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "01/", false, random.nextBoolean(), false }, // $NON-NLS-1$
    { "255.255.0.1", true, false, false }, // $NON-NLS-1$
    { "255.0.255.0", true, false, false }, // $NON-NLS-1$
    { "255.0.0.255", true, false, false }, // $NON-NLS-1$
    { "224.0.255.0", true, false, false }, // $NON-NLS-1$
    { "255.255.0.0", true, true, false }, // $NON-NLS-1$
    { "255.255.255.255", true, true, false }, // $NON-NLS-1$
    { "31", false, random.nextBoolean(), true }, // $NON-NLS-1$
    { "/31", false, random.nextBoolean(), true }, // $NON-NLS-1$
    { "7", false, random.nextBoolean(), true }, // $NON-NLS-1$
    { "/7", false, random.nextBoolean(), true } });
}
#end_block

#method_before
public boolean isCidrNetworkAddressValid(String cidr) {
    String[] temp = cidr.split("/");
    long ipAsInteger = covnertIpToInt(temp[0]);
    int mask = Integer.parseInt(temp[1]);
    return isNetworkAddress(ipAsInteger, mask);
}
#method_after
public boolean isCidrNetworkAddressValid(String cidr) {
    String[] temp = cidr.split("/");
    long ipAsInteger = IpAddressConverter.getInstance().convertIpToLong(temp[0]);
    int mask = Integer.parseInt(temp[1]);
    return isNetworkAddress(ipAsInteger, mask);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("key", configKey).withParameter("value", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("key", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeSnapshotCreateReturnForXmlRpc glusterSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturnForXmlRpc(response);
}
#end_block

#method_before
private void attachInternal(ListModel listModel, StorageDomainType storageType) {
    if (getWindow() != null) {
        return;
    }
    this.setStorageDomainType(storageType);
    setWindow(listModel);
    if (storageType == StorageDomainType.ISO) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<StorageDomain> list = (ArrayList<StorageDomain>) result;
                DataCenterStorageListModel dcStorageModel = (DataCenterStorageListModel) model;
                ArrayList<EntityModel> models;
                models = new ArrayList<EntityModel>();
                ArrayList<StorageDomain> items = dcStorageModel.getItems() != null ? new ArrayList<StorageDomain>(Linq.<StorageDomain>cast(dcStorageModel.getItems())) : new ArrayList<StorageDomain>();
                for (StorageDomain a : list) {
                    if (!Linq.isSDItemExistInList(items, a.getId())) {
                        EntityModel tempVar = new EntityModel();
                        tempVar.setEntity(a);
                        models.add(tempVar);
                    }
                }
                dcStorageModel.postAttachInternal(models);
            }
        };
        AsyncDataProvider.getInstance().getISOStorageDomainList(_asyncQuery);
    } else {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                DataCenterStorageListModel dcStorageModel = (DataCenterStorageListModel) model;
                ArrayList<StorageDomain> list = (ArrayList<StorageDomain>) result;
                ArrayList<EntityModel> models = new ArrayList<EntityModel>();
                boolean addToList;
                ArrayList<StorageDomain> items = dcStorageModel.getItems() != null ? new ArrayList<StorageDomain>(Linq.<StorageDomain>cast(dcStorageModel.getItems())) : new ArrayList<StorageDomain>();
                for (StorageDomain a : list) {
                    addToList = false;
                    if (!Linq.isSDItemExistInList(items, a.getId()) && a.getStorageDomainType() == dcStorageModel.getStorageDomainType()) {
                        if (dcStorageModel.getStorageDomainType() == StorageDomainType.Data && a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
                            if (dcStorageModel.getEntity().getStoragePoolFormatType() == null) {
                                // skip V3 format for DC ver <= 3
                                if (a.getStorageStaticData().getStorageFormat() == StorageFormatType.V3 && dcStorageModel.getEntity().getCompatibilityVersion().compareTo(Version.v3_0) <= 0) {
                                    continue;
                                }
                                addToList = true;
                            } else if (dcStorageModel.getEntity().getStoragePoolFormatType() == a.getStorageStaticData().getStorageFormat()) {
                                addToList = true;
                            } else if (dcStorageModel.getEntity().getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                                // if DC is >= 3.1 we support upgrading
                                if (a.getStorageStaticData().getStorageFormat() == StorageFormatType.V1 || a.getStorageStaticData().getStorageFormat() == StorageFormatType.V2) {
                                    addToList = true;
                                }
                            }
                        } else if (dcStorageModel.getStorageDomainType() == StorageDomainType.ImportExport && a.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) {
                            addToList = true;
                        }
                        if (addToList) {
                            EntityModel tempVar2 = new EntityModel();
                            tempVar2.setEntity(a);
                            models.add(tempVar2);
                        }
                    }
                }
                dcStorageModel.postAttachInternal(models);
            }
        };
        AsyncDataProvider.getInstance().getStorageDomainList(_asyncQuery);
    }
}
#method_after
private void attachInternal(ListModel listModel, StorageDomainType storageType) {
    if (getWindow() != null) {
        return;
    }
    this.setStorageDomainType(storageType);
    setWindow(listModel);
    if (storageType == StorageDomainType.ISO) {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                ArrayList<StorageDomain> list = (ArrayList<StorageDomain>) result;
                DataCenterStorageListModel dcStorageModel = (DataCenterStorageListModel) model;
                ArrayList<EntityModel> models;
                models = new ArrayList<EntityModel>();
                ArrayList<StorageDomain> items = dcStorageModel.getItems() != null ? new ArrayList<StorageDomain>(Linq.<StorageDomain>cast(dcStorageModel.getItems())) : new ArrayList<StorageDomain>();
                for (StorageDomain a : list) {
                    if (!Linq.isSDItemExistInList(items, a.getId())) {
                        EntityModel tempVar = new EntityModel();
                        tempVar.setEntity(a);
                        models.add(tempVar);
                    }
                }
                dcStorageModel.postAttachInternal(models);
            }
        };
        AsyncDataProvider.getInstance().getISOStorageDomainList(_asyncQuery);
    } else {
        AsyncQuery _asyncQuery = new AsyncQuery();
        _asyncQuery.setModel(this);
        _asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object result) {
                DataCenterStorageListModel dcStorageModel = (DataCenterStorageListModel) model;
                ArrayList<StorageDomain> list = (ArrayList<StorageDomain>) result;
                ArrayList<EntityModel> models = new ArrayList<EntityModel>();
                boolean addToList;
                ArrayList<StorageDomain> items = dcStorageModel.getItems() != null ? new ArrayList<StorageDomain>(Linq.<StorageDomain>cast(dcStorageModel.getItems())) : new ArrayList<StorageDomain>();
                for (StorageDomain a : list) {
                    addToList = false;
                    if (Linq.isSDItemExistInList(items, a.getId()) || a.getStorageDomainSharedStatus() != StorageDomainSharedStatus.Unattached) {
                        continue;
                    }
                    if (a.getStorageDomainType() == StorageDomainType.Volume) {
                        addToList = true;
                    } else if (a.getStorageDomainType() == dcStorageModel.getStorageDomainType()) {
                        if (dcStorageModel.getStorageDomainType() == StorageDomainType.Data) {
                            if (dcStorageModel.getEntity().getStoragePoolFormatType() == null) {
                                // skip V3 format for DC ver <= 3
                                if (a.getStorageStaticData().getStorageFormat() == StorageFormatType.V3 && dcStorageModel.getEntity().getCompatibilityVersion().compareTo(Version.v3_0) <= 0) {
                                    continue;
                                }
                                addToList = true;
                            } else if (dcStorageModel.getEntity().getStoragePoolFormatType() == a.getStorageStaticData().getStorageFormat()) {
                                addToList = true;
                            } else if (dcStorageModel.getEntity().getCompatibilityVersion().compareTo(Version.v3_1) >= 0) {
                                // if DC is >= 3.1 we support upgrading
                                if (a.getStorageStaticData().getStorageFormat() == StorageFormatType.V1 || a.getStorageStaticData().getStorageFormat() == StorageFormatType.V2) {
                                    addToList = true;
                                }
                            }
                        } else if (dcStorageModel.getStorageDomainType() == StorageDomainType.ImportExport) {
                            addToList = true;
                        }
                    }
                    if (addToList) {
                        EntityModel tempVar2 = new EntityModel();
                        tempVar2.setEntity(a);
                        models.add(tempVar2);
                    }
                }
                dcStorageModel.postAttachInternal(models);
            }
        };
        AsyncDataProvider.getInstance().getStorageDomainList(_asyncQuery);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getItems() != null ? Linq.<StorageDomain>cast(getItems()) : new ArrayList<StorageDomain>();
    ArrayList<StorageDomain> selectedItems = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    if (getEntity() != null) {
        getAttachStorageCommand().setIsExecutionAllowed(!getEntity().isLocal());
    }
    boolean isMasterPresents = false;
    boolean isISOPresents = false;
    boolean isBackupPresents = false;
    for (StorageDomain domain : items) {
        if (isMasterDomain(domain)) {
            isMasterPresents = true;
        }
        if (domain.getStorageDomainType() == StorageDomainType.ISO) {
            isISOPresents = true;
        }
        if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
            isBackupPresents = true;
        }
    }
    getAttachISOCommand().setIsExecutionAllowed(false);
    getAttachISOCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresents && !isISOPresents);
    getAttachBackupCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresents && !isBackupPresents);
    getDetachCommand().setIsExecutionAllowed(selectedItems.size() > 0 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DetachStorageDomainFromPool));
    getActivateCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.ActivateStorageDomain));
    getMaintenanceCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DeactivateStorageDomainWithOvfUpdate));
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getItems() != null ? Linq.<StorageDomain>cast(getItems()) : new ArrayList<StorageDomain>();
    ArrayList<StorageDomain> selectedItems = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    if (getEntity() != null) {
        getAttachStorageCommand().setIsExecutionAllowed(!getEntity().isLocal());
    }
    boolean isMasterPresent = false;
    boolean isISOPresent = false;
    boolean isBackupPresent = false;
    for (StorageDomain domain : items) {
        if (isDomainMasterAndActive(domain)) {
            isMasterPresent = true;
        } else if (domain.getStorageDomainType() == StorageDomainType.ISO) {
            isISOPresent = true;
        } else if (domain.getStorageDomainType() == StorageDomainType.ImportExport) {
            isBackupPresent = true;
        }
        if (isMasterPresent && isISOPresent && isBackupPresent) {
            break;
        }
    }
    getAttachISOCommand().setIsExecutionAllowed(false);
    getAttachISOCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresent && !isISOPresent);
    getAttachBackupCommand().setIsExecutionAllowed(items.size() > 0 && isMasterPresent && !isBackupPresent);
    getDetachCommand().setIsExecutionAllowed(selectedItems.size() > 0 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DetachStorageDomainFromPool));
    getActivateCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.ActivateStorageDomain));
    getMaintenanceCommand().setIsExecutionAllowed(selectedItems.size() == 1 && VdcActionUtils.canExecute(selectedItems, StorageDomain.class, VdcActionType.DeactivateStorageDomainWithOvfUpdate));
}
#end_block

#method_before
public static int reduceGracePeriod(int interval) {
    return interval - (int) (interval * 0.2);
}
#method_after
public static int reduceGracePeriod(int interval) {
    return interval - (int) (interval * GRACE_PERIOD);
}
#end_block

#method_before
public static int addGracePeriod(int interval) {
    return interval + (int) (interval * 0.2);
}
#method_after
public static int addGracePeriod(int interval) {
    return interval + (int) (interval * GRACE_PERIOD);
}
#end_block

#method_before
public void setOutgoingHeartbeat(int outgoingHeartbeat) {
    this.outgoingHeartbeat = outgoingHeartbeat;
    if (outgoingHeartbeat != 0) {
        this.isOutgoingHeartbeat.set(true);
    } else {
        this.isOutgoingHeartbeat.set(false);
    }
}
#method_after
public final void setOutgoingHeartbeat(int outgoingHeartbeat) {
    this.outgoingHeartbeat = outgoingHeartbeat;
    if (outgoingHeartbeat != 0) {
        this.isOutgoingHeartbeat.set(true);
    } else {
        this.isOutgoingHeartbeat.set(false);
    }
}
#end_block

#method_before
public void setIncomingHeartbeat(int incomingHeartbeat) {
    this.incomingHeartbeat = incomingHeartbeat;
    if (incomingHeartbeat != 0) {
        this.isIncomingHeartbeat.set(true);
    } else {
        this.isIncomingHeartbeat.set(false);
    }
}
#method_after
public final void setIncomingHeartbeat(int incomingHeartbeat) {
    this.incomingHeartbeat = incomingHeartbeat;
    if (incomingHeartbeat != 0) {
        this.isIncomingHeartbeat.set(true);
    } else {
        this.isIncomingHeartbeat.set(false);
    }
}
#end_block

#method_before
private void checkActions(Set<SelectionKey> keys) {
    for (SelectionKey key : keys) {
        Object attachement = key.attachment();
        if (ReactorClient.class.isInstance(attachement)) {
            final ReactorClient client = (ReactorClient) attachement;
            if (client.needPerformAction()) {
                client.performAction();
            }
        }
    }
}
#method_after
private void checkActions(Set<SelectionKey> keys) {
    for (SelectionKey key : keys) {
        Object attachement = key.attachment();
        if (ReactorClient.class.isInstance(attachement)) {
            final ReactorClient client = (ReactorClient) attachement;
            client.performAction();
        }
    }
}
#end_block

#method_before
private void processHeartbeat() {
    if (!this.isInInit() && this.policy.isIncomingHeartbeat() && this.lastIncomingHeartbeat + this.policy.getIncomingHeartbeat() < System.currentTimeMillis()) {
        log.debug("Heartbeat exeeded. Closing channel");
        this.disconnect("Heartbeat exeeded");
    }
}
#method_after
private void processHeartbeat() {
    if (!this.isInInit() && this.policy.isIncomingHeartbeat() && this.isIncomingHeartbeatExeeded()) {
        log.debug("Heartbeat exeeded. Closing channel");
        this.disconnect("Heartbeat exeeded");
    }
}
#end_block

#method_before
public void performAction() {
    this.sendHeartbeat();
}
#method_after
public void performAction() {
    if (!this.isInInit() && this.policy.isOutgoingHeartbeat() && this.isOutgoingHeartbeatExeeded()) {
        this.sendHeartbeat();
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String volumeName, String remoteHost, String remoteVolumeName, boolean force, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String remoteHost, String remoteVolumeName, String optionName, String optionValue, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("key", optionName).withParameter("value", optionValue).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#end_block

#method_before
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param, getActionType()), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            // TODO commented out next line because it can only ever be null here
            // failedRemoveCinderDisks.addAll(cinderDisks);
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#method_after
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param, getActionType()), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks = cinderDisks;
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#end_block

#method_before
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVmFromDb();
            if (getParameters().isRemoveDisks()) {
                for (DiskImage image : diskImages) {
                    getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                    ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
                }
                getCompensationContext().stateChanged();
            } else {
                for (DiskImage image : diskImages) {
                    getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
                }
            }
            return null;
        }
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(failedRemoveCinderDisks);
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#method_after
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVmFromDb();
            if (getParameters().isRemoveDisks()) {
                for (DiskImage image : diskImages) {
                    getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                    ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
                }
                getCompensationContext().stateChanged();
            } else {
                for (DiskImage image : diskImages) {
                    getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
                }
            }
            return null;
        }
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(removeCinderDisks());
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    VmHandler.updateDisksFromDb(getVm());
    if (!getParameters().isRemoveDisks() && !canRemoveVmWithDetachDisks()) {
        return false;
    }
    switch(getVm().getStatus()) {
        case Unassigned:
        case Down:
        case ImageIllegal:
        case ImageLocked:
            break;
        case Suspended:
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_VM_WHEN_STATUS_IS_NOT_DOWN);
        default:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
    }
    if (getVm().getVmPoolId() != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_ATTACHED_TO_POOL);
    }
    // enable to remove vms without images
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    if (!validate(snapshotsValidator.vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (!validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    Collection<Disk> vmDisks = getVm().getDiskMap().values();
    List<DiskImage> vmImages = ImagesHandler.filterImageDisks(vmDisks, true, false, true);
    vmImages.addAll(ImagesHandler.filterDisksBasedOnCinder(vmDisks));
    if (!vmImages.isEmpty()) {
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(vmImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(storageValidator.allDomainsExistAndActive())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(vmImages);
        if (!getParameters().getForce() && !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    // Handle VM status with ImageLocked
    VmValidator vmValidator = new VmValidator(getVm());
    ValidationResult vmLockedValidatorResult = vmValidator.vmNotLocked();
    if (!vmLockedValidatorResult.isValid()) {
        // without force remove, we can't remove the VM
        if (!getParameters().getForce()) {
            return failCanDoAction(vmLockedValidatorResult.getMessage());
        }
        // If it is force, we cannot remove if there are task
        if (CommandCoordinatorUtil.hasTasksByStoragePoolId(getVm().getStoragePoolId())) {
            return failCanDoAction(VdcBllMessages.VM_CANNOT_REMOVE_HAS_RUNNING_TASKS);
        }
    }
    if (getParameters().isRemoveDisks() && !validate(vmValidator.vmNotHavingDeviceSnapshotsAttachedToOtherVms(false))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void removeVmFromDb() {
    removeLunDisks();
    removeCinderDisks();
    removeVmUsers();
    removeVmNetwork();
    removeVmSnapshots();
    removeVmStatic(getParameters().isRemovePermissions());
}
#method_after
protected void removeVmFromDb() {
    removeLunDisks();
    removeVmUsers();
    removeVmNetwork();
    removeVmSnapshots();
    removeVmStatic(getParameters().isRemovePermissions());
}
#end_block

#method_before
private void removeCinderDisks() {
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = ImagesHandler.filterDiskBasedOnCinder(getVm().getDiskMap().values());
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param, getActionType()), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks.addAll(cinderDisks);
            log.error("Exception", e);
        }
    }
}
#method_after
private Collection<CinderDisk> removeCinderDisks() {
    Collection<CinderDisk> failedRemoveCinderDisks = null;
    if (getParameters().isRemoveDisks()) {
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
        RemoveAllVmCinderDisksParameters param = new RemoveAllVmCinderDisksParameters(getVmId(), cinderDisks);
        param.setParentHasTasks(!getReturnValue().getVdsmTaskIdList().isEmpty());
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveAllVmCinderDisks, withRootCommandInfo(param, getActionType()), cloneContextAndDetachFromParent());
        try {
            failedRemoveCinderDisks = future.get().getActionReturnValue();
        } catch (InterruptedException | ExecutionException e) {
            failedRemoveCinderDisks.addAll(cinderDisks);
            log.error("Exception", e);
        }
    }
    return failedRemoveCinderDisks;
}
#end_block

#method_before
private T getCommand(Guid cmdId) {
    return (T) CommandCoordinatorUtil.retrieveCommand(cmdId);
}
#method_after
private T getCommand(Guid cmdId) {
    return CommandCoordinatorUtil.retrieveCommand(cmdId);
}
#end_block

#method_before
private List<CinderDisk> getCinderDisksToBeRemoved() {
    List<CinderDisk> imageDisks = getParameters().cinderDisks;
    List<CinderDisk> cinderDisks = new ArrayList<>();
    if (imageDisks == null) {
        cinderDisks = ImagesHandler.filterDiskBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    } else {
        for (DiskImage diskImage : imageDisks) {
            cinderDisks.add((CinderDisk) diskImage);
        }
    }
    return cinderDisks;
}
#method_after
private List<CinderDisk> getCinderDisksToBeRemoved() {
    List<CinderDisk> imageDisks = getParameters().cinderDisks;
    List<CinderDisk> cinderDisks = new ArrayList<>();
    if (imageDisks == null) {
        cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    } else {
        for (DiskImage diskImage : imageDisks) {
            cinderDisks.add((CinderDisk) diskImage);
        }
    }
    return cinderDisks;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_UPDATE_VM_DISK : AuditLogType.USER_FAILED_UPDATE_VM_DISK;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return isCinderDisk() && resizeDiskImageRequested() ? AuditLogType.USER_EXTENDED_DISK_SIZE : AuditLogType.USER_UPDATE_VM_DISK;
    } else {
        return AuditLogType.USER_FAILED_UPDATE_VM_DISK;
    }
}
#end_block

#method_before
public long getNewDiskSizeInGB() {
    CinderDisk cinderDisk = (CinderDisk) getNewDisk();
    return cinderDisk.getSize() / (1024 * 1024 * 1024);
}
#method_after
public long getNewDiskSizeInGB() {
    CinderDisk cinderDisk = (CinderDisk) getNewDisk();
    return cinderDisk.getSize() / BYTES_IN_GB;
}
#end_block

#method_before
private boolean isDiskImage() {
    return getOldDisk() != null && getNewDisk() != null && DiskStorageType.IMAGE == getOldDisk().getDiskStorageType();
}
#method_after
private boolean isDiskImage() {
    return isDiskStorageType(DiskStorageType.IMAGE);
}
#end_block

#method_before
private boolean isCinderDisk() {
    return getOldDisk() != null && getNewDisk() != null && DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
}
#method_after
private boolean isCinderDisk() {
    return isDiskStorageType(DiskStorageType.CINDER);
}
#end_block

#method_before
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    getCommand().unlockImageInDb();
    log.error("Failed extending disk. ID: {}", getDiskId());
    updateAuditLog(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, getCommand().getNewDiskSizeInGB());
    getCommand().endAction();
    CommandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
}
#method_after
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    super.onFailed(cmdId, childCmdIds);
    log.error("Failed extending disk. ID: {}", getDiskId());
    updateAuditLog(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, getCommand().getNewDiskSizeInGB());
    getCommand().endAction();
    CommandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
}
#end_block

#method_before
private List<CinderDisk> getCinderDisksToBeRemoved() {
    List<CinderDisk> imageDisks = getParameters().cinderDisks;
    List<CinderDisk> cinderDisks = new ArrayList<>();
    if (imageDisks == null) {
        cinderDisks = ImagesHandler.filterDiskBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    } else {
        for (DiskImage diskImage : imageDisks) {
            cinderDisks.add((CinderDisk) diskImage);
        }
    }
    return cinderDisks;
}
#method_after
private List<CinderDisk> getCinderDisksToBeRemoved() {
    List<CinderDisk> imageDisks = getParameters().cinderDisks;
    List<CinderDisk> cinderDisks = new ArrayList<>();
    if (imageDisks == null) {
        cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    } else {
        for (DiskImage diskImage : imageDisks) {
            cinderDisks.add((CinderDisk) diskImage);
        }
    }
    return cinderDisks;
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<GlusterVolumeEntity, VolumeListModel> getVolumeListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VolumeRebalanceStatusPopupPresenterWidget> rebalanceStatusPopupProvider, final Provider<VolumeProfileStatisticsPopupPresenterWidget> volumeProfileStatsPopupProvider) {
    return new MainTabModelProvider<GlusterVolumeEntity, VolumeListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewVolumeCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRebalanceCommand() || lastExecutedCommand.getName().equals("onStopRebalance")) {
                // $NON-NLS-1$
                return rebalanceStatusPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getShowVolumeProfileDetailsCommand() || lastExecutedCommand.getName().equals("showProfileDetails")) {
                // $NON-NLS-1$
                return volumeProfileStatsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getRemoveVolumeCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<GlusterVolumeEntity, VolumeListModel> getVolumeListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumePopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VolumeRebalanceStatusPopupPresenterWidget> rebalanceStatusPopupProvider, final Provider<VolumeProfileStatisticsPopupPresenterWidget> volumeProfileStatsPopupProvider, final Provider<VolumeListModel> modelProvider, final Provider<CommonModel> commonModelProvider, final Provider<GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget> volumeSnapshotConfigOptionsPopupProvider, final Provider<GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget> clusterSnapshotConfigOptionsPopupProvider) {
    MainTabModelProvider<GlusterVolumeEntity, VolumeListModel> result = new MainTabModelProvider<GlusterVolumeEntity, VolumeListModel>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewVolumeCommand()) {
                return popupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRebalanceCommand() || lastExecutedCommand.getName().equals("onStopRebalance")) {
                // $NON-NLS-1$
                return rebalanceStatusPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getShowVolumeProfileDetailsCommand() || lastExecutedCommand.getName().equals("showProfileDetails")) {
                // $NON-NLS-1$
                return volumeProfileStatsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getConfigureVolumeSnapshotOptionsCommand()) {
                return volumeSnapshotConfigOptionsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getConfigureClusterSnapshotOptionsCommand()) {
                return clusterSnapshotConfigOptionsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getRemoveVolumeCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel> getVolumeBrickListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AddBrickPopupPresenterWidget> addBrickPopupProvider, final Provider<RemoveBrickPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RemoveBrickPopupPresenterWidget> removeBrickPopupProvider, final Provider<RemoveBrickStatusPopupPresenterWidget> removeBricksStatusPopupProvider, final Provider<ReplaceBrickPopupPresenterWidget> replaceBrickPopupProvider, final Provider<BrickAdvancedDetailsPopupPresenterWidget> brickDetailsPopupProvider) {
    return new SearchableDetailTabModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, VolumeBrickListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddBricksCommand()) {
                return addBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRemoveBricksCommand()) {
                return removeBricksStatusPopupProvider.get();
            } else if (lastExecutedCommand.getName().equals("OnStopRemoveBricks")) {
                // $NON-NLS-1$
                return removeBricksStatusPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getReplaceBrickCommand()) {
                return replaceBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getBrickAdvancedDetailsCommand()) {
                return brickDetailsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel> getVolumeBrickListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AddBrickPopupPresenterWidget> addBrickPopupProvider, final Provider<RemoveBrickPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RemoveBrickPopupPresenterWidget> removeBrickPopupProvider, final Provider<RemoveBrickStatusPopupPresenterWidget> removeBricksStatusPopupProvider, final Provider<ReplaceBrickPopupPresenterWidget> replaceBrickPopupProvider, final Provider<BrickAdvancedDetailsPopupPresenterWidget> brickDetailsPopupProvider, final Provider<VolumeListModel> mainModelProvider, final Provider<VolumeBrickListModel> modelProvider) {
    SearchableDetailTabModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel> result = new SearchableDetailTabModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddBricksCommand()) {
                return addBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStatusRemoveBricksCommand()) {
                return removeBricksStatusPopupProvider.get();
            } else if (lastExecutedCommand.getName().equals("OnStopRemoveBricks")) {
                // $NON-NLS-1$
                return removeBricksStatusPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getReplaceBrickCommand()) {
                return replaceBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getBrickAdvancedDetailsCommand()) {
                return brickDetailsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterVolumeOptionEntity, VolumeListModel, VolumeParameterListModel> getVolumeParameterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumeParameterPopupPresenterWidget> addParameterPopupProvider, final Provider<VolumeParameterPopupPresenterWidget> editParameterPopupProvider) {
    return new SearchableDetailTabModelProvider<GlusterVolumeOptionEntity, VolumeListModel, VolumeParameterListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, VolumeParameterListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeParameterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddParameterCommand()) {
                return addParameterPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditParameterCommand()) {
                return editParameterPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterVolumeOptionEntity, VolumeListModel, VolumeParameterListModel> getVolumeParameterListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<VolumeParameterPopupPresenterWidget> addParameterPopupProvider, final Provider<VolumeParameterPopupPresenterWidget> editParameterPopupProvider, final Provider<VolumeListModel> mainModelProvider, final Provider<VolumeParameterListModel> modelProvider) {
    SearchableDetailTabModelProvider<GlusterVolumeOptionEntity, VolumeListModel, VolumeParameterListModel> result = new SearchableDetailTabModelProvider<GlusterVolumeOptionEntity, VolumeListModel, VolumeParameterListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeParameterListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddParameterCommand()) {
                return addParameterPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditParameterCommand()) {
                return editParameterPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<AuditLog, VolumeListModel, VolumeEventListModel> getVolumeEventListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<EventPopupPresenterWidget> eventPopupProvider) {
    return new SearchableDetailTabModelProvider<AuditLog, VolumeListModel, VolumeEventListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, VolumeEventListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeEventListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getDetailsCommand())) {
                return eventPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<AuditLog, VolumeListModel, VolumeEventListModel> getVolumeEventListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<EventPopupPresenterWidget> eventPopupProvider, final Provider<VolumeListModel> mainModelProvider, final Provider<VolumeEventListModel> modelProvider) {
    SearchableDetailTabModelProvider<AuditLog, VolumeListModel, VolumeEventListModel> result = new SearchableDetailTabModelProvider<AuditLog, VolumeListModel, VolumeEventListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeEventListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand.equals(getModel().getDetailsCommand())) {
                return eventPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterGeoRepSession, VolumeListModel, VolumeGeoRepListModel> getVolumeGeoRepListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<GlusterVolumeGeoRepCreateSessionPopupPresenterWidget> geoRepPopupProvider) {
    return new SearchableDetailTabModelProvider<GlusterGeoRepSession, VolumeListModel, VolumeGeoRepListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, VolumeGeoRepListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeGeoRepListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getNewSessionCommand()) {
                return geoRepPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterGeoRepSession, VolumeListModel, VolumeGeoRepListModel> getVolumeGeoRepListProvider(EventBus eventBus, final Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget> geoRepActionConfirmationPopupProvider, final Provider<GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget> geoRepConfigPopupProvider, final Provider<GlusterVolumeGeoRepCreateSessionPopupPresenterWidget> geoRepSessionCreatePopupProvider, final Provider<VolumeListModel> mainModelProvider, final Provider<VolumeGeoRepListModel> modelProvider) {
    SearchableDetailTabModelProvider<GlusterGeoRepSession, VolumeListModel, VolumeGeoRepListModel> result = new SearchableDetailTabModelProvider<GlusterGeoRepSession, VolumeListModel, VolumeGeoRepListModel>(eventBus, defaultConfirmPopupProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeGeoRepListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getStartSessionCommand() || lastExecutedCommand == getModel().getStopSessionCommand() || lastExecutedCommand == getModel().getPauseSessionCommand() || lastExecutedCommand == getModel().getResumeSessionCommand() || lastExecutedCommand == getModel().getRemoveSessionCommand()) {
                return geoRepActionConfirmationPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getSessionOptionsCommand()) {
                return geoRepConfigPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewSessionCommand()) {
                return geoRepSessionCreatePopupProvider.get();
            } else {
                return geoRepActionConfirmationPopupProvider.get();
            }
        }
    };
    result.setMainModelProvider(mainModelProvider);
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
}
#method_after
@Override
protected void configure() {
    bind(VolumeListModel.class).in(Singleton.class);
    bind(VolumeGeneralModel.class).in(Singleton.class);
    bind(VolumeBrickListModel.class).in(Singleton.class);
    bind(VolumeParameterListModel.class).in(Singleton.class);
    bind(VolumeEventListModel.class).in(Singleton.class);
    bind(VolumeGeoRepListModel.class).in(Singleton.class);
    bind(GlusterVolumeSnapshotListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<GlusterVolumeEntity>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VolumeListModel, VolumeGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VolumeListModel, VolumeGeneralModel>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VolumeListModel, PermissionListModel<GlusterVolumeEntity>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<GlusterVolumeEntity, VolumeListModel>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = new UICommand("onCreateVolume", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", volumeListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerVolumeModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("onCreateVolume", volumeListModel);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            innerVolumeModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", volumeListModel));
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    model.setHelpTag(HelpTag.remove_volume);
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    model.setHelpTag(HelpTag.remove_volume);
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) provideDetailModelEntity(getSelectedItem());
    getBrickListModel().setVolumeEntity(selectedVolume);
    getGeoRepListModel().setEntity(selectedVolume);
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    GlusterVolumeEntity selectedVolume = (GlusterVolumeEntity) provideDetailModelEntity(getSelectedItem());
    getBrickListModel().setVolumeEntity(selectedVolume);
    getGeoRepListModel().setEntity(selectedVolume);
    getSnapshotListModel().setEntity(selectedVolume);
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    boolean allowCreateGeoRepSession = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
        allowCreateGeoRepSession = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    getNewGeoRepSessionCommand().setIsAvailable(allowCreateGeoRepSession);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    boolean allowConfigureClusterSnapshotOptions = true;
    boolean allowConfigureVolumeSnapshotOptions = false;
    boolean allowCreateSnapshot = false;
    boolean allowEditSnapshotSchedule = false;
    boolean allowCreateGeoRepSession = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
            allowConfigureVolumeSnapshotOptions = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateGeoRepSession = volumeEntity.getStatus() == GlusterStatus.UP;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
        allowCreateSnapshot = isCreateSnapshotAvailable(list);
        allowEditSnapshotSchedule = isEditSnapshotScheduleAvailable(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    getConfigureClusterSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureClusterSnapshotOptions);
    getConfigureVolumeSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureVolumeSnapshotOptions);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
    getNewGeoRepSessionCommand().setIsExecutionAllowed(allowCreateGeoRepSession);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("CancelOptimizeForVirtStore")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equalsIgnoreCase("ConfirmOptimiseForVirtStore")) {
        // $NON-NLS-1$
        List<GlusterVolumeEntity> selectedVolumes = new ArrayList<GlusterVolumeEntity>();
        for (Object selectedVolume : getSelectedItems()) {
            selectedVolumes.add((GlusterVolumeEntity) selectedVolume);
        }
        optimizeVolumesForVirtStore(selectedVolumes);
    } else if (command.equals(getNewGeoRepSessionCommand())) {
        getGeoRepListModel().getNewSessionCommand().execute();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.equals(getNewGeoRepSessionCommand())) {
        getGeoRepListModel().getNewSessionCommand().execute();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelConfirmation")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    } else if (command.equals(getStartVolumeProfilingCommand()) || command.getName().equals("startProfiling")) {
        // $NON-NLS-1$
        startVolumeProfiling();
    } else if (command.equals(getStopVolumeProfilingCommand()) || command.getName().equals("stopProfiling")) {
        // $NON-NLS-1$
        stopVolumeProfiling();
    } else if (command.equals(getShowVolumeProfileDetailsCommand()) || command.getName().equals("showProfileDetails")) {
        // $NON-NLS-1$
        showVolumeProfiling();
    } else if (command.getName().equalsIgnoreCase("closeProfileStats")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("CancelOptimizeForVirtStore")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equalsIgnoreCase("ConfirmOptimiseForVirtStore")) {
        // $NON-NLS-1$
        List<GlusterVolumeEntity> selectedVolumes = new ArrayList<GlusterVolumeEntity>();
        for (Object selectedVolume : getSelectedItems()) {
            selectedVolumes.add((GlusterVolumeEntity) selectedVolume);
        }
        optimizeVolumesForVirtStore(selectedVolumes);
    } else if (command.equals(getConfigureClusterSnapshotOptionsCommand())) {
        configureClusterSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("confirmConfigureClusterSnapshotOptions")) {
        // $NON-NLS-1$
        confirmConfigureClusterSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("onConfigureClusterSnapshotOptions")) {
        // $NON-NLS-1$
        onConfigureClusterSnapshotOptions();
    } else if (command.equals(getConfigureVolumeSnapshotOptionsCommand())) {
        configureVolumeSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("confirmConfigureVolumeSnapshotOptions")) {
        // $NON-NLS-1$
        confirmConfigureVolumeSnapshotOptions();
    } else if (command.getName().equalsIgnoreCase("onConfigureVolumeSnapshotOptions")) {
        // $NON-NLS-1$
        onConfigureVolumeSnapshotOptions();
    } else if (command.equals(getCreateSnapshotCommand())) {
        getSnapshotListModel().getCreateSnapshotCommand().execute();
    } else if (command.equals(getEditSnapshotScheduleCommand())) {
        getSnapshotListModel().getEditSnapshotScheduleCommand().execute();
    }
}
#end_block

#method_before
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    model.setHelpTag(HelpTag.volume_rebalance_stop);
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("CancelConfirmation", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItem() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    model.setHelpTag(HelpTag.volume_rebalance_stop);
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getMessages().confirmStopVolumeRebalance(volumeEntity.getName()));
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("onStopRebalance", this);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("CancelConfirmation", this);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void optimizeVolumesForVirtStore(final List<GlusterVolumeEntity> volumeList) {
    if (getConfirmWindow() != null) {
        setConfirmWindow(null);
    }
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (GlusterVolumeEntity volume : volumeList) {
                                Guid volumeId = volume.getId();
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "group", optionGroupVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-uid", optionOwnerUserVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-gid", optionOwnerGroupVirt)));
                                // $NON-NLS-1$//$NON-NLS-2$
                                final GlusterVolumeOptionEntity checkOption = getOption(volumeId, "network.ping-timeout", "10");
                                List<PredicateFilter<GlusterVolumeOptionEntity>> predicaetFilters = Collections.singletonList(new PredicateFilter<GlusterVolumeOptionEntity>(new Predicate<GlusterVolumeOptionEntity>() {

                                    @Override
                                    public boolean evaluate(GlusterVolumeOptionEntity obj) {
                                        return obj.getKey().equalsIgnoreCase(checkOption.getKey());
                                    }
                                }));
                                if (!isOptionEnabledOnVolume(volume, predicaetFilters)) {
                                    // $NON-NLS-1$
                                    list.add(new GlusterVolumeOptionParameters(checkOption));
                                }
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#method_after
private void optimizeVolumesForVirtStore(final List<GlusterVolumeEntity> volumeList) {
    if (getConfirmWindow() != null) {
        setConfirmWindow(null);
    }
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, final Object result) {
            AsyncQuery aQueryInner = new AsyncQuery();
            aQueryInner.setModel(this);
            aQueryInner.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object modelInner, final Object resultInner) {
                    AsyncQuery aQueryInner1 = new AsyncQuery();
                    aQueryInner1.setModel(this);
                    aQueryInner1.asyncCallback = new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object modelInner1, Object resultInner1) {
                            String optionGroupVirt = (String) result;
                            String optionOwnerUserVirt = (String) resultInner;
                            String optionOwnerGroupVirt = (String) resultInner1;
                            ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
                            for (GlusterVolumeEntity volume : volumeList) {
                                Guid volumeId = volume.getId();
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "group", optionGroupVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-uid", optionOwnerUserVirt)));
                                // $NON-NLS-1$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "storage.owner-gid", optionOwnerGroupVirt)));
                                // $NON-NLS-1$ $NON-NLS-2$
                                list.add(new GlusterVolumeOptionParameters(getOption(volumeId, "server.allow-insecure", "on")));
                                // $NON-NLS-1$//$NON-NLS-2$
                                final GlusterVolumeOptionEntity checkOption = getOption(volumeId, "network.ping-timeout", "10");
                                List<PredicateFilter<GlusterVolumeOptionEntity>> predicaetFilters = Collections.singletonList(new PredicateFilter<GlusterVolumeOptionEntity>(new Predicate<GlusterVolumeOptionEntity>() {

                                    @Override
                                    public boolean evaluate(GlusterVolumeOptionEntity obj) {
                                        return obj.getKey().equalsIgnoreCase(checkOption.getKey());
                                    }
                                }));
                                if (!isOptionEnabledOnVolume(volume, predicaetFilters)) {
                                    // $NON-NLS-1$
                                    list.add(new GlusterVolumeOptionParameters(checkOption));
                                }
                            }
                            Frontend.getInstance().runMultipleAction(VdcActionType.SetGlusterVolumeOption, list);
                        }
                    };
                    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner1);
                }
            };
            AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionOwnerUserVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQueryInner);
        }
    };
    AsyncDataProvider.getInstance().getConfigFromCache(new GetConfigurationValueParameters(ConfigurationValues.GlusterVolumeOptionGroupVirtValue, AsyncDataProvider.getInstance().getDefaultConfigurationVersion()), aQuery);
}
#end_block

#method_before
private void stop() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolume());
    model.setHelpTag(HelpTag.volume_stop);
    // $NON-NLS-1$
    model.setHashName("volume_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().stopVolumeMessage());
    model.setNote(ConstantsManager.getInstance().getConstants().stopVolumeWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("onStop", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void stop() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolume());
    model.setHelpTag(HelpTag.volume_stop);
    // $NON-NLS-1$
    model.setHashName("volume_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().stopVolumeMessage());
    model.setNote(ConstantsManager.getInstance().getConstants().stopVolumeWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("onStop", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable(new Comparator<GlusterVolumeEntity>() {

        @Override
        public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) {
            return GlusterVolumeUtils.getVolumeStatus(o1).ordinal() - GlusterVolumeUtils.getVolumeStatus(o2).ordinal();
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.geoReplicationMainTabTitle(), getGeoRepCreateMenu(constants), CommandLocation.ContextAndToolBar));
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable(new Comparator<GlusterVolumeEntity>() {

        @Override
        public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) {
            return GlusterVolumeUtils.getVolumeStatus(o1).ordinal() - GlusterVolumeUtils.getVolumeStatus(o2).ordinal();
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterVolumeEntity> nameColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> clusterColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> volumeTypeColumn = new AbstractEnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu();
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu();
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotCountColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotsCount().toString();
        }
    };
    snapshotCountColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotCountColumn, constants.noOfSnapshotsLabel(), "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotScheduledColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotScheduled().toString();
        }
    };
    snapshotScheduledColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotScheduledColumn, constants.snapshotScheduledLabel(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeSnapshotMainTabTitle(), getVolumeSnapshotMenu(), CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.geoReplicationMainTabTitle(), getGeoRepCreateMenu(constants), CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
protected void getVolumesForForceSessionCreate(final GlusterVolumeEntity masterVolume) {
    final GlusterVolumeGeoRepCreateModel thisModel = this;
    thisModel.startProgress(constants.fetchingDataMessage());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            setVolumeList((Collection) ((VdcQueryReturnValue) ReturnValue).getReturnValue());
            getVolumeList().remove(masterVolume);
            getSlaveClusters().setItems(getClustersForVolume(getVolumeList()));
            thisModel.stopProgress();
        }
    };
    // $NON-NLS-1$
    SearchParameters vdcQueryParametersBase = new SearchParameters("Volumes:", SearchType.GlusterVolume, false);
    vdcQueryParametersBase.setRefresh(true);
    // $NON-NLS-1$
    Frontend.getInstance().runQuery(VdcQueryType.Search, vdcQueryParametersBase, _asyncQuery);
}
#method_after
public void getVolumesForForceSessionCreate() {
    GlusterVolumeGeoRepCreateModel.this.startProgress(constants.fetchingDataMessage());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            showAvailableVolumes(ReturnValue);
        }
    };
    // $NON-NLS-1$
    SearchParameters volumesSearchParameters = new SearchParameters("Volumes:", SearchType.GlusterVolume, false);
    volumesSearchParameters.setRefresh(true);
    Frontend.getInstance().runQuery(VdcQueryType.Search, volumesSearchParameters, _asyncQuery);
}
#end_block

#method_before
private List<GlusterVolumeEntity> getVolumesInCluster(String cluster, Collection<GlusterVolumeEntity> volumes) {
    List<GlusterVolumeEntity> volumesInCurrentCluster = new ArrayList<GlusterVolumeEntity>();
    for (GlusterVolumeEntity currentVolume : volumes) {
        if (currentVolume.getVdsGroupName().equals(cluster)) {
            volumesInCurrentCluster.add(currentVolume);
        }
    }
    return volumesInCurrentCluster;
}
#method_after
public List<GlusterVolumeEntity> getVolumesInCluster(String cluster, Collection<GlusterVolumeEntity> volumes) {
    List<GlusterVolumeEntity> volumesInCurrentCluster = new ArrayList<GlusterVolumeEntity>();
    for (GlusterVolumeEntity currentVolume : volumes) {
        if (currentVolume.getVdsGroupName().equals(cluster)) {
            volumesInCurrentCluster.add(currentVolume);
        }
    }
    return volumesInCurrentCluster;
}
#end_block

#method_before
private Set<String> getHostNamesForVolume(GlusterVolumeEntity volume) {
    Set<String> hosts = new HashSet<String>();
    for (GlusterBrickEntity currentBrick : volume.getBricks()) {
        hosts.add(currentBrick.getServerName());
    }
    return hosts;
}
#method_after
public Set<String> getHostNamesForVolume(GlusterVolumeEntity volume) {
    Set<String> hosts = new HashSet<String>();
    for (GlusterBrickEntity currentBrick : volume.getBricks()) {
        hosts.add(currentBrick.getServerName());
    }
    return hosts;
}
#end_block

#method_before
public void setVolumeList(Collection<GlusterVolumeEntity> volumeList) {
    this.volumeList = volumeList;
}
#method_after
public void setVolumeList(Collection<GlusterVolumeEntity> volumeList) {
    this.volumeList = volumeList;
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("RecommendationViolations"));
}
#end_block

#method_before
private void init() {
    setTitle(constants.newGeoRepSessionTitle());
    setOverrideSuggestedConfig(new EntityModel<Boolean>());
    setSlaveClusters(new ListModel<String>());
    setSlaveVolumes(new ListModel<GlusterVolumeEntity>());
    setSlaveHosts(new ListModel<String>());
    setStartSession(new EntityModel<Boolean>());
    setSlaveUserName(new EntityModel<String>());
    setSlaveHostRootPassword(new EntityModel<String>());
    getOverrideSuggestedConfig().setEntity(false);
    getSlaveUserName().setIsChangable(true);
    getSlaveUserName().setIsAvailable(true);
    getSlaveUserName().setEntity(constants.geoRepRootUser());
}
#method_after
private void init() {
    setTitle(constants.newGeoRepSessionTitle());
    setHelpTag(HelpTag.volume_geo_rep_create);
    // $NON-NLS-1$
    setHashName("volume_geo_rep_create");
    setShowEligibleVolumes(new EntityModel<Boolean>());
    setSlaveClusters(new ListModel<String>());
    setSlaveVolumes(new ListModel<GlusterVolumeEntity>());
    setSlaveHosts(new ListModel<String>());
    setStartSession(new EntityModel<Boolean>());
    setSlaveUserName(new EntityModel<String>(constants.emptyString()));
    setSlaveUserGroupName(new EntityModel<String>());
}
#end_block

#method_before
public boolean validate() {
    return true;
}
#method_after
public boolean validate() {
    getSlaveVolumes().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(128), new AsciiNameValidation() });
    getSlaveHosts().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(128) });
    return getSlaveVolumes().getIsValid() && getSlaveHosts().getIsValid();
}
#end_block

#method_before
public void isClusterEmpty(AsyncQuery aQuery, Guid id) {
    aQuery.converterCallback = new IAsyncConverter<Boolean>() {

        @Override
        public Boolean Convert(Object source, AsyncQuery _asyncQuery) {
            return (Boolean) source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.IsClusterEmpty, new IdQueryParameters(id), aQuery);
}
#method_after
public void isClusterEmpty(AsyncQuery aQuery, Guid clusterId) {
    runQueryByIdParameter(VdcQueryType.IsClusterEmpty, aQuery, clusterId);
}
#end_block

#method_before
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#method_after
public void getHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((List<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.Search, new // $NON-NLS-1$ //$NON-NLS-2$
    SearchParameters(// $NON-NLS-1$ //$NON-NLS-2$
    "Host: cluster = " + clusterName + " sortby name", SearchType.VDS), aQuery);
}
#end_block

#method_before
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#method_after
public void getHostListByDataCenter(AsyncQuery aQuery, Guid spId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return Linq.<VDS>cast((List<?>) source);
            }
            return new ArrayList<VDS>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVdsByStoragePool, new IdQueryParameters(spId), aQuery);
}
#end_block

#method_before
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permissions>) source : new ArrayList<Permissions>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#method_after
public void getPermissionsByAdElementId(AsyncQuery aQuery, Guid userId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Permission>) source : new ArrayList<Permission>();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(userId), aQuery);
}
#end_block

#method_before
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (ArrayList<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#method_after
public void getLocalStorageHost(AsyncQuery aQuery, String dataCenterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                for (IVdcQueryable item : (List<IVdcQueryable>) source) {
                    return item;
                }
            }
            return null;
        }
    };
    // $NON-NLS-1$
    SearchParameters sp = new SearchParameters("hosts: datacenter=" + dataCenterName, SearchType.VDS);
    Frontend.getInstance().runQuery(VdcQueryType.Search, sp, aQuery);
}
#end_block

#method_before
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                ArrayList<VDS> list = Linq.<VDS>cast((ArrayList<IVdcQueryable>) source);
                return list;
            }
            return new ArrayList<VDS>();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#method_after
public void getUpHostListByCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : Collections.emptyList();
        }
    };
    getUpHostListByCluster(aQuery, clusterName, null);
}
#end_block

#method_before
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisks params = new GetAllAttachableDisks(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisks, params, aQuery);
}
#method_after
public void getAllAttachableDisks(AsyncQuery aQuery, Guid storagePoolId, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Disk>) source : new ArrayList<Disk>();
        }
    };
    GetAllAttachableDisksForVmQueryParameters params = new GetAllAttachableDisksForVmQueryParameters(storagePoolId);
    params.setVmId(vmId);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllAttachableDisksForVm, params, aQuery);
}
#end_block

#method_before
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (ArrayList<Network>) source : new ArrayList<Network>();
        }
    };
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#method_after
public void getAllDataCenterNetworks(AsyncQuery aQuery, Guid storagePoolId) {
    aQuery.converterCallback = new ListAsyncConverter();
    IdQueryParameters params = new IdQueryParameters(storagePoolId);
    Frontend.getInstance().runQuery(VdcQueryType.GetNetworksByDataCenterId, params, aQuery);
}
#end_block

#method_before
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChainText, new ProviderQueryParameters(provider), aQuery);
}
#method_after
public void getProviderCertificateChain(AsyncQuery aQuery, Provider provider) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return Collections.<CertificateInfo>emptyList();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetProviderCertificateChain, new ProviderQueryParameters(provider), aQuery);
}
#end_block

#method_before
public boolean hasSpiceSupport(int osId, Version version) {
    List<DisplayType> osDisplayTypes = getDisplayTypes(osId, version);
    return osDisplayTypes == null ? false : osDisplayTypes.contains(DisplayType.qxl);
}
#method_after
public boolean hasSpiceSupport(int osId, Version version) {
    for (Pair<GraphicsType, DisplayType> graphicsDisplayPair : getGraphicsAndDisplays(osId, version)) {
        if (graphicsDisplayPair.getFirst() == GraphicsType.SPICE) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            graphicsAndDisplays = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId), aQuery);
}
#method_after
public void getVmGuestAgentInterfacesByVmId(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source == null) {
                return new ArrayList<VmGuestAgentInterface>();
            }
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmGuestAgentInterfacesByVmId, new IdQueryParameters(vmId).withoutRefresh(), aQuery);
}
#end_block

#method_before
private ArrayList<VDSGroup> getClusterByServiceList(ArrayList<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#method_after
public ArrayList<VDSGroup> getClusterByServiceList(List<VDSGroup> list, boolean supportsVirtService, boolean supportsGlusterService) {
    final ArrayList<VDSGroup> filteredList = new ArrayList<VDSGroup>();
    for (VDSGroup cluster : list) {
        if ((supportsVirtService && cluster.supportsVirtService()) || (supportsGlusterService && cluster.supportsGlusterService())) {
            filteredList.add(cluster);
        }
    }
    // sort by cluster name
    Collections.sort(filteredList, new NameableComparator());
    return filteredList;
}
#end_block

#method_before
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        // currently on VDSM side reboot is supported only when the guest agent is present and responsive so we need to check for that
        if (!isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion) || StringHelper.isNullOrEmpty(vm.getVmIp())) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isRebootCommandExecutionAllowed(List<VM> vms) {
    if (vms.isEmpty() || !VdcActionUtils.canExecute(vms, VM.class, VdcActionType.RebootVm)) {
        return false;
    }
    for (VM vm : vms) {
        Version version = vm.getVdsGroupCompatibilityVersion();
        Version anyDcVersion = new Version();
        boolean compatibleCluster = isCommandCompatible(VdcActionType.RebootVm, version, anyDcVersion);
        boolean guestAgentPresent = !StringHelper.isNullOrEmpty(vm.getVmIp());
        boolean acpiEnabled = Boolean.TRUE.equals(vm.getAcpiEnable());
        if (!(compatibleCluster && (guestAgentPresent || acpiEnabled))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    if (volumeEntity == null) {
        return;
    }
    getNewSessionCommand().setIsAvailable(volumeEntity == null);
    getRemoveSessionCommand().setIsAvailable(false);
    getStartSessionCommand().setIsAvailable(false);
    getStopSessionCommand().setIsAvailable(false);
    getSessionOptionsCommand().setIsAvailable(false);
    getViewSessionDetailsCommand().setIsAvailable(false);
}
#method_after
private void updateActionAvailability(GlusterVolumeEntity volumeEntity) {
    boolean allowNewGeoRepSessionCommand = true;
    boolean allowStartSessionCommand = false;
    boolean allowStopSessionCommand = false;
    boolean allowResumeSessionCommand = false;
    boolean allowPauseSessionCommand = false;
    boolean allowSessionOptionsCommand = false;
    boolean allowRemoveSessionCommand = false;
    if (volumeEntity == null) {
        return;
    }
    if (getSelectedItems() != null && getSelectedItems().size() == 1) {
        GlusterGeoRepSession selectedSession = getSelectedItem();
        GeoRepSessionStatus sessionStatus = selectedSession.getStatus();
        allowStartSessionCommand = sessionStatus == GeoRepSessionStatus.NOTSTARTED || sessionStatus == GeoRepSessionStatus.STOPPED;
        allowStopSessionCommand = !allowStartSessionCommand;
        allowResumeSessionCommand = sessionStatus == GeoRepSessionStatus.PAUSED;
        allowPauseSessionCommand = sessionStatus == GeoRepSessionStatus.ACTIVE || sessionStatus == GeoRepSessionStatus.INITIALIZING;
        allowSessionOptionsCommand = true;
        allowNewGeoRepSessionCommand = volumeEntity.getStatus() == GlusterStatus.UP;
        allowRemoveSessionCommand = true;
    }
    getNewSessionCommand().setIsExecutionAllowed(allowNewGeoRepSessionCommand);
    getRemoveSessionCommand().setIsExecutionAllowed(allowRemoveSessionCommand);
    getStartSessionCommand().setIsExecutionAllowed(allowStartSessionCommand);
    getStopSessionCommand().setIsExecutionAllowed(allowStopSessionCommand);
    getPauseSessionCommand().setIsExecutionAllowed(allowPauseSessionCommand);
    getResumeSessionCommand().setIsExecutionAllowed(allowResumeSessionCommand);
    getSessionOptionsCommand().setIsExecutionAllowed(allowSessionOptionsCommand);
    getViewSessionDetailsCommand().setIsAvailable(false);
    getRefreshSessionsCommand().setIsAvailable(true);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createNewGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
    } else if (command.equals(getStartSessionCommand())) {
    } else if (command.equals(getStopSessionCommand())) {
    } else if (command.equals(getSessionOptionsCommand())) {
    } else if (command.equals(getViewSessionDetailsCommand())) {
    } else if (command.getName().equalsIgnoreCase("createSession")) {
        // $NON-NLS-1$
        setWindow(null);
    // Action to follow in next patch
    } else if (command.getName().equalsIgnoreCase("close")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewSessionCommand())) {
        createGeoRepSession();
    } else if (command.equals(getRemoveSessionCommand())) {
        removeGeoRepSession();
    } else if (command.equals(getStartSessionCommand())) {
        startGeoRepSession();
    } else if (command.equals(getStopSessionCommand())) {
        stopGeoRepSession();
    } else if (command.equals(getPauseSessionCommand())) {
        pauseGeoRepSession();
    } else if (command.equals(getResumeSessionCommand())) {
        resumeGeoRepSession();
    } else if (command.equals(getSessionOptionsCommand())) {
        showSessionOptions();
    } else if (command.equals(getViewSessionDetailsCommand())) {
    } else if (command.equals(getRefreshSessionsCommand())) {
        refreshSessions();
    } else if (command.getName().equalsIgnoreCase("onCreateSession")) {
        // $NON-NLS-1$
        onCreateSession();
    } else if (command.getName().equalsIgnoreCase("onStartGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StartGlusterVolumeGeoRep);
    } else if (command.getName().equalsIgnoreCase("onStopGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.StopGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onPauseGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.PauseGlusterVolumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onResumeGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.ResumeGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("onRemoveGeoRepSession")) {
        // $NON-NLS-1$
        onGeoRepSessionAction(VdcActionType.DeleteGeoRepSession);
    } else if (command.getName().equalsIgnoreCase("ok")) {
        // $NON-NLS-1$
        updateConfig();
    } else if (command.getName().equalsIgnoreCase("closeWindow")) {
        // $NON-NLS-1$
        closeWindow();
    } else if (command.getName().equalsIgnoreCase("closeConfirmWindow")) {
        // $NON-NLS-1$
        closeConfirmWindow();
    }
}
#end_block

#method_before
public void setEntity(GlusterVolumeEntity value) {
    super.setEntity(value);
}
#method_after
@Override
public void setEntity(GlusterVolumeEntity value) {
    super.setEntity(value);
    updateActionAvailability(value);
}
#end_block

#method_before
private void initEditors() {
    overrideSuggestedConfig = new EntityModelCheckBoxEditor(Align.RIGHT);
    startSessionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    slaveClusterEditor = new ListModelTypeAheadListBoxEditor<String>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<String>() {

        @Override
        public String getReplacementStringNullSafe(String data) {
            return data;
        }

        @Override
        public String getDisplayStringNullSafe(String data) {
            return templates.typeAheadNameDescription(data == null ? constants.empty() : data, constants.empty()).asString();
        }
    });
    slaveHostIpEditor = new ListModelTypeAheadListBoxEditor<String>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<String>() {

        @Override
        public String getReplacementStringNullSafe(String data) {
            return data;
        }

        @Override
        public String getDisplayStringNullSafe(String data) {
            return templates.typeAheadNameDescription(data == null ? constants.empty() : data, constants.empty()).asString();
        }
    });
    slaveVolumeEditor = new ListModelTypeAheadListBoxEditor<GlusterVolumeEntity>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<GlusterVolumeEntity>() {

        @Override
        public String getReplacementStringNullSafe(GlusterVolumeEntity data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(GlusterVolumeEntity data) {
            return templates.typeAheadNameDescription(data.getName() == null ? constants.empty() : data.getName(), data.getVdsGroupName() == null ? constants.empty() : data.getVdsGroupName()).asString();
        }
    });
}
#method_after
private void initEditors() {
    showEligibleVolumes = new EntityModelCheckBoxEditor(Align.RIGHT);
    startSessionEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    slaveClusterEditor = new ListModelTypeAheadListBoxEditor<String>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<String>() {

        @Override
        public String getReplacementStringNullSafe(String data) {
            return data;
        }

        @Override
        public String getDisplayStringNullSafe(String data) {
            return templates.typeAheadNameDescription(data == null ? constants.empty() : data, constants.empty()).asString();
        }
    });
    slaveHostIpEditor = new ListModelTypeAheadListBoxEditor<String>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<String>() {

        @Override
        public String getReplacementStringNullSafe(String data) {
            return data;
        }

        @Override
        public String getDisplayStringNullSafe(String data) {
            return templates.typeAheadNameDescription(data == null ? constants.empty() : data, constants.empty()).asString();
        }
    });
    slaveVolumeEditor = new ListModelTypeAheadListBoxEditor<GlusterVolumeEntity>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<GlusterVolumeEntity>() {

        @Override
        public String getReplacementStringNullSafe(GlusterVolumeEntity data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(GlusterVolumeEntity data) {
            return templates.typeAheadNameDescription(data.getName() == null ? constants.empty() : data.getName(), data.getVdsGroupName() == null ? constants.empty() : data.getVdsGroupName()).asString();
        }
    });
}
#end_block

#method_before
private void addStyles() {
    overrideSuggestedConfig.addContentWidgetStyleName(style.checkBoxEditorWidget());
    startSessionEditor.addContentWidgetStyleName(style.checkBoxEditorWidget());
    suggestedConfigViolations.setReadOnly(true);
}
#method_after
private void addStyles() {
    showEligibleVolumes.addContentWidgetContainerStyleName(style.checkBoxEditorWidget());
    startSessionEditor.addContentWidgetContainerStyleName(style.checkBoxEditorWidget());
    suggestedConfigViolations.setEnabled(false);
}
#end_block

#method_before
private void localize() {
    slaveHostIpEditor.setLabel(constants.geoRepSlaveHostIp());
    slaveHostRootPasswordEditor.setLabel(constants.geoRepSlaveNodePassword());
    slaveClusterEditor.setLabel(constants.volumeClusterVolume());
    slaveVolumeEditor.setLabel(constants.geoRepSlaveVolume());
    overrideSuggestedConfig.setLabel(constants.geoRepOverrideSuggestedConfig());
    slaveUserName.setLabel(constants.geoRepSessionUserName());
    startSessionEditor.setLabel(constants.geoRepSessionCreateAndStart());
}
#method_after
private void localize() {
    slaveHostIpEditor.setLabel(constants.geoRepSlaveHostIp());
    slaveClusterEditor.setLabel(constants.geoRepSessionSlaveCluster());
    slaveVolumeEditor.setLabel(constants.geoRepSlaveVolume());
    showEligibleVolumes.setLabel(constants.geoRepShowEligibleVolumes());
    slaveUserName.setLabel(constants.geoRepSessionUserName());
    slaveUserGroupNameEditor.setLabel(constants.slaveUserGroupName());
    startSessionEditor.setLabel(constants.geoRepSessionCreateAndStart());
}
#end_block

#method_before
@Override
public void edit(final GlusterVolumeGeoRepCreateModel object) {
    driver.edit(object);
    object.getSlaveVolumes().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            suggestedConfigurationViolation(object, object.getMasterVolume(), object.getSlaveVolumes().getSelectedItem());
        }
    });
}
#method_after
@Override
public void edit(final GlusterVolumeGeoRepCreateModel object) {
    driver.edit(object);
}
#end_block

#method_before
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVmFromDb();
            if (getParameters().isRemoveDisks()) {
                for (DiskImage image : diskImages) {
                    getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                    ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
                }
                getCompensationContext().stateChanged();
            } else {
                for (DiskImage image : diskImages) {
                    getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
                }
            }
            return null;
        }
    });
    Collection<DiskImage> unremovedDisks = Collections.emptyList();
    if (getParameters().isRemoveDisks()) {
        if (!diskImages.isEmpty()) {
            unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        }
        unremovedDisks.addAll(failedRemoveCinderDisks);
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#method_after
private boolean removeVm() {
    final List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskList(), true, false, true);
    for (VmNic nic : getInterfaces()) {
        new ExternalNetworkManager(nic).deallocateIfExternal();
    }
    removeMemoryVolumes();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            removeVmFromDb();
            if (getParameters().isRemoveDisks()) {
                for (DiskImage image : diskImages) {
                    getCompensationContext().snapshotEntityStatus(image.getImage(), ImageStatus.ILLEGAL);
                    ImagesHandler.updateImageStatus(image.getImage().getId(), ImageStatus.LOCKED);
                }
                getCompensationContext().stateChanged();
            } else {
                for (DiskImage image : diskImages) {
                    getImageDao().updateImageVmSnapshotId(image.getImageId(), null);
                }
            }
            return null;
        }
    });
    if (getParameters().isRemoveDisks() && !diskImages.isEmpty()) {
        Collection<DiskImage> unremovedDisks = (Collection<DiskImage>) removeVmImages(diskImages).getActionReturnValue();
        if (!unremovedDisks.isEmpty()) {
            processUnremovedDisks(unremovedDisks);
            return false;
        }
    }
    vmDeleted.fire(getVmId());
    return true;
}
#end_block

#method_before
protected void removeVmFromDb() {
    removeLunDisks();
    removeCinderDisks();
    removeVmUsers();
    removeVmNetwork();
    removeVmSnapshots();
    removeVmStatic(getParameters().isRemovePermissions());
}
#method_after
protected void removeVmFromDb() {
    removeLunDisks();
    removeVmUsers();
    removeVmNetwork();
    removeVmSnapshots();
    removeVmStatic(getParameters().isRemovePermissions());
}
#end_block

#method_before
private void processUnremovedDisks(Collection<? extends DiskImage> diskImages) {
    List<String> disksLeftInVm = new ArrayList<>();
    for (DiskImage diskImage : diskImages) {
        disksLeftInVm.add(diskImage.getDiskAlias());
    }
    addCustomValue("DisksNames", StringUtils.join(disksLeftInVm, ","));
}
#method_after
private void processUnremovedDisks(Collection<DiskImage> diskImages) {
    List<String> disksLeftInVm = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        disksLeftInVm.add(diskImage.getDiskAlias());
    }
    addCustomValue("DisksNames", StringUtils.join(disksLeftInVm, ","));
}
#end_block

