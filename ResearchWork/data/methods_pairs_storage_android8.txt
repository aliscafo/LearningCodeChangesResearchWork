443
#method_before
private static byte[] toSequence(Object container, boolean isUnencodedContainer) throws Asn1EncodingException {
    Class<?> containerClass = container.getClass();
    List<AnnotatedField> fields = getAnnotatedFields(container);
    Collections.sort(fields, (f1, f2) -> f1.getAnnotation().index() - f2.getAnnotation().index());
    if (fields.size() > 1) {
        AnnotatedField lastField = null;
        for (AnnotatedField field : fields) {
            if ((lastField != null) && (lastField.getAnnotation().index() == field.getAnnotation().index())) {
                throw new Asn1EncodingException("Fields have the same index: " + containerClass.getName() + "." + lastField.getField().getName() + " and ." + field.getField().getName());
            }
            lastField = field;
        }
    }
    List<byte[]> serializedFields = new ArrayList<>(fields.size());
    int contentLen = 0;
    for (AnnotatedField field : fields) {
        byte[] serializedField;
        try {
            serializedField = field.toDer();
        } catch (Asn1EncodingException e) {
            throw new Asn1EncodingException("Failed to encode " + containerClass.getName() + "." + field.getField().getName(), e);
        }
        if (serializedField != null) {
            serializedFields.add(serializedField);
            contentLen += serializedField.length;
        }
    }
    if (isUnencodedContainer) {
        byte[] unencodedResult = new byte[contentLen];
        int index = 0;
        for (byte[] serializedField : serializedFields) {
            System.arraycopy(serializedField, 0, unencodedResult, index, serializedField.length);
            index += serializedField.length;
        }
        return unencodedResult;
    } else {
        return createTag(BerEncoding.TAG_CLASS_UNIVERSAL, true, BerEncoding.TAG_NUMBER_SEQUENCE, serializedFields.toArray(new byte[0][]));
    }
}
#method_after
private static byte[] toSequence(Object container, boolean omitTag) throws Asn1EncodingException {
    Class<?> containerClass = container.getClass();
    List<AnnotatedField> fields = getAnnotatedFields(container);
    Collections.sort(fields, (f1, f2) -> f1.getAnnotation().index() - f2.getAnnotation().index());
    if (fields.size() > 1) {
        AnnotatedField lastField = null;
        for (AnnotatedField field : fields) {
            if ((lastField != null) && (lastField.getAnnotation().index() == field.getAnnotation().index())) {
                throw new Asn1EncodingException("Fields have the same index: " + containerClass.getName() + "." + lastField.getField().getName() + " and ." + field.getField().getName());
            }
            lastField = field;
        }
    }
    List<byte[]> serializedFields = new ArrayList<>(fields.size());
    int contentLen = 0;
    for (AnnotatedField field : fields) {
        byte[] serializedField;
        try {
            serializedField = field.toDer();
        } catch (Asn1EncodingException e) {
            throw new Asn1EncodingException("Failed to encode " + containerClass.getName() + "." + field.getField().getName(), e);
        }
        if (serializedField != null) {
            serializedFields.add(serializedField);
            contentLen += serializedField.length;
        }
    }
    if (omitTag) {
        byte[] unencodedResult = new byte[contentLen];
        int index = 0;
        for (byte[] serializedField : serializedFields) {
            System.arraycopy(serializedField, 0, unencodedResult, index, serializedField.length);
            index += serializedField.length;
        }
        return unencodedResult;
    } else {
        return createTag(BerEncoding.TAG_CLASS_UNIVERSAL, true, BerEncoding.TAG_NUMBER_SEQUENCE, serializedFields.toArray(new byte[0][]));
    }
}
#end_block

#method_before
// BEGIN Android-removed: Debugging support unused on Android.
public int getHandleKind() {
    return handleKind;
}
#method_after
// BEGIN Android-removed: Debugging support unused on Android.
/*
    /** Return a string with a several lines describing the method handle structure.
     *  This string would be suitable for display in an IDE debugger.
     *
    String debugString() {
        return type+" : "+internalForm()+internalProperties();
    }
    */
// END Android-removed: Debugging support unused on Android.
// BEGIN Android-added: Android specific implementation.
public int getHandleKind() {
    return handleKind;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private void initControllerView(ViewGroup v) {
    mWindowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
    mIconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    // Relating to Title Bar View
    mTitleBar = v.findViewById(R.id.title_bar);
    mTitleView = v.findViewById(R.id.title_text);
    mAdExternalLink = v.findViewById(R.id.ad_external_link);
    mBackButton = v.findViewById(R.id.back);
    if (mBackButton != null) {
        mBackButton.setOnClickListener(mBackListener);
        mBackButton.setVisibility(View.GONE);
    }
    mRouteButton = v.findViewById(R.id.cast);
    // Relating to Center View
    mCenterView = v.findViewById(R.id.center_view);
    mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
    mCenterView.addView(mTransportControls);
    // Relating to Minimal Size FullScreen View. This view is visible only when the current
    // size type is Minimal and it is a view that stretches from left to right end
    // and helps locate the fullscreen button at the right end of the screen.
    mMinimalSizeFullScreenView = (LinearLayout) v.findViewById(R.id.minimal_fullscreen_view);
    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) mMinimalSizeFullScreenView.getLayoutParams();
    int iconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    params.setMargins(0, iconSize * (-1), 0, 0);
    mMinimalSizeFullScreenView.setLayoutParams(params);
    mMinimalSizeFullScreenView.setVisibility(View.GONE);
    // Relating to Progress Bar View
    mProgressBar = v.findViewById(R.id.progress_bar);
    mProgress = v.findViewById(R.id.progress);
    if (mProgress != null) {
        if (mProgress instanceof SeekBar) {
            SeekBar seeker = (SeekBar) mProgress;
            seeker.setOnSeekBarChangeListener(mSeekListener);
            seeker.setProgressDrawable(mResources.getDrawable(R.drawable.custom_progress));
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
        }
        mProgress.setMax(MAX_PROGRESS);
    }
    mProgressBuffer = v.findViewById(R.id.progress_buffer);
    mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
    mNextSeekPosition = SEEK_POSITION_NOT_SET;
    // Relating to Bottom Bar View
    mBottomBar = v.findViewById(R.id.bottom_bar);
    // Relating to Bottom Bar Left View
    mBottomBarLeftView = v.findViewById(R.id.bottom_bar_left);
    mTimeView = v.findViewById(R.id.time);
    mEndTime = v.findViewById(R.id.time_end);
    mCurrentTime = v.findViewById(R.id.time_current);
    mAdSkipView = v.findViewById(R.id.ad_skip_time);
    mFormatBuilder = new StringBuilder();
    mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
    // Relating to Bottom Bar Right View
    mBasicControls = v.findViewById(R.id.basic_controls);
    mExtraControls = v.findViewById(R.id.extra_controls);
    mCustomButtons = v.findViewById(R.id.custom_buttons);
    mSubtitleButton = v.findViewById(R.id.subtitle);
    if (mSubtitleButton != null) {
        mSubtitleButton.setOnClickListener(mSubtitleListener);
    }
    mFullScreenButton = v.findViewById(R.id.fullscreen);
    if (mFullScreenButton != null) {
        mFullScreenButton.setOnClickListener(mFullScreenListener);
    }
    mOverflowShowButton = v.findViewById(R.id.overflow_show);
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setOnClickListener(mOverflowShowListener);
    }
    mOverflowHideButton = v.findViewById(R.id.overflow_hide);
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setOnClickListener(mOverflowHideListener);
    }
    mSettingsButton = v.findViewById(R.id.settings);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
    }
    mVideoQualityButton = v.findViewById(R.id.video_quality);
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setOnClickListener(mVideoQualityListener);
    }
    mAdRemainingView = v.findViewById(R.id.ad_remaining);
    // Relating to Settings List View
    initializeSettingsLists();
    mSettingsListView = (ListView) inflateLayout(getContext(), R.layout.settings_list);
    mSettingsAdapter = new SettingsAdapter(mSettingsMainTextsList, mSettingsSubTextsList, mSettingsIconIdsList);
    mSubSettingsAdapter = new SubSettingsAdapter(null, 0);
    mSettingsListView.setAdapter(mSettingsAdapter);
    mSettingsListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    mSettingsListView.setOnItemClickListener(mSettingsItemClickListener);
    mEmbeddedSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_settings_width);
    mFullSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_full_settings_width);
    mSettingsItemHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_settings_height);
    mSettingsWindowMargin = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_settings_offset);
    mSettingsWindow = new PopupWindow(mSettingsListView, mEmbeddedSettingsItemWidth, LayoutParams.WRAP_CONTENT, true);
    mSettingsWindow.setOnDismissListener(mSettingsDismissListener);
    int titleBarTranslateY = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_title_bar_height);
    int bottomBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_bottom_bar_height);
    int progressThumbHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size);
    int progressBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_max_size);
    int bottomBarTranslateY = bottomBarHeight + progressThumbHeight / 2 - progressBarHeight / 2;
    ValueAnimator fadeOutAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    fadeOutAnimator.setInterpolator(new LinearInterpolator());
    fadeOutAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                LayerDrawable thumb = (LayerDrawable) seekBar.getThumb();
                if (thumb != null) {
                    Drawable drawable = thumb.getDrawable(0);
                    if (drawable instanceof ScaleDrawable) {
                        thumb.setLevel((int) (10000 * alpha));
                    }
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.GONE);
            } else if (alpha == 1.0f) {
                setEnabled(false);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.GONE);
                    mProgressBar.setVisibility(View.GONE);
                }
            }
        }
    });
    ValueAnimator fadeInAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    fadeInAnimator.setInterpolator(new LinearInterpolator());
    fadeInAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                LayerDrawable thumb = (LayerDrawable) seekBar.getThumb();
                if (thumb != null) {
                    Drawable drawable = thumb.getDrawable(0);
                    if (drawable instanceof ScaleDrawable) {
                        thumb.setLevel((int) (10000 * (alpha)));
                    }
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.VISIBLE);
            } else if (alpha == 1.0f) {
                setEnabled(true);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.VISIBLE);
                    mProgressBar.setVisibility(View.VISIBLE);
                }
            }
        }
    });
    mHideMainBarsAnimator = new AnimatorSet();
    mHideMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY)).with(fadeOutAnimator);
    mHideMainBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ONLY_PROGRESS_VISIBLE;
        }
    });
    mHideProgressBarAnimator = new AnimatorSet();
    mHideProgressBarAnimator.play(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight));
    mHideProgressBarAnimator.setDuration(HIDE_TIME_MS);
    mHideProgressBarAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mHideAllBarsAnimator = new AnimatorSet();
    mHideAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(fadeOutAnimator);
    mHideAllBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mShowMainBarsAnimator = new AnimatorSet();
    mShowMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, 0)).with(fadeInAnimator);
    mShowMainBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mShowAllBarsAnimator = new AnimatorSet();
    mShowAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(fadeInAnimator);
    mShowAllBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mOverflowShowAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    mOverflowShowAnimator.setDuration(SHOW_TIME_MS);
    mOverflowShowAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowShowAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mExtraControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.GONE);
            mOverflowHideButton.setVisibility(View.VISIBLE);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mBasicControls.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.GONE);
            }
        }
    });
    mOverflowHideAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    mOverflowHideAnimator.setDuration(SHOW_TIME_MS);
    mOverflowHideAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowHideAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mBasicControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.VISIBLE);
            mOverflowHideButton.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mExtraControls.setVisibility(View.GONE);
        }
    });
}
#method_after
@SuppressWarnings("deprecation")
private void initControllerView(ViewGroup v) {
    mWindowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
    mIconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    // Relating to Title Bar View
    mTitleBar = v.findViewById(R.id.title_bar);
    mTitleView = v.findViewById(R.id.title_text);
    mAdExternalLink = v.findViewById(R.id.ad_external_link);
    mBackButton = v.findViewById(R.id.back);
    if (mBackButton != null) {
        mBackButton.setOnClickListener(mBackListener);
        mBackButton.setVisibility(View.GONE);
    }
    mRouteButton = v.findViewById(R.id.cast);
    // Relating to Center View
    mCenterView = v.findViewById(R.id.center_view);
    mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
    mCenterView.addView(mTransportControls);
    // Relating to Minimal Size FullScreen View. This view is visible only when the current
    // size type is Minimal and it is a view that stretches from left to right end
    // and helps locate the fullscreen button at the right end of the screen.
    mMinimalSizeFullScreenView = (LinearLayout) v.findViewById(R.id.minimal_fullscreen_view);
    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) mMinimalSizeFullScreenView.getLayoutParams();
    int iconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    params.setMargins(0, iconSize * (-1), 0, 0);
    mMinimalSizeFullScreenView.setLayoutParams(params);
    mMinimalSizeFullScreenView.setVisibility(View.GONE);
    // Relating to Progress Bar View
    mProgressBar = v.findViewById(R.id.progress_bar);
    mProgress = v.findViewById(R.id.progress);
    if (mProgress != null) {
        if (mProgress instanceof SeekBar) {
            SeekBar seeker = (SeekBar) mProgress;
            seeker.setOnSeekBarChangeListener(mSeekListener);
            seeker.setProgressDrawable(mResources.getDrawable(R.drawable.custom_progress));
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
            seeker.setThumbOffset(0);
        }
        mProgress.setMax(MAX_PROGRESS);
    }
    mProgressBuffer = v.findViewById(R.id.progress_buffer);
    mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
    mNextSeekPosition = SEEK_POSITION_NOT_SET;
    // Relating to Bottom Bar View
    mBottomBar = v.findViewById(R.id.bottom_bar);
    // Relating to Bottom Bar Left View
    mBottomBarLeftView = v.findViewById(R.id.bottom_bar_left);
    mTimeView = v.findViewById(R.id.time);
    mEndTime = v.findViewById(R.id.time_end);
    mCurrentTime = v.findViewById(R.id.time_current);
    mAdSkipView = v.findViewById(R.id.ad_skip_time);
    mFormatBuilder = new StringBuilder();
    mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
    // Relating to Bottom Bar Right View
    mBasicControls = v.findViewById(R.id.basic_controls);
    mExtraControls = v.findViewById(R.id.extra_controls);
    mCustomButtons = v.findViewById(R.id.custom_buttons);
    mSubtitleButton = v.findViewById(R.id.subtitle);
    if (mSubtitleButton != null) {
        mSubtitleButton.setOnClickListener(mSubtitleListener);
    }
    mFullScreenButton = v.findViewById(R.id.fullscreen);
    if (mFullScreenButton != null) {
        mFullScreenButton.setOnClickListener(mFullScreenListener);
    }
    mOverflowShowButton = v.findViewById(R.id.overflow_show);
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setOnClickListener(mOverflowShowListener);
    }
    mOverflowHideButton = v.findViewById(R.id.overflow_hide);
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setOnClickListener(mOverflowHideListener);
    }
    mSettingsButton = v.findViewById(R.id.settings);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
    }
    mVideoQualityButton = v.findViewById(R.id.video_quality);
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setOnClickListener(mVideoQualityListener);
    }
    mAdRemainingView = v.findViewById(R.id.ad_remaining);
    // Relating to Settings List View
    initializeSettingsLists();
    mSettingsListView = (ListView) inflateLayout(getContext(), R.layout.settings_list);
    mSettingsAdapter = new SettingsAdapter(mSettingsMainTextsList, mSettingsSubTextsList, mSettingsIconIdsList);
    mSubSettingsAdapter = new SubSettingsAdapter(null, 0);
    mSettingsListView.setAdapter(mSettingsAdapter);
    mSettingsListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    mSettingsListView.setOnItemClickListener(mSettingsItemClickListener);
    mEmbeddedSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_settings_width);
    mFullSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_full_settings_width);
    mSettingsItemHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_settings_height);
    mSettingsWindowMargin = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_settings_offset);
    mSettingsWindow = new PopupWindow(mSettingsListView, mEmbeddedSettingsItemWidth, LayoutParams.WRAP_CONTENT, true);
    mSettingsWindow.setOnDismissListener(mSettingsDismissListener);
    int titleBarTranslateY = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_title_bar_height);
    int bottomBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_bottom_bar_height);
    int progressThumbHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size);
    int progressBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_max_size);
    int bottomBarTranslateY = bottomBarHeight + progressThumbHeight / 2 - progressBarHeight / 2;
    ValueAnimator fadeOutAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    fadeOutAnimator.setInterpolator(new LinearInterpolator());
    fadeOutAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                ScaleDrawable thumb = (ScaleDrawable) seekBar.getThumb();
                if (thumb != null) {
                    thumb.setLevel((int) (MAX_SCALE_LEVEL * alpha));
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.GONE);
            } else if (alpha == 1.0f) {
                setEnabled(false);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.GONE);
                    mProgressBar.setVisibility(View.GONE);
                }
            }
        }
    });
    ValueAnimator fadeInAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    fadeInAnimator.setInterpolator(new LinearInterpolator());
    fadeInAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                ScaleDrawable thumb = (ScaleDrawable) seekBar.getThumb();
                if (thumb != null) {
                    thumb.setLevel((int) (MAX_SCALE_LEVEL * alpha));
                }
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.VISIBLE);
            } else if (alpha == 1.0f) {
                setEnabled(true);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.VISIBLE);
                    mProgressBar.setVisibility(View.VISIBLE);
                }
            }
        }
    });
    mHideMainBarsAnimator = new AnimatorSet();
    mHideMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY)).with(fadeOutAnimator);
    mHideMainBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ONLY_PROGRESS_VISIBLE;
        }
    });
    mHideProgressBarAnimator = new AnimatorSet();
    mHideProgressBarAnimator.play(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight));
    mHideProgressBarAnimator.setDuration(HIDE_TIME_MS);
    mHideProgressBarAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mHideAllBarsAnimator = new AnimatorSet();
    mHideAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(fadeOutAnimator);
    mHideAllBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mShowMainBarsAnimator = new AnimatorSet();
    mShowMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, 0)).with(fadeInAnimator);
    mShowMainBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mShowAllBarsAnimator = new AnimatorSet();
    mShowAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(fadeInAnimator);
    mShowAllBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mOverflowShowAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    mOverflowShowAnimator.setDuration(SHOW_TIME_MS);
    mOverflowShowAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowShowAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mExtraControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.GONE);
            mOverflowHideButton.setVisibility(View.VISIBLE);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mBasicControls.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.GONE);
            }
        }
    });
    mOverflowHideAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    mOverflowHideAnimator.setDuration(SHOW_TIME_MS);
    mOverflowHideAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowHideAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mBasicControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.VISIBLE);
            mOverflowHideButton.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mExtraControls.setVisibility(View.GONE);
        }
    });
}
#end_block

#method_before
@Override
public void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    setContentView(R.layout.activity_card_layout);
    mViewPager = findViewById(R.id.view_pager);
    mValueSelector = findViewById(R.id.value_spinner);
    mSuitSelector = findViewById(R.id.suit_spinner);
    mSmoothScrollCheckBox = findViewById(R.id.smooth_scroll_checkbox);
    mRotateCheckBox = findViewById(R.id.rotate_checkbox);
    mTranslateCheckBox = findViewById(R.id.translate_checkbox);
    mScaleCheckBox = findViewById(R.id.scale_checkbox);
    mGotoPage = findViewById(R.id.jump_button);
    mValueSelector.setAdapter(createAdapter(Card.VALUES));
    mSuitSelector.setAdapter(createAdapter(Card.SUITS));
    mViewPager.setPageTransformer(false, mAnimator);
    mGotoPage.setOnClickListener(view -> {
        int suit = mSuitSelector.getSelectedItemPosition();
        int value = mValueSelector.getSelectedItemPosition();
        int targetPosition = suit * Card.VALUES.size() + value;
        boolean smoothScroll = mSmoothScrollCheckBox.isChecked();
        mViewPager.setCurrentItem(targetPosition, smoothScroll);
    });
}
#method_after
@Override
public void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    setContentView(R.layout.activity_card_layout);
    mViewPager = findViewById(R.id.view_pager);
    mOrientationSelector = findViewById(R.id.orientation_spinner);
    mValueSelector = findViewById(R.id.value_spinner);
    mSuitSelector = findViewById(R.id.suit_spinner);
    mSmoothScrollCheckBox = findViewById(R.id.smooth_scroll_checkbox);
    mRotateCheckBox = findViewById(R.id.rotate_checkbox);
    mTranslateCheckBox = findViewById(R.id.translate_checkbox);
    mScaleCheckBox = findViewById(R.id.scale_checkbox);
    mGotoPage = findViewById(R.id.jump_button);
    mOrientationSelector.setAdapter(createOrientationAdapter());
    mValueSelector.setAdapter(createAdapter(Card.VALUES));
    mSuitSelector.setAdapter(createAdapter(Card.SUITS));
    mViewPager.setPageTransformer(mAnimator);
    mOrientationSelector.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            switch(parent.getSelectedItem().toString()) {
                case HORIZONTAL:
                    mViewPager.setOrientation(Orientation.HORIZONTAL);
                    break;
                case VERTICAL:
                    mViewPager.setOrientation(Orientation.VERTICAL);
                    break;
            }
        }

        @Override
        public void onNothingSelected(AdapterView<?> adapterView) {
        }
    });
    mGotoPage.setOnClickListener(view -> {
        int suit = mSuitSelector.getSelectedItemPosition();
        int value = mValueSelector.getSelectedItemPosition();
        int targetPosition = suit * Card.VALUES.size() + value;
        boolean smoothScroll = mSmoothScrollCheckBox.isChecked();
        mViewPager.setCurrentItem(targetPosition, smoothScroll);
    });
}
#end_block

#method_before
private int getShade(Card card) {
    switch(card.getValue()) {
        case '2':
        case '6':
        case '⒑':
        case 'A':
            return 2;
        case '3':
        case '7':
        case 'J':
            return 3;
        case '4':
        case '8':
        case 'Q':
            return 0;
        case '5':
        case '9':
        case 'K':
            return 1;
    }
    return 2;
}
#method_after
private int getShade(Card card) {
    switch(card.getValue()) {
        case '2':
        case '6':
        case '⒑':
        case 'A':
            return 2;
        case '3':
        case '7':
        case 'J':
            return 3;
        case '4':
        case '8':
        case 'Q':
            return 0;
        case '5':
        case '9':
        case 'K':
            return 1;
    }
    throw new IllegalStateException(String.format("Card value cannot be %c (0x%X)", card.getValue(), (int) card.getValue()));
}
#end_block

#method_before
private int getColor(Card card) {
    switch(card.getSuit()) {
        case '♣':
            return 0;
        case '♦':
            return 1;
        case '♥':
            return 2;
        case '♠':
            return 3;
    }
    return 3;
}
#method_after
private int getColor(Card card) {
    switch(card.getSuit()) {
        case '♣':
            return 0;
        case '♦':
            return 1;
        case '♥':
            return 2;
        case '♠':
            return 3;
    }
    throw new IllegalStateException(String.format("Card suit cannot be %c (0x%X)", card.getSuit(), (int) card.getSuit()));
}
#end_block

#method_before
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    int position = getPosition();
    View firstVisibleView = mLayoutManager.findViewByPosition(position);
    if (firstVisibleView == null) {
        return;
    }
    boolean isHorizontal = mLayoutManager.getOrientation() == ViewPager2.Orientation.HORIZONTAL;
    int start, end;
    if (isHorizontal) {
        start = firstVisibleView.getLeft();
        end = firstVisibleView.getRight();
    } else {
        start = firstVisibleView.getTop();
        end = firstVisibleView.getBottom();
    }
    int sizePx = end - start;
    int visiblePx = Math.max(0, Math.min(sizePx, end) - Math.max(0, start));
    int offsetPx = sizePx - visiblePx;
    float offset = sizePx == 0 ? 0 : (float) offsetPx / sizePx;
    if (mDispatchSelected) {
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? position + 1 : position;
        if (mInitialPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(position, offset, offsetPx);
    if (position == mTarget && offsetPx == 0) {
        dispatchStateChanged(ViewPager2.ScrollState.IDLE);
        resetState();
    }
}
#method_after
@Override
public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
    mScrollHappened = true;
    int position = getPosition();
    View firstVisibleView = mLayoutManager.findViewByPosition(position);
    if (firstVisibleView == null) {
        return;
    }
    boolean isHorizontal = mLayoutManager.getOrientation() == ViewPager2.Orientation.HORIZONTAL;
    int start, end;
    if (isHorizontal) {
        start = firstVisibleView.getLeft();
        end = firstVisibleView.getRight();
    } else {
        start = firstVisibleView.getTop();
        end = firstVisibleView.getBottom();
    }
    int offsetPx = -start;
    if (offsetPx < 0) {
        throw new IllegalStateException(String.format("Page can only be offset by a positive " + "amount, not by %d", offsetPx));
    }
    int sizePx = end - start;
    float offset = sizePx == 0 ? 0 : (float) offsetPx / sizePx;
    if (mDispatchSelected) {
        mDispatchSelected = false;
        mTarget = (dx + dy > 0) ? position + 1 : position;
        if (mInitialPosition != mTarget) {
            dispatchSelected(mTarget);
        }
    }
    dispatchScrolled(position, offset, offsetPx);
    if (position == mTarget && offsetPx == 0) {
        dispatchStateChanged(ViewPager2.ScrollState.IDLE);
        resetState();
    }
}
#end_block

#method_before
private void dispatchScrolled(int position, float offset, int offsetPx) {
    if (mPageTransformAdapter != null) {
        mPageTransformAdapter.onPageScrolled(position, offset);
    }
    try {
        for (OnPageChangeListener listener : mListeners) {
            listener.onPageScrolled(position, offset, offsetPx);
        }
    } catch (ConcurrentModificationException ex) {
        throwListenerListModifiedWhileInUse(ex);
    }
}
#method_after
private void dispatchScrolled(int position, float offset, int offsetPx) {
    try {
        for (OnPageChangeListener listener : mListeners) {
            listener.onPageScrolled(position, offset, offsetPx);
        }
    } catch (ConcurrentModificationException ex) {
        throwListenerListModifiedWhileInUse(ex);
    }
    if (mPageTransformerAdapter != null) {
        mPageTransformerAdapter.onPageScrolled(position, offset);
    }
}
#end_block

#method_before
public void setPageTransformer(boolean reverseDrawingOrder, @Nullable PageTransformer transformer) {
    getPageTransformAdapter().setPageTransformer(reverseDrawingOrder, transformer);
}
#method_after
public void setPageTransformer(@Nullable PageTransformer transformer) {
    // TODO: add support for reverseDrawingOrder: b/112892792
    // TODO: add support for pageLayerType: b/112893074
    getPageTransformerAdapter().setPageTransformer(transformer);
}
#end_block

#method_before
void update() {
    if (mRouteForTouchedVolumeSlider != null || mRouteForClickedMuteButton != null) {
        mHasPendingUpdate = true;
        return;
    }
    mHasPendingUpdate = false;
    if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    if (mArtIconIsLoaded) {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            mArtView.setVisibility(View.GONE);
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        } else {
            mArtView.setVisibility(View.VISIBLE);
            mArtView.setImageBitmap(mArtIconLoadedBitmap);
            mArtView.setBackgroundColor(mArtIconBackgroundColor);
            mMetadataLayout.setBackgroundDrawable(new BitmapDrawable(mArtIconLoadedBitmap));
        }
        clearLoadedBitmap();
    } else {
        // Update metadata layout
        mArtView.setVisibility(View.GONE);
    }
    updateMetadataLayout();
}
#method_after
void update() {
    // in the process of selecting route.
    if (mRouteForTouchedVolumeSlider != null || mRouteForClickedMuteButton != null || mIsSelectingRoute) {
        mHasPendingUpdate = true;
        return;
    }
    mHasPendingUpdate = false;
    if (!mSelectedRoute.isSelected() || mSelectedRoute.isDefaultOrBluetooth()) {
        dismiss();
        return;
    }
    if (!mCreated) {
        return;
    }
    if (mArtIconIsLoaded) {
        if (isBitmapRecycled(mArtIconLoadedBitmap)) {
            mArtView.setVisibility(View.GONE);
            Log.w(TAG, "Can't set artwork image with recycled bitmap: " + mArtIconLoadedBitmap);
        } else {
            mArtView.setVisibility(View.VISIBLE);
            mArtView.setImageBitmap(mArtIconLoadedBitmap);
            mArtView.setBackgroundColor(mArtIconBackgroundColor);
            mMetadataLayout.setBackgroundDrawable(new BitmapDrawable(mArtIconLoadedBitmap));
        }
        clearLoadedBitmap();
    } else {
        // Update metadata layout
        mArtView.setVisibility(View.GONE);
    }
    updateMetadataLayout();
}
#end_block

#method_before
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mRouteForTouchedVolumeSlider to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_STOP_TRACKING_TOUCH), UPDATE_VOLUME_DELAY_MS);
}
#method_after
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mRouteForTouchedVolumeSlider to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    mHandler.sendEmptyMessageDelayed(MSG_STOP_TRACKING_TOUCH, UPDATE_VOLUME_DELAY_MS);
}
#end_block

#method_before
@Override
public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
    if (fromUser || mRouteForClickedMuteButton != null) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        MediaRouteVolumeSliderHolder holder = mVolumeSliderHolderMap.get(route.getId());
        if (holder != null) {
            boolean wasMuted = holder.getMuteButton().isActivated();
            if (wasMuted && progress > 0 || !wasMuted && progress == 0) {
                holder.toggleMute();
            }
        }
        route.requestSetVolume(progress);
        if (!fromUser) {
            // Defer resetting mRouteForClickedMuteButton to allow the media route provider
            // a little time to settle into its new state and publish the final
            // volume update.
            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_CLICK_MUTE_BUTTON), UPDATE_VOLUME_DELAY_MS);
        }
    }
}
#method_after
@Override
public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
    if (fromUser) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        MediaRouteVolumeSliderHolder holder = mVolumeSliderHolderMap.get(route.getId());
        if (holder != null) {
            holder.setMute(progress == MUTED_VOLUME);
        }
        route.requestSetVolume(progress);
    }
}
#end_block

#method_before
public void updateVolume() {
    MediaRouter.RouteInfo route = getRoute();
    ImageButton muteButton = getMuteButton();
    MediaRouteVolumeSlider volumeSlider = getVolumeSlider();
    int volume = route.getVolume();
    boolean isMuted = (volume == 0);
    muteButton.setActivated(isMuted);
    volumeSlider.setProgress(volume);
}
#method_after
void updateVolume() {
    int volume = mRoute.getVolume();
    setMute(volume == MUTED_VOLUME);
    mVolumeSlider.setProgress(volume);
}
#end_block

#method_before
int getUnmutedVolume() {
    MediaRouter.RouteInfo route = getRoute();
    Integer beforeMuteVolume = mBeforeMuteVolumeMap.get(route.getId());
    return (beforeMuteVolume == null) ? MIN_UNMUTED_VOLUME : Math.max(MIN_UNMUTED_VOLUME, beforeMuteVolume);
}
#method_after
int getUnmutedVolume() {
    Integer beforeMuteVolume = mBeforeMuteVolumeMap.get(mRoute.getId());
    return (beforeMuteVolume == null) ? MIN_UNMUTED_VOLUME : Math.max(MIN_UNMUTED_VOLUME, beforeMuteVolume);
}
#end_block

#method_before
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    int volume = route.getVolume();
    boolean isMuted = (volume == 0);
    mRoute = route;
    mTextView.setText(route.getName().toUpperCase());
    mMuteButton.setActivated(isMuted);
    mMuteButton.setOnClickListener(mMuteButtonClickListener);
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(volume);
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
}
#method_after
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    super.bindRouteVolumeSliderHolder(route);
    mTextView.setText(route.getName());
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    int volume = route.getVolume();
    boolean isMuted = (volume == 0);
    boolean selected = isSelectedRoute(route);
    mRoute = route;
    mImageView.setImageDrawable(getIconDrawable(route));
    mMuteButton.setActivated(isMuted);
    mMuteButton.setOnClickListener(mMuteButtonClickListener);
    mTextView.setText(route.getName());
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(route.getVolume());
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mSelectButton.setOnClickListener(mSelectButtonClickListener);
    // TODO(b/111624415): Make button works for both selected and unselected routes.
    if (selected) {
        mSelectButton.setSelected(true);
        mSelectButton.setEnabled(true);
    } else {
        mSelectButton.setEnabled(false);
    }
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    boolean selected = isSelectedRoute(route);
    super.bindRouteVolumeSliderHolder(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setChecked(false);
        mCheckBox.setEnabled(false);
    }
}
#end_block

#method_before
public void bindGroupViewHolder(Item item) {
    final MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mItemView.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            route.select();
        }
    });
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
}
#method_after
public void bindGroupViewHolder(Item item) {
    final MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    mRoute = route;
    mItemView.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            mIsSelectingRoute = true;
            mRoute.select();
        }
    });
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
}
#end_block

#method_before
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    mSelectedRoute = route;
    update();
}
#method_after
@Override
public void onRouteSelected(MediaRouter router, MediaRouter.RouteInfo route) {
    mSelectedRoute = route;
    mIsSelectingRoute = false;
    update();
}
#end_block

#method_before
@Override
public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    // Call refreshRoutes only when there's no volume update in progress.
    if (mRouteForTouchedVolumeSlider == null && mRouteForClickedMuteButton == null) {
        refreshRoutes();
    }
}
#method_after
@Override
public void onRouteChanged(MediaRouter router, MediaRouter.RouteInfo route) {
    // Call refreshRoutes only when there's no updating volume.
    if (mRouteForTouchedVolumeSlider == null && mRouteForClickedMuteButton == null) {
        refreshRoutes();
    }
}
#end_block

#method_before
@Override
public void onVideoSizeChanged(final int width, final int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            DataSourceDesc2 dataSourceDesc2;
            synchronized (mLock) {
                // TODO(b/80232248): get the active data source from a data source queue.
                dataSourceDesc2 = mDataSourceDescription;
                mVideoWidth = width;
                mVideoHeight = height;
            }
            callback.onVideoSizeChanged(ExoPlayerMediaPlayer2Impl.this, dataSourceDesc2, width, height);
        }
    });
}
#method_after
@Override
public void onVideoSizeChanged(final int width, final int height, int unappliedRotationDegrees, float pixelWidthHeightRatio) {
    final DataSourceDesc2 dataSourceDesc2;
    synchronized (mLock) {
        // TODO(b/80232248): get the active data source from a data source queue.
        dataSourceDesc2 = mDataSourceDescription;
        mVideoWidth = width;
        mVideoHeight = height;
    }
    notifyMediaPlayer2Event(new Mp2EventNotifier() {

        @Override
        public void notify(EventCallback callback) {
            callback.onVideoSizeChanged(ExoPlayerMediaPlayer2Impl.this, dataSourceDesc2, width, height);
        }
    });
}
#end_block

#method_before
void updateDescriptors(Collection<DynamicGroupRouteController.DynamicRouteDescriptor> dynamicDescriptors) {
    mMemberRoutes.clear();
    mUnselectableRoutes.clear();
    mGroupableRoutes.clear();
    mTransferableRoutes.clear();
    for (DynamicGroupRouteController.DynamicRouteDescriptor dynamicDescriptor : dynamicDescriptors) {
        if (dynamicDescriptor.isGroupable()) {
            mGroupableRoutes.add(dynamicDescriptor.getRouteDescriptor().getId());
        }
        if (dynamicDescriptor.isTransferable()) {
            mTransferableRoutes.add(dynamicDescriptor.getRouteDescriptor().getId());
        }
        if ((dynamicDescriptor.getSelectionState() == DynamicGroupRouteController.DynamicRouteDescriptor.SELECTING) || (dynamicDescriptor.getSelectionState() == DynamicGroupRouteController.DynamicRouteDescriptor.SELECTED)) {
            mMemberRoutes.add(dynamicDescriptor.getRouteDescriptor().getId());
            if (dynamicDescriptor.isUnselectable()) {
                mUnselectableRoutes.add(dynamicDescriptor.getRouteDescriptor().getId());
            }
        }
    }
}
#method_after
void updateDescriptors(Collection<DynamicRouteDescriptor> dynamicDescriptors) {
    mMemberRoutes.clear();
    mUnselectableRoutes.clear();
    mGroupableRoutes.clear();
    mTransferableRoutes.clear();
    for (DynamicRouteDescriptor dynamicDescriptor : dynamicDescriptors) {
        if (dynamicDescriptor.isGroupable()) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mGroupableRoutes.add(route.getId());
            }
        }
        if (dynamicDescriptor.isTransferable()) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mTransferableRoutes.add(route.getId());
            }
        }
        if ((dynamicDescriptor.getSelectionState() == DynamicRouteDescriptor.SELECTING) || (dynamicDescriptor.getSelectionState() == DynamicRouteDescriptor.SELECTED)) {
            RouteInfo route = findRouteByDynamicRouteDescriptor(dynamicDescriptor);
            if (route != null) {
                mMemberRoutes.add(route.getId());
                if (dynamicDescriptor.isUnselectable()) {
                    mUnselectableRoutes.add(route.getId());
                }
            }
        }
    }
}
#end_block

#method_before
int findRouteByDescriptorId(String id) {
    final int count = mRoutes.size();
    for (int i = 0; i < count; i++) {
        if (mRoutes.get(i).mDescriptorId.equals(id)) {
            return i;
        }
    }
    return -1;
}
#method_after
RouteInfo findRouteByDescriptorId(String id) {
    final int count = mRoutes.size();
    for (int i = 0; i < count; i++) {
        if (mRoutes.get(i).mDescriptorId.equals(id)) {
            return mRoutes.get(i);
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void addProvider(MediaRouteProvider providerInstance) {
    int index = findProviderInfo(providerInstance);
    if (index < 0) {
        // 1. Add the provider to the list.
        ProviderInfo provider = new ProviderInfo(providerInstance);
        mProviders.add(provider);
        if (DEBUG) {
            Log.d(TAG, "Provider added: " + provider);
        }
        mCallbackHandler.post(CallbackHandler.MSG_PROVIDER_ADDED, provider);
        // 2. Create the provider's contents.
        updateProviderContents(provider, providerInstance.getDescriptor());
        // 3. Register the provider callback.
        providerInstance.setCallback(mProviderCallback);
        // 4. Set the discovery request.
        providerInstance.setDiscoveryRequest(mDiscoveryRequest);
    }
}
#method_after
@Override
public void addProvider(MediaRouteProvider providerInstance) {
    if (findProviderInfo(providerInstance) == null) {
        // 1. Add the provider to the list.
        ProviderInfo provider = new ProviderInfo(providerInstance);
        mProviders.add(provider);
        if (DEBUG) {
            Log.d(TAG, "Provider added: " + provider);
        }
        mCallbackHandler.post(CallbackHandler.MSG_PROVIDER_ADDED, provider);
        // 2. Create the provider's contents.
        updateProviderContents(provider, providerInstance.getDescriptor());
        // 3. Register the provider callback.
        providerInstance.setCallback(mProviderCallback);
        // 4. Set the discovery request.
        providerInstance.setDiscoveryRequest(mDiscoveryRequest);
    }
}
#end_block

#method_before
@Override
public void removeProvider(MediaRouteProvider providerInstance) {
    int index = findProviderInfo(providerInstance);
    if (index >= 0) {
        // 1. Unregister the provider callback.
        providerInstance.setCallback(null);
        // 2. Clear the discovery request.
        providerInstance.setDiscoveryRequest(null);
        // 3. Delete the provider's contents.
        ProviderInfo provider = mProviders.get(index);
        updateProviderContents(provider, null);
        // 4. Remove the provider from the list.
        if (DEBUG) {
            Log.d(TAG, "Provider removed: " + provider);
        }
        mCallbackHandler.post(CallbackHandler.MSG_PROVIDER_REMOVED, provider);
        mProviders.remove(index);
    }
}
#method_after
@Override
public void removeProvider(MediaRouteProvider providerInstance) {
    ProviderInfo provider = findProviderInfo(providerInstance);
    if (provider != null) {
        // 1. Unregister the provider callback.
        providerInstance.setCallback(null);
        // 2. Clear the discovery request.
        providerInstance.setDiscoveryRequest(null);
        // 3. Delete the provider's contents.
        updateProviderContents(provider, null);
        // 4. Remove the provider from the list.
        if (DEBUG) {
            Log.d(TAG, "Provider removed: " + provider);
        }
        mCallbackHandler.post(CallbackHandler.MSG_PROVIDER_REMOVED, provider);
        mProviders.remove(provider);
    }
}
#end_block

#method_before
void updateProviderDescriptor(MediaRouteProvider providerInstance, MediaRouteProviderDescriptor descriptor) {
    int index = findProviderInfo(providerInstance);
    if (index >= 0) {
        // Update the provider's contents.
        ProviderInfo provider = mProviders.get(index);
        updateProviderContents(provider, descriptor);
    }
}
#method_after
void updateProviderDescriptor(MediaRouteProvider providerInstance, MediaRouteProviderDescriptor descriptor) {
    ProviderInfo provider = findProviderInfo(providerInstance);
    if (provider != null) {
        // Update the provider's contents.
        updateProviderContents(provider, descriptor);
    }
}
#end_block

#method_before
private int findProviderInfo(MediaRouteProvider providerInstance) {
    final int count = mProviders.size();
    for (int i = 0; i < count; i++) {
        if (mProviders.get(i).mProviderInstance == providerInstance) {
            return i;
        }
    }
    return -1;
}
#method_after
private ProviderInfo findProviderInfo(MediaRouteProvider providerInstance) {
    final int count = mProviders.size();
    for (int i = 0; i < count; i++) {
        if (mProviders.get(i).mProviderInstance == providerInstance) {
            return mProviders.get(i);
        }
    }
    return null;
}
#end_block

#method_before
private void updateProviderContents(ProviderInfo provider, MediaRouteProviderDescriptor providerDescriptor) {
    if (!provider.updateDescriptor(providerDescriptor)) {
        // Nothing to update.
        return;
    }
    // Update all existing routes and reorder them to match
    // the order of their descriptors.
    int targetIndex = 0;
    boolean selectedRouteDescriptorChanged = false;
    if (providerDescriptor != null && providerDescriptor.isValid()) {
        final List<MediaRouteDescriptor> routeDescriptors = providerDescriptor.getRoutes();
        // Updating route group's contents requires all member routes' information.
        // Add the groups to the lists and update them later.
        List<Pair<RouteInfo, MediaRouteDescriptor>> addedGroups = new ArrayList<>();
        List<Pair<RouteInfo, MediaRouteDescriptor>> updatedGroups = new ArrayList<>();
        for (MediaRouteDescriptor routeDescriptor : routeDescriptors) {
            final String id = routeDescriptor.getId();
            final int sourceIndex = provider.findRouteByDescriptorId(id);
            boolean isGroup = routeDescriptor.getGroupMemberIds() != null;
            if (sourceIndex < 0) {
                // 1. Add the route to the list.
                String uniqueId = assignRouteUniqueId(provider, id);
                RouteInfo route = isGroup ? new RouteGroup(provider, id, uniqueId) : new RouteInfo(provider, id, uniqueId);
                provider.mRoutes.add(targetIndex++, route);
                mRoutes.add(route);
                // 2. Create the route's contents.
                if (isGroup) {
                    addedGroups.add(new Pair<>(route, routeDescriptor));
                } else {
                    route.maybeUpdateDescriptor(routeDescriptor);
                    // 3. Notify clients about addition.
                    if (DEBUG) {
                        Log.d(TAG, "Route added: " + route);
                    }
                    mCallbackHandler.post(CallbackHandler.MSG_ROUTE_ADDED, route);
                }
            } else if (sourceIndex < targetIndex) {
                Log.w(TAG, "Ignoring route descriptor with duplicate id: " + routeDescriptor);
            } else {
                RouteInfo route = provider.mRoutes.get(sourceIndex);
                // or vice versa.
                if ((route instanceof RouteGroup) != isGroup) {
                    route = isGroup ? new RouteGroup(provider, id, route.getId()) : new RouteInfo(provider, id, route.getId());
                    provider.mRoutes.set(sourceIndex, route);
                }
                // 2. Reorder the route within the list.
                Collections.swap(provider.mRoutes, sourceIndex, targetIndex++);
                // 3. Update the route's contents.
                if (route instanceof RouteGroup) {
                    updatedGroups.add(new Pair<>(route, routeDescriptor));
                } else {
                    // 4. Notify clients about changes.
                    if (updateRouteDescriptorAndNotify(route, routeDescriptor) != 0) {
                        if (route == mSelectedRoute) {
                            selectedRouteDescriptorChanged = true;
                        }
                    }
                }
            }
        }
        // Update the new and/or existing groups.
        for (Pair<RouteInfo, MediaRouteDescriptor> pair : addedGroups) {
            RouteInfo route = pair.first;
            route.maybeUpdateDescriptor(pair.second);
            if (DEBUG) {
                Log.d(TAG, "Route added: " + route);
            }
            mCallbackHandler.post(CallbackHandler.MSG_ROUTE_ADDED, route);
        }
        for (Pair<RouteInfo, MediaRouteDescriptor> pair : updatedGroups) {
            RouteInfo route = pair.first;
            if (updateRouteDescriptorAndNotify(route, pair.second) != 0) {
                if (route == mSelectedRoute) {
                    selectedRouteDescriptorChanged = true;
                }
            }
        }
    } else {
        Log.w(TAG, "Ignoring invalid provider descriptor: " + providerDescriptor);
    }
    // Dispose all remaining routes that do not have matching descriptors.
    for (int i = provider.mRoutes.size() - 1; i >= targetIndex; i--) {
        // 1. Delete the route's contents.
        RouteInfo route = provider.mRoutes.get(i);
        route.maybeUpdateDescriptor(null);
        // 2. Remove the route from the list.
        mRoutes.remove(route);
    }
    // Update the selected route if needed.
    updateSelectedRouteIfNeeded(selectedRouteDescriptorChanged);
    // selected route may have side-effects.
    for (int i = provider.mRoutes.size() - 1; i >= targetIndex; i--) {
        RouteInfo route = provider.mRoutes.remove(i);
        if (DEBUG) {
            Log.d(TAG, "Route removed: " + route);
        }
        mCallbackHandler.post(CallbackHandler.MSG_ROUTE_REMOVED, route);
    }
    // Notify provider changed.
    if (DEBUG) {
        Log.d(TAG, "Provider changed: " + provider);
    }
    mCallbackHandler.post(CallbackHandler.MSG_PROVIDER_CHANGED, provider);
}
#method_after
private void updateProviderContents(ProviderInfo provider, MediaRouteProviderDescriptor providerDescriptor) {
    if (!provider.updateDescriptor(providerDescriptor)) {
        // Nothing to update.
        return;
    }
    // Update all existing routes and reorder them to match
    // the order of their descriptors.
    int targetIndex = 0;
    boolean selectedRouteDescriptorChanged = false;
    if (providerDescriptor != null && providerDescriptor.isValid()) {
        final List<MediaRouteDescriptor> routeDescriptors = providerDescriptor.getRoutes();
        // Updating route group's contents requires all member routes' information.
        // Add the groups to the lists and update them later.
        List<Pair<RouteInfo, MediaRouteDescriptor>> addedGroups = new ArrayList<>();
        List<Pair<RouteInfo, MediaRouteDescriptor>> updatedGroups = new ArrayList<>();
        for (MediaRouteDescriptor routeDescriptor : routeDescriptors) {
            final String id = routeDescriptor.getId();
            final int sourceIndex = provider.findRouteIndexByDescriptorId(id);
            boolean isGroup = routeDescriptor.getGroupMemberIds() != null;
            if (sourceIndex < 0) {
                // 1. Add the route to the list.
                String uniqueId = assignRouteUniqueId(provider, id);
                RouteInfo route = isGroup ? new RouteGroup(provider, id, uniqueId) : new RouteInfo(provider, id, uniqueId);
                provider.mRoutes.add(targetIndex++, route);
                mRoutes.add(route);
                // 2. Create the route's contents.
                if (isGroup) {
                    addedGroups.add(new Pair<>(route, routeDescriptor));
                } else {
                    route.maybeUpdateDescriptor(routeDescriptor);
                    // 3. Notify clients about addition.
                    if (DEBUG) {
                        Log.d(TAG, "Route added: " + route);
                    }
                    mCallbackHandler.post(CallbackHandler.MSG_ROUTE_ADDED, route);
                }
            } else if (sourceIndex < targetIndex) {
                Log.w(TAG, "Ignoring route descriptor with duplicate id: " + routeDescriptor);
            } else {
                RouteInfo route = provider.mRoutes.get(sourceIndex);
                // or vice versa.
                if ((route instanceof RouteGroup) != isGroup) {
                    route = isGroup ? new RouteGroup(provider, id, route.getId()) : new RouteInfo(provider, id, route.getId());
                    provider.mRoutes.set(sourceIndex, route);
                }
                // 2. Reorder the route within the list.
                Collections.swap(provider.mRoutes, sourceIndex, targetIndex++);
                // 3. Update the route's contents.
                if (route instanceof RouteGroup) {
                    updatedGroups.add(new Pair<>(route, routeDescriptor));
                } else {
                    // 4. Notify clients about changes.
                    if (updateRouteDescriptorAndNotify(route, routeDescriptor) != 0) {
                        if (route == mSelectedRoute) {
                            selectedRouteDescriptorChanged = true;
                        }
                    }
                }
            }
        }
        // Update the new and/or existing groups.
        for (Pair<RouteInfo, MediaRouteDescriptor> pair : addedGroups) {
            RouteInfo route = pair.first;
            route.maybeUpdateDescriptor(pair.second);
            if (DEBUG) {
                Log.d(TAG, "Route added: " + route);
            }
            mCallbackHandler.post(CallbackHandler.MSG_ROUTE_ADDED, route);
        }
        for (Pair<RouteInfo, MediaRouteDescriptor> pair : updatedGroups) {
            RouteInfo route = pair.first;
            if (updateRouteDescriptorAndNotify(route, pair.second) != 0) {
                if (route == mSelectedRoute) {
                    selectedRouteDescriptorChanged = true;
                }
            }
        }
    } else {
        Log.w(TAG, "Ignoring invalid provider descriptor: " + providerDescriptor);
    }
    // Dispose all remaining routes that do not have matching descriptors.
    for (int i = provider.mRoutes.size() - 1; i >= targetIndex; i--) {
        // 1. Delete the route's contents.
        RouteInfo route = provider.mRoutes.get(i);
        route.maybeUpdateDescriptor(null);
        // 2. Remove the route from the list.
        mRoutes.remove(route);
    }
    // Update the selected route if needed.
    updateSelectedRouteIfNeeded(selectedRouteDescriptorChanged);
    // selected route may have side-effects.
    for (int i = provider.mRoutes.size() - 1; i >= targetIndex; i--) {
        RouteInfo route = provider.mRoutes.remove(i);
        if (DEBUG) {
            Log.d(TAG, "Route removed: " + route);
        }
        mCallbackHandler.post(CallbackHandler.MSG_ROUTE_REMOVED, route);
    }
    // Notify provider changed.
    if (DEBUG) {
        Log.d(TAG, "Provider changed: " + provider);
    }
    mCallbackHandler.post(CallbackHandler.MSG_PROVIDER_CHANGED, provider);
}
#end_block

#method_before
@Override
public void onSystemRouteSelectedByDescriptorId(String id) {
    // System route is selected, do not sync the route we selected before.
    mCallbackHandler.removeMessages(CallbackHandler.MSG_ROUTE_SELECTED);
    int providerIndex = findProviderInfo(mSystemProvider);
    if (providerIndex >= 0) {
        ProviderInfo provider = mProviders.get(providerIndex);
        int routeIndex = provider.findRouteByDescriptorId(id);
        if (routeIndex >= 0) {
            provider.mRoutes.get(routeIndex).select();
        }
    }
}
#method_after
@Override
public void onSystemRouteSelectedByDescriptorId(String id) {
    // System route is selected, do not sync the route we selected before.
    mCallbackHandler.removeMessages(CallbackHandler.MSG_ROUTE_SELECTED);
    ProviderInfo provider = findProviderInfo(mSystemProvider);
    if (provider != null) {
        RouteInfo route = provider.findRouteByDescriptorId(id);
        if (route != null) {
            route.select();
        }
    }
}
#end_block

#method_before
void animateLayoutHeight(final View view, int targetHeight) {
    final ViewGroup.LayoutParams lp = view.getLayoutParams();
    final int startValue = lp.height;
    final int endValue = targetHeight;
    Animation anim = new Animation() {

        @Override
        protected void applyTransformation(float interpolatedTime, Transformation t) {
            int deltaHeight = (int) ((endValue - startValue) * interpolatedTime);
            lp.height = startValue + deltaHeight;
            view.setLayoutParams(lp);
        }
    };
    boolean isLayoutExpanded = (startValue == mExpandedLayoutHeight);
    Interpolator interpolator;
    if (android.os.Build.VERSION.SDK_INT >= 21) {
        interpolator = isLayoutExpanded ? mLinearOutSlowInInterpolator : mFastOutSlowInInterpolator;
    } else {
        interpolator = mAccelerateDecelerateInterpolator;
    }
    anim.setDuration(mLayoutAnimationDurationMs);
    anim.setInterpolator(interpolator);
    view.startAnimation(anim);
}
#method_after
void animateLayoutHeight(final View view, int targetHeight) {
    final int startValue = view.getLayoutParams().height;
    final int endValue = targetHeight;
    Animation anim = new Animation() {

        @Override
        protected void applyTransformation(float interpolatedTime, Transformation t) {
            int deltaHeight = (int) ((endValue - startValue) * interpolatedTime);
            setLayoutHeight(view, startValue + deltaHeight);
        }
    };
    anim.setDuration(mLayoutAnimationDurationMs);
    anim.setInterpolator(mAccelerateDecelerateInterpolator);
    view.startAnimation(anim);
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    boolean selected = isSelectedRoute(route);
    super.bindRouteVolumeSliderHolder(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setChecked(false);
        mCheckBox.setEnabled(false);
    }
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    boolean selected = isSelectedRoute(route);
    super.bindRouteVolumeSliderHolder(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    setLayoutHeight(mVolumeSliderLayout, selected ? mExpandedLayoutHeight : mCollapsedLayoutHeight);
    mCheckBox.setChecked(selected);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
}
#end_block

#method_before
public static UiccController getInstance() {
    synchronized (mLock) {
        return mInstance;
    }
}
#method_after
public static UiccController getInstance() {
    synchronized (mLock) {
        if (mInstance == null) {
            Rlog.e(LOG_TAG, "UiccController.getInstance can't be called before make()");
        }
        return mInstance;
    }
}
#end_block

#method_before
@Override
public void onCreate(MediaSessionService2 service) {
    synchronized (mLock) {
        mService = service;
        mStub = new MediaSessionService2Stub(this);
        mExecutor = new MainHandlerExecutor(service);
    }
}
#method_after
@Override
public void onCreate(MediaSessionService2 service) {
    synchronized (mLock) {
        mInstance = service;
        mStub = new MediaSessionService2Stub(this);
        mNotificationHandler = new MediaNotificationHandler(service);
    }
}
#end_block

#method_before
@Override
public IBinder onBind(Intent intent) {
    final MediaSessionService2 service = mService;
    if (service == null) {
        Log.w(TAG, "Service hasn't created before onBind()");
        return null;
    }
    switch(intent.getAction()) {
        case MediaSessionService2.SERVICE_INTERFACE:
            {
                final MediaSessionService2Stub stub = mStub;
                if (stub == null) {
                    return null;
                }
                return stub.asBinder();
            }
        case MediaBrowserServiceCompat.SERVICE_INTERFACE:
            {
                final MediaSession2 session = service.onGetSession();
                addSession(session);
                // MediaBrowserCompat and MediaBrowserServiceCompat.
                return session.getLegacyBrowerServiceBinder();
            }
    }
    return null;
}
#method_after
@Override
public IBinder onBind(Intent intent) {
    final MediaSessionService2 service = getInstance();
    if (service == null) {
        Log.w(TAG, "Service hasn't created before onBind()");
        return null;
    }
    switch(intent.getAction()) {
        case MediaSessionService2.SERVICE_INTERFACE:
            {
                return getServiceBinder();
            }
        case MediaBrowserServiceCompat.SERVICE_INTERFACE:
            {
                final MediaSession2 session = service.onGetSession();
                addSession(session);
                // MediaBrowserCompat and MediaBrowserServiceCompat.
                return session.getLegacyBrowerServiceBinder();
            }
    }
    return null;
}
#end_block

#method_before
@Override
public void onDestroy() {
    synchronized (mLock) {
        if (mExecutor != null) {
            mExecutor.clear();
            mExecutor = null;
        }
        mService = null;
        if (mStub != null) {
            mStub.close();
            mStub = null;
        }
    }
}
#method_after
@Override
public void onDestroy() {
    synchronized (mLock) {
        mInstance = null;
        if (mStub != null) {
            mStub.close();
            mStub = null;
        }
    }
}
#end_block

#method_before
@Override
public void addSession(final MediaSession2 session) {
    if (session == null) {
        throw new IllegalArgumentException("session shouldn't be null");
    }
    final MediaSession2 old;
    synchronized (mLock) {
        old = mSessions.get(session.getId());
        if (old != null && old != session) {
            // onGetSession.
            throw new IllegalArgumentException("Session ID should be unique.");
        }
        mSessions.put(session.getId(), session);
    }
    if (old == null) {
        // TODO: Check whether the session is registered in multiple sessions.
        session.getCallback().setOnHandleForegroundServiceCallback(new MediaSession2.SessionCallback.OnHandleForegroundServiceCallback() {

            @Override
            public void onPlayerStateChanged(int state) {
                final MediaSessionService2 service = mService;
                if (service == null) {
                    return;
                }
                if (state == MediaPlayerConnector.PLAYER_STATE_IDLE || state == MediaPlayerConnector.PLAYER_STATE_ERROR) {
                    service.stopForeground(false);
                    return;
                }
                // state is PLAYER_STATE_PLAYING or PLAYER_STATE_PAUSE.
                MediaNotification mediaNotification = service.onUpdateNotification(session);
                if (mediaNotification == null) {
                    return;
                }
                int notificationId = mediaNotification.getNotificationId();
                Notification notification = mediaNotification.getNotification();
                NotificationManagerCompat manager = NotificationManagerCompat.from(service);
                manager.notify(notificationId, notification);
                service.startForeground(notificationId, notification);
            }

            @Override
            public void onSessionClosed() {
                removeSession(session);
            }
        });
    }
}
#method_after
@Override
public void addSession(final MediaSession2 session) {
    if (session == null) {
        throw new IllegalArgumentException("session shouldn't be null");
    }
    if (session.getPlayerConnector() == null) {
        throw new IllegalArgumentException("session is already closed");
    }
    final MediaSession2 old;
    synchronized (mLock) {
        old = mSessions.get(session.getId());
        if (old != null && old != session) {
            // onGetSession.
            throw new IllegalArgumentException("Session ID should be unique.");
        }
        mSessions.put(session.getId(), session);
    }
    if (old == null) {
        // Session has returned for the first time. Register callbacks.
        // TODO: Check whether the session is registered in multiple sessions.
        final MediaNotificationHandler handler;
        synchronized (mLock) {
            handler = mNotificationHandler;
        }
        handler.onPlayerStateChanged(session, session.getPlayerState());
        session.getCallback().setForegroundServiceEventCallback(handler);
    }
}
#end_block

#method_before
@Override
public MediaNotification onUpdateNotification(MediaSession2 session) {
    // May supply default implementation later
    return null;
}
#method_after
@Override
public MediaNotification onUpdateNotification(MediaSession2 session) {
    final MediaNotificationHandler handler;
    synchronized (mLock) {
        handler = mNotificationHandler;
    }
    if (handler == null) {
        throw new IllegalStateException("Service hasn't created");
    }
    return handler.onUpdateNotification(session);
}
#end_block

#method_before
@Override
public void connect(final IMediaController2 caller, final String packageName) {
    final MediaSessionService2ImplBase serviceImpl = mServiceImpl.get();
    if (serviceImpl == null) {
        if (DEBUG) {
            Log.d(TAG, "ServiceImpl isn't available");
        }
        return;
    }
    final Executor executor = serviceImpl.mExecutor;
    if (executor == null) {
        if (DEBUG) {
            Log.d(TAG, "ServiceImpl.mExecutor isn't available");
        }
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    executor.execute(new Runnable() {

        @Override
        public void run() {
            boolean shouldNotifyDisconnected = true;
            try {
                final MediaSessionService2ImplBase serviceImpl = mServiceImpl.get();
                if (serviceImpl == null) {
                    if (DEBUG) {
                        Log.d(TAG, "ServiceImpl isn't available");
                    }
                    return;
                }
                final MediaSessionService2 service = serviceImpl.mService;
                if (service == null) {
                    if (DEBUG) {
                        Log.d(TAG, "Service isn't available");
                    }
                    return;
                }
                final MediaSession2 session;
                try {
                    session = service.onGetSession();
                    service.addSession(session);
                    shouldNotifyDisconnected = false;
                    session.connectFromService(caller, packageName, pid, uid);
                } catch (Exception e) {
                    // Don't propagate exception in service to the controller.
                    Log.w(TAG, "Failed to add a session to session service", e);
                }
            } finally {
                // Trick to call onDisconnected() in one place.
                if (shouldNotifyDisconnected) {
                    if (DEBUG) {
                        Log.d(TAG, "Service has destroyed prematurely." + " Rejecting connection");
                    }
                    try {
                        caller.onDisconnected();
                    } catch (RemoteException e) {
                    // Controller may be died prematurely.
                    // Not an issue because we'll ignore it anyway.
                    }
                }
            }
        }
    });
}
#method_after
@Override
public void connect(final IMediaController2 caller, final String packageName) {
    final MediaSessionService2ImplBase serviceImpl = mServiceImpl.get();
    if (serviceImpl == null) {
        if (DEBUG) {
            Log.d(TAG, "ServiceImpl isn't available");
        }
        return;
    }
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    mMainExecutor.execute(new Runnable() {

        @Override
        public void run() {
            boolean shouldNotifyDisconnected = true;
            try {
                final MediaSessionService2ImplBase serviceImpl = mServiceImpl.get();
                if (serviceImpl == null) {
                    if (DEBUG) {
                        Log.d(TAG, "ServiceImpl isn't available");
                    }
                    return;
                }
                final MediaSessionService2 service = serviceImpl.getInstance();
                if (service == null) {
                    if (DEBUG) {
                        Log.d(TAG, "Service isn't available");
                    }
                    return;
                }
                final MediaSession2 session;
                try {
                    session = service.onGetSession();
                    service.addSession(session);
                    shouldNotifyDisconnected = false;
                    session.handleControllerConnectionFromService(caller, packageName, pid, uid);
                } catch (Exception e) {
                    // Don't propagate exception in service to the controller.
                    Log.w(TAG, "Failed to add a session to session service", e);
                }
            } finally {
                // Trick to call onDisconnected() in one place.
                if (shouldNotifyDisconnected) {
                    if (DEBUG) {
                        Log.d(TAG, "Service has destroyed prematurely." + " Rejecting connection");
                    }
                    try {
                        caller.onDisconnected();
                    } catch (RemoteException e) {
                    // Controller may be died prematurely.
                    // Not an issue because we'll ignore it anyway.
                    }
                }
            }
        }
    });
}
#end_block

#method_before
@Override
public void close() {
    mServiceImpl.clear();
}
#method_after
@Override
public void close() {
    mServiceImpl.clear();
    mMainExecutor.clear();
}
#end_block

#method_before
@Override
public void updatePlayer(@NonNull MediaPlayerConnector player, @Nullable MediaPlaylistAgent playlistAgent) {
    if (player == null) {
        throw new IllegalArgumentException("player shouldn't be null");
    }
    synchronized (mLock) {
        if (player == mPlayer && playlistAgent == mPlaylistAgent) {
            return;
        }
    }
    final boolean isPlaybackInfoChanged;
    final MediaPlayerConnector oldPlayer;
    final MediaPlaylistAgent oldPlaylistAgent;
    final PlaybackInfo info = createPlaybackInfo(player);
    synchronized (mLock) {
        isPlaybackInfoChanged = !info.equals(mPlaybackInfo);
        oldPlayer = mPlayer;
        oldPlaylistAgent = mPlaylistAgent;
        mPlayer = player;
        if (playlistAgent == null) {
            mSessionPlaylistAgent = new SessionPlaylistAgentImplBase(this, mPlayer);
            if (mDsmHelper != null) {
                mSessionPlaylistAgent.setOnDataSourceMissingHelper(mDsmHelper);
            }
            playlistAgent = mSessionPlaylistAgent;
        } else if (mSessionPlaylistAgent != null) {
            mSessionPlaylistAgent.setPlayer(mPlayer);
        }
        mPlaylistAgent = playlistAgent;
        mPlaybackInfo = info;
        if (oldPlayer != mPlayer) {
            if (oldPlayer != null) {
                // Warning: Poorly implement player may ignore this
                oldPlayer.unregisterPlayerEventCallback(mPlayerEventCallback);
            }
            // Registering callbacks is critical in case the player is being reused after reset.
            mPlayer.registerPlayerEventCallback(mCallbackExecutor, mPlayerEventCallback);
        }
        if (oldPlaylistAgent != mPlaylistAgent) {
            if (oldPlaylistAgent != null) {
                // Warning: Poorly implement agent may ignore this
                oldPlaylistAgent.unregisterPlaylistEventCallback(mPlaylistEventCallback);
            }
            mPlaylistAgent.registerPlaylistEventCallback(mCallbackExecutor, mPlaylistEventCallback);
        }
    }
    if (oldPlayer == null) {
        // updatePlayerConnector() is called inside of the constructor.
        // There's no connected controllers at this moment, so just initialize session compat's
        // playback state. Otherwise, framework doesn't know whether this is ready to receive
        // media key event.
        mSessionCompat.setPlaybackState(createPlaybackStateCompat());
    } else {
        // connector, agent, and playback info.
        if (playlistAgent != oldPlaylistAgent) {
            // Update agent first. Otherwise current position may be changed off the current
            // media item's duration, and controller may consider it as a bug.
            notifyAgentUpdatedNotLocked(oldPlaylistAgent);
        }
        if (player != oldPlayer) {
            final int state = getPlayerState();
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onPlayerStateChanged(state);
                }
            });
            notifyPlayerUpdatedNotLocked(oldPlayer);
        }
        if (isPlaybackInfoChanged) {
            // Currently hasPlaybackInfo is always true, but check this in case that we're
            // adding PlaybackInfo#equals().
            notifyPlaybackInfoChangedNotLocked(info);
        }
    }
    if (player instanceof BaseRemoteMediaPlayerConnector) {
        final BaseRemoteMediaPlayerConnector remotePlayer = (BaseRemoteMediaPlayerConnector) player;
        VolumeProviderCompat volumeProvider = new VolumeProviderCompat(remotePlayer.getVolumeControlType(), (int) remotePlayer.getMaxPlayerVolume(), (int) remotePlayer.getPlayerVolume()) {

            @Override
            public void onSetVolumeTo(int volume) {
                remotePlayer.setPlayerVolume(volume);
            }

            @Override
            public void onAdjustVolume(int direction) {
                remotePlayer.adjustPlayerVolume(direction);
            }
        };
        mSessionCompat.setPlaybackToRemote(volumeProvider);
    } else {
        int stream = getLegacyStreamType(player.getAudioAttributes());
        mSessionCompat.setPlaybackToLocal(stream);
    }
}
#method_after
@Override
public void updatePlayer(@NonNull MediaPlayerConnector player, @Nullable MediaPlaylistAgent playlistAgent) {
    if (player == null) {
        throw new IllegalArgumentException("player shouldn't be null");
    }
    synchronized (mLock) {
        if (player == mPlayer && playlistAgent == mPlaylistAgent) {
            return;
        }
    }
    final boolean isPlaybackInfoChanged;
    final MediaPlayerConnector oldPlayer;
    final MediaPlaylistAgent oldPlaylistAgent;
    final PlaybackInfo info = createPlaybackInfo(player);
    synchronized (mLock) {
        isPlaybackInfoChanged = !info.equals(mPlaybackInfo);
        oldPlayer = mPlayer;
        oldPlaylistAgent = mPlaylistAgent;
        mPlayer = player;
        if (playlistAgent == null) {
            mSessionPlaylistAgent = new SessionPlaylistAgentImplBase(this, mPlayer);
            if (mDsmHelper != null) {
                mSessionPlaylistAgent.setOnDataSourceMissingHelper(mDsmHelper);
            }
            playlistAgent = mSessionPlaylistAgent;
        } else if (mSessionPlaylistAgent != null) {
            mSessionPlaylistAgent.setPlayer(mPlayer);
        }
        mPlaylistAgent = playlistAgent;
        mPlaybackInfo = info;
        if (oldPlayer != mPlayer) {
            if (oldPlayer != null) {
                // Warning: Poorly implement player may ignore this
                oldPlayer.unregisterPlayerEventCallback(mPlayerEventCallback);
            }
            // Registering callbacks is critical in case the player is being reused after reset.
            mPlayer.registerPlayerEventCallback(mCallbackExecutor, mPlayerEventCallback);
        }
        if (oldPlaylistAgent != mPlaylistAgent) {
            if (oldPlaylistAgent != null) {
                // Warning: Poorly implement agent may ignore this
                oldPlaylistAgent.unregisterPlaylistEventCallback(mPlaylistEventCallback);
            }
            mPlaylistAgent.registerPlaylistEventCallback(mCallbackExecutor, mPlaylistEventCallback);
        }
    }
    if (oldPlayer == null) {
        // updatePlayerConnector() is called inside of the constructor.
        // There's no connected controllers at this moment, so just initialize session compat's
        // playback state. Otherwise, framework doesn't know whether this is ready to receive
        // media key event.
        mSessionCompat.setPlaybackState(createPlaybackStateCompat());
    } else {
        // connector, agent, and playback info.
        if (playlistAgent != oldPlaylistAgent) {
            // Update agent first. Otherwise current position may be changed off the current
            // media item's duration, and controller may consider it as a bug.
            notifyAgentUpdatedNotLocked(oldPlaylistAgent);
        }
        if (player != oldPlayer) {
            final int state = getPlayerState();
            mCallbackExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    mCallback.onPlayerStateChanged(getInstance(), state);
                }
            });
            notifyPlayerUpdatedNotLocked(oldPlayer);
        }
        if (isPlaybackInfoChanged) {
            // Currently hasPlaybackInfo is always true, but check this in case that we're
            // adding PlaybackInfo#equals().
            notifyPlaybackInfoChangedNotLocked(info);
        }
    }
    if (player instanceof BaseRemoteMediaPlayerConnector) {
        final BaseRemoteMediaPlayerConnector remotePlayer = (BaseRemoteMediaPlayerConnector) player;
        VolumeProviderCompat volumeProvider = new VolumeProviderCompat(remotePlayer.getVolumeControlType(), (int) remotePlayer.getMaxPlayerVolume(), (int) remotePlayer.getPlayerVolume()) {

            @Override
            public void onSetVolumeTo(int volume) {
                remotePlayer.setPlayerVolume(volume);
            }

            @Override
            public void onAdjustVolume(int direction) {
                remotePlayer.adjustPlayerVolume(direction);
            }
        };
        mSessionCompat.setPlaybackToRemote(volumeProvider);
    } else {
        int stream = getLegacyStreamType(player.getAudioAttributes());
        mSessionCompat.setPlaybackToLocal(stream);
    }
}
#end_block

#method_before
@Override
public void close() {
    synchronized (mLock) {
        if (mPlayer == null) {
            return;
        }
        mAudioFocusHandler.close();
        mPlayer.unregisterPlayerEventCallback(mPlayerEventCallback);
        mPlayer = null;
        mSessionCompat.release();
        mCallback.onSessionClosed();
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#method_after
@Override
public void close() {
    synchronized (mLock) {
        if (mPlayer == null) {
            return;
        }
        mAudioFocusHandler.close();
        mPlayer.unregisterPlayerEventCallback(mPlayerEventCallback);
        mPlayer = null;
        mSessionCompat.release();
        mCallback.onSessionClosed(mInstance);
        notifyToAllControllers(new NotifyRunnable() {

            @Override
            public void run(ControllerCb callback) throws RemoteException {
                callback.onDisconnected();
            }
        });
        mHandler.removeCallbacksAndMessages(null);
        if (mHandlerThread.isAlive()) {
            if (Build.VERSION.SDK_INT >= 18) {
                mHandlerThread.quitSafely();
            } else {
                mHandlerThread.quit();
            }
        }
    }
}
#end_block

#method_before
MediaBrowserServiceCompat getLegacyBrowserService() {
    return mBrowserServiceLegacyStub;
}
#method_after
MediaBrowserServiceCompat getLegacyBrowserService() {
    synchronized (mLock) {
        return mBrowserServiceLegacyStub;
    }
}
#end_block

#method_before
@Override
public void onPlayerStateChanged(final MediaPlayerConnector player, final int state) {
    final MediaSession2ImplBase session = getSession();
    if (session == null) {
        return;
    }
    session.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // Order is important here. AudioFocusHandler should be called at the first
            // for testing purpose.
            session.mAudioFocusHandler.onPlayerStateChanged(state);
            session.getCallback().onPlayerStateChanged(state);
            session.getCallback().onPlayerStateChanged(session.getInstance(), player, state);
            session.notifyToAllControllers(new NotifyRunnable() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
                }
            });
            // Currently we don't have a listener to player's AudioAttributes changes.
            // Therefore, MediaController2 can get wrong AudioAttributes from
            // MediaController2.getPlaybackInfo(). As a remedy, we update the
            // AudioAttributes whenever player's state is changed.
            PlaybackInfo newInfo = session.createPlaybackInfo(player);
            PlaybackInfo oldInfo;
            synchronized (session.mLock) {
                oldInfo = session.mPlaybackInfo;
                session.mPlaybackInfo = newInfo;
            }
            if (!ObjectsCompat.equals(newInfo.getAudioAttributes(), oldInfo.getAudioAttributes())) {
                session.notifyPlaybackInfoChangedNotLocked(newInfo);
            }
        }
    });
}
#method_after
@Override
public void onPlayerStateChanged(final MediaPlayerConnector player, final int state) {
    final MediaSession2ImplBase session = getSession();
    if (session == null) {
        return;
    }
    session.getCallbackExecutor().execute(new Runnable() {

        @Override
        public void run() {
            // Order is important here. AudioFocusHandler should be called at the first
            // for testing purpose.
            session.mAudioFocusHandler.onPlayerStateChanged(state);
            session.getCallback().onPlayerStateChanged(session.getInstance(), state);
            session.getCallback().onPlayerStateChanged(session.getInstance(), player, state);
            session.notifyToAllControllers(new NotifyRunnable() {

                @Override
                public void run(ControllerCb callback) throws RemoteException {
                    callback.onPlayerStateChanged(SystemClock.elapsedRealtime(), player.getCurrentPosition(), state);
                }
            });
            // Currently we don't have a listener to player's AudioAttributes changes.
            // Therefore, MediaController2 can get wrong AudioAttributes from
            // MediaController2.getPlaybackInfo(). As a remedy, we update the
            // AudioAttributes whenever player's state is changed.
            PlaybackInfo newInfo = session.createPlaybackInfo(player);
            PlaybackInfo oldInfo;
            synchronized (session.mLock) {
                oldInfo = session.mPlaybackInfo;
                session.mPlaybackInfo = newInfo;
            }
            if (!ObjectsCompat.equals(newInfo.getAudioAttributes(), oldInfo.getAudioAttributes())) {
                session.notifyPlaybackInfoChangedNotLocked(newInfo);
            }
        }
    });
}
#end_block

#method_before
@Override
@Nullable
MediaLibraryService2LegacyStub getLegacyBrowserService() {
    return (MediaLibraryService2LegacyStub) super.getLegacyBrowserService();
}
#method_after
@Override
MediaLibraryService2LegacyStub getLegacyBrowserService() {
    return (MediaLibraryService2LegacyStub) super.getLegacyBrowserService();
}
#end_block

#method_before
@Test
public void testOnGetSession() throws InterruptedException {
    final CountDownLatch latch = new CountDownLatch(1);
    final List<SessionToken2> tokens = new ArrayList<>();
    TestServiceRegistry.getInstance().setOnGetSessionHandler(new TestServiceRegistry.OnGetSessionHandler() {

        @Override
        public MediaSession2 onGetSession() {
            MockPlayer player = new MockPlayer(1);
            MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(player).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {
            }).setId("testOnGetSession" + System.currentTimeMillis()).build();
            tokens.add(session.getToken());
            latch.countDown();
            return session;
        }
    });
    MediaController2 controller1 = createController(mToken);
    MediaController2 controller2 = createController(mToken);
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    assertNotEquals(controller1.getConnectedSessionToken(), controller2.getConnectedSessionToken());
    assertEquals(tokens.get(0), controller1.getConnectedSessionToken());
    assertEquals(tokens.get(1), controller2.getConnectedSessionToken());
}
#method_after
@Test
public void testOnGetSession() throws InterruptedException {
    prepareLooper();
    final List<SessionToken2> tokens = new ArrayList<>();
    TestServiceRegistry.getInstance().setOnGetSessionHandler(new TestServiceRegistry.OnGetSessionHandler() {

        @Override
        public MediaSession2 onGetSession() {
            MockPlayer player = new MockPlayer(1);
            MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(player).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {
            }).setId("testOnGetSession" + System.currentTimeMillis()).build();
            tokens.add(session.getToken());
            return session;
        }
    });
    MediaController2 controller1 = createController(mToken);
    MediaController2 controller2 = createController(mToken);
    assertNotEquals(controller1.getConnectedSessionToken(), controller2.getConnectedSessionToken());
    assertEquals(tokens.get(0), controller1.getConnectedSessionToken());
    assertEquals(tokens.get(1), controller2.getConnectedSessionToken());
}
#end_block

#method_before
@Test
public void testGetSessions() throws InterruptedException {
    createController(mToken);
    MediaSessionService2 service = TestServiceRegistry.getInstance().getServiceInstance();
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setId("testGetSessions").setPlayer(new MockPlayer(0)).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {
    }).build()) {
        service.addSession(session);
        List<MediaSession2> sessions = service.getSessions();
        assertTrue(sessions.contains(session));
        assertEquals(2, sessions.size());
        service.removeSession(session);
        sessions = service.getSessions();
        assertFalse(sessions.contains(session));
    }
}
#method_after
@Test
public void testGetSessions() throws InterruptedException {
    prepareLooper();
    createController(mToken);
    MediaSessionService2 service = TestServiceRegistry.getInstance().getServiceInstance();
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setId("testGetSessions").setPlayer(new MockPlayer(0)).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {
    }).build()) {
        service.addSession(session);
        List<MediaSession2> sessions = service.getSessions();
        assertTrue(sessions.contains(session));
        assertEquals(2, sessions.size());
        service.removeSession(session);
        sessions = service.getSessions();
        assertFalse(sessions.contains(session));
    }
}
#end_block

#method_before
@Test
public void testAddSessions_removedWhenClose() throws InterruptedException {
    createController(mToken);
    MediaSessionService2 service = TestServiceRegistry.getInstance().getServiceInstance();
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setId("testAddSessions_removedWhenClose").setPlayer(new MockPlayer(0)).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {
    }).build()) {
        service.addSession(session);
        List<MediaSession2> sessions = service.getSessions();
        assertTrue(sessions.contains(session));
        assertEquals(2, sessions.size());
        session.close();
        sessions = service.getSessions();
        assertFalse(sessions.contains(session));
    }
}
#method_after
@Test
public void testAddSessions_removedWhenClose() throws InterruptedException {
    prepareLooper();
    createController(mToken);
    MediaSessionService2 service = TestServiceRegistry.getInstance().getServiceInstance();
    try (MediaSession2 session = new MediaSession2.Builder(mContext).setId("testAddSessions_removedWhenClose").setPlayer(new MockPlayer(0)).setSessionCallback(sHandlerExecutor, new MediaSession2.SessionCallback() {
    }).build()) {
        service.addSession(session);
        List<MediaSession2> sessions = service.getSessions();
        assertTrue(sessions.contains(session));
        assertEquals(2, sessions.size());
        session.close();
        sessions = service.getSessions();
        assertFalse(sessions.contains(session));
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    TestServiceRegistry.getInstance().setServiceInstance(this);
    super.onCreate();
    mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
}
#method_after
@Override
public void onCreate() {
    TestServiceRegistry.getInstance().setServiceInstance(this);
    super.onCreate();
}
#end_block

#method_before
@Override
public MediaSession2 onGetSession() {
    TestServiceRegistry registry = TestServiceRegistry.getInstance();
    TestServiceRegistry.OnGetSessionHandler onGetSessionHandler = registry.getOnGetSessionHandler();
    if (onGetSessionHandler != null) {
        return onGetSessionHandler.onGetSession();
    }
    final MockPlayer player = new MockPlayer(1);
    final SyncHandler handler = (SyncHandler) registry.getHandler();
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            handler.post(runnable);
        }
    };
    SessionCallback sessionCallback = registry.getSessionCallback();
    if (sessionCallback == null) {
        // Ensures non-null
        sessionCallback = new SessionCallback() {
        };
    }
    mSession = new MediaSession2.Builder(this).setPlayer(player).setSessionCallback(executor, sessionCallback).setId(ID).build();
    return mSession;
}
#method_after
@Override
public MediaSession2 onGetSession() {
    TestServiceRegistry registry = TestServiceRegistry.getInstance();
    TestServiceRegistry.OnGetSessionHandler onGetSessionHandler = registry.getOnGetSessionHandler();
    if (onGetSessionHandler != null) {
        return onGetSessionHandler.onGetSession();
    }
    if (getSessions().size() > 0) {
        return getSessions().get(0);
    }
    final MockPlayer player = new MockPlayer(1);
    final SyncHandler handler = (SyncHandler) registry.getHandler();
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            handler.post(runnable);
        }
    };
    SessionCallback sessionCallback = registry.getSessionCallback();
    if (sessionCallback == null) {
        // Ensures non-null
        sessionCallback = new SessionCallback() {
        };
    }
    mSession = new MediaSession2.Builder(this).setPlayer(player).setSessionCallback(executor, sessionCallback).setId(ID).build();
    return mSession;
}
#end_block

#method_before
final void onPlayerStateChanged(@PlayerState int state) {
    if (mOnHandleForegroundServiceCallback != null) {
        mOnHandleForegroundServiceCallback.onPlayerStateChanged(state);
    }
}
#method_after
final void onPlayerStateChanged(MediaSession2 session, @PlayerState int state) {
    if (mForegroundServiceEventCallback != null) {
        mForegroundServiceEventCallback.onPlayerStateChanged(session, state);
    }
}
#end_block

#method_before
final void onSessionClosed() {
    if (mOnHandleForegroundServiceCallback != null) {
        mOnHandleForegroundServiceCallback.onSessionClosed();
    }
}
#method_after
final void onSessionClosed(MediaSession2 session) {
    if (mForegroundServiceEventCallback != null) {
        mForegroundServiceEventCallback.onSessionClosed(session);
    }
}
#end_block

#method_before
@NonNull
public CommandButton build() {
    return new CommandButton(mCommand, mIconResId, mDisplayName, mExtras, mEnabled);
}
#method_after
@Override
@NonNull
public MediaSession2 build() {
    if (mCallbackExecutor == null) {
        mCallbackExecutor = new MainHandlerExecutor(mContext);
    }
    if (mCallback == null) {
        mCallback = new SessionCallback() {
        };
    }
    return new MediaSession2(mContext, mId, mPlayer, mPlaylistAgent, mSessionActivity, mCallbackExecutor, mCallback);
}
#end_block

#method_before
@Override
public SessionToken2 getConnectedSessionToken() {
    return mConnectedToken;
}
#method_after
@Override
public SessionToken2 getConnectedSessionToken() {
    synchronized (mLock) {
        return isConnected() ? mConnectedToken : null;
    }
}
#end_block

#method_before
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    // Note that it's always main-thread.
    if (DEBUG) {
        Log.d(TAG, "onServiceConnected " + name + " " + this);
    }
    // Sanity check
    if (!mToken.getPackageName().equals(name.getPackageName())) {
        Log.wtf(TAG, "Expected connection to " + mToken.getPackageName() + " but is" + " connected to " + name);
        return;
    }
    IMediaSessionService2 iService = IMediaSessionService2.Stub.asInterface(service);
    if (iService == null) {
        Log.wtf(TAG, "Service interface is missing.");
        return;
    }
    try {
        iService.connect(mControllerStub, mContext.getPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Service " + name + " has died died prematurely");
        mInstance.close();
    }
}
#method_after
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    // Note that it's always main-thread.
    if (DEBUG) {
        Log.d(TAG, "onServiceConnected " + name + " " + this);
    }
    // Sanity check
    if (!mToken.getPackageName().equals(name.getPackageName())) {
        Log.wtf(TAG, "Expected connection to " + mToken.getPackageName() + " but is" + " connected to " + name);
        return;
    }
    IMediaSessionService2 iService = IMediaSessionService2.Stub.asInterface(service);
    if (iService == null) {
        Log.wtf(TAG, "Service interface is missing.");
        return;
    }
    try {
        iService.connect(mControllerStub, getContext().getPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Service " + name + " has died prematurely");
        mInstance.close();
    }
}
#end_block

#method_before
@Override
public IBinder onBind(Intent intent) {
    if (MediaLibraryService2.SERVICE_INTERFACE.equals(intent.getAction())) {
        final IInterface stub = mStub;
        if (stub == null) {
            return null;
        }
        return stub.asBinder();
    }
    return super.onBind(intent);
}
#method_after
@Override
public IBinder onBind(Intent intent) {
    if (MediaLibraryService2.SERVICE_INTERFACE.equals(intent.getAction())) {
        return getServiceBinder();
    }
    return super.onBind(intent);
}
#end_block

#method_before
@Override
@NonNull
public SessionToken2 getConnectedSessionToken() {
    return mToken;
}
#method_after
@Override
@Nullable
public SessionToken2 getConnectedSessionToken() {
    synchronized (mLock) {
        return mConnected ? mToken : null;
    }
}
#end_block

#method_before
public static boolean matchesServiceSolicitationUuids(ParcelUuid solicitationUuid, ParcelUuid parcelSolicitationUuidMask, List<ParcelUuid> solicitationUuids) {
    if (solicitationUuid == null) {
        return true;
    }
    if (solicitationUuids == null) {
        return false;
    }
    for (ParcelUuid parcelSolicitationUuid : solicitationUuids) {
        UUID solicitationUuidMask = parcelSolicitationUuidMask == null ? null : parcelSolicitationUuidMask.getUuid();
        if (matchesServiceUuid(solicitationUuid.getUuid(), solicitationUuidMask, parcelSolicitationUuid.getUuid())) {
            return true;
        }
    }
    return false;
}
#method_after
private static boolean matchesServiceSolicitationUuids(ParcelUuid solicitationUuid, ParcelUuid parcelSolicitationUuidMask, List<ParcelUuid> solicitationUuids) {
    if (solicitationUuid == null) {
        return true;
    }
    if (solicitationUuids == null) {
        return false;
    }
    for (ParcelUuid parcelSolicitationUuid : solicitationUuids) {
        UUID solicitationUuidMask = parcelSolicitationUuidMask == null ? null : parcelSolicitationUuidMask.getUuid();
        if (matchesServiceUuid(solicitationUuid.getUuid(), solicitationUuidMask, parcelSolicitationUuid.getUuid())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<ParcelUuid> getServiceSolicitationUuids() {
    return mServiceSolicitationUuids;
}
#method_after
@Nullable
public List<ParcelUuid> getServiceSolicitationUuids() {
    return mServiceSolicitationUuids;
}
#end_block

#method_before
@Nullable
public byte[] getServiceData(ParcelUuid serviceDataUuid) {
    if (serviceDataUuid == null) {
        return null;
    }
    return mServiceData.get(serviceDataUuid);
}
#method_after
@Nullable
public byte[] getServiceData(ParcelUuid serviceDataUuid) {
    if (serviceDataUuid == null || mServiceData == null) {
        return null;
    }
    return mServiceData.get(serviceDataUuid);
}
#end_block

#method_before
public static ScanRecord parseFromBytes(byte[] scanRecord) {
    if (scanRecord == null) {
        return null;
    }
    int currentPos = 0;
    int advertiseFlag = -1;
    List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
    List<ParcelUuid> serviceSolicitationUuids = new ArrayList<ParcelUuid>();
    String localName = null;
    int txPowerLevel = Integer.MIN_VALUE;
    SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
    Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
    try {
        while (currentPos < scanRecord.length) {
            // length is unsigned int.
            int length = scanRecord[currentPos++] & 0xFF;
            if (length == 0) {
                break;
            }
            // Note the length includes the length of the field type itself.
            int dataLength = length - 1;
            // fieldType is unsigned int.
            int fieldType = scanRecord[currentPos++] & 0xFF;
            switch(fieldType) {
                case DATA_TYPE_FLAGS:
                    advertiseFlag = scanRecord[currentPos] & 0xFF;
                    break;
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_16_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_32_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_128_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_LOCAL_NAME_SHORT:
                case DATA_TYPE_LOCAL_NAME_COMPLETE:
                    localName = new String(extractBytes(scanRecord, currentPos, dataLength));
                    break;
                case DATA_TYPE_TX_POWER_LEVEL:
                    txPowerLevel = scanRecord[currentPos];
                    break;
                case DATA_TYPE_SERVICE_DATA_16_BIT:
                case DATA_TYPE_SERVICE_DATA_32_BIT:
                case DATA_TYPE_SERVICE_DATA_128_BIT:
                    int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;
                    if (fieldType == DATA_TYPE_SERVICE_DATA_32_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_32_BIT;
                    } else if (fieldType == DATA_TYPE_SERVICE_DATA_128_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_128_BIT;
                    }
                    byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos, serviceUuidLength);
                    ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(serviceDataUuidBytes);
                    byte[] serviceDataArray = extractBytes(scanRecord, currentPos + serviceUuidLength, dataLength - serviceUuidLength);
                    serviceData.put(serviceDataUuid, serviceDataArray);
                    break;
                case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:
                    // The first two bytes of the manufacturer specific data are
                    // manufacturer ids in little endian.
                    int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) + (scanRecord[currentPos] & 0xFF);
                    byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2, dataLength - 2);
                    manufacturerData.put(manufacturerId, manufacturerDataBytes);
                    break;
                default:
                    // Just ignore, we don't handle such data type.
                    break;
            }
            currentPos += dataLength;
        }
        if (serviceUuids.isEmpty()) {
            serviceUuids = null;
        }
        if (serviceSolicitationUuids.isEmpty()) {
            serviceSolicitationUuids = null;
        }
        return new ScanRecord(serviceUuids, serviceSolicitationUuids, manufacturerData, serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
    } catch (Exception e) {
        Log.e(TAG, "unable to parse scan record: " + Arrays.toString(scanRecord));
        // and return an empty record with raw scanRecord bytes in results
        return new ScanRecord(null, null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
    }
}
#method_after
@UnsupportedAppUsage
public static ScanRecord parseFromBytes(byte[] scanRecord) {
    if (scanRecord == null) {
        return null;
    }
    int currentPos = 0;
    int advertiseFlag = -1;
    List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
    List<ParcelUuid> serviceSolicitationUuids = new ArrayList<ParcelUuid>();
    String localName = null;
    int txPowerLevel = Integer.MIN_VALUE;
    SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
    Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
    try {
        while (currentPos < scanRecord.length) {
            // length is unsigned int.
            int length = scanRecord[currentPos++] & 0xFF;
            if (length == 0) {
                break;
            }
            // Note the length includes the length of the field type itself.
            int dataLength = length - 1;
            // fieldType is unsigned int.
            int fieldType = scanRecord[currentPos++] & 0xFF;
            switch(fieldType) {
                case DATA_TYPE_FLAGS:
                    advertiseFlag = scanRecord[currentPos] & 0xFF;
                    break;
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_16_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_32_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_128_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_LOCAL_NAME_SHORT:
                case DATA_TYPE_LOCAL_NAME_COMPLETE:
                    localName = new String(extractBytes(scanRecord, currentPos, dataLength));
                    break;
                case DATA_TYPE_TX_POWER_LEVEL:
                    txPowerLevel = scanRecord[currentPos];
                    break;
                case DATA_TYPE_SERVICE_DATA_16_BIT:
                case DATA_TYPE_SERVICE_DATA_32_BIT:
                case DATA_TYPE_SERVICE_DATA_128_BIT:
                    int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;
                    if (fieldType == DATA_TYPE_SERVICE_DATA_32_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_32_BIT;
                    } else if (fieldType == DATA_TYPE_SERVICE_DATA_128_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_128_BIT;
                    }
                    byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos, serviceUuidLength);
                    ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(serviceDataUuidBytes);
                    byte[] serviceDataArray = extractBytes(scanRecord, currentPos + serviceUuidLength, dataLength - serviceUuidLength);
                    serviceData.put(serviceDataUuid, serviceDataArray);
                    break;
                case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:
                    // The first two bytes of the manufacturer specific data are
                    // manufacturer ids in little endian.
                    int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) + (scanRecord[currentPos] & 0xFF);
                    byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2, dataLength - 2);
                    manufacturerData.put(manufacturerId, manufacturerDataBytes);
                    break;
                default:
                    // Just ignore, we don't handle such data type.
                    break;
            }
            currentPos += dataLength;
        }
        if (serviceUuids.isEmpty()) {
            serviceUuids = null;
        }
        if (serviceSolicitationUuids.isEmpty()) {
            serviceSolicitationUuids = null;
        }
        return new ScanRecord(serviceUuids, serviceSolicitationUuids, manufacturerData, serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
    } catch (Exception e) {
        Log.e(TAG, "unable to parse scan record: " + Arrays.toString(scanRecord));
        // and return an empty record with raw scanRecord bytes in results
        return new ScanRecord(null, null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
    }
}
#end_block

#method_before
@Deprecated
public static String getNetworkTypeName(int type) {
    switch(type) {
        case TYPE_NONE:
            return "NONE";
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        case TYPE_MOBILE_EMERGENCY:
            return "MOBILE_EMERGENCY";
        case TYPE_PROXY:
            return "PROXY";
        case TYPE_VPN:
            return "VPN";
        default:
            return Integer.toString(type);
    }
}
#method_after
@Deprecated
@UnsupportedAppUsage
public static String getNetworkTypeName(int type) {
    switch(type) {
        case TYPE_NONE:
            return "NONE";
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        case TYPE_MOBILE_EMERGENCY:
            return "MOBILE_EMERGENCY";
        case TYPE_PROXY:
            return "PROXY";
        case TYPE_VPN:
            return "VPN";
        default:
            return Integer.toString(type);
    }
}
#end_block

#method_before
@Deprecated
public static boolean isNetworkTypeMobile(int networkType) {
    switch(networkType) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_MMS:
        case TYPE_MOBILE_SUPL:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
        case TYPE_MOBILE_FOTA:
        case TYPE_MOBILE_IMS:
        case TYPE_MOBILE_CBS:
        case TYPE_MOBILE_IA:
        case TYPE_MOBILE_EMERGENCY:
            return true;
        default:
            return false;
    }
}
#method_after
@Deprecated
@UnsupportedAppUsage
public static boolean isNetworkTypeMobile(int networkType) {
    switch(networkType) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_MMS:
        case TYPE_MOBILE_SUPL:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
        case TYPE_MOBILE_FOTA:
        case TYPE_MOBILE_IMS:
        case TYPE_MOBILE_CBS:
        case TYPE_MOBILE_IA:
        case TYPE_MOBILE_EMERGENCY:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public NetworkInfo getActiveNetworkInfoForUid(int uid) {
    return getActiveNetworkInfoForUid(uid, false);
}
#method_after
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
@UnsupportedAppUsage
public NetworkInfo getActiveNetworkInfoForUid(int uid) {
    return getActiveNetworkInfoForUid(uid, false);
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public Network getNetworkForType(int networkType) {
    try {
        return mService.getNetworkForType(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public Network getNetworkForType(int networkType) {
    try {
        return mService.getNetworkForType(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public NetworkCapabilities[] getDefaultNetworkCapabilitiesForUser(int userId) {
    try {
        return mService.getDefaultNetworkCapabilitiesForUser(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public NetworkCapabilities[] getDefaultNetworkCapabilitiesForUser(int userId) {
    try {
        return mService.getDefaultNetworkCapabilitiesForUser(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public LinkProperties getActiveLinkProperties() {
    try {
        return mService.getActiveLinkProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public LinkProperties getActiveLinkProperties() {
    try {
        return mService.getActiveLinkProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public LinkProperties getLinkProperties(int networkType) {
    try {
        return mService.getLinkPropertiesForType(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public LinkProperties getLinkProperties(int networkType) {
    try {
        return mService.getLinkPropertiesForType(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
private NetworkCapabilities networkCapabilitiesForFeature(int networkType, String feature) {
    if (networkType == TYPE_MOBILE) {
        switch(feature) {
            case "enableCBS":
                return networkCapabilitiesForType(TYPE_MOBILE_CBS);
            case "enableDUN":
            case "enableDUNAlways":
                return networkCapabilitiesForType(TYPE_MOBILE_DUN);
            case "enableFOTA":
                return networkCapabilitiesForType(TYPE_MOBILE_FOTA);
            case "enableHIPRI":
                return networkCapabilitiesForType(TYPE_MOBILE_HIPRI);
            case "enableIMS":
                return networkCapabilitiesForType(TYPE_MOBILE_IMS);
            case "enableMMS":
                return networkCapabilitiesForType(TYPE_MOBILE_MMS);
            case "enableSUPL":
                return networkCapabilitiesForType(TYPE_MOBILE_SUPL);
            default:
                return null;
        }
    } else if (networkType == TYPE_WIFI && "p2p".equals(feature)) {
        return networkCapabilitiesForType(TYPE_WIFI_P2P);
    }
    return null;
}
#method_after
@UnsupportedAppUsage
private NetworkCapabilities networkCapabilitiesForFeature(int networkType, String feature) {
    if (networkType == TYPE_MOBILE) {
        switch(feature) {
            case "enableCBS":
                return networkCapabilitiesForType(TYPE_MOBILE_CBS);
            case "enableDUN":
            case "enableDUNAlways":
                return networkCapabilitiesForType(TYPE_MOBILE_DUN);
            case "enableFOTA":
                return networkCapabilitiesForType(TYPE_MOBILE_FOTA);
            case "enableHIPRI":
                return networkCapabilitiesForType(TYPE_MOBILE_HIPRI);
            case "enableIMS":
                return networkCapabilitiesForType(TYPE_MOBILE_IMS);
            case "enableMMS":
                return networkCapabilitiesForType(TYPE_MOBILE_MMS);
            case "enableSUPL":
                return networkCapabilitiesForType(TYPE_MOBILE_SUPL);
            default:
                return null;
        }
    } else if (networkType == TYPE_WIFI && "p2p".equals(feature)) {
        return networkCapabilitiesForType(TYPE_WIFI_P2P);
    }
    return null;
}
#end_block

#method_before
private NetworkRequest requestNetworkForFeatureLocked(NetworkCapabilities netCap) {
    int delay = -1;
    int type = legacyTypeForNetworkCapabilities(netCap);
    try {
        delay = mService.getRestoreDefaultNetworkDelay(type);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    LegacyRequest l = new LegacyRequest();
    l.networkCapabilities = netCap;
    l.delay = delay;
    l.expireSequenceNumber = 0;
    l.networkRequest = sendRequestForNetwork(netCap, l.networkCallback, 0, REQUEST, type, getDefaultHandler());
    if (l.networkRequest == null)
        return null;
    sLegacyRequests.put(netCap, l);
    sendExpireMsgForFeature(netCap, l.expireSequenceNumber, delay);
    return l.networkRequest;
}
#method_after
@UnsupportedAppUsage
private NetworkRequest requestNetworkForFeatureLocked(NetworkCapabilities netCap) {
    int delay = -1;
    int type = legacyTypeForNetworkCapabilities(netCap);
    try {
        delay = mService.getRestoreDefaultNetworkDelay(type);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    LegacyRequest l = new LegacyRequest();
    l.networkCapabilities = netCap;
    l.delay = delay;
    l.expireSequenceNumber = 0;
    l.networkRequest = sendRequestForNetwork(netCap, l.networkCallback, 0, REQUEST, type, getDefaultHandler());
    if (l.networkRequest == null)
        return null;
    sLegacyRequests.put(netCap, l);
    sendExpireMsgForFeature(netCap, l.expireSequenceNumber, delay);
    return l.networkRequest;
}
#end_block

#method_before
private boolean removeRequestForFeature(NetworkCapabilities netCap) {
    final LegacyRequest l;
    synchronized (sLegacyRequests) {
        l = sLegacyRequests.remove(netCap);
    }
    if (l == null)
        return false;
    unregisterNetworkCallback(l.networkCallback);
    l.clearDnsBinding();
    return true;
}
#method_after
@UnsupportedAppUsage
private boolean removeRequestForFeature(NetworkCapabilities netCap) {
    final LegacyRequest l;
    synchronized (sLegacyRequests) {
        l = sLegacyRequests.remove(netCap);
    }
    if (l == null)
        return false;
    unregisterNetworkCallback(l.networkCallback);
    l.clearDnsBinding();
    return true;
}
#end_block

#method_before
public void onStarted() {
}
#method_after
@UnsupportedAppUsage
public void onStarted() {
}
#end_block

#method_before
public void onStopped() {
}
#method_after
@UnsupportedAppUsage
public void onStopped() {
}
#end_block

#method_before
public void onError(int error) {
}
#method_after
@UnsupportedAppUsage
public void onError(int error) {
}
#end_block

#method_before
public void stop() {
    try {
        mService.stopKeepalive(mNetwork, mSlot);
    } catch (RemoteException e) {
        Log.e(TAG, "Error stopping packet keepalive: ", e);
        stopLooper();
    }
}
#method_after
@UnsupportedAppUsage
public void stop() {
    try {
        mService.stopKeepalive(mNetwork, mSlot);
    } catch (RemoteException e) {
        Log.e(TAG, "Error stopping packet keepalive: ", e);
        stopLooper();
    }
}
#end_block

#method_before
public PacketKeepalive startNattKeepalive(Network network, int intervalSeconds, PacketKeepaliveCallback callback, InetAddress srcAddr, int srcPort, InetAddress dstAddr) {
    final PacketKeepalive k = new PacketKeepalive(network, callback);
    try {
        mService.startNattKeepalive(network, intervalSeconds, k.mMessenger, new Binder(), srcAddr.getHostAddress(), srcPort, dstAddr.getHostAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "Error starting packet keepalive: ", e);
        k.stopLooper();
        return null;
    }
    return k;
}
#method_after
@UnsupportedAppUsage
public PacketKeepalive startNattKeepalive(Network network, int intervalSeconds, PacketKeepaliveCallback callback, InetAddress srcAddr, int srcPort, InetAddress dstAddr) {
    final PacketKeepalive k = new PacketKeepalive(network, callback);
    try {
        mService.startNattKeepalive(network, intervalSeconds, k.mMessenger, new Binder(), srcAddr.getHostAddress(), srcPort, dstAddr.getHostAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "Error starting packet keepalive: ", e);
        k.stopLooper();
        return null;
    }
    return k;
}
#end_block

#method_before
@Deprecated
public boolean requestRouteToHostAddress(int networkType, InetAddress hostAddress) {
    checkLegacyRoutingApiAccess();
    try {
        return mService.requestRouteToHostAddress(networkType, hostAddress.getAddress());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@UnsupportedAppUsage
public boolean requestRouteToHostAddress(int networkType, InetAddress hostAddress) {
    checkLegacyRoutingApiAccess();
    try {
        return mService.requestRouteToHostAddress(networkType, hostAddress.getAddress());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
public void setBackgroundDataSetting(boolean allowBackgroundData) {
// ignored
}
#method_after
@Deprecated
@UnsupportedAppUsage
public void setBackgroundDataSetting(boolean allowBackgroundData) {
// ignored
}
#end_block

#method_before
@Deprecated
public NetworkQuotaInfo getActiveNetworkQuotaInfo() {
    try {
        return mService.getActiveNetworkQuotaInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@UnsupportedAppUsage
public NetworkQuotaInfo getActiveNetworkQuotaInfo() {
    try {
        return mService.getActiveNetworkQuotaInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
public boolean getMobileDataEnabled() {
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            int subId = SubscriptionManager.getDefaultDataSubscriptionId();
            Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
            boolean retVal = it.isUserDataEnabled(subId);
            Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId + " retVal=" + retVal);
            return retVal;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
    return false;
}
#method_after
@Deprecated
@UnsupportedAppUsage
public boolean getMobileDataEnabled() {
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            int subId = SubscriptionManager.getDefaultDataSubscriptionId();
            Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
            boolean retVal = it.isUserDataEnabled(subId);
            Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId + " retVal=" + retVal);
            return retVal;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
    return false;
}
#end_block

#method_before
public static ConnectivityManager from(Context context) {
    return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
}
#method_after
@UnsupportedAppUsage
public static ConnectivityManager from(Context context) {
    return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
}
#end_block

#method_before
@Deprecated
private static ConnectivityManager getInstance() {
    if (getInstanceOrNull() == null) {
        throw new IllegalStateException("No ConnectivityManager yet constructed");
    }
    return getInstanceOrNull();
}
#method_after
@Deprecated
@UnsupportedAppUsage
private static ConnectivityManager getInstance() {
    if (getInstanceOrNull() == null) {
        throw new IllegalStateException("No ConnectivityManager yet constructed");
    }
    return getInstanceOrNull();
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public String[] getTetherableIfaces() {
    try {
        return mService.getTetherableIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public String[] getTetherableIfaces() {
    try {
        return mService.getTetherableIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public String[] getTetheredIfaces() {
    try {
        return mService.getTetheredIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public String[] getTetheredIfaces() {
    try {
        return mService.getTetheredIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public String[] getTetheringErroredIfaces() {
    try {
        return mService.getTetheringErroredIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public String[] getTetheringErroredIfaces() {
    try {
        return mService.getTetheringErroredIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int tether(String iface) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "tether caller:" + pkgName);
        return mService.tether(iface, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public int tether(String iface) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "tether caller:" + pkgName);
        return mService.tether(iface, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int untether(String iface) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "untether caller:" + pkgName);
        return mService.untether(iface, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public int untether(String iface) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "untether caller:" + pkgName);
        return mService.untether(iface, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public String[] getTetherableUsbRegexs() {
    try {
        return mService.getTetherableUsbRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public String[] getTetherableUsbRegexs() {
    try {
        return mService.getTetherableUsbRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public String[] getTetherableWifiRegexs() {
    try {
        return mService.getTetherableWifiRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public String[] getTetherableWifiRegexs() {
    try {
        return mService.getTetherableWifiRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public String[] getTetherableBluetoothRegexs() {
    try {
        return mService.getTetherableBluetoothRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public String[] getTetherableBluetoothRegexs() {
    try {
        return mService.getTetherableBluetoothRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public int setUsbTethering(boolean enable) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "setUsbTethering caller:" + pkgName);
        return mService.setUsbTethering(enable, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public int setUsbTethering(boolean enable) {
    try {
        String pkgName = mContext.getOpPackageName();
        Log.i(TAG, "setUsbTethering caller:" + pkgName);
        return mService.setUsbTethering(enable, pkgName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public int getLastTetherError(String iface) {
    try {
        return mService.getLastTetherError(iface);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public int getLastTetherError(String iface) {
    try {
        return mService.getLastTetherError(iface);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public boolean isNetworkSupported(int networkType) {
    try {
        return mService.isNetworkSupported(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@Deprecated
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
@UnsupportedAppUsage
public boolean isNetworkSupported(int networkType) {
    try {
        return mService.isNetworkSupported(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
public void setAirplaneMode(boolean enable) {
    try {
        mService.setAirplaneMode(enable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@RequiresPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL)
@UnsupportedAppUsage
public void setAirplaneMode(boolean enable) {
    try {
        mService.setAirplaneMode(enable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void registerNetworkFactory(Messenger messenger, String name) {
    try {
        mService.registerNetworkFactory(messenger, name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public void registerNetworkFactory(Messenger messenger, String name) {
    try {
        mService.registerNetworkFactory(messenger, name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
public void unregisterNetworkFactory(Messenger messenger) {
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#method_after
@UnsupportedAppUsage
public void unregisterNetworkFactory(Messenger messenger) {
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
#end_block

#method_before
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback, Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    NetworkCapabilities nullCapabilities = null;
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(nullCapabilities, networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#method_after
@RequiresPermission(android.Manifest.permission.ACCESS_NETWORK_STATE)
public void registerDefaultNetworkCallback(NetworkCallback networkCallback, Handler handler) {
    // This works because if the NetworkCapabilities are null,
    // ConnectivityService takes them from the default request.
    // 
    // Since the capabilities are exactly the same as the default request's
    // capabilities, this request is guaranteed, at all times, to be
    // satisfied by the same network, if any, that satisfies the default
    // request, i.e., the system default network.
    CallbackHandler cbHandler = new CallbackHandler(handler);
    sendRequestForNetwork(null, /* NetworkCapabilities need */
    networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
}
#end_block

#method_before
@Deprecated
public static boolean setProcessDefaultNetworkForHostResolution(Network network) {
    return NetworkUtils.bindProcessToNetworkForHostResolution((network == null) ? NETID_UNSET : network.getNetIdForResolv());
}
#method_after
@Deprecated
@UnsupportedAppUsage
public static boolean setProcessDefaultNetworkForHostResolution(Network network) {
    return NetworkUtils.bindProcessToNetworkForHostResolution((network == null) ? NETID_UNSET : network.getNetIdForResolv());
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    logMetricsEvent(MetricsEvent.ACTION_CAPTIVE_PORTAL_LOGIN_ACTIVITY);
    mCm = ConnectivityManager.from(this);
    mNetwork = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_NETWORK);
    mCaptivePortal = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL);
    mUserAgent = getIntent().getStringExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT);
    mUrl = getUrl();
    if (mUrl == null) {
        // getUrl() failed to parse the url provided in the intent: bail out in a way that
        // at least provides network access.
        done(Result.WANTED_AS_IS);
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("onCreate for %s", mUrl.toString()));
    }
    // Also initializes proxy system properties.
    mCm.bindProcessToNetwork(mNetwork);
    mNetwork.setBypassPrivateDns(true);
    mCm.setProcessDefaultNetworkForHostResolution(mNetwork);
    // Proxy system properties must be initialized before setContentView is called because
    // setContentView initializes the WebView logic which in turn reads the system properties.
    setContentView(R.layout.activity_captive_portal_login);
    // Exit app if Network disappears.
    final NetworkCapabilities networkCapabilities = mCm.getNetworkCapabilities(mNetwork);
    if (networkCapabilities == null) {
        finishAndRemoveTask();
        return;
    }
    mNetworkCallback = new NetworkCallback() {

        @Override
        public void onLost(Network lostNetwork) {
            if (mNetwork.equals(lostNetwork))
                done(Result.UNWANTED);
        }
    };
    final NetworkRequest.Builder builder = new NetworkRequest.Builder();
    for (int transportType : networkCapabilities.getTransportTypes()) {
        builder.addTransportType(transportType);
    }
    mCm.registerNetworkCallback(builder.build(), mNetworkCallback);
    getActionBar().setDisplayShowHomeEnabled(false);
    // remove shadow
    getActionBar().setElevation(0);
    getActionBar().setTitle(getHeaderTitle());
    getActionBar().setSubtitle("");
    final WebView webview = getWebview();
    webview.clearCache(true);
    CookieManager.getInstance().setAcceptThirdPartyCookies(webview, true);
    WebSettings webSettings = webview.getSettings();
    webSettings.setJavaScriptEnabled(true);
    webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setSupportZoom(true);
    webSettings.setBuiltInZoomControls(true);
    webSettings.setDisplayZoomControls(false);
    mWebViewClient = new MyWebViewClient();
    webview.setWebViewClient(mWebViewClient);
    webview.setWebChromeClient(new MyWebChromeClient());
    // Start initial page load so WebView finishes loading proxy settings.
    // Actual load of mUrl is initiated by MyWebViewClient.
    webview.loadData("", "text/html", null);
    mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        webview.reload();
        mSwipeRefreshLayout.setRefreshing(true);
    });
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    logMetricsEvent(MetricsEvent.ACTION_CAPTIVE_PORTAL_LOGIN_ACTIVITY);
    mCm = ConnectivityManager.from(this);
    mNetwork = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_NETWORK);
    mCaptivePortal = getIntent().getParcelableExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL);
    mUserAgent = getIntent().getStringExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT);
    mUrl = getUrl();
    if (mUrl == null) {
        // getUrl() failed to parse the url provided in the intent: bail out in a way that
        // at least provides network access.
        done(Result.WANTED_AS_IS);
        return;
    }
    if (DBG) {
        Log.d(TAG, String.format("onCreate for %s", mUrl.toString()));
    }
    final String spec = getIntent().getStringExtra(EXTRA_CAPTIVE_PORTAL_PROBE_SPEC);
    try {
        mProbeSpec = CaptivePortalProbeSpec.parseSpecOrNull(spec);
    } catch (Exception e) {
        // Make extra sure that invalid configurations do not cause crashes
        mProbeSpec = null;
    }
    // Also initializes proxy system properties.
    mNetwork = mNetwork.getPrivateDnsBypassingCopy();
    mCm.bindProcessToNetwork(mNetwork);
    mCm.setProcessDefaultNetworkForHostResolution(mNetwork);
    // Proxy system properties must be initialized before setContentView is called because
    // setContentView initializes the WebView logic which in turn reads the system properties.
    setContentView(R.layout.activity_captive_portal_login);
    // Exit app if Network disappears.
    final NetworkCapabilities networkCapabilities = mCm.getNetworkCapabilities(mNetwork);
    if (networkCapabilities == null) {
        finishAndRemoveTask();
        return;
    }
    mNetworkCallback = new NetworkCallback() {

        @Override
        public void onLost(Network lostNetwork) {
            if (mNetwork.equals(lostNetwork))
                done(Result.UNWANTED);
        }
    };
    final NetworkRequest.Builder builder = new NetworkRequest.Builder();
    for (int transportType : networkCapabilities.getTransportTypes()) {
        builder.addTransportType(transportType);
    }
    mCm.registerNetworkCallback(builder.build(), mNetworkCallback);
    getActionBar().setDisplayShowHomeEnabled(false);
    // remove shadow
    getActionBar().setElevation(0);
    getActionBar().setTitle(getHeaderTitle());
    getActionBar().setSubtitle("");
    final WebView webview = getWebview();
    webview.clearCache(true);
    CookieManager.getInstance().setAcceptThirdPartyCookies(webview, true);
    WebSettings webSettings = webview.getSettings();
    webSettings.setJavaScriptEnabled(true);
    webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_COMPATIBILITY_MODE);
    webSettings.setUseWideViewPort(true);
    webSettings.setLoadWithOverviewMode(true);
    webSettings.setSupportZoom(true);
    webSettings.setBuiltInZoomControls(true);
    webSettings.setDisplayZoomControls(false);
    mWebViewClient = new MyWebViewClient();
    webview.setWebViewClient(mWebViewClient);
    webview.setWebChromeClient(new MyWebChromeClient());
    // Start initial page load so WebView finishes loading proxy settings.
    // Actual load of mUrl is initiated by MyWebViewClient.
    webview.loadData("", "text/html", null);
    mSwipeRefreshLayout = findViewById(R.id.swipe_refresh);
    mSwipeRefreshLayout.setOnRefreshListener(() -> {
        webview.reload();
        mSwipeRefreshLayout.setRefreshing(true);
    });
}
#end_block

#method_before
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (httpResponseCode == 204) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#method_after
private void testForCaptivePortal() {
    // TODO: reuse NetworkMonitor facilities for consistent captive portal detection.
    new Thread(new Runnable() {

        public void run() {
            // Give time for captive portal to open.
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            HttpURLConnection urlConnection = null;
            int httpResponseCode = 500;
            String locationHeader = null;
            try {
                urlConnection = (HttpURLConnection) mNetwork.openConnection(mUrl);
                urlConnection.setInstanceFollowRedirects(false);
                urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
                urlConnection.setUseCaches(false);
                if (mUserAgent != null) {
                    urlConnection.setRequestProperty("User-Agent", mUserAgent);
                }
                // cannot read request header after connection
                String requestHeader = urlConnection.getRequestProperties().toString();
                urlConnection.getInputStream();
                httpResponseCode = urlConnection.getResponseCode();
                locationHeader = urlConnection.getHeaderField(HTTP_LOCATION_HEADER_NAME);
                if (DBG) {
                    Log.d(TAG, "probe at " + mUrl + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
                }
            } catch (IOException e) {
            } finally {
                if (urlConnection != null)
                    urlConnection.disconnect();
            }
            if (isDismissed(httpResponseCode, locationHeader, mProbeSpec)) {
                done(Result.DISMISSED);
            }
        }
    }).start();
}
#end_block

#method_before
private String getHeaderTitle() {
    NetworkInfo info = mCm.getNetworkInfo(mNetwork);
    if (info == null) {
        return getString(R.string.action_bar_label);
    }
    NetworkCapabilities nc = mCm.getNetworkCapabilities(mNetwork);
    if (!nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return getString(R.string.action_bar_label);
    }
    return getString(R.string.action_bar_title, info.getExtraInfo().replaceAll("^\"|\"$", ""));
}
#method_after
private String getHeaderTitle() {
    NetworkCapabilities nc = mCm.getNetworkCapabilities(mNetwork);
    if (nc == null || TextUtils.isEmpty(nc.getSSID()) || !nc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return getString(R.string.action_bar_label);
    }
    return getString(R.string.action_bar_title, WifiInfo.removeDoubleQuotes(nc.getSSID()));
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_LAUNCH_CAPTIVE_PORTAL_APP:
            final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
            // OneAddressPerFamilyNetwork is not parcelable across processes.
            intent.putExtra(ConnectivityManager.EXTRA_NETWORK, new Network(mNetwork));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new ICaptivePortal.Stub() {

                @Override
                public void appResponse(int response) {
                    if (response == APP_RETURN_WANTED_AS_IS) {
                        mContext.enforceCallingPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "CaptivePortal");
                    }
                    sendMessage(CMD_CAPTIVE_PORTAL_APP_FINISHED, response);
                }
            }));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_URL, mLastPortalProbeResult.detectUrl);
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT, mCaptivePortalUserAgent);
            intent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#method_after
@Override
public boolean processMessage(Message message) {
    switch(message.what) {
        case CMD_LAUNCH_CAPTIVE_PORTAL_APP:
            final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
            // OneAddressPerFamilyNetwork is not parcelable across processes.
            intent.putExtra(ConnectivityManager.EXTRA_NETWORK, new Network(mNetwork));
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL, new CaptivePortal(new ICaptivePortal.Stub() {

                @Override
                public void appResponse(int response) {
                    if (response == APP_RETURN_WANTED_AS_IS) {
                        mContext.enforceCallingPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "CaptivePortal");
                    }
                    sendMessage(CMD_CAPTIVE_PORTAL_APP_FINISHED, response);
                }
            }));
            final CaptivePortalProbeResult probeRes = mLastPortalProbeResult;
            intent.putExtra(EXTRA_CAPTIVE_PORTAL_URL, probeRes.detectUrl);
            if (probeRes.probeSpec != null) {
                final String encodedSpec = probeRes.probeSpec.getEncodedSpec();
                intent.putExtra(EXTRA_CAPTIVE_PORTAL_PROBE_SPEC, encodedSpec);
            }
            intent.putExtra(ConnectivityManager.EXTRA_CAPTIVE_PORTAL_USER_AGENT, mCaptivePortalUserAgent);
            intent.setFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT | Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            return HANDLED;
        default:
            return NOT_HANDLED;
    }
}
#end_block

#method_before
private void resolveStrictModeHostname() {
    try {
        // Do a blocking DNS resolution using the network-assigned nameservers.
        final Network netForResolv = new Network(mNetwork);
        netForResolv.setBypassPrivateDns(true);
        final InetAddress[] ips = netForResolv.getAllByName(mPrivateDnsProviderHostname);
        mPrivateDnsConfig = new PrivateDnsConfig(mPrivateDnsProviderHostname, ips);
    } catch (UnknownHostException uhe) {
        mPrivateDnsConfig = null;
    }
}
#method_after
private void resolveStrictModeHostname() {
    try {
        // Do a blocking DNS resolution using the network-assigned nameservers.
        final InetAddress[] ips = mNetwork.getAllByName(mPrivateDnsProviderHostname);
        mPrivateDnsConfig = new PrivateDnsConfig(mPrivateDnsProviderHostname, ips);
        validationLog("Strict mode hostname resolved: " + mPrivateDnsConfig);
    } catch (UnknownHostException uhe) {
        mPrivateDnsConfig = null;
        validationLog("Strict mode hostname resolution failed: " + uhe.getMessage());
    }
}
#end_block

#method_before
private boolean sendPrivateDnsProbe() {
    // q.v. system/netd/server/dns/DnsTlsTransport.cpp
    final String ONE_TIME_HOSTNAME_SUFFIX = "-dnsotls-ds.metric.gstatic.com";
    final String host = UUID.randomUUID().toString().substring(0, 8) + ONE_TIME_HOSTNAME_SUFFIX;
    try {
        final InetAddress[] ips = mNetworkAgentInfo.network().getAllByName(host);
        return (ips != null && ips.length > 0);
    } catch (UnknownHostException uhe) {
    }
    return false;
}
#method_after
private boolean sendPrivateDnsProbe() {
    // q.v. system/netd/server/dns/DnsTlsTransport.cpp
    final String ONE_TIME_HOSTNAME_SUFFIX = "-dnsotls-ds.metric.gstatic.com";
    final String host = UUID.randomUUID().toString().substring(0, 8) + ONE_TIME_HOSTNAME_SUFFIX;
    final Stopwatch watch = new Stopwatch().start();
    try {
        final InetAddress[] ips = mNetworkAgentInfo.network().getAllByName(host);
        final long time = watch.stop();
        final String strIps = Arrays.toString(ips);
        final boolean success = (ips != null && ips.length > 0);
        validationLog(PROBE_PRIVDNS, host, String.format("%dms: %s", time, strIps));
        logValidationProbe(time, PROBE_PRIVDNS, success ? DNS_SUCCESS : DNS_FAILURE);
        return success;
    } catch (UnknownHostException uhe) {
        final long time = watch.stop();
        validationLog(PROBE_PRIVDNS, host, String.format("%dms - Error: %s", time, uhe.getMessage()));
        logValidationProbe(time, PROBE_PRIVDNS, DNS_FAILURE);
    }
    return false;
}
#end_block

#method_before
public boolean getIsCaptivePortalCheckEnabled() {
    String symbol = Settings.Global.CAPTIVE_PORTAL_MODE;
    int defaultValue = Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT;
    int mode = mSettings.getSetting(mContext, symbol, defaultValue);
    return mode != Settings.Global.CAPTIVE_PORTAL_MODE_IGNORE;
}
#method_after
public boolean getIsCaptivePortalCheckEnabled() {
    String symbol = Settings.Global.CAPTIVE_PORTAL_MODE;
    int defaultValue = Settings.Global.CAPTIVE_PORTAL_MODE_PROMPT;
    int mode = mDependencies.getSetting(mContext, symbol, defaultValue);
    return mode != Settings.Global.CAPTIVE_PORTAL_MODE_IGNORE;
}
#end_block

#method_before
public boolean getUseHttpsValidation() {
    return mSettings.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_USE_HTTPS, 1) == 1;
}
#method_after
public boolean getUseHttpsValidation() {
    return mDependencies.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_USE_HTTPS, 1) == 1;
}
#end_block

#method_before
public boolean getWifiScansAlwaysAvailableDisabled() {
    return mSettings.getSetting(mContext, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, 0) == 0;
}
#method_after
public boolean getWifiScansAlwaysAvailableDisabled() {
    return mDependencies.getSetting(mContext, Settings.Global.WIFI_SCAN_ALWAYS_AVAILABLE, 0) == 0;
}
#end_block

#method_before
private String getCaptivePortalServerHttpsUrl() {
    return mSettings.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL);
}
#method_after
private String getCaptivePortalServerHttpsUrl() {
    return mDependencies.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_HTTPS_URL, DEFAULT_HTTPS_URL);
}
#end_block

#method_before
public static String getCaptivePortalServerHttpUrl(Context context) {
    return getCaptivePortalServerHttpUrl(NetworkMonitorSettings.DEFAULT, context);
}
#method_after
public static String getCaptivePortalServerHttpUrl(Context context) {
    return getCaptivePortalServerHttpUrl(Dependencies.DEFAULT, context);
}
#end_block

#method_before
public static String getCaptivePortalServerHttpUrl(NetworkMonitorSettings settings, Context context) {
    return settings.getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTP_URL, DEFAULT_HTTP_URL);
}
#method_after
public static String getCaptivePortalServerHttpUrl(Dependencies deps, Context context) {
    return deps.getSetting(context, Settings.Global.CAPTIVE_PORTAL_HTTP_URL, DEFAULT_HTTP_URL);
}
#end_block

#method_before
private URL[] makeCaptivePortalFallbackUrls() {
    String separator = ",";
    String firstUrl = mSettings.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, DEFAULT_FALLBACK_URL);
    String joinedUrls = firstUrl + separator + mSettings.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS);
    List<URL> urls = new ArrayList<>();
    for (String s : joinedUrls.split(separator)) {
        URL u = makeURL(s);
        if (u == null) {
            continue;
        }
        urls.add(u);
    }
    if (urls.isEmpty()) {
        Log.e(TAG, String.format("could not create any url from %s", joinedUrls));
    }
    return urls.toArray(new URL[urls.size()]);
}
#method_after
private URL[] makeCaptivePortalFallbackUrls() {
    try {
        String separator = ",";
        String firstUrl = mDependencies.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_FALLBACK_URL, DEFAULT_FALLBACK_URL);
        String joinedUrls = firstUrl + separator + mDependencies.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_OTHER_FALLBACK_URLS, DEFAULT_OTHER_FALLBACK_URLS);
        List<URL> urls = new ArrayList<>();
        for (String s : joinedUrls.split(separator)) {
            URL u = makeURL(s);
            if (u == null) {
                continue;
            }
            urls.add(u);
        }
        if (urls.isEmpty()) {
            Log.e(TAG, String.format("could not create any url from %s", joinedUrls));
        }
        return urls.toArray(new URL[urls.size()]);
    } catch (Exception e) {
        // Don't let a misconfiguration bootloop the system.
        Log.e(TAG, "Error parsing configured fallback URLs", e);
        return new URL[0];
    }
}
#end_block

#method_before
private String getCaptivePortalUserAgent() {
    return mSettings.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_USER_AGENT, DEFAULT_USER_AGENT);
}
#method_after
private String getCaptivePortalUserAgent() {
    return mDependencies.getSetting(mContext, Settings.Global.CAPTIVE_PORTAL_USER_AGENT, DEFAULT_USER_AGENT);
}
#end_block

#method_before
private URL nextFallbackUrl() {
    if (mCaptivePortalFallbackUrls.length == 0) {
        return null;
    }
    int idx = Math.abs(mNextFallbackUrlIndex) % mCaptivePortalFallbackUrls.length;
    // randomely change url without memory.
    mNextFallbackUrlIndex += new Random().nextInt();
    return mCaptivePortalFallbackUrls[idx];
}
#method_after
private URL nextFallbackUrl() {
    if (mCaptivePortalFallbackUrls.length == 0) {
        return null;
    }
    int idx = Math.abs(mNextFallbackUrlIndex) % mCaptivePortalFallbackUrls.length;
    // randomly change url without memory.
    mNextFallbackUrlIndex += mRandom.nextInt();
    return mCaptivePortalFallbackUrls[idx];
}
#end_block

#method_before
private CaptivePortalProbeResult sendDnsAndHttpProbes(ProxyInfo proxy, URL url, int probeType) {
    // Pre-resolve the captive portal server host so we can log it.
    // Only do this if HttpURLConnection is about to, to avoid any potentially
    // unnecessary resolution.
    final String host = (proxy != null) ? proxy.getHost() : url.getHost();
    sendDnsProbe(host);
    return sendHttpProbe(url, probeType);
}
#method_after
private CaptivePortalProbeResult sendDnsAndHttpProbes(ProxyInfo proxy, URL url, int probeType) {
    // Pre-resolve the captive portal server host so we can log it.
    // Only do this if HttpURLConnection is about to, to avoid any potentially
    // unnecessary resolution.
    final String host = (proxy != null) ? proxy.getHost() : url.getHost();
    sendDnsProbe(host);
    return sendHttpProbe(url, probeType, null);
}
#end_block

#method_before
@VisibleForTesting
protected CaptivePortalProbeResult sendHttpProbe(URL url, int probeType) {
    HttpURLConnection urlConnection = null;
    int httpResponseCode = CaptivePortalProbeResult.FAILED_CODE;
    String redirectUrl = null;
    final Stopwatch probeTimer = new Stopwatch().start();
    final int oldTag = TrafficStats.getAndSetThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);
    try {
        urlConnection = (HttpURLConnection) mNetwork.openConnection(url);
        urlConnection.setInstanceFollowRedirects(probeType == ValidationProbeEvent.PROBE_PAC);
        urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setUseCaches(false);
        if (mCaptivePortalUserAgent != null) {
            urlConnection.setRequestProperty("User-Agent", mCaptivePortalUserAgent);
        }
        // cannot read request header after connection
        String requestHeader = urlConnection.getRequestProperties().toString();
        // Time how long it takes to get a response to our request
        long requestTimestamp = SystemClock.elapsedRealtime();
        httpResponseCode = urlConnection.getResponseCode();
        redirectUrl = urlConnection.getHeaderField("location");
        // Time how long it takes to get a response to our request
        long responseTimestamp = SystemClock.elapsedRealtime();
        validationLog(probeType, url, "time=" + (responseTimestamp - requestTimestamp) + "ms" + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
        // proxy server.
        if (httpResponseCode == 200) {
            if (probeType == ValidationProbeEvent.PROBE_PAC) {
                validationLog(probeType, url, "PAC fetch 200 response interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == 0) {
                // Consider 200 response with "Content-length=0" to not be a captive portal.
                // There's no point in considering this a captive portal as the user cannot
                // sign-in to an empty page. Probably the result of a broken transparent proxy.
                // See http://b/9972012.
                validationLog(probeType, url, "200 response with Content-length=0 interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == -1) {
                // response. Do not use available() as it is unreliable. See http://b/33498325.
                if (urlConnection.getInputStream().read() == -1) {
                    validationLog(probeType, url, "Empty 200 response interpreted as 204 response.");
                    httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
                }
            }
        }
    } catch (IOException e) {
        validationLog(probeType, url, "Probe failed with exception " + e);
        if (httpResponseCode == CaptivePortalProbeResult.FAILED_CODE) {
        // TODO: Ping gateway and DNS server and log results.
        }
    } finally {
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
        TrafficStats.setThreadStatsTag(oldTag);
    }
    logValidationProbe(probeTimer.stop(), probeType, httpResponseCode);
    return new CaptivePortalProbeResult(httpResponseCode, redirectUrl, url.toString());
}
#method_after
@VisibleForTesting
protected CaptivePortalProbeResult sendHttpProbe(URL url, int probeType, @Nullable CaptivePortalProbeSpec probeSpec) {
    HttpURLConnection urlConnection = null;
    int httpResponseCode = CaptivePortalProbeResult.FAILED_CODE;
    String redirectUrl = null;
    final Stopwatch probeTimer = new Stopwatch().start();
    final int oldTag = TrafficStats.getAndSetThreadStatsTag(TrafficStats.TAG_SYSTEM_PROBE);
    try {
        urlConnection = (HttpURLConnection) mNetwork.openConnection(url);
        urlConnection.setInstanceFollowRedirects(probeType == ValidationProbeEvent.PROBE_PAC);
        urlConnection.setConnectTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setReadTimeout(SOCKET_TIMEOUT_MS);
        urlConnection.setUseCaches(false);
        if (mCaptivePortalUserAgent != null) {
            urlConnection.setRequestProperty("User-Agent", mCaptivePortalUserAgent);
        }
        // cannot read request header after connection
        String requestHeader = urlConnection.getRequestProperties().toString();
        // Time how long it takes to get a response to our request
        long requestTimestamp = SystemClock.elapsedRealtime();
        httpResponseCode = urlConnection.getResponseCode();
        redirectUrl = urlConnection.getHeaderField("location");
        // Time how long it takes to get a response to our request
        long responseTimestamp = SystemClock.elapsedRealtime();
        validationLog(probeType, url, "time=" + (responseTimestamp - requestTimestamp) + "ms" + " ret=" + httpResponseCode + " request=" + requestHeader + " headers=" + urlConnection.getHeaderFields());
        // proxy server.
        if (httpResponseCode == 200) {
            if (probeType == ValidationProbeEvent.PROBE_PAC) {
                validationLog(probeType, url, "PAC fetch 200 response interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == 0) {
                // Consider 200 response with "Content-length=0" to not be a captive portal.
                // There's no point in considering this a captive portal as the user cannot
                // sign-in to an empty page. Probably the result of a broken transparent proxy.
                // See http://b/9972012.
                validationLog(probeType, url, "200 response with Content-length=0 interpreted as 204 response.");
                httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
            } else if (urlConnection.getContentLengthLong() == -1) {
                // response. Do not use available() as it is unreliable. See http://b/33498325.
                if (urlConnection.getInputStream().read() == -1) {
                    validationLog(probeType, url, "Empty 200 response interpreted as 204 response.");
                    httpResponseCode = CaptivePortalProbeResult.SUCCESS_CODE;
                }
            }
        }
    } catch (IOException e) {
        validationLog(probeType, url, "Probe failed with exception " + e);
        if (httpResponseCode == CaptivePortalProbeResult.FAILED_CODE) {
        // TODO: Ping gateway and DNS server and log results.
        }
    } finally {
        if (urlConnection != null) {
            urlConnection.disconnect();
        }
        TrafficStats.setThreadStatsTag(oldTag);
    }
    logValidationProbe(probeTimer.stop(), probeType, httpResponseCode);
    if (probeSpec == null) {
        return new CaptivePortalProbeResult(httpResponseCode, redirectUrl, url.toString());
    } else {
        return probeSpec.getResult(httpResponseCode, redirectUrl);
    }
}
#end_block

#method_before
private CaptivePortalProbeResult sendParallelHttpProbes(ProxyInfo proxy, URL httpsUrl, URL httpUrl) {
    // Number of probes to wait for. If a probe completes with a conclusive answer
    // it shortcuts the latch immediately by forcing the count to 0.
    final CountDownLatch latch = new CountDownLatch(2);
    final class ProbeThread extends Thread {

        private final boolean mIsHttps;

        private volatile CaptivePortalProbeResult mResult = CaptivePortalProbeResult.FAILED;

        public ProbeThread(boolean isHttps) {
            mIsHttps = isHttps;
        }

        public CaptivePortalProbeResult result() {
            return mResult;
        }

        @Override
        public void run() {
            if (mIsHttps) {
                mResult = sendDnsAndHttpProbes(proxy, httpsUrl, ValidationProbeEvent.PROBE_HTTPS);
            } else {
                mResult = sendDnsAndHttpProbes(proxy, httpUrl, ValidationProbeEvent.PROBE_HTTP);
            }
            if ((mIsHttps && mResult.isSuccessful()) || (!mIsHttps && mResult.isPortal())) {
                // Stop waiting immediately if https succeeds or if http finds a portal.
                while (latch.getCount() > 0) {
                    latch.countDown();
                }
            }
            // Signal this probe has completed.
            latch.countDown();
        }
    }
    final ProbeThread httpsProbe = new ProbeThread(true);
    final ProbeThread httpProbe = new ProbeThread(false);
    try {
        httpsProbe.start();
        httpProbe.start();
        latch.await(PROBE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
        validationLog("Error: probes wait interrupted!");
        return CaptivePortalProbeResult.FAILED;
    }
    final CaptivePortalProbeResult httpsResult = httpsProbe.result();
    final CaptivePortalProbeResult httpResult = httpProbe.result();
    // Look for a conclusive probe result first.
    if (httpResult.isPortal()) {
        return httpResult;
    }
    // httpsResult.isPortal() is not expected, but check it nonetheless.
    if (httpsResult.isPortal() || httpsResult.isSuccessful()) {
        return httpsResult;
    }
    // If a fallback url exists, use a fallback probe to try again portal detection.
    URL fallbackUrl = nextFallbackUrl();
    if (fallbackUrl != null) {
        CaptivePortalProbeResult result = sendHttpProbe(fallbackUrl, ValidationProbeEvent.PROBE_FALLBACK);
        if (result.isPortal()) {
            return result;
        }
    }
    // Otherwise wait until http and https probes completes and use their results.
    try {
        httpProbe.join();
        if (httpProbe.result().isPortal()) {
            return httpProbe.result();
        }
        httpsProbe.join();
        return httpsProbe.result();
    } catch (InterruptedException e) {
        validationLog("Error: http or https probe wait interrupted!");
        return CaptivePortalProbeResult.FAILED;
    }
}
#method_after
private CaptivePortalProbeResult sendParallelHttpProbes(ProxyInfo proxy, URL httpsUrl, URL httpUrl) {
    // Number of probes to wait for. If a probe completes with a conclusive answer
    // it shortcuts the latch immediately by forcing the count to 0.
    final CountDownLatch latch = new CountDownLatch(2);
    final class ProbeThread extends Thread {

        private final boolean mIsHttps;

        private volatile CaptivePortalProbeResult mResult = CaptivePortalProbeResult.FAILED;

        public ProbeThread(boolean isHttps) {
            mIsHttps = isHttps;
        }

        public CaptivePortalProbeResult result() {
            return mResult;
        }

        @Override
        public void run() {
            if (mIsHttps) {
                mResult = sendDnsAndHttpProbes(proxy, httpsUrl, ValidationProbeEvent.PROBE_HTTPS);
            } else {
                mResult = sendDnsAndHttpProbes(proxy, httpUrl, ValidationProbeEvent.PROBE_HTTP);
            }
            if ((mIsHttps && mResult.isSuccessful()) || (!mIsHttps && mResult.isPortal())) {
                // Stop waiting immediately if https succeeds or if http finds a portal.
                while (latch.getCount() > 0) {
                    latch.countDown();
                }
            }
            // Signal this probe has completed.
            latch.countDown();
        }
    }
    final ProbeThread httpsProbe = new ProbeThread(true);
    final ProbeThread httpProbe = new ProbeThread(false);
    try {
        httpsProbe.start();
        httpProbe.start();
        latch.await(PROBE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
    } catch (InterruptedException e) {
        validationLog("Error: probes wait interrupted!");
        return CaptivePortalProbeResult.FAILED;
    }
    final CaptivePortalProbeResult httpsResult = httpsProbe.result();
    final CaptivePortalProbeResult httpResult = httpProbe.result();
    // Look for a conclusive probe result first.
    if (httpResult.isPortal()) {
        return httpResult;
    }
    // httpsResult.isPortal() is not expected, but check it nonetheless.
    if (httpsResult.isPortal() || httpsResult.isSuccessful()) {
        return httpsResult;
    }
    // If a fallback method exists, use it to retry portal detection.
    // If we have new-style probe specs, use those. Otherwise, use the fallback URLs.
    final CaptivePortalProbeSpec probeSpec = nextFallbackSpec();
    final URL fallbackUrl = (probeSpec != null) ? probeSpec.getUrl() : nextFallbackUrl();
    if (fallbackUrl != null) {
        CaptivePortalProbeResult result = sendHttpProbe(fallbackUrl, PROBE_FALLBACK, probeSpec);
        if (result.isPortal()) {
            return result;
        }
    }
    // Otherwise wait until http and https probes completes and use their results.
    try {
        httpProbe.join();
        if (httpProbe.result().isPortal()) {
            return httpProbe.result();
        }
        httpsProbe.join();
        return httpsProbe.result();
    } catch (InterruptedException e) {
        validationLog("Error: http or https probe wait interrupted!");
        return CaptivePortalProbeResult.FAILED;
    }
}
#end_block

#method_before
public static Uri[] getPrivateDnsSettingsUris() {
    return new Uri[] { Settings.Global.getUriFor(PRIVATE_DNS_MODE), Settings.Global.getUriFor(PRIVATE_DNS_SPECIFIER) };
}
#method_after
public static Uri[] getPrivateDnsSettingsUris() {
    return new Uri[] { Settings.Global.getUriFor(PRIVATE_DNS_DEFAULT_MODE), Settings.Global.getUriFor(PRIVATE_DNS_MODE), Settings.Global.getUriFor(PRIVATE_DNS_SPECIFIER) };
}
#end_block

#method_before
private static String getPrivateDnsMode(ContentResolver cr) {
    final String mode = getStringSetting(cr, PRIVATE_DNS_MODE);
    return !TextUtils.isEmpty(mode) ? mode : PRIVATE_DNS_DEFAULT_MODE;
}
#method_after
private static String getPrivateDnsMode(ContentResolver cr) {
    String mode = getStringSetting(cr, PRIVATE_DNS_MODE);
    if (TextUtils.isEmpty(mode))
        mode = getStringSetting(cr, PRIVATE_DNS_DEFAULT_MODE);
    if (TextUtils.isEmpty(mode))
        mode = PRIVATE_DNS_DEFAULT_MODE_FALLBACK;
    return mode;
}
#end_block

#method_before
public InetAddress[] getAllByName(String host) throws UnknownHostException {
    return mBypassPrivateDns ? resolveAllLocally(host, getNetIdForResolv()) : InetAddress.getAllByNameOnNet(host, netId);
}
#method_after
public InetAddress[] getAllByName(String host) throws UnknownHostException {
    return InetAddress.getAllByNameOnNet(host, getNetIdForResolv());
}
#end_block

#method_before
public InetAddress getByName(String host) throws UnknownHostException {
    return mBypassPrivateDns ? resolveOneLocally(host, getNetIdForResolv()) : InetAddress.getByNameOnNet(host, netId);
}
#method_after
public InetAddress getByName(String host) throws UnknownHostException {
    return InetAddress.getByNameOnNet(host, getNetIdForResolv());
}
#end_block

#method_before
public int getNetIdForResolv() {
    return mBypassPrivateDns ? // Non-portable DNS resolution flag.
    (int) (0x80000000L | (long) netId) : netId;
}
#method_after
public int getNetIdForResolv() {
    return mPrivateDnsBypass ? // Non-portable DNS resolution flag.
    (int) (0x80000000L | (long) netId) : netId;
}
#end_block

#method_before
public SocketFactory getSocketFactory() {
    if (mNetworkBoundSocketFactory == null) {
        synchronized (mLock) {
            if (mNetworkBoundSocketFactory == null) {
                mNetworkBoundSocketFactory = new NetworkBoundSocketFactory(netId);
            }
        }
    }
    return mNetworkBoundSocketFactory;
}
#method_after
public SocketFactory getSocketFactory() {
    if (mNetworkBoundSocketFactory == null) {
        synchronized (mLock) {
            if (mNetworkBoundSocketFactory == null) {
                mNetworkBoundSocketFactory = new NetworkBoundSocketFactory();
            }
        }
    }
    return mNetworkBoundSocketFactory;
}
#end_block

#method_before
public long getNetworkHandle() {
    // value in the native/android/net.c NDK implementation.
    if (netId == 0) {
        // make this zero condition obvious for debugging
        return 0L;
    }
    final long handleMagic = 0xcafed00dL;
    return (((long) netId) << 32) | handleMagic;
}
#method_after
public long getNetworkHandle() {
    // IETF mif working group.
    if (netId == 0) {
        // make this zero condition obvious for debugging
        return 0L;
    }
    return (((long) netId) << HANDLE_MAGIC_SIZE) | HANDLE_MAGIC;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj instanceof Network == false)
        return false;
    Network other = (Network) obj;
    return this.netId == other.netId;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof Network))
        return false;
    Network other = (Network) obj;
    return this.netId == other.netId;
}
#end_block

#method_before
private void setText() {
    @DimenRes
    int textStartPadding;
    switch(mTextStartMarginType) {
        case TEXT_START_MARGIN_TYPE_NONE:
            textStartPadding = R.dimen.car_keyline_1;
            break;
        case TEXT_START_MARGIN_TYPE_LARGE:
            textStartPadding = R.dimen.car_keyline_4;
            break;
        case TEXT_START_MARGIN_TYPE_SMALL:
            textStartPadding = R.dimen.car_keyline_3;
            break;
        default:
            throw new IllegalStateException("Unknown text start margin type.");
    }
    int startMargin = mContext.getResources().getDimensionPixelSize(textStartPadding);
    mBinders.add(vh -> {
        vh.getText().setText(mText);
        vh.getText().setPaddingRelative(startMargin, 0, 0, 0);
        vh.getText().requestLayout();
    });
}
#method_after
public void setText(@NonNull CharSequence text) {
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Text for subheader cannot be empty.");
    }
    mText = text;
    markDirty();
}
#end_block

#method_before
public Builder setMaxStringLength(int length) {
    mMaxStringLength = length;
    return this;
}
#method_after
@NonNull
public Builder setMaxStringLength(int maxStringLength) {
    mMaxStringLength = maxStringLength;
    return this;
}
#end_block

#method_before
public Builder setMaxCumulativeContentItems(int number) {
    mMaxCumulativeContentItems = number;
    return this;
}
#method_after
@NonNull
public Builder setMaxCumulativeContentItems(int maxCumulativeContentItems) {
    mMaxCumulativeContentItems = maxCumulativeContentItems;
    return this;
}
#end_block

#method_before
public Builder setMaxContentDepth(int depth) {
    mMaxContentDepth = depth;
    return this;
}
#method_after
@NonNull
public Builder setMaxContentDepth(int maxContentDepth) {
    mMaxContentDepth = maxContentDepth;
    return this;
}
#end_block

#method_before
public CarUxRestrictions build() {
    return new CarUxRestrictions(this);
}
#method_after
@NonNull
public CarUxRestrictions build() {
    return new CarUxRestrictions(this);
}
#end_block

#method_before
public boolean isDistractionOptimizationRequired() {
    return mRequiresDistractionOptimization;
}
#method_after
public boolean isDistractionOptimizationRequired() {
    return mIsDistractionOptimizationRequired;
}
#end_block

#method_before
@Override
public String toString() {
    return "DO: " + mRequiresDistractionOptimization + " UxR: " + mActiveRestrictions + " time: " + mTimeStamp;
}
#method_after
@Override
public String toString() {
    return "DO: " + mIsDistractionOptimizationRequired + " UxR: " + mActiveRestrictions + " time: " + mTimestamp;
}
#end_block

#method_before
public void setText(String text) {
    mText = text;
    markDirty();
}
#method_after
public void setText(@Nullable CharSequence text) {
    mText = text;
    markDirty();
}
#end_block

#method_before
public void setTitle(String title) {
    mTitle = title;
    markDirty();
}
#method_after
public void setTitle(CharSequence title) {
    mTitle = title;
    markDirty();
}
#end_block

#method_before
public void setBody(String body, boolean asPrimary) {
    mBody = body;
    mIsBodyPrimary = asPrimary;
    markDirty();
}
#method_after
public void setBody(CharSequence body) {
    setBody(body, false);
}
#end_block

#method_before
public void setAction(String text, boolean showDivider, View.OnClickListener listener) {
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Action text cannot be empty.");
    }
    if (listener == null) {
        throw new IllegalArgumentException("Action OnClickListener cannot be null.");
    }
    mSupplementalActionType = SUPPLEMENTAL_ACTION_ONE_ACTION;
    mAction1Text = text;
    mAction1OnClickListener = listener;
    mShowAction1Divider = showDivider;
    markDirty();
}
#method_after
@Deprecated
public void setAction(String text, boolean showDivider, View.OnClickListener listener) {
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Action text cannot be empty.");
    }
    if (listener == null) {
        throw new IllegalArgumentException("Action OnClickListener cannot be null.");
    }
    mSupplementalActionType = SUPPLEMENTAL_ACTION_ONE_ACTION;
    mAction1Text = text;
    mAction1OnClickListener = listener;
    mShowAction1Divider = showDivider;
    markDirty();
}
#end_block

#method_before
public void setActions(String action1Text, boolean showAction1Divider, View.OnClickListener action1OnClickListener, String action2Text, boolean showAction2Divider, View.OnClickListener action2OnClickListener) {
    if (TextUtils.isEmpty(action1Text) || TextUtils.isEmpty(action2Text)) {
        throw new IllegalArgumentException("Action text cannot be empty.");
    }
    if (action1OnClickListener == null || action2OnClickListener == null) {
        throw new IllegalArgumentException("Action OnClickListener cannot be null.");
    }
    mSupplementalActionType = SUPPLEMENTAL_ACTION_TWO_ACTIONS;
    mAction1Text = action1Text;
    mAction1OnClickListener = action1OnClickListener;
    mShowAction1Divider = showAction1Divider;
    mAction2Text = action2Text;
    mAction2OnClickListener = action2OnClickListener;
    mShowAction2Divider = showAction2Divider;
    markDirty();
}
#method_after
@Deprecated
public void setActions(String action1Text, boolean showAction1Divider, View.OnClickListener action1OnClickListener, String action2Text, boolean showAction2Divider, View.OnClickListener action2OnClickListener) {
    if (TextUtils.isEmpty(action1Text) || TextUtils.isEmpty(action2Text)) {
        throw new IllegalArgumentException("Action text cannot be empty.");
    }
    if (action1OnClickListener == null || action2OnClickListener == null) {
        throw new IllegalArgumentException("Action OnClickListener cannot be null.");
    }
    mSupplementalActionType = SUPPLEMENTAL_ACTION_TWO_ACTIONS;
    mAction1Text = action1Text;
    mAction1OnClickListener = action1OnClickListener;
    mShowAction1Divider = showAction1Divider;
    mAction2Text = action2Text;
    mAction2OnClickListener = action2OnClickListener;
    mShowAction2Divider = showAction2Divider;
    markDirty();
}
#end_block

#method_before
private static long generateFdOwnerId(Object owner) {
    if (owner == null) {
        return 0;
    }
    // Type values from bionic's <android/fdsan.h>, where 255 is a generic Java owner.
    long tagType = 255;
    if (owner instanceof java.io.FileInputStream) {
        tagType = 251;
    } else if (owner instanceof java.io.FileOutputStream) {
        tagType = 252;
    } else if (owner instanceof java.io.RandomAccessFile) {
        tagType = 253;
    } else {
        // We need to look up ParcelFileDescriptor dynamically, since we're in libcore.
        try {
            Class<?> pfdClass = Class.forName("android.os.ParcelFileDescriptor");
            if (pfdClass.isInstance(owner)) {
                tagType = 254;
            }
        } catch (ClassNotFoundException ex) {
        }
    }
    // The owner ID is not required to be unique but should be stable and attempt to avoid
    // collision with identifiers generated both here and in native code (which are simply the
    // address of the owning object). identityHashCode(Object) meets these requirements.
    long tagValue = System.identityHashCode(owner);
    return tagType << 56 | tagValue;
}
#method_after
private static long generateFdOwnerId(Object owner) {
    if (owner == null) {
        return 0;
    }
    // Type values from bionic's <android/fdsan.h>.
    long tagType;
    if (owner instanceof java.io.FileInputStream) {
        tagType = 5;
    } else if (owner instanceof java.io.FileOutputStream) {
        tagType = 6;
    } else if (owner instanceof java.io.RandomAccessFile) {
        tagType = 7;
    } else if (isParcelFileDescriptor(owner)) {
        tagType = 8;
    } else {
        // Generic Java type.
        tagType = 255;
    }
    // The owner ID is not required to be unique but should be stable and attempt to avoid
    // collision with identifiers generated both here and in native code (which are simply the
    // address of the owning object). identityHashCode(Object) meets these requirements.
    long tagValue = System.identityHashCode(owner);
    return tagType << 56 | tagValue;
}
#end_block

#method_before
@Override
public void handleMessage(Message message) {
    Log.d("Handling Remote request");
    int senderId = message.sendingUid == DEFAULT_UNSET_SENDING_ID ? DEFAULT_SENDING_ID : message.sendingUid;
    if (message.what == SL4A_ACTION) {
        RpcReceiverManager receiverManager;
        if (mRpcReceiverManagerFactory.getRpcReceiverManagers().containsKey("" + senderId)) {
            receiverManager = mRpcReceiverManagerFactory.getRpcReceiverManagers().get(senderId);
        } else {
            receiverManager = mRpcReceiverManagerFactory.create("" + senderId);
        }
        Bundle sl4aRequest = message.getData();
        String method = sl4aRequest.getString(SL4A_METHOD);
        if (method == null || "".equals(method)) {
            Log.e("No SL4A method specified on the Bundle. Specify one with " + SL4A_METHOD);
            return;
        }
        MethodDescriptor rpc = receiverManager.getMethodDescriptor(method);
        if (rpc == null) {
            Log.e("Unknown RPC: \"" + method + "\"");
            return;
        }
        try {
            Log.d("Invoking method " + rpc.getName());
            Object result = rpc.invoke(receiverManager, sl4aRequest);
            // client did not care for the response.
            if (message.replyTo != null) {
                Message reply = Message.obtain();
                Bundle sl4aResponse = new Bundle();
                putResult(senderId, result, sl4aResponse);
                reply.setData(sl4aResponse);
                message.replyTo.send(reply);
            }
        } catch (RemoteException e) {
            Log.e("Could not send reply back to client", e);
        } catch (Throwable t) {
            Log.e("Exception while executing sl4a method", t);
        }
    }
}
#method_after
@Override
public void handleMessage(Message message) {
    Log.d("Handling Remote request");
    int senderId = message.sendingUid == DEFAULT_UNSET_SENDING_ID ? DEFAULT_SENDING_ID : message.sendingUid;
    String sessionId = "" + senderId;
    if (message.what == SL4A_ACTION) {
        RpcReceiverManager receiverManager;
        if (mRpcReceiverManagerFactory.getRpcReceiverManagers().containsKey(sessionId)) {
            receiverManager = mRpcReceiverManagerFactory.getRpcReceiverManagers().get(sessionId);
        } else {
            receiverManager = mRpcReceiverManagerFactory.create(sessionId);
        }
        Bundle sl4aRequest = message.getData();
        String method = sl4aRequest.getString(SL4A_METHOD);
        if (method == null || "".equals(method)) {
            Log.e("No SL4A method specified on the Bundle. Specify one with " + SL4A_METHOD);
            return;
        }
        MethodDescriptor rpc = receiverManager.getMethodDescriptor(method);
        if (rpc == null) {
            Log.e("Unknown RPC: \"" + method + "\"");
            return;
        }
        try {
            Log.d("Invoking method " + rpc.getName());
            Object result = rpc.invoke(receiverManager, sl4aRequest);
            // client did not care for the response.
            if (message.replyTo != null) {
                Message reply = Message.obtain();
                Bundle sl4aResponse = new Bundle();
                putResult(senderId, result, sl4aResponse);
                reply.setData(sl4aResponse);
                message.replyTo.send(reply);
            }
        } catch (RemoteException e) {
            Log.e("Could not send reply back to client", e);
        } catch (Throwable t) {
            Log.e("Exception while executing sl4a method", t);
        }
    }
}
#end_block

#method_before
@Override
public FacadeManager create(String id) {
    FacadeManager facadeManager = new FacadeManager(mSdkLevel, mService, mIntent, mClassList);
    mFacadeManagers.put(id, facadeManager);
    return facadeManager;
}
#method_after
@Override
public FacadeManager create(String sessionId) throws IllegalArgumentException {
    FacadeManager facadeManager = new FacadeManager(mSdkLevel, mService, mIntent, mClassList);
    // Refactor this to prevent that from potentially occurring.
    synchronized (mFacadeManagers) {
        if (mFacadeManagers.containsKey(sessionId)) {
            throw new IllegalArgumentException("SessionID " + sessionId + " already exists.");
        }
        mFacadeManagers.put(sessionId, facadeManager);
    }
    return facadeManager;
}
#end_block

#method_before
@Override
public boolean destroy(String id) {
    RpcReceiverManager removed = mFacadeManagers.remove(id);
    if (removed != null) {
        removed.shutdown();
    }
    return removed != null;
}
#method_after
@Override
public boolean destroy(String sessionId) {
    RpcReceiverManager removed = mFacadeManagers.remove(sessionId);
    if (removed != null) {
        removed.shutdown();
    }
    return removed != null;
}
#end_block

#method_before
public Object getResponse(String request) {
    try {
        return getResponse(new JSONObject(request));
    } catch (JSONException ignored) {
    // May have been a JSONObject instead of a JSONArray.
    }
    try {
        return Sl4aErrors.JSON_RPC_REQUEST_NOT_JSON.toJson(JSONObject.NULL);
    } catch (JSONException e) {
        // This error will never occur.
        Log.e("Received JSONException on invalid request.", e);
        return JsonRpcResult.wtf();
    }
}
#method_after
public Object getResponse(String request) {
    try {
        return getResponse(new JSONObject(request));
    } catch (JSONException ignored) {
    // May have been a bad request.
    }
    try {
        return Sl4aErrors.JSON_RPC_REQUEST_NOT_JSON.toJson(JSONObject.NULL);
    } catch (JSONException e) {
        // This error will never occur.
        Log.e("Received JSONException on invalid request.", e);
        return JsonRpcResult.wtf();
    }
}
#end_block

#method_before
public Object getResponse(JSONObject request) {
    if (isSessionManagementRpc(request)) {
        return handleSessionRpc(request);
    }
    Object validationErrors = getValidationErrors(request);
    if (validationErrors != null) {
        return validationErrors;
    }
    try {
        Object id = request.get("id");
        String method = request.getString("method");
        JSONArray params = new JSONArray();
        if (request.has("params")) {
            params = request.getJSONArray("params");
        }
        RpcReceiverManager receiverManager = mManagerFactory.getRpcReceiverManagers().get(mSessionId);
        MethodDescriptor rpc = receiverManager.getMethodDescriptor(method);
        if (rpc == null) {
            return Sl4aErrors.JSON_RPC_UNKNOWN_RPC_METHOD.toJson(id, method);
        }
        Object rpcResult;
        try {
            rpcResult = rpc.invoke(receiverManager, params);
        } catch (Throwable t) {
            Log.e("RPC call threw an error.", t);
            return Sl4aErrors.JSON_RPC_FACADE_EXCEPTION_OCCURRED.toJson(id, t);
        }
        try {
            return JsonRpcResult.result(id, rpcResult);
        } catch (JSONException e) {
            // This error is rare, but may occur when the JsonBuilder fails to properly
            // convert the resulting class from the RPC into valid JSON. This may happen
            // when a resulting number is returned as NaN or infinite, but is not converted
            // to a String first.
            Log.e("Unable to build object of class \"" + rpcResult.getClass() + "\".", e);
            return Sl4aErrors.JSON_RPC_RESULT_NOT_JSON_VALID.toJson(id, e);
        } catch (Throwable t) {
            // This error will occur whenever the underlying Android APIs built against are
            // unavailable for the version of Android SL4A is installed onto.
            Log.e("Unable to build object of class \"" + rpcResult.getClass() + "\".", t);
            return Sl4aErrors.JSON_RPC_FAILED_TO_BUILD_RESULT.toJson(id, t);
        }
    } catch (JSONException exception) {
        // This error should never happen. NULL and all values found within Sl4aErrors are
        // guaranteed not to raise an error when being converted to JSON.
        // Also, all JSONObject.get() calls are only done after they have been validated to
        // exist after a corresponding JSONObject.has() call has been made.
        // Returning a raw string here to prevent the need to catch JsonRpcResult.error().
        Log.e(exception);
        return JsonRpcResult.wtf();
    }
}
#method_after
public Object getResponse(JSONObject request) {
    if (isSessionManagementRpc(request)) {
        return handleSessionRpc(request);
    }
    Object validationErrors = getValidationErrors(request);
    if (validationErrors != null) {
        return validationErrors;
    }
    try {
        Object id = request.get("id");
        String method = request.getString("method");
        JSONArray params = new JSONArray();
        if (request.has("params")) {
            params = request.getJSONArray("params");
        }
        RpcReceiverManager receiverManager = mManagerFactory.getRpcReceiverManagers().get(mSessionId);
        if (receiverManager == null) {
            Log.e("Unable to find sessionId \"" + mSessionId + "\".");
            for (String key : mManagerFactory.getRpcReceiverManagers().keySet()) {
                Log.d("Available key: " + key);
            }
            return Sl4aErrors.SESSION_INVALID.toJson(id, mSessionId);
        }
        MethodDescriptor rpc = receiverManager.getMethodDescriptor(method);
        if (rpc == null) {
            return Sl4aErrors.JSON_RPC_UNKNOWN_RPC_METHOD.toJson(id, method);
        }
        Object rpcResult;
        try {
            rpcResult = rpc.invoke(receiverManager, params);
        } catch (Throwable t) {
            Log.e("RPC call threw an error.", t);
            return Sl4aErrors.JSON_RPC_FACADE_EXCEPTION_OCCURRED.toJson(id, t);
        }
        try {
            return JsonRpcResult.result(id, rpcResult);
        } catch (JSONException e) {
            // This error is rare, but may occur when the JsonBuilder fails to properly
            // convert the resulting class from the RPC into valid JSON. This may happen
            // when a resulting number is returned as NaN or infinite, but is not converted
            // to a String first.
            Log.e("Unable to build object of class \"" + rpcResult.getClass() + "\".", e);
            return Sl4aErrors.JSON_RPC_RESULT_NOT_JSON_VALID.toJson(id, e);
        } catch (Throwable t) {
            // This error will occur whenever the underlying Android APIs built against are
            // unavailable for the version of Android SL4A is installed onto.
            Log.e("Unable to build object of class \"" + rpcResult.getClass() + "\".", t);
            return Sl4aErrors.JSON_RPC_FAILED_TO_BUILD_RESULT.toJson(id, t);
        }
    } catch (JSONException exception) {
        // This error should never happen. NULL and all values found within Sl4aErrors are
        // guaranteed not to raise an error when being converted to JSON.
        // Also, all JSONObject.get() calls are only done after they have been validated to
        // exist after a corresponding JSONObject.has() call has been made.
        // Returning a raw string here to prevent the need to catch JsonRpcResult.error().
        Log.e(exception);
        return JsonRpcResult.wtf();
    }
}
#end_block

#method_before
private Object handleSessionRpc(JSONObject request) {
    try {
        Object id = request.get("uid");
        String cmd = request.getString("cmd");
        switch(cmd) {
            case "initiate":
                {
                    String newId;
                    synchronized (mManagerFactory) {
                        newId = "" + mNextSessionId;
                        while (mManagerFactory.getRpcReceiverManagers().containsKey(newId)) {
                            newId = "" + mNextSessionId++;
                        }
                    }
                    mSessionId = newId;
                    mManagerFactory.create(newId);
                    return "{\"uid\": \"" + newId + "\", \"status\":true}";
                }
            case "continue":
                {
                    for (String key : mManagerFactory.getRpcReceiverManagers().keySet()) {
                        Log.d("Available key: " + key);
                    }
                    boolean canContinue = mManagerFactory.getRpcReceiverManagers().containsKey(id);
                    if (canContinue) {
                        mSessionId = id;
                        return "{\"uid\":\"" + id + "\",\"status\":true}";
                    }
                    return "{\"uid\":\"" + id + "\",\"status\":false," + "\"error\":\"Session does not exist.\"}";
                }
            default:
                {
                    // This case should never be reached if isSessionManagementRpc is called first.
                    Log.e("Hit default case for handling session rpcs.");
                    return JsonRpcResult.wtf();
                }
        }
    } catch (JSONException jsonException) {
        // This error will never occur, because the above IDs and objects will always be JSON
        // serializable.
        Log.e("Exception during handleRpcCall: " + jsonException);
        return JsonRpcResult.wtf();
    }
}
#method_after
private Object handleSessionRpc(JSONObject request) {
    try {
        Object id = request.get("uid");
        String cmd = request.getString("cmd");
        switch(cmd) {
            case "initiate":
                {
                    String newId;
                    synchronized (mManagerFactory) {
                        newId = "" + mNextSessionId;
                        while (mManagerFactory.getRpcReceiverManagers().containsKey(newId)) {
                            newId = "" + mNextSessionId++;
                        }
                        mSessionId = newId;
                        mManagerFactory.create(newId);
                    }
                    return "{\"uid\": \"" + newId + "\", \"status\":true}";
                }
            case "continue":
                {
                    for (String key : mManagerFactory.getRpcReceiverManagers().keySet()) {
                        Log.d("Available key: " + key);
                    }
                    String stringId = id.toString();
                    boolean canContinue = mManagerFactory.getRpcReceiverManagers().containsKey(stringId);
                    if (canContinue) {
                        mSessionId = stringId;
                        return "{\"uid\":\"" + id + "\",\"status\":true}";
                    }
                    return "{\"uid\":\"" + id + "\",\"status\":false," + "\"error\":\"Session does not exist.\"}";
                }
            default:
                {
                    // This case should never be reached if isSessionManagementRpc is called first.
                    Log.e("Hit default case for handling session rpcs.");
                    return JsonRpcResult.wtf();
                }
        }
    } catch (JSONException jsonException) {
        // This error will never occur, because the above IDs and objects will always be JSON
        // serializable.
        Log.e("Exception during handleRpcCall: " + jsonException);
        return JsonRpcResult.wtf();
    }
}
#end_block

#method_before
private String postCoverageDataSum(String urlSafeKey) {
    List<List<String>> allHalApiList = new ArrayList();
    List<List<String>> allCoveredHalApiList = new ArrayList();
    Key<TestPlanRunEntity> key = Key.create(urlSafeKey);
    TestPlanRunEntity testPlanRunEntity = ofy().load().key(key).now();
    for (Key testRunKey : testPlanRunEntity.getTestRuns()) {
        List<ApiCoverageEntity> apiCoverageEntityList = ofy().load().type(ApiCoverageEntity.class).ancestor(testRunKey).list();
        for (ApiCoverageEntity apiCoverageEntity : apiCoverageEntityList) {
            allHalApiList.add(apiCoverageEntity.getHalApi());
            allCoveredHalApiList.add(apiCoverageEntity.getCoveredHalApi());
        }
    }
    long totalHalApiNum = allHalApiList.stream().flatMap(Collection::stream).distinct().count();
    long totalCoveredHalApiNum = allCoveredHalApiList.stream().flatMap(Collection::stream).distinct().count();
    testPlanRunEntity.setTotalApiCount(totalHalApiNum);
    testPlanRunEntity.setCoveredApiCount(totalCoveredHalApiNum);
    testPlanRunEntity.save();
    Map<String, Long> halApiNumMap = new HashMap<String, Long>() {

        {
            put("totalHalApiNum", totalHalApiNum);
            put("totalCoveredHalApiNum", totalCoveredHalApiNum);
        }
    };
    // log.info("totalHalApiNum => " + halApiNumMap.get("totalHalApiNum"));
    // log.info("totalCoveredHalApiNum => " + halApiNumMap.get("totalCoveredHalApiNum"));
    String json = new Gson().toJson(halApiNumMap);
    return json;
}
#method_after
private String postCoverageDataSum(String urlSafeKey) {
    List<List<String>> allHalApiList = new ArrayList();
    List<List<String>> allCoveredHalApiList = new ArrayList();
    Key<TestPlanRunEntity> key = Key.create(urlSafeKey);
    TestPlanRunEntity testPlanRunEntity = ofy().load().key(key).now();
    for (Key testRunKey : testPlanRunEntity.getTestRuns()) {
        List<ApiCoverageEntity> apiCoverageEntityList = ofy().load().type(ApiCoverageEntity.class).ancestor(testRunKey).list();
        for (ApiCoverageEntity apiCoverageEntity : apiCoverageEntityList) {
            allHalApiList.add(apiCoverageEntity.getHalApi());
            allCoveredHalApiList.add(apiCoverageEntity.getCoveredHalApi());
        }
    }
    long totalHalApiNum = allHalApiList.stream().flatMap(Collection::stream).distinct().count();
    long totalCoveredHalApiNum = allCoveredHalApiList.stream().flatMap(Collection::stream).distinct().count();
    testPlanRunEntity.setTotalApiCount(totalHalApiNum);
    testPlanRunEntity.setCoveredApiCount(totalCoveredHalApiNum);
    testPlanRunEntity.save();
    Map<String, Long> halApiNumMap = new HashMap<String, Long>() {

        {
            put("totalHalApiNum", totalHalApiNum);
            put("totalCoveredHalApiNum", totalCoveredHalApiNum);
        }
    };
    String json = new Gson().toJson(halApiNumMap);
    return json;
}
#end_block

#method_before
private String getPackageNameForUid(int uid) {
    String result = mContext.getPackageManager().getNameForUid(uid);
    if (TextUtils.isEmpty(result)) {
        result = LEGACY_CONTROLLER;
    }
    return result;
}
#method_after
String getPackageNameForUid(int uid) {
    String result = mContext.getPackageManager().getNameForUid(uid);
    if (TextUtils.isEmpty(result)) {
        result = LEGACY_CONTROLLER;
    }
    return result;
}
#end_block

#method_before
@Override
public void onAddMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null || !dynamicDescriptor.isGroupable() || mMemberRouteIds.contains(routeId)) {
        Log.d(TAG, "onAddMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor).setSelectionState(DynamicRouteDescriptor.SELECTED);
    // Initial member shouldn't be unselected.
    if (mMemberRouteIds.isEmpty()) {
        builder.setIsUnselectable(true);
    }
    mDynamicRouteDescriptors.put(routeId, builder.build());
    mMemberRouteIds.add(routeId);
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).addGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    publishRoutes();
    mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(new ArrayList<>(mDynamicRouteDescriptors.values())));
}
#method_after
@Override
public void onAddMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null || !dynamicDescriptor.isGroupable() || mMemberRouteIds.contains(routeId)) {
        Log.d(TAG, "onAddMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor).setSelectionState(DynamicRouteDescriptor.SELECTED);
    // Initial member shouldn't be unselected.
    if (mMemberRouteIds.isEmpty()) {
        builder.setIsUnselectable(true);
    }
    mDynamicRouteDescriptors.put(routeId, builder.build());
    mMemberRouteIds.add(routeId);
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).addGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    publishRoutes();
    mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(mDynamicRouteDescriptors.values()));
}
#end_block

#method_before
@Override
public void onRemoveMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null || !dynamicDescriptor.isUnselectable() || !mMemberRouteIds.remove(routeId)) {
        Log.d(TAG, "onRemoveMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    MediaRouteDescriptor descriptor = dynamicDescriptor.getRouteDescriptor();
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor);
    if (descriptor.getDeviceType() == MediaRouter.RouteInfo.DEVICE_TYPE_TV) {
        builder.setIsTransferable(true);
        builder.setIsGroupable(false);
    } else {
        builder.setIsTransferable(true);
        builder.setIsGroupable(true);
    }
    builder.setSelectionState(DynamicRouteDescriptor.UNSELECTED);
    mDynamicRouteDescriptors.put(routeId, builder.build());
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).removeGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    publishRoutes();
    mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(new ArrayList<>(mDynamicRouteDescriptors.values())));
}
#method_after
@Override
public void onRemoveMemberRoute(String routeId) {
    DynamicRouteDescriptor dynamicDescriptor = mDynamicRouteDescriptors.get(routeId);
    if (dynamicDescriptor == null || !dynamicDescriptor.isUnselectable() || !mMemberRouteIds.remove(routeId)) {
        Log.d(TAG, "onRemoveMemberRoute: Ignored for routeId: " + routeId);
        return;
    }
    MediaRouteDescriptor descriptor = dynamicDescriptor.getRouteDescriptor();
    DynamicRouteDescriptor.Builder builder = new DynamicRouteDescriptor.Builder(dynamicDescriptor);
    if (descriptor.getDeviceType() == MediaRouter.RouteInfo.DEVICE_TYPE_TV) {
        builder.setIsTransferable(true);
        builder.setIsGroupable(false);
    } else {
        builder.setIsTransferable(true);
        builder.setIsGroupable(true);
    }
    builder.setSelectionState(DynamicRouteDescriptor.UNSELECTED);
    mDynamicRouteDescriptors.put(routeId, builder.build());
    MediaRouteDescriptor groupDescriptor = new MediaRouteDescriptor.Builder(mRouteDescriptors.get(mRouteId)).removeGroupMemberId(routeId).build();
    mRouteDescriptors.put(mRouteId, groupDescriptor);
    publishRoutes();
    mListenerExecutor.execute(() -> mDynamicRoutesChangedListener.onRoutesChanged(mDynamicRouteDescriptors.values()));
}
#end_block

#method_before
// ////////////////////////////////////////////
// Overrides RouteController
// ////////////////////////////////////////////
@Override
public void onRelease() {
    Log.d(TAG, mRouteId + ": Controller released");
    mPlayer.release();
}
#method_after
// ////////////////////////////////////////////
// Overrides RouteController
// ////////////////////////////////////////////
@Override
public void onRelease() {
    Log.d(TAG, mRouteId + ": Controller released");
    mHelper.onRelease();
}
#end_block

#method_before
@Override
public void onSelect() {
    Log.d(TAG, mRouteId + ": Selected");
    mPlayer.connect(null);
}
#method_after
@Override
public void onSelect() {
    Log.d(TAG, mRouteId + ": Selected");
    mHelper.onSelect();
}
#end_block

#method_before
@Override
public void onUnselect() {
    Log.d(TAG, mRouteId + ": Unselected");
    mPlayer.release();
    if (mRouteDescriptors.get(mRouteId).isDynamicGroupRoute()) {
        mRouteDescriptors.remove(mRouteId);
    }
    publishRoutes();
}
#method_after
@Override
public void onUnselect() {
    Log.d(TAG, mRouteId + ": Unselected");
    mHelper.onUnselect();
    if (mRouteDescriptors.get(mRouteId).isDynamicGroupRoute()) {
        mRouteDescriptors.remove(mRouteId);
    }
    publishRoutes();
}
#end_block

#method_before
@Override
public void onSetVolume(int volume) {
    Log.d(TAG, mRouteId + ": Set volume to " + volume);
    if (!mRouteId.equals(FIXED_VOLUME_ROUTE_ID)) {
        setVolumeInternal(volume);
    }
}
#method_after
@Override
public void onSetVolume(int volume) {
    Log.d(TAG, mRouteId + ": Set volume to " + volume);
    mHelper.onSetVolume(volume);
}
#end_block

#method_before
@Override
public void onUpdateVolume(int delta) {
    Log.d(TAG, mRouteId + ": Update volume by " + delta);
    if (!mRouteId.equals(FIXED_VOLUME_ROUTE_ID)) {
        setVolumeInternal(mVolume + delta);
    }
}
#method_after
@Override
public void onUpdateVolume(int delta) {
    Log.d(TAG, mRouteId + ": Update volume by " + delta);
    mHelper.onUpdateVolume(delta);
}
#end_block

#method_before
@Override
public boolean onControlRequest(Intent intent, ControlRequestCallback callback) {
    Log.d(TAG, mRouteId + ": Received control request " + intent);
    String action = intent.getAction();
    if (intent.hasCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK)) {
        boolean success = false;
        if (action.equals(MediaControlIntent.ACTION_PLAY)) {
            success = handlePlay(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_ENQUEUE)) {
            success = handleEnqueue(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_REMOVE)) {
            success = handleRemove(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_SEEK)) {
            success = handleSeek(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_GET_STATUS)) {
            success = handleGetStatus(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_PAUSE)) {
            success = handlePause(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_RESUME)) {
            success = handleResume(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_STOP)) {
            success = handleStop(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_START_SESSION)) {
            success = handleStartSession(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_GET_SESSION_STATUS)) {
            success = handleGetSessionStatus(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_END_SESSION)) {
            success = handleEndSession(intent, callback);
        }
        Log.d(TAG, mSessionManager.toString());
        return success;
    }
    if (callback != null && action.equals(ACTION_TAKE_SNAPSHOT) && intent.hasCategory(CATEGORY_SAMPLE_ROUTE)) {
        if (mSessionManager.getCurrentItem() != null) {
            Bundle data = new Bundle();
            data.putParcelable(EXTRA_SNAPSHOT, mPlayer.getSnapshot());
            callback.onResult(data);
        } else {
            callback.onError("Failed to take a snapshot", null);
        }
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onControlRequest(Intent intent, ControlRequestCallback callback) {
    Log.d(TAG, mRouteId + ": Received control request " + intent);
    return mHelper.onControlRequest(intent, callback);
}
#end_block

#method_before
private void publishRoutes() {
    Resources r = getContext().getResources();
    Intent settingsIntent = new Intent(Intent.ACTION_MAIN);
    settingsIntent.setClass(getContext(), SampleMediaRouteSettingsActivity.class).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    IntentSender is = PendingIntent.getActivity(getContext(), 99, settingsIntent, PendingIntent.FLAG_UPDATE_CURRENT).getIntentSender();
    MediaRouteDescriptor routeDescriptor1 = new MediaRouteDescriptor.Builder(FIXED_VOLUME_ROUTE_ID, r.getString(R.string.fixed_volume_route_name)).setDescription(r.getString(R.string.sample_route_description)).addControlFilters(CONTROL_FILTERS_BASIC).setPlaybackStream(AudioManager.STREAM_MUSIC).setPlaybackType(MediaRouter.RouteInfo.PLAYBACK_TYPE_REMOTE).setVolumeHandling(MediaRouter.RouteInfo.PLAYBACK_VOLUME_FIXED).setVolume(VOLUME_MAX).setCanDisconnect(true).setSettingsActivity(is).build();
    MediaRouteDescriptor routeDescriptor2 = new MediaRouteDescriptor.Builder(VARIABLE_VOLUME_BASIC_ROUTE_ID, r.getString(R.string.variable_volume_basic_route_name)).setDescription(r.getString(R.string.sample_route_description)).addControlFilters(CONTROL_FILTERS_BASIC).setPlaybackStream(AudioManager.STREAM_MUSIC).setPlaybackType(MediaRouter.RouteInfo.PLAYBACK_TYPE_REMOTE).setVolumeHandling(MediaRouter.RouteInfo.PLAYBACK_VOLUME_VARIABLE).setVolumeMax(VOLUME_MAX).setVolume(mVolume).setSettingsActivity(is).build();
    MediaRouteDescriptor routeDescriptor3 = new MediaRouteDescriptor.Builder(VARIABLE_VOLUME_QUEUING_ROUTE_ID, r.getString(R.string.variable_volume_queuing_route_name)).setDescription(r.getString(R.string.sample_route_description)).addControlFilters(CONTROL_FILTERS_QUEUING).setPlaybackStream(AudioManager.STREAM_MUSIC).setPlaybackType(MediaRouter.RouteInfo.PLAYBACK_TYPE_REMOTE).setVolumeHandling(MediaRouter.RouteInfo.PLAYBACK_VOLUME_VARIABLE).setVolumeMax(VOLUME_MAX).setVolume(mVolume).setCanDisconnect(true).build();
    Uri iconUri = Uri.parse("android.resource://com.example.android.supportv7/" + R.drawable.ic_android);
    MediaRouteDescriptor routeDescriptor4 = new MediaRouteDescriptor.Builder(VARIABLE_VOLUME_SESSION_ROUTE_ID, r.getString(R.string.variable_volume_session_route_name)).setDescription(r.getString(R.string.sample_route_description)).addControlFilters(CONTROL_FILTERS_SESSION).setPlaybackStream(AudioManager.STREAM_MUSIC).setPlaybackType(MediaRouter.RouteInfo.PLAYBACK_TYPE_REMOTE).setVolumeHandling(MediaRouter.RouteInfo.PLAYBACK_VOLUME_VARIABLE).setVolumeMax(VOLUME_MAX).setVolume(mVolume).setIconUri(iconUri).build();
    MediaRouteProviderDescriptor providerDescriptor = new MediaRouteProviderDescriptor.Builder().addRoute(routeDescriptor1).addRoute(routeDescriptor2).addRoute(routeDescriptor3).addRoute(routeDescriptor4).build();
    setDescriptor(providerDescriptor);
}
#method_after
protected void publishRoutes() {
    MediaRouteProviderDescriptor providerDescriptor = new MediaRouteProviderDescriptor.Builder().setSupportsDynamicGroupRoute(true).addRoutes(mRouteDescriptors.values()).build();
    setDescriptor(providerDescriptor);
}
#end_block

#method_before
@Override
public void onRelease() {
    Log.d(TAG, mRouteId + ": Controller released");
    mPlayer.release();
}
#method_after
@Override
public void onRelease() {
    Log.d(TAG, mRouteId + ": Controller released");
    mHelper.onRelease();
}
#end_block

#method_before
@Override
public void onSelect() {
    Log.d(TAG, mRouteId + ": Selected");
    mPlayer.connect(null);
}
#method_after
@Override
public void onSelect() {
    Log.d(TAG, mRouteId + ": Selected");
    mHelper.onSelect();
}
#end_block

#method_before
@Override
public void onUnselect() {
    Log.d(TAG, mRouteId + ": Unselected");
    mPlayer.release();
}
#method_after
@Override
public void onUnselect() {
    Log.d(TAG, mRouteId + ": Unselected");
    mHelper.onUnselect();
}
#end_block

#method_before
@Override
public void onSetVolume(int volume) {
    Log.d(TAG, mRouteId + ": Set volume to " + volume);
    if (!mRouteId.equals(FIXED_VOLUME_ROUTE_ID)) {
        setVolumeInternal(volume);
    }
}
#method_after
@Override
public void onSetVolume(int volume) {
    Log.d(TAG, mRouteId + ": Set volume to " + volume);
    mHelper.onSetVolume(volume);
}
#end_block

#method_before
@Override
public void onUpdateVolume(int delta) {
    Log.d(TAG, mRouteId + ": Update volume by " + delta);
    if (!mRouteId.equals(FIXED_VOLUME_ROUTE_ID)) {
        setVolumeInternal(mVolume + delta);
    }
}
#method_after
@Override
public void onUpdateVolume(int delta) {
    Log.d(TAG, mRouteId + ": Update volume by " + delta);
    mHelper.onUpdateVolume(delta);
}
#end_block

#method_before
@Override
public boolean onControlRequest(Intent intent, ControlRequestCallback callback) {
    Log.d(TAG, mRouteId + ": Received control request " + intent);
    String action = intent.getAction();
    if (intent.hasCategory(MediaControlIntent.CATEGORY_REMOTE_PLAYBACK)) {
        boolean success = false;
        if (action.equals(MediaControlIntent.ACTION_PLAY)) {
            success = handlePlay(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_ENQUEUE)) {
            success = handleEnqueue(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_REMOVE)) {
            success = handleRemove(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_SEEK)) {
            success = handleSeek(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_GET_STATUS)) {
            success = handleGetStatus(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_PAUSE)) {
            success = handlePause(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_RESUME)) {
            success = handleResume(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_STOP)) {
            success = handleStop(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_START_SESSION)) {
            success = handleStartSession(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_GET_SESSION_STATUS)) {
            success = handleGetSessionStatus(intent, callback);
        } else if (action.equals(MediaControlIntent.ACTION_END_SESSION)) {
            success = handleEndSession(intent, callback);
        }
        Log.d(TAG, mSessionManager.toString());
        return success;
    }
    if (callback != null && action.equals(ACTION_TAKE_SNAPSHOT) && intent.hasCategory(CATEGORY_SAMPLE_ROUTE)) {
        if (mSessionManager.getCurrentItem() != null) {
            Bundle data = new Bundle();
            data.putParcelable(EXTRA_SNAPSHOT, mPlayer.getSnapshot());
            callback.onResult(data);
        } else {
            callback.onError("Failed to take a snapshot", null);
        }
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onControlRequest(Intent intent, ControlRequestCallback callback) {
    Log.d(TAG, mRouteId + ": Received control request " + intent);
    return mHelper.onControlRequest(intent, callback);
}
#end_block

#method_before
@Override
@NonNull
public Lifecycle getLifecycle() {
    return super.getLifecycle();
}
#method_after
@Override
public Lifecycle getLifecycle() {
    return super.getLifecycle();
}
#end_block

#method_before
@Override
protected void onPause() {
    super.onPause();
    mFragments.dispatchPause();
}
#method_after
@Override
protected void onPause() {
    super.onPause();
    mResumed = false;
    mFragments.dispatchPause();
}
#end_block

#method_before
@Override
protected void onResume() {
    super.onResume();
    mFragments.noteStateNotSaved();
    mFragments.execPendingActions();
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    mResumed = true;
    mFragments.noteStateNotSaved();
    mFragments.execPendingActions();
}
#end_block

#method_before
@Override
protected void onStart() {
    super.onStart();
    if (!mCreated) {
        mCreated = true;
        mFragments.dispatchActivityCreated();
    }
    mFragments.noteStateNotSaved();
    mFragments.execPendingActions();
    // NOTE: HC onStart goes here.
    mFragments.dispatchStart();
}
#method_after
@Override
protected void onStart() {
    super.onStart();
    mStopped = false;
    if (!mCreated) {
        mCreated = true;
        mFragments.dispatchActivityCreated();
    }
    mFragments.noteStateNotSaved();
    mFragments.execPendingActions();
    // NOTE: HC onStart goes here.
    mFragments.dispatchStart();
}
#end_block

#method_before
@Override
protected void onStop() {
    super.onStop();
    markFragmentsCreated();
    mFragments.dispatchStop();
}
#method_after
@Override
protected void onStop() {
    super.onStop();
    mStopped = true;
    markFragmentsCreated();
    mFragments.dispatchStop();
}
#end_block

#method_before
@Override
public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
    super.dump(prefix, fd, writer, args);
    writer.print(prefix);
    writer.print("Local FragmentActivity ");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println(" State:" + getLifecycle().getCurrentState());
    if (getApplication() != null) {
        LoaderManager.getInstance(this).dump(prefix + "  ", fd, writer, args);
    }
    mFragments.getSupportFragmentManager().dump(prefix, fd, writer, args);
}
#method_after
@Override
public void dump(String prefix, FileDescriptor fd, PrintWriter writer, String[] args) {
    super.dump(prefix, fd, writer, args);
    writer.print(prefix);
    writer.print("Local FragmentActivity ");
    writer.print(Integer.toHexString(System.identityHashCode(this)));
    writer.println(" State:");
    String innerPrefix = prefix + "  ";
    writer.print(innerPrefix);
    writer.print("mCreated=");
    writer.print(mCreated);
    writer.print(" mResumed=");
    writer.print(mResumed);
    writer.print(" mStopped=");
    writer.print(mStopped);
    if (getApplication() != null) {
        LoaderManager.getInstance(this).dump(innerPrefix, fd, writer, args);
    }
    mFragments.getSupportFragmentManager().dump(prefix, fd, writer, args);
}
#end_block

#method_before
private static void initializePatternSeparator(LocaleData localeData, Locale locale) {
    NumberingSystem ns = NumberingSystem.getInstance(locale);
    String nsName = ns != null && ns.getRadix() == 10 && !ns.isAlgorithmic() ? ns.getName() : "latn";
    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
    String patternSeparator = null;
    // as fallback.
    if (!"latn".equals(nsName)) {
        try {
            patternSeparator = rb.getStringWithFallback("NumberElements/" + nsName + "/symbols/list");
        } catch (MissingResourceException e) {
        // Try latin numbering system later
        }
    }
    if (patternSeparator == null) {
        try {
            patternSeparator = rb.getStringWithFallback("NumberElements/latn/symbols/list");
        } catch (MissingResourceException e) {
        // Fallback to the default separator ';'.
        }
    }
    if (patternSeparator == null || patternSeparator.isEmpty()) {
        patternSeparator = ";";
    }
    // Pattern separator in libcore supports single java character only.
    localeData.patternSeparator = patternSeparator.charAt(0);
}
#method_after
private static void initializePatternSeparator(LocaleData localeData, Locale locale) {
    NumberingSystem ns = NumberingSystem.getInstance(locale);
    // A numbering system could be numeric or algorithmic. DecimalFormat can only use
    // a numeric and decimal-based (radix == 10) system. Fallback to a Latin, a known numeric
    // and decimal-based if the default numbering system isn't. All locales should have data
    // for Latin numbering system after locale data fallback. See Numbering system section
    // in Unicode Technical Standard #35 for more details.
    String nsName = ns != null && ns.getRadix() == 10 && !ns.isAlgorithmic() ? ns.getName() : "latn";
    ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
    String patternSeparator = null;
    // as fallback.
    if (!"latn".equals(nsName)) {
        try {
            patternSeparator = rb.getStringWithFallback("NumberElements/" + nsName + "/symbols/list");
        } catch (MissingResourceException e) {
        // Try Latin numbering system later
        }
    }
    if (patternSeparator == null) {
        try {
            patternSeparator = rb.getStringWithFallback("NumberElements/latn/symbols/list");
        } catch (MissingResourceException e) {
        // Fallback to the default separator ';'.
        }
    }
    if (patternSeparator == null || patternSeparator.isEmpty()) {
        patternSeparator = ";";
    }
    // Pattern separator in libcore supports single java character only.
    localeData.patternSeparator = patternSeparator.charAt(0);
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public void setButtonVisibility(@Button int button, /*@Visibility*/
int visibility) {
    switch(button) {
        case MediaControlView2.BUTTON_PLAY_PAUSE:
            if (mPlayPauseButton != null && canPause()) {
                mPlayPauseButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_FFWD:
            if (mFfwdButton != null && canSeekForward()) {
                mFfwdButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_REW:
            if (mRewButton != null && canSeekBackward()) {
                mRewButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_NEXT:
            if (mNextButton != null) {
                mNextButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_PREV:
            if (mPrevButton != null) {
                mPrevButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_SUBTITLE:
            if (mSubtitleButton != null && mSubtitleTrackCount > 0) {
                mSubtitleButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_FULL_SCREEN:
            if (mFullScreenButton != null && mOnFullScreenListener != null) {
                mFullScreenButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_OVERFLOW:
            if (mOverflowShowButton != null) {
                mOverflowShowButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_MUTE:
            if (mMuteButton != null) {
                mMuteButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_SETTINGS:
            if (mSettingsButton != null) {
                mSettingsButton.setVisibility(visibility);
            }
            break;
        default:
            break;
    }
}
#method_after
@RestrictTo(LIBRARY_GROUP)
public void setButtonVisibility(@Button int button, /*@Visibility*/
int visibility) {
    switch(button) {
        case MediaControlView2.BUTTON_PLAY_PAUSE:
            if (mPlayPauseButton != null && canPause()) {
                mPlayPauseButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_FFWD:
            if (mFfwdButton != null && canSeekForward()) {
                mFfwdButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_REW:
            if (mRewButton != null && canSeekBackward()) {
                mRewButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_NEXT:
            if (mNextButton != null) {
                mNextButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_PREV:
            if (mPrevButton != null) {
                mPrevButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_SUBTITLE:
            if (mSubtitleButton != null && mSubtitleTrackCount > 0) {
                mSubtitleButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_FULL_SCREEN:
            if (mFullScreenButton != null && mOnFullScreenListener != null) {
                mFullScreenButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_OVERFLOW:
            if (mOverflowShowButton != null) {
                mOverflowShowButton.setVisibility(visibility);
            }
            break;
        case MediaControlView2.BUTTON_SETTINGS:
            if (mSettingsButton != null) {
                mSettingsButton.setVisibility(visibility);
            }
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    // transport controls.
    if (mPrevWidth != getMeasuredWidth()) {
        // Dismiss SettingsWindow if it is showing.
        mSettingsWindow.dismiss();
        // Hide Overflow if it is showing.
        if (mOverflowIsShowing) {
            mOverflowHideAnimator.start();
        }
        // The following view may not have been initialized yet.
        if (mTimeView.getWidth() == 0) {
            return;
        }
        // Update layout if necessary
        int currWidth = getMeasuredWidth();
        int currHeight = getMeasuredHeight();
        Point screenSize = new Point();
        mWindowManager.getDefaultDisplay().getSize(screenSize);
        if (mMediaType == MEDIA_TYPE_DEFAULT) {
            updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_DEFAULT, currWidth, currHeight, screenSize.x, screenSize.y);
        } else if (mMediaType == MEDIA_TYPE_MUSIC) {
            updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_MUSIC, currWidth, currHeight, screenSize.x, screenSize.y);
        }
        mPrevWidth = currWidth;
        // By default, show all bars when view size is changed.
        showAllBars();
    }
    // By default, show all bars when view orientation is changed.
    int currOrientation = retrieveOrientation();
    if (currOrientation != mPrevOrientation) {
        showAllBars();
        mPrevOrientation = currOrientation;
    }
}
#method_after
@Override
public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    // transport controls.
    if (mPrevWidth != getMeasuredWidth()) {
        // The following view may not have been initialized yet.
        if (mTimeView.getWidth() == 0) {
            return;
        }
        // Update layout if necessary
        int currWidth = getMeasuredWidth();
        int currHeight = getMeasuredHeight();
        Point screenSize = new Point();
        mWindowManager.getDefaultDisplay().getSize(screenSize);
        if (mMediaType == MEDIA_TYPE_DEFAULT) {
            updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_DEFAULT, currWidth, currHeight, screenSize.x, screenSize.y);
        } else if (mMediaType == MEDIA_TYPE_MUSIC) {
            updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_MUSIC, currWidth, currHeight, screenSize.x, screenSize.y);
        }
        mPrevWidth = currWidth;
        // By default, show all bars and hide settings window and overflow view when view size
        // is changed.
        showAllBars();
        hideSettingsAndOverflow();
    }
    // By default, show all bars and hide settings window and overflow view when view
    // orientation is changed.
    int currOrientation = retrieveOrientation();
    if (currOrientation != mPrevOrientation) {
        showAllBars();
        hideSettingsAndOverflow();
        mPrevOrientation = currOrientation;
    }
}
#end_block

#method_before
@Override
public void setEnabled(boolean enabled) {
    super.setEnabled(enabled);
    if (mPlayPauseButton != null) {
        mPlayPauseButton.setEnabled(enabled);
    }
    if (mFfwdButton != null) {
        mFfwdButton.setEnabled(enabled);
    }
    if (mRewButton != null) {
        mRewButton.setEnabled(enabled);
    }
    if (mNextButton != null) {
        mNextButton.setEnabled(enabled);
    }
    if (mPrevButton != null) {
        mPrevButton.setEnabled(enabled);
    }
    if (mProgress != null) {
        mProgress.setEnabled(enabled);
    }
    if (mSubtitleButton != null) {
        mSubtitleButton.setEnabled(enabled);
    }
    if (mFullScreenButton != null) {
        mFullScreenButton.setEnabled(enabled);
    }
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setEnabled(enabled);
    }
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setEnabled(enabled);
    }
    if (mMuteButton != null) {
        mMuteButton.setEnabled(enabled);
    }
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setEnabled(enabled);
    }
    if (mSettingsButton != null) {
        mSettingsButton.setEnabled(enabled);
    }
    if (mBackButton != null) {
        mBackButton.setEnabled(enabled);
    }
    if (mRouteButton != null) {
        mRouteButton.setEnabled(enabled);
    }
    disableUnsupportedButtons();
}
#method_after
@Override
public void setEnabled(boolean enabled) {
    super.setEnabled(enabled);
    if (mPlayPauseButton != null) {
        mPlayPauseButton.setEnabled(enabled);
    }
    if (mFfwdButton != null) {
        mFfwdButton.setEnabled(enabled);
    }
    if (mRewButton != null) {
        mRewButton.setEnabled(enabled);
    }
    if (mNextButton != null) {
        mNextButton.setEnabled(enabled);
    }
    if (mPrevButton != null) {
        mPrevButton.setEnabled(enabled);
    }
    if (mProgress != null) {
        mProgress.setEnabled(enabled);
    }
    if (mSubtitleButton != null) {
        mSubtitleButton.setEnabled(enabled);
    }
    if (mFullScreenButton != null) {
        mFullScreenButton.setEnabled(enabled);
    }
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setEnabled(enabled);
    }
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setEnabled(enabled);
    }
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setEnabled(enabled);
    }
    if (mSettingsButton != null) {
        mSettingsButton.setEnabled(enabled);
    }
    if (mBackButton != null) {
        mBackButton.setEnabled(enabled);
    }
    if (mRouteButton != null) {
        mRouteButton.setEnabled(enabled);
    }
    disableUnsupportedButtons();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private void initControllerView(ViewGroup v) {
    mWindowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
    mIconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    // Relating to Title Bar View
    mTitleBar = v.findViewById(R.id.title_bar);
    mTitleView = v.findViewById(R.id.title_text);
    mAdExternalLink = v.findViewById(R.id.ad_external_link);
    mBackButton = v.findViewById(R.id.back);
    if (mBackButton != null) {
        mBackButton.setOnClickListener(mBackListener);
        mBackButton.setVisibility(View.GONE);
    }
    mRouteButton = v.findViewById(R.id.cast);
    // Relating to Center View
    mCenterView = v.findViewById(R.id.center_view);
    mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
    mCenterView.addView(mTransportControls);
    // Relating to Minimal Size FullScreen View. This view is visible only when the current
    // size type is Minimal and it is a view that stretches from left to right end
    // and helps locate the fullscreen button at the right end of the screen.
    mMinimalSizeFullScreenView = (LinearLayout) v.findViewById(R.id.minimal_fullscreen_view);
    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) mMinimalSizeFullScreenView.getLayoutParams();
    int iconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    params.setMargins(0, iconSize * (-1), 0, 0);
    mMinimalSizeFullScreenView.setLayoutParams(params);
    mMinimalSizeFullScreenView.setVisibility(View.GONE);
    // Relating to Progress Bar View
    mProgressBar = v.findViewById(R.id.progress_bar);
    mProgress = v.findViewById(R.id.progress);
    if (mProgress != null) {
        if (mProgress instanceof SeekBar) {
            SeekBar seeker = (SeekBar) mProgress;
            seeker.setOnSeekBarChangeListener(mSeekListener);
            seeker.setProgressDrawable(mResources.getDrawable(R.drawable.custom_progress));
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
        }
        mProgress.setMax(MAX_PROGRESS);
    }
    mProgressBuffer = v.findViewById(R.id.progress_buffer);
    mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
    mNextSeekPosition = SEEK_POSITION_NOT_SET;
    // Relating to Bottom Bar View
    mBottomBar = v.findViewById(R.id.bottom_bar);
    // Relating to Bottom Bar Left View
    mBottomBarLeftView = v.findViewById(R.id.bottom_bar_left);
    mTimeView = v.findViewById(R.id.time);
    // class supports (00:00:00 · 00:00:00).
    if (mTimeView != null) {
        mMaxTimeViewWidth = mTimeView.getWidth();
    }
    mEndTime = v.findViewById(R.id.time_end);
    mCurrentTime = v.findViewById(R.id.time_current);
    mAdSkipView = v.findViewById(R.id.ad_skip_time);
    mFormatBuilder = new StringBuilder();
    mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
    // Relating to Bottom Bar Right View
    mBasicControls = v.findViewById(R.id.basic_controls);
    mExtraControls = v.findViewById(R.id.extra_controls);
    mCustomButtons = v.findViewById(R.id.custom_buttons);
    mSubtitleButton = v.findViewById(R.id.subtitle);
    if (mSubtitleButton != null) {
        mSubtitleButton.setOnClickListener(mSubtitleListener);
    }
    mFullScreenButton = v.findViewById(R.id.fullscreen);
    if (mFullScreenButton != null) {
        mFullScreenButton.setOnClickListener(mFullScreenListener);
    }
    mOverflowShowButton = v.findViewById(R.id.overflow_show);
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setOnClickListener(mOverflowShowListener);
    }
    mOverflowHideButton = v.findViewById(R.id.overflow_hide);
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setOnClickListener(mOverflowHideListener);
    }
    mMuteButton = v.findViewById(R.id.mute);
    if (mMuteButton != null) {
        mMuteButton.setOnClickListener(mMuteButtonListener);
    }
    mSettingsButton = v.findViewById(R.id.settings);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
    }
    mVideoQualityButton = v.findViewById(R.id.video_quality);
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setOnClickListener(mVideoQualityListener);
    }
    mAdRemainingView = v.findViewById(R.id.ad_remaining);
    // Relating to Settings List View
    initializeSettingsLists();
    mSettingsListView = (ListView) inflateLayout(getContext(), R.layout.settings_list);
    mSettingsAdapter = new SettingsAdapter(mSettingsMainTextsList, mSettingsSubTextsList, mSettingsIconIdsList);
    mSubSettingsAdapter = new SubSettingsAdapter(null, 0);
    mSettingsListView.setAdapter(mSettingsAdapter);
    mSettingsListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    mSettingsListView.setOnItemClickListener(mSettingsItemClickListener);
    mEmbeddedSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_settings_width);
    mFullSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_full_settings_width);
    mSettingsItemHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_settings_height);
    mSettingsWindowMargin = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_settings_offset);
    mSettingsWindow = new PopupWindow(mSettingsListView, mEmbeddedSettingsItemWidth, LayoutParams.WRAP_CONTENT, true);
    mSettingsWindow.setOnDismissListener(mSettingsDismissListener);
    int titleBarTranslateY = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_title_bar_height);
    int bottomBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_bottom_bar_height);
    int progressThumbHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size);
    int progressBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_max_size);
    int bottomBarTranslateY = bottomBarHeight + progressThumbHeight / 2 - progressBarHeight / 2;
    ValueAnimator fadeOutAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    fadeOutAnimator.setInterpolator(new LinearInterpolator());
    fadeOutAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                GradientDrawable thumb = (GradientDrawable) mResources.getDrawable(R.drawable.custom_progress_thumb);
                int newSize = (int) (mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size) * alpha);
                thumb.setSize(newSize, newSize);
                seekBar.setThumb(thumb);
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.GONE);
            } else if (alpha == 1.0f) {
                setEnabled(false);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.GONE);
                    mProgressBar.setVisibility(View.GONE);
                }
            }
        }
    });
    ValueAnimator fadeInAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    fadeInAnimator.setInterpolator(new LinearInterpolator());
    fadeInAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                GradientDrawable thumb = (GradientDrawable) mResources.getDrawable(R.drawable.custom_progress_thumb);
                int newSize = (int) (mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size) * alpha);
                thumb.setSize(newSize, newSize);
                seekBar.setThumb(thumb);
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.VISIBLE);
            } else if (alpha == 1.0f) {
                setEnabled(true);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.VISIBLE);
                    mProgressBar.setVisibility(View.VISIBLE);
                }
            }
        }
    });
    mHideMainBarsAnimator = new AnimatorSet();
    mHideMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY)).with(fadeOutAnimator);
    mHideMainBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ONLY_PROGRESS_VISIBLE;
        }
    });
    mHideProgressBarAnimator = new AnimatorSet();
    mHideProgressBarAnimator.play(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight));
    mHideProgressBarAnimator.setDuration(HIDE_TIME_MS);
    mHideProgressBarAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mHideAllBarsAnimator = new AnimatorSet();
    mHideAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(fadeOutAnimator);
    mHideAllBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mShowMainBarsAnimator = new AnimatorSet();
    mShowMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, 0)).with(fadeInAnimator);
    mShowMainBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mShowAllBarsAnimator = new AnimatorSet();
    mShowAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(fadeInAnimator);
    mShowAllBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mOverflowShowAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    mOverflowShowAnimator.setDuration(SHOW_TIME_MS);
    mOverflowShowAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowShowAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mExtraControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.GONE);
            mOverflowHideButton.setVisibility(View.VISIBLE);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mBasicControls.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.GONE);
            }
        }
    });
    mOverflowHideAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    mOverflowHideAnimator.setDuration(SHOW_TIME_MS);
    mOverflowHideAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowHideAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mBasicControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.VISIBLE);
            mOverflowHideButton.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mExtraControls.setVisibility(View.GONE);
        }
    });
}
#method_after
@SuppressWarnings("deprecation")
private void initControllerView(ViewGroup v) {
    mWindowManager = (WindowManager) getContext().getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
    mIconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    // Relating to Title Bar View
    mTitleBar = v.findViewById(R.id.title_bar);
    mTitleView = v.findViewById(R.id.title_text);
    mAdExternalLink = v.findViewById(R.id.ad_external_link);
    mBackButton = v.findViewById(R.id.back);
    if (mBackButton != null) {
        mBackButton.setOnClickListener(mBackListener);
        mBackButton.setVisibility(View.GONE);
    }
    mRouteButton = v.findViewById(R.id.cast);
    // Relating to Center View
    mCenterView = v.findViewById(R.id.center_view);
    mTransportControls = inflateTransportControls(R.layout.embedded_transport_controls);
    mCenterView.addView(mTransportControls);
    // Relating to Minimal Size FullScreen View. This view is visible only when the current
    // size type is Minimal and it is a view that stretches from left to right end
    // and helps locate the fullscreen button at the right end of the screen.
    mMinimalSizeFullScreenView = (LinearLayout) v.findViewById(R.id.minimal_fullscreen_view);
    LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) mMinimalSizeFullScreenView.getLayoutParams();
    int iconSize = mResources.getDimensionPixelSize(R.dimen.mcv2_icon_size);
    params.setMargins(0, iconSize * (-1), 0, 0);
    mMinimalSizeFullScreenView.setLayoutParams(params);
    mMinimalSizeFullScreenView.setVisibility(View.GONE);
    // Relating to Progress Bar View
    mProgressBar = v.findViewById(R.id.progress_bar);
    mProgress = v.findViewById(R.id.progress);
    if (mProgress != null) {
        if (mProgress instanceof SeekBar) {
            SeekBar seeker = (SeekBar) mProgress;
            seeker.setOnSeekBarChangeListener(mSeekListener);
            seeker.setProgressDrawable(mResources.getDrawable(R.drawable.custom_progress));
            seeker.setThumb(mResources.getDrawable(R.drawable.custom_progress_thumb));
        }
        mProgress.setMax(MAX_PROGRESS);
    }
    mProgressBuffer = v.findViewById(R.id.progress_buffer);
    mCurrentSeekPosition = SEEK_POSITION_NOT_SET;
    mNextSeekPosition = SEEK_POSITION_NOT_SET;
    // Relating to Bottom Bar View
    mBottomBar = v.findViewById(R.id.bottom_bar);
    // Relating to Bottom Bar Left View
    mBottomBarLeftView = v.findViewById(R.id.bottom_bar_left);
    mTimeView = v.findViewById(R.id.time);
    // class supports (00:00:00 · 00:00:00).
    if (mTimeView != null) {
        mMaxTimeViewWidth = mTimeView.getWidth();
    }
    mEndTime = v.findViewById(R.id.time_end);
    mCurrentTime = v.findViewById(R.id.time_current);
    mAdSkipView = v.findViewById(R.id.ad_skip_time);
    mFormatBuilder = new StringBuilder();
    mFormatter = new Formatter(mFormatBuilder, Locale.getDefault());
    // Relating to Bottom Bar Right View
    mBasicControls = v.findViewById(R.id.basic_controls);
    mExtraControls = v.findViewById(R.id.extra_controls);
    mCustomButtons = v.findViewById(R.id.custom_buttons);
    mSubtitleButton = v.findViewById(R.id.subtitle);
    if (mSubtitleButton != null) {
        mSubtitleButton.setOnClickListener(mSubtitleListener);
    }
    mFullScreenButton = v.findViewById(R.id.fullscreen);
    if (mFullScreenButton != null) {
        mFullScreenButton.setOnClickListener(mFullScreenListener);
    }
    mOverflowShowButton = v.findViewById(R.id.overflow_show);
    if (mOverflowShowButton != null) {
        mOverflowShowButton.setOnClickListener(mOverflowShowListener);
    }
    mOverflowHideButton = v.findViewById(R.id.overflow_hide);
    if (mOverflowHideButton != null) {
        mOverflowHideButton.setOnClickListener(mOverflowHideListener);
    }
    mSettingsButton = v.findViewById(R.id.settings);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
    }
    mVideoQualityButton = v.findViewById(R.id.video_quality);
    if (mVideoQualityButton != null) {
        mVideoQualityButton.setOnClickListener(mVideoQualityListener);
    }
    mAdRemainingView = v.findViewById(R.id.ad_remaining);
    // Relating to Settings List View
    initializeSettingsLists();
    mSettingsListView = (ListView) inflateLayout(getContext(), R.layout.settings_list);
    mSettingsAdapter = new SettingsAdapter(mSettingsMainTextsList, mSettingsSubTextsList, mSettingsIconIdsList);
    mSubSettingsAdapter = new SubSettingsAdapter(null, 0);
    mSettingsListView.setAdapter(mSettingsAdapter);
    mSettingsListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    mSettingsListView.setOnItemClickListener(mSettingsItemClickListener);
    mEmbeddedSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_embedded_settings_width);
    mFullSettingsItemWidth = mResources.getDimensionPixelSize(R.dimen.mcv2_full_settings_width);
    mSettingsItemHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_settings_height);
    mSettingsWindowMargin = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_settings_offset);
    mSettingsWindow = new PopupWindow(mSettingsListView, mEmbeddedSettingsItemWidth, LayoutParams.WRAP_CONTENT, true);
    mSettingsWindow.setOnDismissListener(mSettingsDismissListener);
    int titleBarTranslateY = (-1) * mResources.getDimensionPixelSize(R.dimen.mcv2_title_bar_height);
    int bottomBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_bottom_bar_height);
    int progressThumbHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size);
    int progressBarHeight = mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_max_size);
    int bottomBarTranslateY = bottomBarHeight + progressThumbHeight / 2 - progressBarHeight / 2;
    ValueAnimator fadeOutAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    fadeOutAnimator.setInterpolator(new LinearInterpolator());
    fadeOutAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                GradientDrawable thumb = (GradientDrawable) mResources.getDrawable(R.drawable.custom_progress_thumb);
                int newSize = (int) (mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size) * alpha);
                thumb.setSize(newSize, newSize);
                seekBar.setThumb(thumb);
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.GONE);
            } else if (alpha == 1.0f) {
                setEnabled(false);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.GONE);
                    mProgressBar.setVisibility(View.GONE);
                }
            }
        }
    });
    ValueAnimator fadeInAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    fadeInAnimator.setInterpolator(new LinearInterpolator());
    fadeInAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            float alpha = (float) animation.getAnimatedValue();
            SeekBar seekBar = (SeekBar) mProgress;
            if (mSizeType != SIZE_TYPE_MINIMAL) {
                GradientDrawable thumb = (GradientDrawable) mResources.getDrawable(R.drawable.custom_progress_thumb);
                int newSize = (int) (mResources.getDimensionPixelSize(R.dimen.mcv2_custom_progress_thumb_size) * alpha);
                thumb.setSize(newSize, newSize);
                seekBar.setThumb(thumb);
            }
            mTransportControls.setAlpha(alpha);
            if (alpha == 0.0f) {
                mTransportControls.setVisibility(View.VISIBLE);
            } else if (alpha == 1.0f) {
                setEnabled(true);
            }
            if (mSizeType == SIZE_TYPE_MINIMAL) {
                mFullScreenButton.setAlpha(alpha);
                mProgressBar.setAlpha(alpha);
                if (alpha == 0.0f) {
                    mFullScreenButton.setVisibility(View.VISIBLE);
                    mProgressBar.setVisibility(View.VISIBLE);
                }
            }
        }
    });
    mHideMainBarsAnimator = new AnimatorSet();
    mHideMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY)).with(fadeOutAnimator);
    mHideMainBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ONLY_PROGRESS_VISIBLE;
        }
    });
    mHideProgressBarAnimator = new AnimatorSet();
    mHideProgressBarAnimator.play(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, bottomBarTranslateY + progressBarHeight));
    mHideProgressBarAnimator.setDuration(HIDE_TIME_MS);
    mHideProgressBarAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mHideAllBarsAnimator = new AnimatorSet();
    mHideAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", 0, titleBarTranslateY)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", 0, bottomBarTranslateY + progressBarHeight)).with(fadeOutAnimator);
    mHideAllBarsAnimator.setDuration(HIDE_TIME_MS);
    mHideAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_NONE_VISIBLE;
        }
    });
    mShowMainBarsAnimator = new AnimatorSet();
    mShowMainBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY, 0)).with(fadeInAnimator);
    mShowMainBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowMainBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mShowAllBarsAnimator = new AnimatorSet();
    mShowAllBarsAnimator.play(ObjectAnimator.ofFloat(mTitleBar, "translationY", titleBarTranslateY, 0)).with(ObjectAnimator.ofFloat(mBottomBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(ObjectAnimator.ofFloat(mProgressBar, "translationY", bottomBarTranslateY + progressBarHeight, 0)).with(fadeInAnimator);
    mShowAllBarsAnimator.setDuration(SHOW_TIME_MS);
    mShowAllBarsAnimator.getChildAnimations().get(0).addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            setEnabled(false);
            mUxState = UX_STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            setEnabled(true);
            mUxState = UX_STATE_ALL_VISIBLE;
        }
    });
    mOverflowShowAnimator = ValueAnimator.ofFloat(0.0f, 1.0f);
    mOverflowShowAnimator.setDuration(SHOW_TIME_MS);
    mOverflowShowAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowShowAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mExtraControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.GONE);
            mOverflowHideButton.setVisibility(View.VISIBLE);
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mBasicControls.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.GONE);
            }
        }
    });
    mOverflowHideAnimator = ValueAnimator.ofFloat(1.0f, 0.0f);
    mOverflowHideAnimator.setDuration(SHOW_TIME_MS);
    mOverflowHideAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            animateOverflow(animation);
        }
    });
    mOverflowHideAnimator.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            mBasicControls.setVisibility(View.VISIBLE);
            mOverflowShowButton.setVisibility(View.VISIBLE);
            mOverflowHideButton.setVisibility(View.GONE);
            if (mSizeType == SIZE_TYPE_FULL && mMediaType == MEDIA_TYPE_DEFAULT) {
                mFfwdButton.setVisibility(View.VISIBLE);
            }
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mExtraControls.setVisibility(View.GONE);
        }
    });
}
#end_block

#method_before
void updateAudioMetadata() {
    if (mMediaType != MEDIA_TYPE_MUSIC) {
        return;
    }
    if (mController.hasMetadata()) {
        String titleText = mController.getTitle();
        String artistText = mController.getArtistText();
        if (titleText == null) {
            titleText = mResources.getString(R.string.mcv2_music_title_unknown_text);
        }
        if (artistText == null) {
            artistText = mResources.getString(R.string.mcv2_music_artist_unknown_text);
        }
        // Update title for Embedded size type
        mTitleView.setText(titleText + " - " + artistText);
        // Update mute button location
        mBasicControls.removeView(mMuteButton);
        mExtraControls.addView(mMuteButton, 0);
        // Remove unnecessary buttons
        mVideoQualityButton.setVisibility(View.GONE);
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.GONE);
        }
        if (mRewButton != null) {
            mRewButton.setVisibility(View.GONE);
        }
        Point screenSize = new Point();
        mWindowManager.getDefaultDisplay().getSize(screenSize);
        updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_MUSIC, getMeasuredWidth(), getMeasuredHeight(), screenSize.x, screenSize.y);
    }
}
#method_after
void updateAudioMetadata() {
    if (mMediaType != MEDIA_TYPE_MUSIC) {
        return;
    }
    if (mController.hasMetadata()) {
        String titleText = mController.getTitle();
        String artistText = mController.getArtistText();
        if (titleText == null) {
            titleText = mResources.getString(R.string.mcv2_music_title_unknown_text);
        }
        if (artistText == null) {
            artistText = mResources.getString(R.string.mcv2_music_artist_unknown_text);
        }
        // Update title for Embedded size type
        mTitleView.setText(titleText + " - " + artistText);
        // Remove unnecessary buttons
        mVideoQualityButton.setVisibility(View.GONE);
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.GONE);
        }
        if (mRewButton != null) {
            mRewButton.setVisibility(View.GONE);
        }
        Point screenSize = new Point();
        mWindowManager.getDefaultDisplay().getSize(screenSize);
        updateLayout(BOTTOM_BAR_RIGHT_VIEW_MAX_ICON_NUM_MUSIC, getMeasuredWidth(), getMeasuredHeight(), screenSize.x, screenSize.y);
    }
}
#end_block

#method_before
private void initializeSettingsLists() {
    mSettingsMainTextsList = new ArrayList<String>();
    mSettingsMainTextsList.add(mResources.getString(R.string.MediaControlView2_audio_track_text));
    mSettingsMainTextsList.add(mResources.getString(R.string.MediaControlView2_playback_speed_text));
    mSettingsSubTextsList = new ArrayList<String>();
    mSettingsSubTextsList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
    mSettingsSubTextsList.add(mResources.getStringArray(R.array.MediaControlView2_playback_speeds)[PLAYBACK_SPEED_1x_INDEX]);
    mSettingsSubTextsList.add(RESOURCE_EMPTY);
    mSettingsIconIdsList = new ArrayList<Integer>();
    mSettingsIconIdsList.add(R.drawable.ic_audiotrack);
    mSettingsIconIdsList.add(R.drawable.ic_play_circle_filled);
    mAudioTrackList = new ArrayList<String>();
    mAudioTrackList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
    mVideoQualityList = new ArrayList<String>();
    mVideoQualityList.add(mResources.getString(R.string.MediaControlView2_video_quality_auto_text));
    mPlaybackSpeedTextList = new ArrayList<String>(Arrays.asList(mResources.getStringArray(R.array.MediaControlView2_playback_speeds)));
    // Select the "1x" speed as the default value.
    mSelectedSpeedIndex = PLAYBACK_SPEED_1x_INDEX;
    mPlaybackSpeedList = new ArrayList<Float>();
    int[] speeds = mResources.getIntArray(R.array.speed_multiplied_by_100);
    for (int i = 0; i < speeds.length; i++) {
        float speed = (float) speeds[i] / 100.0f;
        mPlaybackSpeedList.add(speed);
    }
    mCustomPlaybackSpeedIndex = -1;
}
#method_after
private void initializeSettingsLists() {
    mSettingsMainTextsList = new ArrayList<String>();
    mSettingsMainTextsList.add(mResources.getString(R.string.MediaControlView2_audio_track_text));
    mSettingsMainTextsList.add(mResources.getString(R.string.MediaControlView2_playback_speed_text));
    mSettingsSubTextsList = new ArrayList<String>();
    mSettingsSubTextsList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
    String normalSpeed = mResources.getString(R.string.MediaControlView2_playback_speed_normal);
    mSettingsSubTextsList.add(normalSpeed);
    mSettingsSubTextsList.add(RESOURCE_EMPTY);
    mSettingsIconIdsList = new ArrayList<Integer>();
    mSettingsIconIdsList.add(R.drawable.ic_audiotrack);
    mSettingsIconIdsList.add(R.drawable.ic_play_circle_filled);
    mAudioTrackList = new ArrayList<String>();
    mAudioTrackList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
    mVideoQualityList = new ArrayList<String>();
    mVideoQualityList.add(mResources.getString(R.string.MediaControlView2_video_quality_auto_text));
    mPlaybackSpeedTextList = new ArrayList<String>(Arrays.asList(mResources.getStringArray(R.array.MediaControlView2_playback_speeds)));
    // Select the normal speed (1x) as the default value.
    mPlaybackSpeedTextList.add(PLAYBACK_SPEED_1x_INDEX, normalSpeed);
    mSelectedSpeedIndex = PLAYBACK_SPEED_1x_INDEX;
    mPlaybackSpeedMultBy100List = new ArrayList<Integer>();
    int[] speeds = mResources.getIntArray(R.array.speed_multiplied_by_100);
    for (int i = 0; i < speeds.length; i++) {
        mPlaybackSpeedMultBy100List.add(speeds[i]);
    }
    mCustomPlaybackSpeedIndex = -1;
}
#end_block

#method_before
boolean isHttpSchemeUrl(MediaItem2 currentMediaItem) {
    if (currentMediaItem == null) {
        return false;
    }
    DataSourceDesc2 dsd = currentMediaItem.getDataSourceDesc();
    Uri uri = (dsd != null && dsd.getType() == DataSourceDesc2.TYPE_URI) ? ((UriDataSourceDesc2) dsd).getUri() : null;
    if (uri == null) {
        // Something wrong.
        return false;
    }
    String scheme = uri.getScheme();
    if (scheme != null) {
        if (scheme.equals("http") || scheme.equals("https")) {
            return true;
        }
    }
    return false;
}
#method_after
boolean isHttpSchemeUrl(MediaItem2 currentMediaItem) {
    if (currentMediaItem == null) {
        return false;
    }
    DataSourceDesc2 dsd = currentMediaItem.getDataSourceDesc();
    Uri uri = (dsd != null && dsd instanceof UriDataSourceDesc2) ? ((UriDataSourceDesc2) dsd).getUri() : null;
    if (uri == null) {
        // Something wrong.
        return false;
    }
    String scheme = uri.getScheme();
    if (scheme != null) {
        if (scheme.equals("http") || scheme.equals("https")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
void updateAllowedCommands(SessionCommandGroup2 commands) {
    if (DEBUG) {
        Log.d(TAG, "updateAllowedCommands(): commands: " + commands);
    }
    if (mAllowedCommands == commands) {
        return;
    }
    mAllowedCommands = commands;
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYBACK_PAUSE)) {
        mPlayPauseButton.setVisibility(View.VISIBLE);
        mPlayPauseButton.setEnabled(true);
    } else {
        mPlayPauseButton.setVisibility(View.GONE);
    }
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_SESSION_REWIND) && mMediaType != MEDIA_TYPE_MUSIC) {
        if (mRewButton != null) {
            mRewButton.setVisibility(View.VISIBLE);
            mRewButton.setEnabled(true);
        }
    } else {
        if (mRewButton != null) {
            mRewButton.setVisibility(View.GONE);
        }
    }
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD) && mMediaType != MEDIA_TYPE_MUSIC) {
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.VISIBLE);
            mFfwdButton.setEnabled(true);
        }
    } else {
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.GONE);
        }
    }
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYBACK_SEEK_TO)) {
        mSeekAvailable = true;
        mProgress.setEnabled(true);
    }
    if (commands.hasCommand(new SessionCommand2(COMMAND_SHOW_SUBTITLE, null)) && commands.hasCommand(new SessionCommand2(COMMAND_HIDE_SUBTITLE, null))) {
        mSubtitleButton.setVisibility(View.VISIBLE);
    } else {
        mSubtitleButton.setVisibility(View.GONE);
    }
    if (commands.hasCommand(new SessionCommand2(COMMAND_MUTE, null)) && commands.hasCommand(new SessionCommand2(COMMAND_UNMUTE, null))) {
        mMuteButton.setVisibility(View.VISIBLE);
    } else {
        mMuteButton.setVisibility(View.GONE);
    }
}
#method_after
void updateAllowedCommands(SessionCommandGroup2 commands) {
    if (DEBUG) {
        Log.d(TAG, "updateAllowedCommands(): commands: " + commands);
    }
    if (mAllowedCommands == commands) {
        return;
    }
    mAllowedCommands = commands;
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYBACK_PAUSE)) {
        mPlayPauseButton.setVisibility(View.VISIBLE);
        mPlayPauseButton.setEnabled(true);
    } else {
        mPlayPauseButton.setVisibility(View.GONE);
    }
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_SESSION_REWIND) && mMediaType != MEDIA_TYPE_MUSIC) {
        if (mRewButton != null) {
            mRewButton.setVisibility(View.VISIBLE);
            mRewButton.setEnabled(true);
        }
    } else {
        if (mRewButton != null) {
            mRewButton.setVisibility(View.GONE);
        }
    }
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_SESSION_FAST_FORWARD) && mMediaType != MEDIA_TYPE_MUSIC) {
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.VISIBLE);
            mFfwdButton.setEnabled(true);
        }
    } else {
        if (mFfwdButton != null) {
            mFfwdButton.setVisibility(View.GONE);
        }
    }
    if (commands.hasCommand(SessionCommand2.COMMAND_CODE_PLAYBACK_SEEK_TO)) {
        mSeekAvailable = true;
        mProgress.setEnabled(true);
    }
    if (commands.hasCommand(new SessionCommand2(COMMAND_SHOW_SUBTITLE, null)) && commands.hasCommand(new SessionCommand2(COMMAND_HIDE_SUBTITLE, null))) {
        mSubtitleButton.setVisibility(View.VISIBLE);
    } else {
        mSubtitleButton.setVisibility(View.GONE);
    }
}
#end_block

#method_before
private void showAllBars() {
    if (mUxState != UX_STATE_ALL_VISIBLE) {
        removeCallbacks(mHideMainBars);
        removeCallbacks(mHideProgressBar);
        // b/112570875
        post(mShowMainBars);
    }
}
#method_after
private void showAllBars() {
    if (mUxState != UX_STATE_ALL_VISIBLE) {
        removeCallbacks(mHideMainBars);
        removeCallbacks(mHideProgressBar);
        // b/112570875
        post(mShowMainBars);
    } else {
        resetHideCallbacks();
    }
}
#end_block

#method_before
private void removeCustomSpeedFromList() {
    mPlaybackSpeedList.remove(mCustomPlaybackSpeedIndex);
    mPlaybackSpeedTextList.remove(mCustomPlaybackSpeedIndex);
    mCustomPlaybackSpeedIndex = -1;
}
#method_after
void removeCustomSpeedFromList() {
    mPlaybackSpeedMultBy100List.remove(mCustomPlaybackSpeedIndex);
    mPlaybackSpeedTextList.remove(mCustomPlaybackSpeedIndex);
    mCustomPlaybackSpeedIndex = -1;
}
#end_block

#method_before
private void updateSelectedSpeed(int selectedSpeedIndex, String selectedSpeedText) {
    mSelectedSpeedIndex = selectedSpeedIndex;
    mSettingsSubTextsList.set(SETTINGS_MODE_PLAYBACK_SPEED, selectedSpeedText);
    mSubSettingsAdapter.setTexts(mPlaybackSpeedTextList);
    mSubSettingsAdapter.setCheckPosition(mSelectedSpeedIndex);
}
#method_after
void updateSelectedSpeed(int selectedSpeedIndex, String selectedSpeedText) {
    mSelectedSpeedIndex = selectedSpeedIndex;
    mSettingsSubTextsList.set(SETTINGS_MODE_PLAYBACK_SPEED, selectedSpeedText);
    mSubSettingsAdapter.setTexts(mPlaybackSpeedTextList);
    mSubSettingsAdapter.setCheckPosition(mSelectedSpeedIndex);
}
#end_block

#method_before
@Override
public void onPlaybackSpeedChanged(@NonNull MediaController2 controller, float speed) {
    float roundedPlaybackSpeed = Math.round(speed * 100.0f) / 100.0f;
    // playback speed to the default list.
    if (mPlaybackSpeedList.contains(roundedPlaybackSpeed)) {
        if (mCustomPlaybackSpeedIndex != -1) {
            // Remove existing custom playback speed
            removeCustomSpeedFromList();
            for (int i = 0; i < mPlaybackSpeedList.size(); i++) {
                if (roundedPlaybackSpeed == mPlaybackSpeedList.get(i)) {
                    updateSelectedSpeed(i, mPlaybackSpeedTextList.get(i));
                    break;
                }
            }
        }
    } else {
        if (mCustomPlaybackSpeedIndex != -1) {
            // Remove existing custom playback speed
            removeCustomSpeedFromList();
        }
        float customPlaybackSpeed = roundedPlaybackSpeed;
        String customPlaybackSpeedText = Float.toString(roundedPlaybackSpeed) + "x";
        for (int i = 0; i < mPlaybackSpeedList.size(); i++) {
            if (customPlaybackSpeed < mPlaybackSpeedList.get(i)) {
                mPlaybackSpeedList.add(i, customPlaybackSpeed);
                mPlaybackSpeedTextList.add(i, customPlaybackSpeedText);
                updateSelectedSpeed(i, customPlaybackSpeedText);
                break;
            }
            // value in the default speed list.
            if (i == mPlaybackSpeedList.size() - 1 && customPlaybackSpeed > mPlaybackSpeedList.get(i)) {
                mPlaybackSpeedList.add(customPlaybackSpeed);
                mPlaybackSpeedTextList.add(customPlaybackSpeedText);
                updateSelectedSpeed(i + 1, customPlaybackSpeedText);
            }
        }
        mCustomPlaybackSpeedIndex = mSelectedSpeedIndex;
    }
}
#method_after
@Override
public void onPlaybackSpeedChanged(@NonNull MediaController2 controller, float speed) {
    int customSpeedMultBy100 = Math.round(speed * 100);
    // playback speed to the default list.
    if (mCustomPlaybackSpeedIndex != -1) {
        // Remove existing custom playback speed
        removeCustomSpeedFromList();
    }
    if (mPlaybackSpeedMultBy100List.contains(customSpeedMultBy100)) {
        for (int i = 0; i < mPlaybackSpeedMultBy100List.size(); i++) {
            if (customSpeedMultBy100 == mPlaybackSpeedMultBy100List.get(i)) {
                updateSelectedSpeed(i, mPlaybackSpeedTextList.get(i));
                break;
            }
        }
    } else {
        String customSpeedText = mResources.getString(R.string.MediaControlView2_custom_playback_speed_text, customSpeedMultBy100 / 100.0f);
        for (int i = 0; i < mPlaybackSpeedMultBy100List.size(); i++) {
            if (customSpeedMultBy100 < mPlaybackSpeedMultBy100List.get(i)) {
                mPlaybackSpeedMultBy100List.add(i, customSpeedMultBy100);
                mPlaybackSpeedTextList.add(i, customSpeedText);
                updateSelectedSpeed(i, customSpeedText);
                break;
            }
            // value in the default speed list.
            if (i == mPlaybackSpeedMultBy100List.size() - 1 && customSpeedMultBy100 > mPlaybackSpeedMultBy100List.get(i)) {
                mPlaybackSpeedMultBy100List.add(customSpeedMultBy100);
                mPlaybackSpeedTextList.add(customSpeedText);
                updateSelectedSpeed(i + 1, customSpeedText);
            }
        }
        mCustomPlaybackSpeedIndex = mSelectedSpeedIndex;
    }
}
#end_block

#method_before
@Override
public void onCustomCommand(@NonNull MediaController2 controller, @NonNull SessionCommand2 command, @Nullable Bundle args, @Nullable ResultReceiver receiver) {
    if (DEBUG) {
        Log.d(TAG, "onCustomCommand(): command: " + command);
    }
    switch(command.getCustomCommand()) {
        case EVENT_UPDATE_TRACK_STATUS:
            mVideoTrackCount = (args != null) ? args.getInt(KEY_VIDEO_TRACK_COUNT) : 0;
            // If there is one or more audio tracks, and this information has not been
            // reflected into the Settings window yet, automatically check the first
            // track.
            // Otherwise, the Audio Track selection will be defaulted to "None".
            mAudioTrackCount = (args != null) ? args.getInt(KEY_AUDIO_TRACK_COUNT) : 0;
            mAudioTrackList = new ArrayList<String>();
            if (mAudioTrackCount > 0) {
                for (int i = 0; i < mAudioTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView2_audio_track_number_text, i + 1);
                    mAudioTrackList.add(track);
                }
                // Change sub text inside the Settings window.
                mSettingsSubTextsList.set(SETTINGS_MODE_AUDIO_TRACK, mAudioTrackList.get(0));
            } else {
                mAudioTrackList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
            }
            if (mVideoTrackCount == 0 && mAudioTrackCount > 0) {
                mMediaType = MEDIA_TYPE_MUSIC;
            }
            mSubtitleTrackCount = (args != null) ? args.getInt(KEY_SUBTITLE_TRACK_COUNT) : 0;
            List<String> subtitleTracksLanguageList = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
            mSubtitleDescriptionsList = new ArrayList<String>();
            if (mSubtitleTrackCount > 0) {
                mSubtitleButton.setVisibility(View.VISIBLE);
                mSubtitleButton.setEnabled(true);
                mSubtitleDescriptionsList.add(mResources.getString(R.string.MediaControlView2_subtitle_off_text));
                for (int i = 0; i < mSubtitleTrackCount; i++) {
                    String lang = subtitleTracksLanguageList.get(i);
                    String track;
                    if (lang.equals("")) {
                        track = mResources.getString(R.string.MediaControlView2_subtitle_track_number_text, i + 1);
                    } else {
                        track = mResources.getString(R.string.MediaControlView2_subtitle_track_number_and_lang_text, i + 1, lang);
                    }
                    mSubtitleDescriptionsList.add(track);
                }
            } else {
                mSubtitleButton.setVisibility(View.GONE);
                mSubtitleButton.setEnabled(false);
            }
            break;
        case EVENT_UPDATE_MEDIA_TYPE_STATUS:
            boolean isAd = (args != null) && args.getBoolean(KEY_STATE_IS_ADVERTISEMENT);
            if (isAd != mIsAdvertisement) {
                mIsAdvertisement = isAd;
                updateLayoutForAd();
            }
            break;
        case EVENT_UPDATE_SUBTITLE_SELECTED:
            int selectedTrackIndex = args != null ? args.getInt(KEY_SELECTED_SUBTITLE_INDEX, -1) : -1;
            if (selectedTrackIndex < 0 || selectedTrackIndex >= mSubtitleTrackCount) {
                Log.w(TAG, "Selected subtitle track index (" + selectedTrackIndex + ") is out of range.");
                break;
            }
            mSelectedSubtitleTrackIndex = selectedTrackIndex + 1;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
        case EVENT_UPDATE_SUBTITLE_DESELECTED:
            mSelectedSubtitleTrackIndex = 0;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
    }
}
#method_after
@Override
public void onCustomCommand(@NonNull MediaController2 controller, @NonNull SessionCommand2 command, @Nullable Bundle args, @Nullable ResultReceiver receiver) {
    if (DEBUG) {
        Log.d(TAG, "onCustomCommand(): command: " + command);
    }
    switch(command.getCustomCommand()) {
        case EVENT_UPDATE_TRACK_STATUS:
            mVideoTrackCount = (args != null) ? args.getInt(KEY_VIDEO_TRACK_COUNT) : 0;
            // If there is one or more audio tracks, and this information has not been
            // reflected into the Settings window yet, automatically check the first
            // track.
            // Otherwise, the Audio Track selection will be defaulted to "None".
            mAudioTrackCount = (args != null) ? args.getInt(KEY_AUDIO_TRACK_COUNT) : 0;
            mAudioTrackList = new ArrayList<String>();
            if (mAudioTrackCount > 0) {
                for (int i = 0; i < mAudioTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView2_audio_track_number_text, i + 1);
                    mAudioTrackList.add(track);
                }
                // Change sub text inside the Settings window.
                mSettingsSubTextsList.set(SETTINGS_MODE_AUDIO_TRACK, mAudioTrackList.get(0));
            } else {
                mAudioTrackList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
            }
            if (mVideoTrackCount == 0 && mAudioTrackCount > 0) {
                mMediaType = MEDIA_TYPE_MUSIC;
            }
            mSubtitleTrackCount = (args != null) ? args.getInt(KEY_SUBTITLE_TRACK_COUNT) : 0;
            List<String> subtitleTracksLanguageList = (args != null) ? args.getStringArrayList(KEY_SUBTITLE_TRACK_LANGUAGE_LIST) : null;
            mSubtitleDescriptionsList = new ArrayList<String>();
            if (mSubtitleTrackCount > 0) {
                mSubtitleButton.setAlpha(1.0f);
                mSubtitleButton.setEnabled(true);
                mSubtitleDescriptionsList.add(mResources.getString(R.string.MediaControlView2_subtitle_off_text));
                for (int i = 0; i < mSubtitleTrackCount; i++) {
                    String lang = subtitleTracksLanguageList.get(i);
                    String track;
                    if (lang.equals("")) {
                        track = mResources.getString(R.string.MediaControlView2_subtitle_track_number_text, i + 1);
                    } else {
                        track = mResources.getString(R.string.MediaControlView2_subtitle_track_number_and_lang_text, i + 1, lang);
                    }
                    mSubtitleDescriptionsList.add(track);
                }
            } else {
                if (mMediaType == MEDIA_TYPE_MUSIC) {
                    mSubtitleButton.setVisibility(View.GONE);
                } else {
                    mSubtitleButton.setAlpha(0.5f);
                    mSubtitleButton.setEnabled(false);
                }
            }
            break;
        case EVENT_UPDATE_MEDIA_TYPE_STATUS:
            boolean isAd = (args != null) && args.getBoolean(KEY_STATE_IS_ADVERTISEMENT);
            if (isAd != mIsAdvertisement) {
                mIsAdvertisement = isAd;
                updateLayoutForAd();
            }
            break;
        case EVENT_UPDATE_SUBTITLE_SELECTED:
            int selectedTrackIndex = args != null ? args.getInt(KEY_SELECTED_SUBTITLE_INDEX, -1) : -1;
            if (selectedTrackIndex < 0 || selectedTrackIndex >= mSubtitleTrackCount) {
                Log.w(TAG, "Selected subtitle track index (" + selectedTrackIndex + ") is out of range.");
                break;
            }
            mSelectedSubtitleTrackIndex = selectedTrackIndex + 1;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
        case EVENT_UPDATE_SUBTITLE_DESELECTED:
            mSelectedSubtitleTrackIndex = 0;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
    }
}
#end_block

#method_before
@Override
public void onSessionEvent(String event, Bundle extras) {
    switch(event) {
        case EVENT_UPDATE_TRACK_STATUS:
            mVideoTrackCount = extras.getInt(KEY_VIDEO_TRACK_COUNT);
            // If there is one or more audio tracks, and this information has not been
            // reflected into the Settings window yet, automatically check the first
            // track.
            // Otherwise, the Audio Track selection will be defaulted to "None".
            mAudioTrackCount = extras.getInt(KEY_AUDIO_TRACK_COUNT);
            mAudioTrackList = new ArrayList<String>();
            if (mAudioTrackCount > 0) {
                for (int i = 0; i < mAudioTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView2_audio_track_number_text, i + 1);
                    mAudioTrackList.add(track);
                }
                // Change sub text inside the Settings window.
                mSettingsSubTextsList.set(SETTINGS_MODE_AUDIO_TRACK, mAudioTrackList.get(0));
            } else {
                mAudioTrackList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
            }
            if (mVideoTrackCount == 0 && mAudioTrackCount > 0) {
                mMediaType = MEDIA_TYPE_MUSIC;
            }
            mSubtitleTrackCount = extras.getInt(KEY_SUBTITLE_TRACK_COUNT);
            mSubtitleDescriptionsList = new ArrayList<String>();
            if (mSubtitleTrackCount > 0) {
                mSubtitleButton.setVisibility(View.VISIBLE);
                mSubtitleButton.setEnabled(true);
                mSubtitleDescriptionsList.add(mResources.getString(R.string.MediaControlView2_subtitle_off_text));
                for (int i = 0; i < mSubtitleTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView2_subtitle_track_number_text, i + 1);
                    mSubtitleDescriptionsList.add(track);
                }
            } else {
                mSubtitleButton.setVisibility(View.GONE);
                mSubtitleButton.setEnabled(false);
            }
            break;
        case EVENT_UPDATE_MEDIA_TYPE_STATUS:
            boolean newStatus = extras.getBoolean(KEY_STATE_IS_ADVERTISEMENT);
            if (newStatus != mIsAdvertisement) {
                mIsAdvertisement = newStatus;
                updateLayoutForAd();
            }
            break;
        case EVENT_UPDATE_SUBTITLE_SELECTED:
            int selectedTrackIndex = extras.getInt(KEY_VIDEO_TRACK_COUNT);
            if (selectedTrackIndex < 0 || selectedTrackIndex >= mSubtitleTrackCount) {
                Log.w(TAG, "Selected subtitle track index (" + selectedTrackIndex + ") is out of range.");
                break;
            }
            mSelectedSubtitleTrackIndex = selectedTrackIndex + 1;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
        case EVENT_UPDATE_SUBTITLE_DESELECTED:
            mSelectedSubtitleTrackIndex = 0;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
    }
}
#method_after
@Override
public void onSessionEvent(String event, Bundle extras) {
    switch(event) {
        case EVENT_UPDATE_TRACK_STATUS:
            mVideoTrackCount = extras.getInt(KEY_VIDEO_TRACK_COUNT);
            // If there is one or more audio tracks, and this information has not been
            // reflected into the Settings window yet, automatically check the first
            // track.
            // Otherwise, the Audio Track selection will be defaulted to "None".
            mAudioTrackCount = extras.getInt(KEY_AUDIO_TRACK_COUNT);
            mAudioTrackList = new ArrayList<String>();
            if (mAudioTrackCount > 0) {
                for (int i = 0; i < mAudioTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView2_audio_track_number_text, i + 1);
                    mAudioTrackList.add(track);
                }
                // Change sub text inside the Settings window.
                mSettingsSubTextsList.set(SETTINGS_MODE_AUDIO_TRACK, mAudioTrackList.get(0));
            } else {
                mAudioTrackList.add(mResources.getString(R.string.MediaControlView2_audio_track_none_text));
            }
            if (mVideoTrackCount == 0 && mAudioTrackCount > 0) {
                mMediaType = MEDIA_TYPE_MUSIC;
            }
            mSubtitleTrackCount = extras.getInt(KEY_SUBTITLE_TRACK_COUNT);
            mSubtitleDescriptionsList = new ArrayList<String>();
            if (mSubtitleTrackCount > 0) {
                mSubtitleButton.setAlpha(1.0f);
                mSubtitleButton.setEnabled(true);
                mSubtitleDescriptionsList.add(mResources.getString(R.string.MediaControlView2_subtitle_off_text));
                for (int i = 0; i < mSubtitleTrackCount; i++) {
                    String track = mResources.getString(R.string.MediaControlView2_subtitle_track_number_text, i + 1);
                    mSubtitleDescriptionsList.add(track);
                }
            } else {
                if (mMediaType == MEDIA_TYPE_MUSIC) {
                    mSubtitleButton.setVisibility(View.GONE);
                } else {
                    mSubtitleButton.setAlpha(0.5f);
                    mSubtitleButton.setEnabled(false);
                }
            }
            break;
        case EVENT_UPDATE_MEDIA_TYPE_STATUS:
            boolean newStatus = extras.getBoolean(KEY_STATE_IS_ADVERTISEMENT);
            if (newStatus != mIsAdvertisement) {
                mIsAdvertisement = newStatus;
                updateLayoutForAd();
            }
            break;
        case EVENT_UPDATE_SUBTITLE_SELECTED:
            int selectedTrackIndex = extras.getInt(KEY_VIDEO_TRACK_COUNT);
            if (selectedTrackIndex < 0 || selectedTrackIndex >= mSubtitleTrackCount) {
                Log.w(TAG, "Selected subtitle track index (" + selectedTrackIndex + ") is out of range.");
                break;
            }
            mSelectedSubtitleTrackIndex = selectedTrackIndex + 1;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
        case EVENT_UPDATE_SUBTITLE_DESELECTED:
            mSelectedSubtitleTrackIndex = 0;
            if (mSettingsMode == SETTINGS_MODE_SUBTITLE_TRACK) {
                mSubSettingsAdapter.setCheckPosition(mSelectedSubtitleTrackIndex);
            }
            break;
    }
}
#end_block

#method_before
public Inet4Address getPrefixMaskAsAddress() {
    return (Inet4Address) intToInetAddress(prefixLengthToNetmaskInt(onlinkPrefix.getPrefixLength()));
}
#method_after
@NonNull
public Inet4Address getPrefixMaskAsAddress() {
    return getPrefixMaskAsInet4Address(serverAddr.getPrefixLength());
}
#end_block

#method_before
public Inet4Address getBroadcastAddress() {
    final int intBroadcastAddr = inetAddressToInt((Inet4Address) onlinkPrefix.getAddress()) | ~prefixLengthToNetmaskInt(onlinkPrefix.getPrefixLength());
    return (Inet4Address) intToInetAddress(intBroadcastAddr);
}
#method_after
@NonNull
public Inet4Address getBroadcastAddress() {
    return NetworkUtils.getBroadcastAddress(getServerInet4Addr(), serverAddr.getPrefixLength());
}
#end_block

#method_before
public Builder setDefaultRouters(Set<Inet4Address> defaultRouters) {
    this.defaultRouters = defaultRouters;
    return this;
}
#method_after
public Builder setDefaultRouters(@NonNull Set<Inet4Address> defaultRouters) {
    this.defaultRouters = defaultRouters;
    return this;
}
#end_block

#method_before
public Builder setDnsServers(Set<Inet4Address> dnsServers) {
    this.dnsServers = Collections.unmodifiableSet(dnsServers);
    return this;
}
#method_after
public Builder setDnsServers(@NonNull Set<Inet4Address> dnsServers) {
    this.dnsServers = dnsServers;
    return this;
}
#end_block

#method_before
public Builder setExcludedAddrs(Set<Inet4Address> excludedAddrs) {
    this.excludedAddrs = excludedAddrs;
    return this;
}
#method_after
public Builder setExcludedAddrs(@NonNull Set<Inet4Address> excludedAddrs) {
    this.excludedAddrs = excludedAddrs;
    return this;
}
#end_block

#method_before
public DhcpServingParams build() throws InvalidParameterException {
    if (inet4Addr == null) {
        throw new InvalidParameterException("Missing inet4Addr");
    }
    if (onlinkPrefix == null) {
        throw new InvalidParameterException("Missing onlinkPrefix");
    }
    if (defaultRouters == null) {
        throw new InvalidParameterException("Missing defaultRouters");
    }
    if (dnsServers == null) {
        // Empty set is OK, but enforce explicitly setting it
        throw new InvalidParameterException("Missing dnsServers");
    }
    Set<Inet4Address> excl = new HashSet<>();
    if (excludedAddrs != null) {
        excl.addAll(excludedAddrs);
    }
    excl.add(inet4Addr);
    excl.addAll(defaultRouters);
    excl.addAll(dnsServers);
    if (dhcpLeaseTimeSecs <= 0 || dhcpLeaseTimeSecs > toUnsignedLong(INFINITE_LEASE)) {
        throw new InvalidParameterException("Invalid lease time: " + dhcpLeaseTimeSecs);
    }
    if (upstreamMtu < IPV4_MIN_MTU || upstreamMtu > IPV4_MAX_MTU) {
        throw new InvalidParameterException("Invalid upstream MTU: " + upstreamMtu);
    }
    if (!onlinkPrefix.isIPv4()) {
        throw new InvalidParameterException("onlinkPrefix must be IPv4");
    }
    if (onlinkPrefix.getPrefixLength() < 2 || onlinkPrefix.getPrefixLength() > (IPV4_ADDR_BITS - 2)) {
        throw new InvalidParameterException("Prefix length is not in supported range");
    }
    for (Inet4Address addr : defaultRouters) {
        if (!onlinkPrefix.contains(addr)) {
            throw new InvalidParameterException(String.format("Default router %s is not in onlinkPrefix %s", addr, onlinkPrefix));
        }
    }
    return new DhcpServingParams(inet4Addr, onlinkPrefix, Collections.unmodifiableSet(new HashSet<>(defaultRouters)), Collections.unmodifiableSet(new HashSet<>(dnsServers)), Collections.unmodifiableSet(excl), dhcpLeaseTimeSecs, upstreamMtu);
}
#method_after
@NonNull
public DhcpServingParams build() throws InvalidParameterException {
    if (serverAddr == null) {
        throw new InvalidParameterException("Missing serverAddr");
    }
    if (defaultRouters == null) {
        throw new InvalidParameterException("Missing defaultRouters");
    }
    if (dnsServers == null) {
        // Empty set is OK, but enforce explicitly setting it
        throw new InvalidParameterException("Missing dnsServers");
    }
    if (dhcpLeaseTimeSecs <= 0 || dhcpLeaseTimeSecs > toUnsignedLong(INFINITE_LEASE)) {
        throw new InvalidParameterException("Invalid lease time: " + dhcpLeaseTimeSecs);
    }
    if (linkMtu != MTU_UNSET && (linkMtu < IPV4_MIN_MTU || linkMtu > IPV4_MAX_MTU)) {
        throw new InvalidParameterException("Invalid link MTU: " + linkMtu);
    }
    if (!serverAddr.isIPv4()) {
        throw new InvalidParameterException("serverAddr must be IPv4");
    }
    if (serverAddr.getPrefixLength() < MIN_PREFIX_LENGTH || serverAddr.getPrefixLength() > MAX_PREFIX_LENGTH) {
        throw new InvalidParameterException("Prefix length is not in supported range");
    }
    final IpPrefix prefix = makeIpPrefix(serverAddr);
    for (Inet4Address addr : defaultRouters) {
        if (!prefix.contains(addr)) {
            throw new InvalidParameterException(String.format("Default router %s is not in server prefix %s", addr, serverAddr));
        }
    }
    final Set<Inet4Address> excl = new HashSet<>();
    if (excludedAddrs != null) {
        excl.addAll(excludedAddrs);
    }
    excl.add((Inet4Address) serverAddr.getAddress());
    excl.addAll(defaultRouters);
    excl.addAll(dnsServers);
    return new DhcpServingParams(serverAddr, Collections.unmodifiableSet(new HashSet<>(defaultRouters)), Collections.unmodifiableSet(new HashSet<>(dnsServers)), Collections.unmodifiableSet(excl), dhcpLeaseTimeSecs, linkMtu);
}
#end_block

#method_before
@Before
public void setUp() {
    mBuilder = new DhcpServingParams.Builder().setDefaultRouters(TEST_DEFAULT_ROUTERS).setDhcpLeaseTimeSecs(TEST_LEASE_TIME_SECS).setDnsServers(TEST_DNS_SERVERS).setInet4Addr(TEST_SERVER_ADDR).setOnlinkPrefix(TEST_PREFIX).setUpstreamMtu(TEST_MTU).setExcludedAddrs(TEST_EXCLUDED_ADDRS);
}
#method_after
@Before
public void setUp() {
    mBuilder = new DhcpServingParams.Builder().setDefaultRouters(TEST_DEFAULT_ROUTERS).setDhcpLeaseTimeSecs(TEST_LEASE_TIME_SECS).setDnsServers(TEST_DNS_SERVERS).setServerAddr(TEST_LINKADDR).setLinkMtu(TEST_MTU).setExcludedAddrs(TEST_EXCLUDED_ADDRS);
}
#end_block

#method_before
@Test()
public void testBuild_InfiniteLeaseTime() throws InvalidParameterException {
    final long infiniteLeaseTime = 0xffffffffL;
    final DhcpServingParams params = mBuilder.setDhcpLeaseTimeSecs(infiniteLeaseTime).build();
    assertEquals(infiniteLeaseTime, params.dhcpLeaseTimeSecs);
}
#method_after
@Test
public void testBuild_InfiniteLeaseTime() throws InvalidParameterException {
    final long infiniteLeaseTime = 0xffffffffL;
    final DhcpServingParams params = mBuilder.setDhcpLeaseTimeSecs(infiniteLeaseTime).build();
    assertEquals(infiniteLeaseTime, params.dhcpLeaseTimeSecs);
    assertTrue(params.dhcpLeaseTimeSecs > 0L);
}
#end_block

#method_before
@Test(expected = InvalidParameterException.class)
public void testBuild_MtuTooSmall() throws InvalidParameterException {
    mBuilder.setUpstreamMtu(20).build();
}
#method_after
@Test(expected = InvalidParameterException.class)
public void testBuild_MtuTooSmall() throws InvalidParameterException {
    mBuilder.setLinkMtu(20).build();
}
#end_block

#method_before
@Test(expected = InvalidParameterException.class)
public void testBuild_MtuTooLarge() throws InvalidParameterException {
    mBuilder.setUpstreamMtu(65_536).build();
}
#method_after
@Test(expected = InvalidParameterException.class)
public void testBuild_MtuTooLarge() throws InvalidParameterException {
    mBuilder.setLinkMtu(65_536).build();
}
#end_block

#method_before
@Test(expected = InvalidParameterException.class)
public void testBuild_PrefixTooLarge() throws InvalidParameterException {
    mBuilder.setOnlinkPrefix(new IpPrefix(TEST_SERVER_ADDR, 1)).build();
}
#method_after
@Test(expected = InvalidParameterException.class)
public void testBuild_PrefixTooLarge() throws InvalidParameterException {
    mBuilder.setServerAddr(new LinkAddress(TEST_SERVER_ADDR, 15)).build();
}
#end_block

#method_before
@Test(expected = InvalidParameterException.class)
public void testBuild_PrefixTooSmall() throws InvalidParameterException {
    mBuilder.setDefaultRouters(Collections.singleton(parseAddr("192.168.0.254"))).setOnlinkPrefix(new IpPrefix(TEST_SERVER_ADDR, 31)).build();
}
#method_after
@Test(expected = InvalidParameterException.class)
public void testBuild_PrefixTooSmall() throws InvalidParameterException {
    mBuilder.setDefaultRouters(Collections.singleton(parseAddr("192.168.0.254"))).setServerAddr(new LinkAddress(TEST_SERVER_ADDR, 31)).build();
}
#end_block

#method_before
private static <T> void assertContains(Set<T> set, Set<T> subset) {
    for (T elem : subset) {
        assertContains(set, elem);
    }
}
#method_after
private static <T> void assertContains(@NonNull Set<T> set, @NonNull Set<T> subset) {
    for (final T elem : subset) {
        assertContains(set, elem);
    }
}
#end_block

#method_before
private static <T> void assertContains(Set<T> set, T elem) {
    assertTrue("Set does not contain " + elem, set.contains(elem));
}
#method_after
private static <T> void assertContains(@NonNull Set<T> set, @Nullable T elem) {
    assertTrue("Set does not contain " + elem, set.contains(elem));
}
#end_block

#method_before
private static Inet4Address parseAddr(String inet4Addr) {
    return (Inet4Address) parseNumericAddress(inet4Addr);
}
#method_after
@NonNull
private static Inet4Address parseAddr(@NonNull String inet4Addr) {
    return (Inet4Address) parseNumericAddress(inet4Addr);
}
#end_block

#method_before
@Test
public void testViewLifecycleInFragmentLifecycle() throws Throwable {
    final FragmentTestActivity activity = mActivityRule.getActivity();
    final FragmentManager fm = activity.getSupportFragmentManager();
    final CountDownLatch upwardCountDownLatch = new CountDownLatch(2);
    final CountDownLatch downwardCountDownLatch = new CountDownLatch(2);
    final StrictViewFragment fragment = new StrictViewFragment();
    fragment.setLayoutId(R.layout.fragment_a);
    final Lifecycle.State[] state = new Lifecycle.State[4];
    final GenericLifecycleObserver onStartObserver = mock(GenericLifecycleObserver.class);
    final GenericLifecycleObserver onResumeObserver = mock(GenericLifecycleObserver.class);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            fragment.getLifecycle().addObserver(new GenericLifecycleObserver() {

                private Lifecycle.State getViewLifecyleState() {
                    return fragment.getViewLifecycleOwner().getLifecycle().getCurrentState();
                }

                @Override
                public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {
                    if (event == Lifecycle.Event.ON_START) {
                        state[0] = getViewLifecyleState();
                        upwardCountDownLatch.countDown();
                        // The Fragment view lifecycle changes after the Fragment lifecycle
                        // so attach a listener to ensure we get the ON_START event there
                        fragment.getViewLifecycleOwner().getLifecycle().addObserver(onStartObserver);
                    } else if (event == Lifecycle.Event.ON_RESUME) {
                        // Remove the listener so we only capture events up to this point
                        fragment.getViewLifecycleOwner().getLifecycle().removeObserver(onStartObserver);
                        state[1] = getViewLifecyleState();
                        upwardCountDownLatch.countDown();
                        // The Fragment view lifecycle changes after the Fragment lifecycle
                        // so attach a listener to ensure we get the ON_RESUME event there
                        fragment.getViewLifecycleOwner().getLifecycle().addObserver(onResumeObserver);
                    } else if (event == Lifecycle.Event.ON_PAUSE) {
                        state[2] = getViewLifecyleState();
                        downwardCountDownLatch.countDown();
                    } else if (event == Lifecycle.Event.ON_STOP) {
                        state[3] = getViewLifecyleState();
                        downwardCountDownLatch.countDown();
                    }
                }
            });
            fm.beginTransaction().add(R.id.content, fragment).commitNow();
        }
    });
    upwardCountDownLatch.await(1, TimeUnit.SECONDS);
    // Confirm we are still created when the Fragment's onStart happens
    assertEquals("View Lifecycle should still be created when the Fragment is started", state[0], Lifecycle.State.CREATED);
    // Now check to see if our onStartObserver got a ON_START event before onResume
    verify(onStartObserver).onStateChanged(fragment.getViewLifecycleOwner(), Lifecycle.Event.ON_CREATE);
    verify(onStartObserver).onStateChanged(fragment.getViewLifecycleOwner(), Lifecycle.Event.ON_START);
    verifyNoMoreInteractions(onStartObserver);
    // Confirm we are still started when the Fragment's onResume happens
    assertEquals("View Lifecycle should still be started when the Fragment is resumed", state[1], Lifecycle.State.STARTED);
    // Now check to see if our onResumeObserver got a ON_RESUME event after the
    // Fragment was resumed
    verify(onResumeObserver, timeout(1000)).onStateChanged(fragment.getViewLifecycleOwner(), Lifecycle.Event.ON_CREATE);
    verify(onResumeObserver, timeout(1000)).onStateChanged(fragment.getViewLifecycleOwner(), Lifecycle.Event.ON_START);
    verify(onResumeObserver, timeout(1000)).onStateChanged(fragment.getViewLifecycleOwner(), Lifecycle.Event.ON_RESUME);
    verifyNoMoreInteractions(onResumeObserver);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            fragment.getViewLifecycleOwner().getLifecycle().removeObserver(onResumeObserver);
            // Now remove the Fragment to trigger the destruction of the view
            fm.beginTransaction().remove(fragment).commitNow();
        }
    });
    downwardCountDownLatch.await(1, TimeUnit.SECONDS);
    assertEquals("View Lifecycle should be started when the Fragment is paused", state[2], Lifecycle.State.STARTED);
    assertEquals("View Lifecycle should be created when the Fragment is stopped", state[3], Lifecycle.State.CREATED);
}
#method_after
@Test
public void testViewLifecycleInFragmentLifecycle() throws Throwable {
    final FragmentTestActivity activity = mActivityRule.getActivity();
    final FragmentManager fm = activity.getSupportFragmentManager();
    final StrictViewFragment fragment = new StrictViewFragment();
    fragment.setLayoutId(R.layout.fragment_a);
    final GenericLifecycleObserver lifecycleObserver = mock(GenericLifecycleObserver.class);
    final LifecycleOwner[] viewLifecycleOwner = new LifecycleOwner[1];
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            fragment.getViewLifecycleOwnerLiveData().observe(activity, new Observer<LifecycleOwner>() {

                @Override
                public void onChanged(LifecycleOwner lifecycleOwner) {
                    if (lifecycleOwner != null) {
                        viewLifecycleOwner[0] = lifecycleOwner;
                        lifecycleOwner.getLifecycle().addObserver(lifecycleObserver);
                    }
                }
            });
            fragment.getLifecycle().addObserver(lifecycleObserver);
            fm.beginTransaction().add(R.id.content, fragment).commitNow();
            // Now remove the Fragment to trigger the destruction of the view
            fm.beginTransaction().remove(fragment).commitNow();
        }
    });
    // The Fragment's lifecycle should change first, followed by the fragment's view lifecycle
    verify(lifecycleObserver).onStateChanged(fragment, Lifecycle.Event.ON_CREATE);
    verify(lifecycleObserver).onStateChanged(viewLifecycleOwner[0], Lifecycle.Event.ON_CREATE);
    verify(lifecycleObserver).onStateChanged(fragment, Lifecycle.Event.ON_START);
    verify(lifecycleObserver).onStateChanged(viewLifecycleOwner[0], Lifecycle.Event.ON_START);
    verify(lifecycleObserver).onStateChanged(fragment, Lifecycle.Event.ON_RESUME);
    verify(lifecycleObserver).onStateChanged(viewLifecycleOwner[0], Lifecycle.Event.ON_RESUME);
    // Now the order reverses as things unwind
    verify(lifecycleObserver).onStateChanged(viewLifecycleOwner[0], Lifecycle.Event.ON_PAUSE);
    verify(lifecycleObserver).onStateChanged(fragment, Lifecycle.Event.ON_PAUSE);
    verify(lifecycleObserver).onStateChanged(viewLifecycleOwner[0], Lifecycle.Event.ON_STOP);
    verify(lifecycleObserver).onStateChanged(fragment, Lifecycle.Event.ON_STOP);
    verify(lifecycleObserver).onStateChanged(viewLifecycleOwner[0], Lifecycle.Event.ON_DESTROY);
    verify(lifecycleObserver).onStateChanged(fragment, Lifecycle.Event.ON_DESTROY);
    verifyNoMoreInteractions(lifecycleObserver);
}
#end_block

#method_before
final void restoreViewState(Bundle savedInstanceState) {
    if (mSavedViewState != null) {
        mInnerView.restoreHierarchyState(mSavedViewState);
        mSavedViewState = null;
    }
    mCalled = false;
    onViewStateRestored(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException("Fragment " + this + " did not call through to super.onViewStateRestored()");
    }
}
#method_after
final void restoreViewState(Bundle savedInstanceState) {
    if (mSavedViewState != null) {
        mInnerView.restoreHierarchyState(mSavedViewState);
        mSavedViewState = null;
    }
    mCalled = false;
    onViewStateRestored(savedInstanceState);
    if (!mCalled) {
        throw new SuperNotCalledException("Fragment " + this + " did not call through to super.onViewStateRestored()");
    }
    if (mView != null) {
        mViewLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);
    }
}
#end_block

#method_before
@CallSuper
public void onViewStateRestored(@Nullable Bundle savedInstanceState) {
    mCalled = true;
    if (mView != null) {
        mViewLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);
    }
}
#method_after
@CallSuper
public void onViewStateRestored(@Nullable Bundle savedInstanceState) {
    mCalled = true;
}
#end_block

#method_before
@CallSuper
public void onDestroyView() {
    mCalled = true;
    if (mView != null) {
        mViewLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);
    }
}
#method_after
@CallSuper
public void onDestroyView() {
    mCalled = true;
}
#end_block

#method_before
void performDestroyView() {
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mState = CREATED;
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException("Fragment " + this + " did not call through to super.onDestroyView()");
    }
    // Handles the detach/reattach case where the view hierarchy
    // is destroyed and recreated and an additional call to
    // onLoadFinished may be needed to ensure the new view
    // hierarchy is populated from data from the Loaders
    LoaderManager.getInstance(this).markForRedelivery();
    mPerformedCreateView = false;
}
#method_after
void performDestroyView() {
    if (mView != null) {
        mViewLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY);
    }
    if (mChildFragmentManager != null) {
        mChildFragmentManager.dispatchDestroyView();
    }
    mState = CREATED;
    mCalled = false;
    onDestroyView();
    if (!mCalled) {
        throw new SuperNotCalledException("Fragment " + this + " did not call through to super.onDestroyView()");
    }
    // Handles the detach/reattach case where the view hierarchy
    // is destroyed and recreated and an additional call to
    // onLoadFinished may be needed to ensure the new view
    // hierarchy is populated from data from the Loaders
    LoaderManager.getInstance(this).markForRedelivery();
    mPerformedCreateView = false;
}
#end_block

#method_before
@NonNull
TypedArray obtainStyledAttributes(@NonNull Resources.Theme wrapper, AttributeSet set, @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "obtainStyledAttributes");
    synchronized (mKey) {
        final int len = attrs.length;
        final TypedArray array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        mAssets.applyStyle(mTheme, defStyleAttr, defStyleRes, parser, attrs, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
        return array;
    }
}
#method_after
@NonNull
TypedArray obtainStyledAttributes(@NonNull Resources.Theme wrapper, AttributeSet set, @StyleableRes int[] attrs, @AttrRes int defStyleAttr, @StyleRes int defStyleRes) {
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "obtainStyledAttributes");
    TypedArray array;
    synchronized (mKey) {
        final int len = attrs.length;
        array = TypedArray.obtain(wrapper.getResources(), len);
        // XXX note that for now we only work with compiled XML files.
        // To support generic XML files we will need to manually parse
        // out the attributes from the XML file (applying type information
        // contained in the resources and such).
        final XmlBlock.Parser parser = (XmlBlock.Parser) set;
        mAssets.applyStyle(mTheme, defStyleAttr, defStyleRes, parser, attrs, array.mDataAddress, array.mIndicesAddress);
        array.mTheme = wrapper;
        array.mXml = parser;
    }
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return array;
}
#end_block

#method_before
@MainThread
@SuppressWarnings("FutureReturnValueIgnored")
private void processCommand() {
    assertMainThread();
    PowerManager.WakeLock processCommandLock = WakeLocks.newWakeLock(mContext, PROCESS_COMMAND_TAG);
    try {
        processCommandLock.acquire();
        // Process commands on the actual executor service,
        // so we are no longer blocking the main thread.
        mCommandExecutorService.submit(new Runnable() {

            @Override
            public void run() {
                synchronized (mIntents) {
                    mCurrentIntent = mIntents.get(0);
                }
                if (mCurrentIntent != null) {
                    final String action = mCurrentIntent.getAction();
                    final int startId = mCurrentIntent.getIntExtra(KEY_START_ID, DEFAULT_START_ID);
                    Logger.debug(TAG, String.format("Processing command %s, %s", mCurrentIntent, startId));
                    final PowerManager.WakeLock wakeLock = WakeLocks.newWakeLock(mContext, String.format("%s (%s)", action, startId));
                    try {
                        Logger.debug(TAG, String.format("Acquiring operation wake lock (%s) %s", action, wakeLock));
                        wakeLock.acquire();
                        mCommandHandler.onHandleIntent(mCurrentIntent, startId, SystemAlarmDispatcher.this);
                    } catch (Throwable throwable) {
                        Logger.error(TAG, "This is unexpected. Please file a bug in the issue tracker " + "at (https://issuetracker.google.com/issues/new?component=409906)", throwable);
                    } finally {
                        Logger.debug(TAG, String.format("Releasing operation wake lock (%s) %s", action, wakeLock));
                        wakeLock.release();
                        // Check if we have processed all commands
                        postOnMainThread(new DequeueAndCheckForCompletion(SystemAlarmDispatcher.this));
                    }
                }
            }
        });
    } finally {
        processCommandLock.release();
    }
}
#method_after
@MainThread
@SuppressWarnings("FutureReturnValueIgnored")
private void processCommand() {
    assertMainThread();
    PowerManager.WakeLock processCommandLock = WakeLocks.newWakeLock(mContext, PROCESS_COMMAND_TAG);
    try {
        processCommandLock.acquire();
        // Process commands on the actual executor service,
        // so we are no longer blocking the main thread.
        mCommandExecutorService.submit(new Runnable() {

            @Override
            public void run() {
                synchronized (mIntents) {
                    mCurrentIntent = mIntents.get(0);
                }
                if (mCurrentIntent != null) {
                    final String action = mCurrentIntent.getAction();
                    final int startId = mCurrentIntent.getIntExtra(KEY_START_ID, DEFAULT_START_ID);
                    Logger.debug(TAG, String.format("Processing command %s, %s", mCurrentIntent, startId));
                    final PowerManager.WakeLock wakeLock = WakeLocks.newWakeLock(mContext, String.format("%s (%s)", action, startId));
                    try {
                        Logger.debug(TAG, String.format("Acquiring operation wake lock (%s) %s", action, wakeLock));
                        wakeLock.acquire();
                        mCommandHandler.onHandleIntent(mCurrentIntent, startId, SystemAlarmDispatcher.this);
                    } catch (Throwable throwable) {
                        Logger.error(TAG, "Unexpected error in onHandleIntent", throwable);
                    } finally {
                        Logger.debug(TAG, String.format("Releasing operation wake lock (%s) %s", action, wakeLock));
                        wakeLock.release();
                        // Check if we have processed all commands
                        postOnMainThread(new DequeueAndCheckForCompletion(SystemAlarmDispatcher.this));
                    }
                }
            }
        });
    } finally {
        processCommandLock.release();
    }
}
#end_block

#method_before
static TestCompilationResult parseXsdAndCompile(InputStream in) throws Exception {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    factory.setNamespaceAware(true);
    SAXParser parser = factory.newSAXParser();
    XsdHandler xsdHandler = new XsdHandler();
    parser.parse(in, xsdHandler);
    XmlSchema xmlSchema = xsdHandler.getSchema();
    StringCodeWriterSupervisor codeWriterSupervisor = new StringCodeWriterSupervisor();
    JavaCodeGenerator javaCodeGenerator = new JavaCodeGenerator(xmlSchema, packageName);
    javaCodeGenerator.print(codeWriterSupervisor);
    List<JavaFileObject> javaFileObjects = new ArrayList<>();
    for (Map.Entry<String, StringWriter> entry : codeWriterSupervisor.getCodeOutputs().entrySet()) {
        javaFileObjects.add(new InMemoryJavaFileObject(entry.getKey(), entry.getValue().toString()));
    }
    return new TestCompilationResult(compile(javaFileObjects));
}
#method_after
static TestCompilationResult parseXsdAndCompile(InputStream in) throws Exception {
    SAXParserFactory factory = SAXParserFactory.newInstance();
    factory.setNamespaceAware(true);
    SAXParser parser = factory.newSAXParser();
    XsdHandler xsdHandler = new XsdHandler();
    parser.parse(in, xsdHandler);
    XmlSchema xmlSchema = xsdHandler.getSchema();
    Map<String, StringBuffer> fileOutputMap = new HashMap<>();
    FileSystem fs = new FileSystem(fileOutputMap);
    JavaCodeGenerator javaCodeGenerator = new JavaCodeGenerator(xmlSchema, packageName);
    javaCodeGenerator.print(fs);
    List<JavaFileObject> javaFileObjects = new ArrayList<>();
    for (Map.Entry<String, StringBuffer> entry : fileOutputMap.entrySet()) {
        String className = entry.getKey().split("\\.")[0];
        javaFileObjects.add(new InMemoryJavaFileObject(className, entry.getValue().toString()));
    }
    return new TestCompilationResult(compile(javaFileObjects));
}
#end_block

#method_before
@Override
String getName() {
    return list ? String.format("java.util.List<%s>", name) : name;
}
#method_after
@Override
public String getName() {
    return list ? String.format("java.util.List<%s>", name) : name;
}
#end_block

#method_before
@Override
String getParsingExpression() {
    StringBuilder expression = new StringBuilder();
    if (list) {
        expression.append(String.format("%s value = new java.util.ArrayList<>();\n", getName()));
        expression.append("for (String token : raw.split(\"\\\\s+\")) {\n");
        expression.append(String.format("value.add(%s);\n", String.format(rawParsingExpression, "token")));
        expression.append("}\n");
    } else {
        expression.append(String.format("%s value = %s;\n", getName(), String.format(rawParsingExpression, "raw")));
    }
    return expression.toString();
}
#method_after
@Override
public String getParsingExpression() {
    StringBuilder expression = new StringBuilder();
    if (list) {
        expression.append(String.format("%s value = new java.util.ArrayList<>();\n", getName()));
        expression.append("for (String token : raw.split(\"\\\\s+\")) {\n");
        expression.append(String.format("value.add(%s);\n", String.format(rawParsingExpression, "token")));
        expression.append("}\n");
    } else {
        expression.append(String.format("%s value = %s;\n", getName(), String.format(rawParsingExpression, "raw")));
    }
    return expression.toString();
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    if (args.length != 3) {
        System.err.println("Failed - it should have three arguments: path of an input xsd file, " + "package name, and output directory");
        exit(-1);
    }
    String xsdFile = args[0], packageName = args[1], outDir = args[2];
    XmlSchema xmlSchema;
    try (FileInputStream in = new FileInputStream(xsdFile)) {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        SAXParser parser = factory.newSAXParser();
        XsdHandler xsdHandler = new XsdHandler();
        parser.parse(in, xsdHandler);
        xmlSchema = xsdHandler.getSchema();
    }
    File packageDir = new File(Paths.get(outDir, packageName.replace(".", "/")).toString());
    FileCodeWriterSupervisor codeWriterSupervisor = new FileCodeWriterSupervisor(packageDir);
    JavaCodeGenerator javaCodeGenerator = new JavaCodeGenerator(xmlSchema, packageName);
    javaCodeGenerator.print(codeWriterSupervisor);
}
#method_after
public static void main(String[] args) throws Exception {
    if (args.length != 3) {
        System.err.println("Failed - the number of arguments should be 3.");
        System.err.println("Usage: ./xsdc input_xsd_file package_name output_directory");
        exit(-1);
    }
    String xsdFile = args[0], packageName = args[1], outDir = args[2];
    XmlSchema xmlSchema;
    try (FileInputStream in = new FileInputStream(xsdFile)) {
        SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(true);
        SAXParser parser = factory.newSAXParser();
        XsdHandler xsdHandler = new XsdHandler();
        parser.parse(in, xsdHandler);
        xmlSchema = xsdHandler.getSchema();
    }
    File packageDir = new File(Paths.get(outDir, packageName.replace(".", "/")).toString());
    packageDir.mkdirs();
    FileSystem fs = new FileSystem(packageDir);
    JavaCodeGenerator javaCodeGenerator = new JavaCodeGenerator(xmlSchema, packageName);
    javaCodeGenerator.print(fs);
}
#end_block

#method_before
@Override
String getName() {
    return name;
}
#method_after
@Override
public String getName() {
    return name;
}
#end_block

#method_before
@Override
String getParsingExpression() {
    return String.format("%s value = %s.read(parser);\n", name, name);
}
#method_after
@Override
public String getParsingExpression() {
    return String.format("%s value = %s.read(parser);\n", name, name);
}
#end_block

#method_before
public void print(CodeWriterSupervisor codeWriterSupervisor) throws JavaCodeGeneratorException, IOException {
    for (XsdType type : xmlSchema.getTypeMap().values()) {
        if (type instanceof XsdComplexType) {
            String name = Utils.toClassName(type.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            try (CodeWriter out = codeWriterSupervisor.createCodeWriter(name)) {
                out.printf("package %s;\n\n", packageName);
                printClass(out, name, complexType, "");
            }
        }
    }
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        XsdType type = element.getType();
        if (type.getRef() == null && type instanceof XsdComplexType) {
            String name = Utils.toClassName(element.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            try (CodeWriter out = codeWriterSupervisor.createCodeWriter(name)) {
                out.printf("package %s;\n\n", packageName);
                printClass(out, name, complexType, "");
            }
        }
    }
    try (CodeWriter out = codeWriterSupervisor.createCodeWriter("XmlParser")) {
        printXmlParser(out);
    }
}
#method_after
public void print(FileSystem fs) throws JavaCodeGeneratorException, IOException {
    for (XsdType type : xmlSchema.getTypeMap().values()) {
        if (type instanceof XsdComplexType) {
            String name = Utils.toClassName(type.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            try (CodeWriter out = new CodeWriter(fs.getPrintWriter(name + ".java"))) {
                out.printf("package %s;\n\n", packageName);
                printClass(out, name, complexType, "");
            }
        }
    }
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        XsdType type = element.getType();
        if (type.getRef() == null && type instanceof XsdComplexType) {
            String name = Utils.toClassName(element.getName());
            XsdComplexType complexType = (XsdComplexType) type;
            try (CodeWriter out = new CodeWriter(fs.getPrintWriter(name + ".java"))) {
                out.printf("package %s;\n\n", packageName);
                printClass(out, name, complexType, "");
            }
        }
    }
    try (CodeWriter out = new CodeWriter(fs.getPrintWriter("XmlParser.java"))) {
        printXmlParser(out);
    }
}
#end_block

#method_before
private void printXmlParser(CodeWriter out) throws JavaCodeGeneratorException {
    out.printf("package %s;\n", packageName);
    out.println();
    out.println("public class XmlParser {");
    out.print("public static java.lang.Object read(java.io.InputStream in)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n" + "org.xmlpull.v1.XmlPullParser parser = org.xmlpull.v1.XmlPullParserFactory" + ".newInstance().newPullParser();\n" + "parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_PROCESS_NAMESPACES, " + "true);\n" + "parser.setInput(in, null);\n" + "parser.nextTag();\n" + "String tagName = parser.getName();\n");
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        JavaType javaType = parseType(element.getType(), element.getName());
        out.printf("if (tagName.equals(\"%s\")) {\n", element.getName());
        if (javaType instanceof JavaSimpleType) {
            out.print("raw = XmlParser.readText(parser);\n");
        }
        out.print(javaType.getParsingExpression());
        out.print("return value;\n" + "} else ");
    }
    out.print("{\n" + "throw new RuntimeException(String.format(\"unknown element '%s'\", tagName));\n" + "}\n}\n");
    out.println();
    out.print("public static java.lang.String readText(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "String result = \"\";\n" + "if (parser.next() == org.xmlpull.v1.XmlPullParser.TEXT) {\n" + "result = parser.getText();\n" + "parser.nextTag();\n" + "}\n" + "return result;\n" + "}\n");
    out.println();
    out.print("public static void skip(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) {\n" + "throw new IllegalStateException();\n" + "}\n" + "int depth = 1;\n" + "while (depth != 0) {\n" + "switch (parser.next()) {\n" + "case org.xmlpull.v1.XmlPullParser.END_TAG:\n" + "depth--;\n" + "break;\n" + "case org.xmlpull.v1.XmlPullParser.START_TAG:\n" + "depth++;\n" + "break;\n" + "}\n}\n}\n");
    out.println("}");
}
#method_after
private void printXmlParser(CodeWriter out) throws JavaCodeGeneratorException {
    out.printf("package %s;\n", packageName);
    out.println();
    out.println("public class XmlParser {");
    out.print("public static java.lang.Object read(java.io.InputStream in)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n" + "    org.xmlpull.v1.XmlPullParser parser = org.xmlpull.v1.XmlPullParserFactory" + ".newInstance().newPullParser();\n" + "    parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_PROCESS_NAMESPACES, " + "true);\n" + "    parser.setInput(in, null);\n" + "    parser.nextTag();\n" + "    String tagName = parser.getName();\n");
    for (XsdElement element : xmlSchema.getElementMap().values()) {
        JavaType javaType = parseType(element.getType(), element.getName());
        out.printf("if (tagName.equals(\"%s\")) {\n", element.getName());
        if (javaType instanceof JavaSimpleType) {
            out.print("raw = XmlParser.readText(parser);\n");
        }
        out.print(javaType.getParsingExpression());
        out.print("return value;\n" + "} else ");
    }
    out.print("{\n" + "throw new RuntimeException(String.format(\"unknown element '%s'\", tagName));\n" + "}\n}\n");
    out.println();
    out.print("public static java.lang.String readText(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "String result = \"\";\n" + "if (parser.next() == org.xmlpull.v1.XmlPullParser.TEXT) {\n" + "    result = parser.getText();\n" + "    parser.nextTag();\n" + "}\n" + "return result;\n" + "}\n");
    out.println();
    out.print("public static void skip(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) {\n" + "    throw new IllegalStateException();\n" + "}\n" + "int depth = 1;\n" + "while (depth != 0) {\n" + "    switch (parser.next()) {\n" + "        case org.xmlpull.v1.XmlPullParser.END_TAG:\n" + "            depth--;\n" + "            break;\n" + "        case org.xmlpull.v1.XmlPullParser.START_TAG:\n" + "            depth++;\n" + "            break;\n" + "    }\n" + "}\n" + "}\n");
    out.println("}");
}
#end_block

#method_before
@Override
protected void drawableStateChanged() {
    super.drawableStateChanged();
    // progressDrawable and thumb with layout xml file.
    if (USE_SUPPORT_DYNAMIC_GROUP) {
        return;
    }
    int alpha = isEnabled() ? 0xFF : (int) (0xFF * mDisabledAlpha);
    // The thumb drawable is a collection of drawables and its current drawables are changed per
    // state. Apply the color filter and alpha on every state change.
    mThumb.setColorFilter(mColor, PorterDuff.Mode.SRC_IN);
    mThumb.setAlpha(alpha);
    getProgressDrawable().setColorFilter(mColor, PorterDuff.Mode.SRC_IN);
    getProgressDrawable().setAlpha(alpha);
}
#method_after
@Override
protected void drawableStateChanged() {
    super.drawableStateChanged();
    int alpha = isEnabled() ? 0xFF : (int) (0xFF * mDisabledAlpha);
    // The thumb drawable is a collection of drawables and its current drawables are changed per
    // state. Apply the color filter and alpha on every state change.
    mThumb.setColorFilter(mProgressAndThumbColor, PorterDuff.Mode.SRC_IN);
    mThumb.setAlpha(alpha);
    LayerDrawable ld = (LayerDrawable) getProgressDrawable();
    Drawable progressDrawable = ld.findDrawableByLayerId(android.R.id.progress);
    Drawable backgroundDrawable = ld.findDrawableByLayerId(android.R.id.background);
    progressDrawable.setColorFilter(mProgressAndThumbColor, PorterDuff.Mode.SRC_IN);
    backgroundDrawable.setColorFilter(mBackgroundColor, PorterDuff.Mode.SRC_IN);
    ld.setAlpha(alpha);
}
#end_block

#method_before
public void setColor(int color) {
    if (mColor == color) {
        return;
    }
    if (Color.alpha(color) != 0xFF) {
        Log.e(TAG, "Volume slider color cannot be translucent: #" + Integer.toHexString(color));
    }
    mColor = color;
}
#method_after
public void setColor(int color) {
    setColor(color, color);
}
#end_block

#method_before
public void setColor(int color) {
    if (mColor == color) {
        return;
    }
    if (Color.alpha(color) != 0xFF) {
        Log.e(TAG, "Volume slider color cannot be translucent: #" + Integer.toHexString(color));
    }
    mColor = color;
}
#method_after
public void setColor(int progressAndThumbColor, int backgroundColor) {
    // Sets the color of progress part of progress bar and thumb.
    if (mProgressAndThumbColor != progressAndThumbColor) {
        if (Color.alpha(progressAndThumbColor) != 0xFF) {
            Log.e(TAG, "Volume slider progress and thumb color cannot be translucent: #" + Integer.toHexString(progressAndThumbColor));
        }
        mProgressAndThumbColor = progressAndThumbColor;
    }
    // Sets the color of background part of progress bar.
    if (mBackgroundColor != backgroundColor) {
        if (Color.alpha(backgroundColor) != 0xFF) {
            Log.e(TAG, "Volume slider background color cannot be translucent: #" + Integer.toHexString(backgroundColor));
        }
        mBackgroundColor = backgroundColor;
    }
}
#end_block

#method_before
static void setVolumeSliderColor(Context context, MediaRouteVolumeSlider volumeSlider, View backgroundView) {
    int controllerColor = getControllerColor(context, 0);
    if (Color.alpha(controllerColor) != 0xFF) {
        // Composite with the background in order not to show the underlying progress bar
        // through the thumb.
        int backgroundColor = (int) backgroundView.getTag();
        controllerColor = ColorUtils.compositeColors(controllerColor, backgroundColor);
    }
    volumeSlider.setColor(controllerColor);
}
#method_after
static void setVolumeSliderColor(Context context, MediaRouteVolumeSlider volumeSlider) {
    int progressAndThumbColor, backgroundColor;
    if (isLightTheme(context)) {
        progressAndThumbColor = ContextCompat.getColor(context, R.color.mr_cast_progressbar_progress_and_thumb_light);
        backgroundColor = ContextCompat.getColor(context, R.color.mr_cast_progressbar_background_light);
    } else {
        progressAndThumbColor = ContextCompat.getColor(context, R.color.mr_cast_progressbar_progress_and_thumb_dark);
        backgroundColor = ContextCompat.getColor(context, R.color.mr_cast_progressbar_background_dark);
    }
    volumeSlider.setColor(progressAndThumbColor, backgroundColor);
}
#end_block

#method_before
public static void openExtendedNotificationsPanel(UiDevice device) throws UiObjectNotFoundException {
    new NetworkUtilPopupWatcher(device).checkForCondition();
    device.openNotification();
    new NetworkUtilPopupWatcher(device).checkForCondition();
    UiObject expandIndicator = device.findObject(new UiSelector().resourceId(Res.NOTIFICATION_BAR_EXPAND_RES));
    if (expandIndicator.waitForExists(5L)) {
        expandIndicator.clickAndWaitForNewWindow();
    } else {
        Log.d(TAG, "tray expander icon not found");
    }
    UiObject notificationHeader = device.findObject(new UiSelector().resourceId(Res.NOTIFICATION_BAR_HEADER_RES));
    if (notificationHeader.waitForExists(5L)) {
        notificationHeader.click();
        notificationHeader.swipeDown(3);
    } else {
        Log.d(TAG, "notification bar header not found");
    }
    openNotificationQuickPanel(device);
}
#method_after
private static void openExtendedNotificationsPanel(UiDevice device) throws UiObjectNotFoundException {
    new NetworkUtilPopupWatcher(device).checkForCondition();
    device.openNotification();
    new NetworkUtilPopupWatcher(device).checkForCondition();
    UiObject expandIndicator = device.findObject(new UiSelector().resourceId(Res.NOTIFICATION_BAR_EXPAND_RES));
    if (expandIndicator.waitForExists(5L)) {
        expandIndicator.clickAndWaitForNewWindow();
    } else {
        Log.d(TAG, "tray expander icon not found");
    }
    UiObject notificationHeader = device.findObject(new UiSelector().resourceId(Res.NOTIFICATION_BAR_HEADER_RES));
    if (notificationHeader.waitForExists(5L)) {
        notificationHeader.click();
        notificationHeader.swipeDown(3);
    } else {
        Log.d(TAG, "notification bar header not found");
    }
    openNotificationQuickPanel(device);
}
#end_block

#method_before
public void setTitle(String title) {
    mTitle = title;
    markDirty();
}
#method_after
public void setTitle(CharSequence title) {
    mTitle = title;
    markDirty();
}
#end_block

#method_before
public void setBody(String body, boolean asPrimary) {
    mBody = body;
    mIsBodyPrimary = asPrimary;
    markDirty();
}
#method_after
public void setBody(CharSequence body) {
    setBody(body, false);
}
#end_block

#method_before
// setPlaybackParams() with non-zero speed should NOT start playback.
// TODO: enable this test when MediaPlayer2.setPlaybackParams() is fixed
/*
    public void testSetPlaybackParamsPositiveSpeed() throws Exception {
        if (!checkLoadResource(
                R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
            return; // skip
        }

        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {
            @Override
            public void onInfo(MediaPlayer2 mp, DataSourceDesc2 dsd, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    mOnPrepareCalled.signal();
                } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                    mOnCompletionCalled.signal();
                }
            }

            @Override
            public void onCallCompleted(
                    MediaPlayer2 mp, DataSourceDesc2 dsd, int what, int status) {
                if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                    mOnSeekCompleteCalled.signal();
                }
            }
        };
        synchronized (mEventCbLock) {
            mEventCallbacks.add(ecb);
        }

        mOnCompletionCalled.reset();
        mPlayer.setDisplay(mActivity.getSurfaceHolder());

        mOnPrepareCalled.reset();
        mPlayer.prepare();
        mOnPrepareCalled.waitForSignal();

        mOnSeekCompleteCalled.reset();
        mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        mOnSeekCompleteCalled.waitForSignal();

        final float playbackRate = 1.0f;

        int playTime = 2000;  // The testing clip is about 10 second long.
        mPlayer.setPlaybackParams(new PlaybackParams2().setSpeed(playbackRate));
        assertTrue("MediaPlayer2 should be playing", mPlayer.isPlaying());
        Thread.sleep(playTime);
        assertTrue("MediaPlayer2 should still be playing",
                mPlayer.getCurrentPosition() > 0);

        long duration = mPlayer.getDuration();
        mOnSeekCompleteCalled.reset();
        mPlayer.seekTo(duration - 1000, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        mOnSeekCompleteCalled.waitForSignal();

        mOnCompletionCalled.waitForSignal();
        assertFalse("MediaPlayer2 should not be playing", mPlayer.isPlaying());
        long eosPosition = mPlayer.getCurrentPosition();

        mPlayer.setPlaybackParams(new PlaybackParams2().setSpeed(playbackRate));
        assertTrue("MediaPlayer2 should be playing after EOS", mPlayer.isPlaying());
        Thread.sleep(playTime);
        long position = mPlayer.getCurrentPosition();
        assertTrue("MediaPlayer2 should still be playing after EOS",
                position > 0 && position < eosPosition);

        mPlayer.reset();
    }
    */
@Test
@LargeTest
public void testPlaybackRate() throws Exception {
    final int toleranceMs = 1000;
    if (!checkLoadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        // skip
        return;
    }
    final Monitor labelReached = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, DataSourceDesc2 dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCommandLabelReached(MediaPlayer2 mp, @NonNull Object label) {
            labelReached.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    float[] rates = { 0.25f, 0.5f, 1.0f, 2.0f };
    for (float playbackRate : rates) {
        mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        // The testing clip is about 10 second long.
        int playTime = 4000;
        mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(playbackRate).build());
        Thread.sleep(playTime);
        labelReached.reset();
        mPlayer.notifyWhenCommandLabelReached(new Object());
        labelReached.waitForSignal();
        PlaybackParams2 pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertTrue("MediaPlayer2 should still be playing", mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        int diff = Math.abs((int) (playedMediaDurationMs / playbackRate) - playTime);
        if (diff > toleranceMs) {
            fail("Media player had error in playback rate " + playbackRate + ", play time is " + playTime + " vs expected " + playedMediaDurationMs);
        }
        mPlayer.pause();
        labelReached.reset();
        mPlayer.notifyWhenCommandLabelReached(new Object());
        labelReached.waitForSignal();
        pbp = mPlayer.getPlaybackParams();
        assertEquals(0.f, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}
#method_after
// setPlaybackParams() with non-zero speed should NOT start playback.
// TODO: enable this test when MediaPlayer2.setPlaybackParams() is fixed
/*
    public void testSetPlaybackParamsPositiveSpeed() throws Exception {
        if (!checkLoadResource(
                R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
            return; // skip
        }

        MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {
            @Override
            public void onInfo(MediaPlayer2 mp, DataSourceDesc2 dsd, int what, int extra) {
                if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                    mOnPrepareCalled.signal();
                } else if (what == MediaPlayer2.MEDIA_INFO_DATA_SOURCE_END) {
                    mOnCompletionCalled.signal();
                }
            }

            @Override
            public void onCallCompleted(
                    MediaPlayer2 mp, DataSourceDesc2 dsd, int what, int status) {
                if (what == MediaPlayer2.CALL_COMPLETED_SEEK_TO) {
                    mOnSeekCompleteCalled.signal();
                }
            }
        };
        synchronized (mEventCbLock) {
            mEventCallbacks.add(ecb);
        }

        mOnCompletionCalled.reset();
        mPlayer.setDisplay(mActivity.getSurfaceHolder());

        mOnPrepareCalled.reset();
        mPlayer.prepare();
        mOnPrepareCalled.waitForSignal();

        mOnSeekCompleteCalled.reset();
        mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        mOnSeekCompleteCalled.waitForSignal();

        final float playbackRate = 1.0f;

        int playTime = 2000;  // The testing clip is about 10 second long.
        mPlayer.setPlaybackParams(new PlaybackParams2().setSpeed(playbackRate));
        assertTrue("MediaPlayer2 should be playing", mPlayer.isPlaying());
        Thread.sleep(playTime);
        assertTrue("MediaPlayer2 should still be playing",
                mPlayer.getCurrentPosition() > 0);

        long duration = mPlayer.getDuration();
        mOnSeekCompleteCalled.reset();
        mPlayer.seekTo(duration - 1000, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        mOnSeekCompleteCalled.waitForSignal();

        mOnCompletionCalled.waitForSignal();
        assertFalse("MediaPlayer2 should not be playing", mPlayer.isPlaying());
        long eosPosition = mPlayer.getCurrentPosition();

        mPlayer.setPlaybackParams(new PlaybackParams2().setSpeed(playbackRate));
        assertTrue("MediaPlayer2 should be playing after EOS", mPlayer.isPlaying());
        Thread.sleep(playTime);
        long position = mPlayer.getCurrentPosition();
        assertTrue("MediaPlayer2 should still be playing after EOS",
                position > 0 && position < eosPosition);

        mPlayer.reset();
    }
    */
@Test
@LargeTest
public void testPlaybackRate() throws Exception {
    final int toleranceMs = 1000;
    if (!checkLoadResource(R.raw.video_480x360_mp4_h264_1000kbps_30fps_aac_stereo_128kbps_44100hz)) {
        // skip
        return;
    }
    final Monitor labelReached = new Monitor();
    MediaPlayer2.EventCallback ecb = new MediaPlayer2.EventCallback() {

        @Override
        public void onInfo(MediaPlayer2 mp, DataSourceDesc2 dsd, int what, int extra) {
            if (what == MediaPlayer2.MEDIA_INFO_PREPARED) {
                mOnPrepareCalled.signal();
            }
        }

        @Override
        public void onCommandLabelReached(MediaPlayer2 mp, @NonNull Object label) {
            labelReached.signal();
        }
    };
    synchronized (mEventCbLock) {
        mEventCallbacks.add(ecb);
    }
    mPlayer.setSurface(mActivity.getSurfaceHolder().getSurface());
    mOnPrepareCalled.reset();
    mPlayer.prepare();
    mOnPrepareCalled.waitForSignal();
    float[] rates = { 0.25f, 0.5f, 1.0f, 2.0f };
    for (float playbackRate : rates) {
        mPlayer.seekTo(0, MediaPlayer2.SEEK_PREVIOUS_SYNC);
        Thread.sleep(1000);
        // The testing clip is about 10 second long.
        int playTime = 4000;
        int privState = mPlayer.getState();
        mPlayer.setPlaybackParams(new PlaybackParams2.Builder().setSpeed(playbackRate).build());
        labelReached.reset();
        mPlayer.notifyWhenCommandLabelReached(new Object());
        labelReached.waitForSignal();
        assertTrue("setPlaybackParams() should not change player state. " + mPlayer.getState(), mPlayer.getState() == privState);
        mPlayer.play();
        Thread.sleep(playTime);
        labelReached.reset();
        mPlayer.notifyWhenCommandLabelReached(new Object());
        labelReached.waitForSignal();
        PlaybackParams2 pbp = mPlayer.getPlaybackParams();
        assertEquals(playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
        assertTrue("MediaPlayer2 should still be playing", mPlayer.getState() == MediaPlayer2.PLAYER_STATE_PLAYING);
        long playedMediaDurationMs = mPlayer.getCurrentPosition();
        int diff = Math.abs((int) (playedMediaDurationMs / playbackRate) - playTime);
        if (diff > toleranceMs) {
            fail("Media player had error in playback rate " + playbackRate + ", play time is " + playTime + " vs expected " + playedMediaDurationMs);
        }
        mPlayer.pause();
        labelReached.reset();
        mPlayer.notifyWhenCommandLabelReached(new Object());
        labelReached.waitForSignal();
        pbp = mPlayer.getPlaybackParams();
        assertEquals("pause() should not change the playback rate property.", playbackRate, pbp.getSpeed(), FLOAT_TOLERANCE);
    }
    mPlayer.reset();
}
#end_block

#method_before
synchronized void setFirst(DataSourceDesc2 dsd) throws IOException {
    if (mQueue.isEmpty()) {
        mQueue.add(0, new MediaPlayerSource(dsd));
    } else {
        mQueue.get(0).mDSD = dsd;
        setUpListeners(mQueue.get(0));
    }
    handleDataSource(mQueue.get(0));
    if (mPlaybackParamsToSetAfterSetDataSource != null) {
        getCurrentPlayer().setPlaybackParams(mPlaybackParamsToSetAfterSetDataSource);
        mPlaybackParams = mPlaybackParamsToSetAfterSetDataSource;
        mPlaybackParamsToSetAfterSetDataSource = null;
    }
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(PlayerEventCallback cb) {
            cb.onCurrentDataSourceChanged(mMediaPlayerConnectorImpl, mQueue.get(0).mDSD);
        }
    });
}
#method_after
synchronized void setFirst(DataSourceDesc2 dsd) throws IOException {
    if (mQueue.isEmpty()) {
        mQueue.add(0, new MediaPlayerSource(dsd));
    } else {
        mQueue.get(0).mDSD = dsd;
        setUpListeners(mQueue.get(0));
    }
    handleDataSource(mQueue.get(0));
    notifyPlayerEvent(new PlayerEventNotifier() {

        @Override
        public void notify(PlayerEventCallback cb) {
            cb.onCurrentDataSourceChanged(mMediaPlayerConnectorImpl, mQueue.get(0).mDSD);
        }
    });
}
#end_block

#method_before
synchronized void play() {
    final MediaPlayerSource src = mQueue.get(0);
    if (src.mSourceState == SOURCE_STATE_PREPARED) {
        src.getPlayer().start();
        setMp2State(src.getPlayer(), PLAYER_STATE_PLAYING);
        notifyMediaPlayer2Event(new Mp2EventNotifier() {

            @Override
            public void notify(EventCallback callback) {
                callback.onInfo(MediaPlayer2Impl.this, src.getDSD(), MEDIA_INFO_DATA_SOURCE_START, 0);
            }
        });
    } else {
        throw new IllegalStateException();
    }
}
#method_after
synchronized void play() {
    final MediaPlayerSource src = mQueue.get(0);
    if (src.mSourceState == SOURCE_STATE_PREPARED) {
        if (mPlaybackParamsToSetWhenStarting != null) {
            src.getPlayer().setPlaybackParams(mPlaybackParamsToSetWhenStarting);
            mPlaybackParamsToSetWhenStarting = null;
        }
        src.getPlayer().start();
        setMp2State(src.getPlayer(), PLAYER_STATE_PLAYING);
        notifyMediaPlayer2Event(new Mp2EventNotifier() {

            @Override
            public void notify(EventCallback callback) {
                callback.onInfo(MediaPlayer2Impl.this, src.getDSD(), MEDIA_INFO_DATA_SOURCE_START, 0);
            }
        });
    } else {
        throw new IllegalStateException();
    }
}
#end_block

#method_before
synchronized void applyProperties() {
    final MediaPlayerSource src = mQueue.get(0);
    if (mSurface != null) {
        src.getPlayer().setSurface(mSurface);
    }
    if (mVolume != null) {
        src.getPlayer().setVolume(mVolume, mVolume);
    }
    if (mAudioAttributes != null) {
        src.getPlayer().setAudioAttributes((AudioAttributes) mAudioAttributes.unwrap());
    }
    if (mAuxEffect != null) {
        src.getPlayer().attachAuxEffect(mAuxEffect);
    }
    if (mAuxEffectSendLevel != null) {
        src.getPlayer().setAuxEffectSendLevel(mAuxEffectSendLevel);
    }
    if (mSyncParams != null) {
        src.getPlayer().setSyncParams(mSyncParams);
    }
    if (mPlaybackParams != null) {
        src.getPlayer().setPlaybackParams(mPlaybackParams);
    }
}
#method_after
synchronized void applyProperties() {
    final MediaPlayerSource src = mQueue.get(0);
    if (mSurface != null) {
        src.getPlayer().setSurface(mSurface);
    }
    if (mVolume != null) {
        src.getPlayer().setVolume(mVolume, mVolume);
    }
    if (mAudioAttributes != null) {
        src.getPlayer().setAudioAttributes((AudioAttributes) mAudioAttributes.unwrap());
    }
    if (mAuxEffect != null) {
        src.getPlayer().attachAuxEffect(mAuxEffect);
    }
    if (mAuxEffectSendLevel != null) {
        src.getPlayer().setAuxEffectSendLevel(mAuxEffectSendLevel);
    }
    if (mSyncParams != null) {
        src.getPlayer().setSyncParams(mSyncParams);
    }
    if (mPlaybackParams != DEFAULT_PLAYBACK_PARAMS) {
        src.getPlayer().setPlaybackParams(mPlaybackParams);
    }
}
#end_block

#method_before
synchronized void setPlaybackParams(final PlaybackParams params) {
    PlaybackParams current = null;
    try {
        current = getPlaybackParams();
    } catch (IllegalStateException e) {
    // Do nothing.
    }
    MediaPlayer currentPlayer = getCurrentPlayer();
    try {
        currentPlayer.setPlaybackParams(params);
        mPlaybackParams = params;
    } catch (IllegalStateException e) {
        // Keep the value so that it can be set later.
        mPlaybackParamsToSetAfterSetDataSource = params;
    }
    if (current != null && current.getSpeed() != params.getSpeed()) {
        notifyPlayerEvent(new PlayerEventNotifier() {

            @Override
            public void notify(PlayerEventCallback cb) {
                cb.onPlaybackSpeedChanged(mMediaPlayerConnectorImpl, params.getSpeed());
            }
        });
        final int currentState = mPlayer.getFirst().mMp2State;
        if (currentState != PLAYER_STATE_IDLE && currentState != PLAYER_STATE_ERROR) {
            if (params.getSpeed() == 0f) {
                setMp2State(currentPlayer, PLAYER_STATE_PAUSED);
            } else {
                setMp2State(currentPlayer, PLAYER_STATE_PLAYING);
            }
        }
    }
}
#method_after
synchronized void setPlaybackParams(final PlaybackParams params) {
    if (params == null || params.getSpeed() == 0f) {
        throw new IllegalArgumentException();
    }
    PlaybackParams current = getPlaybackParams();
    MediaPlayerSource firstPlayer = mPlayer.getFirst();
    if (firstPlayer.mMp2State != PLAYER_STATE_PLAYING) {
        // MediaPlayer1 may start the playback on setPlaybackParams. Store the value here
        // so that it can be applied later when starting the playback.
        mPlaybackParamsToSetWhenStarting = params;
    } else {
        firstPlayer.mPlayer.setPlaybackParams(params);
        mPlaybackParamsToSetWhenStarting = null;
    }
    if (current != null && current.getSpeed() != params.getSpeed()) {
        notifyPlayerEvent(new PlayerEventNotifier() {

            @Override
            public void notify(PlayerEventCallback cb) {
                cb.onPlaybackSpeedChanged(mMediaPlayerConnectorImpl, params.getSpeed());
            }
        });
    }
    mPlaybackParams = params;
}
#end_block

#method_before
synchronized PlaybackParams getPlaybackParams() {
    return getCurrentPlayer().getPlaybackParams();
}
#method_after
synchronized PlaybackParams getPlaybackParams() {
    // PlaybackParams is mutable. Make a copy of mPlaybackParams and return.
    Parcel parcel = Parcel.obtain();
    mPlaybackParams.writeToParcel(parcel, 0);
    parcel.setDataPosition(0);
    PlaybackParams ret = PlaybackParams.CREATOR.createFromParcel(parcel);
    parcel.recycle();
    return ret;
}
#end_block

#method_before
synchronized void reset() {
    MediaPlayerSource src = mQueue.get(0);
    src.getPlayer().reset();
    src.mBufferedPercentage.set(0);
    mVolume = 1.0f;
    mSurface = null;
    mAuxEffect = null;
    mAuxEffectSendLevel = null;
    mAudioAttributes = null;
    mAudioSessionId = null;
    mSyncParams = null;
    mPlaybackParams = null;
    mLooping = false;
    setMp2State(src.getPlayer(), PLAYER_STATE_IDLE);
    setBufferingState(src.getPlayer(), MediaPlayerConnector.BUFFERING_STATE_UNKNOWN);
}
#method_after
synchronized void reset() {
    MediaPlayerSource src = mQueue.get(0);
    src.getPlayer().reset();
    src.mBufferedPercentage.set(0);
    mVolume = 1.0f;
    mSurface = null;
    mAuxEffect = null;
    mAuxEffectSendLevel = null;
    mAudioAttributes = null;
    mAudioSessionId = null;
    mSyncParams = null;
    mPlaybackParams = DEFAULT_PLAYBACK_PARAMS;
    mPlaybackParamsToSetWhenStarting = null;
    mLooping = false;
    setMp2State(src.getPlayer(), PLAYER_STATE_IDLE);
    setBufferingState(src.getPlayer(), MediaPlayerConnector.BUFFERING_STATE_UNKNOWN);
}
#end_block

#method_before
@RequiresPermission(Manifest.permission.BLUETOOTsH_ADMIN)
public void stopScan(PendingIntent callbackIntent) {
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopScanForIntent(callbackIntent, ActivityThread.currentOpPackageName());
    } catch (RemoteException e) {
    }
}
#method_after
@RequiresPermission(Manifest.permission.BLUETOOTH_ADMIN)
public void stopScan(PendingIntent callbackIntent) {
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
        gatt.stopScanForIntent(callbackIntent, ActivityThread.currentOpPackageName());
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void assertMemoryForScreenDensity(int memoryClass, int screenDensity, int screenSize) {
    Context context = getInstrumentation().getTargetContext();
    boolean isWatch = context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    int expectedMinimumMemory = ExpectedMemorySizesClass.getExpectedMemorySize(screenSize, screenDensity, isWatch);
    assertTrue("CDD 3.7/C-0-2 Expected to have at least " + expectedMinimumMemory + "mb of memory for screen density " + screenDensity, memoryClass >= expectedMinimumMemory);
}
#method_after
private void assertMemoryForScreenDensity(int memoryClass, int screenDensity, int screenSize) {
    Context context = getInstrumentation().getTargetContext();
    boolean isWatch = context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    int expectedMinimumMemory = ExpectedMemorySizesClass.getExpectedMemorySize(screenSize, screenDensity, isWatch);
    assertTrue("Expected to have at least " + expectedMinimumMemory + "mb of memory for screen density " + screenDensity, memoryClass >= expectedMinimumMemory);
}
#end_block

#method_before
private synchronized void msgPassThru(int cmd) {
    if (DBG)
        Log.d(TAG, "msgPassThru " + cmd);
    if (mA2dpDevice == null) {
        // We should have already disconnected - ignore this message.
        Log.w(TAG, "Already disconnected ignoring.");
        return;
    }
    // Some keys should be held until the next event.
    if (mCurrentlyHeldKey != 0) {
        mAvrcpCtrlSrvc.sendPassThroughCmd(mA2dpDevice, mCurrentlyHeldKey, AvrcpControllerService.KEY_STATE_RELEASED);
        mCurrentlyHeldKey = 0;
        // Return to prevent doing FF/FR operation again
        return;
    }
    // Send the pass through.
    mAvrcpCtrlSrvc.sendPassThroughCmd(mA2dpDevice, cmd, AvrcpControllerService.KEY_STATE_PRESSED);
    if (isHoldableKey(cmd)) {
        // Release cmd next time a command is sent.
        mCurrentlyHeldKey = cmd;
    } else {
        mAvrcpCtrlSrvc.sendPassThroughCmd(mA2dpDevice, cmd, AvrcpControllerService.KEY_STATE_RELEASED);
    }
}
#method_after
private synchronized void msgPassThru(int cmd) {
    if (DBG)
        Log.d(TAG, "msgPassThru " + cmd);
    if (mA2dpDevice == null) {
        // We should have already disconnected - ignore this message.
        Log.w(TAG, "Already disconnected ignoring.");
        return;
    }
    // Some keys should be held until the next event.
    if (mCurrentlyHeldKey != 0) {
        mAvrcpCtrlSrvc.sendPassThroughCmd(mA2dpDevice, mCurrentlyHeldKey, AvrcpControllerService.KEY_STATE_RELEASED);
        if (mCurrentlyHeldKey == cmd) {
            // Return to prevent starting FF/FR operation again
            mCurrentlyHeldKey = 0;
            return;
        } else {
            // FF/FR is in progress and other operation is desired
            // so after stopping FF/FR, not returning so that command
            // can be sent for the desired operation.
            mCurrentlyHeldKey = 0;
        }
    }
    // Send the pass through.
    mAvrcpCtrlSrvc.sendPassThroughCmd(mA2dpDevice, cmd, AvrcpControllerService.KEY_STATE_PRESSED);
    if (isHoldableKey(cmd)) {
        // Release cmd next time a command is sent.
        mCurrentlyHeldKey = cmd;
    } else {
        mAvrcpCtrlSrvc.sendPassThroughCmd(mA2dpDevice, cmd, AvrcpControllerService.KEY_STATE_RELEASED);
    }
}
#end_block

#method_before
@SuppressWarnings("WeakerAccess")
static /* synthetic access */
void handleDataSource(MediaPlayerSource src) throws IOException {
    final DataSourceDesc2 dsd = src.getDSD();
    Preconditions.checkArgument(dsd != null, "the DataSourceDesc2 cannot be null");
    MediaPlayer player = src.getPlayer();
    if (dsd instanceof CallbackDataSourceDesc2) {
        player.setDataSource(new MediaDataSource() {

            DataSourceCallback2 mDataSource = ((CallbackDataSourceDesc2) dsd).getCallbackDataSource2();

            @Override
            public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
                return mDataSource.readAt(position, buffer, offset, size);
            }

            @Override
            public long getSize() throws IOException {
                return mDataSource.getSize();
            }

            @Override
            public void close() throws IOException {
                mDataSource.close();
            }
        });
    } else if (dsd instanceof FileDataSourceDesc2) {
        FileDataSourceDesc2 fdsd = (FileDataSourceDesc2) dsd;
        player.setDataSource(fdsd.getFileDescriptor(), fdsd.getFileDescriptorOffset(), fdsd.getFileDescriptorLength());
    } else if (dsd instanceof UriDataSourceDesc2) {
        UriDataSourceDesc2 udsd = (UriDataSourceDesc2) dsd;
        player.setDataSource(udsd.getUriContext(), udsd.getUri(), udsd.getUriHeaders(), udsd.getUriCookies());
        throw new IllegalArgumentException("Unsupported data source description. " + dsd.toString());
    }
}
#method_after
@SuppressWarnings("WeakerAccess")
static /* synthetic access */
void handleDataSource(MediaPlayerSource src) throws IOException {
    final DataSourceDesc2 dsd = src.getDSD();
    Preconditions.checkArgument(dsd != null, "the DataSourceDesc2 cannot be null");
    MediaPlayer player = src.getPlayer();
    if (dsd instanceof CallbackDataSourceDesc2) {
        player.setDataSource(new MediaDataSource() {

            DataSourceCallback2 mDataSource = ((CallbackDataSourceDesc2) dsd).getDataSourceCallback2();

            @Override
            public int readAt(long position, byte[] buffer, int offset, int size) throws IOException {
                return mDataSource.readAt(position, buffer, offset, size);
            }

            @Override
            public long getSize() throws IOException {
                return mDataSource.getSize();
            }

            @Override
            public void close() throws IOException {
                mDataSource.close();
            }
        });
    } else if (dsd instanceof FileDataSourceDesc2) {
        FileDataSourceDesc2 fdsd = (FileDataSourceDesc2) dsd;
        player.setDataSource(fdsd.getFileDescriptor(), fdsd.getFileDescriptorOffset(), fdsd.getFileDescriptorLength());
    } else if (dsd instanceof UriDataSourceDesc2) {
        UriDataSourceDesc2 udsd = (UriDataSourceDesc2) dsd;
        player.setDataSource(udsd.getUriContext(), udsd.getUri(), udsd.getUriHeaders(), udsd.getUriCookies());
    } else {
        throw new IllegalArgumentException("Unsupported data source description. " + dsd.toString());
    }
}
#end_block

#method_before
public void printXmlParser(String packageName, CodeWriter out) {
    out.printf("package %s;", packageName);
    out.println();
    out.print("public class XmlParser {");
    out.print("public static java.lang.Object read(java.io.InputStream in)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {" + "org.xmlpull.v1.XmlPullParser parser = org.xmlpull.v1.XmlPullParserFactory" + ".newInstance().newPullParser();" + "parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_PROCESS_NAMESPACES, " + "true);" + "parser.setInput(in, null);" + "parser.nextTag();" + "String tagName = parser.getName();");
    for (VariableDescriptor element : rootElementMap.values()) {
        out.printf("if (tagName.equals(\"%s\")) {", element.getXmlName());
        if (element.getType().isSimple()) {
            out.print("raw = XmlParser.readText(parser);");
        }
        out.print(element.getType().getParsingExpression());
        out.print("return value; } else ");
    }
    out.print("{" + "throw new RuntimeException(String.format(\"unknown element '%s'\", tagName));" + "} }");
    out.println();
    out.print("public static java.lang.String readText(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {" + "String result = \"\";" + "if (parser.next() == org.xmlpull.v1.XmlPullParser.TEXT) {" + "result = parser.getText();" + "parser.nextTag();" + "}" + "return result;" + "}");
    out.println();
    out.print("public static void skip(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) {" + "throw new IllegalStateException();" + "}" + "int depth = 1;" + "while (depth != 0) {" + "switch (parser.next()) {" + "case org.xmlpull.v1.XmlPullParser.END_TAG:" + "depth--;" + "break;" + "case org.xmlpull.v1.XmlPullParser.START_TAG:" + "depth++;" + "break;" + "} } }");
    out.print("}");
}
#method_after
public void printXmlParser(String packageName, CodeWriter out) {
    out.printf("package %s;\n", packageName);
    out.println();
    out.println("public class XmlParser {");
    out.print("public static java.lang.Object read(java.io.InputStream in)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n" + "org.xmlpull.v1.XmlPullParser parser = org.xmlpull.v1.XmlPullParserFactory" + ".newInstance().newPullParser();\n" + "parser.setFeature(org.xmlpull.v1.XmlPullParser.FEATURE_PROCESS_NAMESPACES, " + "true);\n" + "parser.setInput(in, null);\n" + "parser.nextTag();\n" + "String tagName = parser.getName();\n");
    for (VariableDescriptor element : rootElementMap.values()) {
        out.printf("if (tagName.equals(\"%s\")) {\n", element.getXmlName());
        if (element.getType().isSimple()) {
            out.print("raw = XmlParser.readText(parser);\n");
        }
        out.print(element.getType().getParsingExpression());
        out.print("return value;\n" + "} else ");
    }
    out.print("{\n" + "throw new RuntimeException(String.format(\"unknown element '%s'\", tagName));\n" + "}\n}\n");
    out.println();
    out.print("public static java.lang.String readText(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "String result = \"\";\n" + "if (parser.next() == org.xmlpull.v1.XmlPullParser.TEXT) {\n" + "result = parser.getText();\n" + "parser.nextTag();\n" + "}\n" + "return result;\n" + "}\n");
    out.println();
    out.print("public static void skip(org.xmlpull.v1.XmlPullParser parser)" + " throws org.xmlpull.v1.XmlPullParserException, java.io.IOException {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) {\n" + "throw new IllegalStateException();\n" + "}\n" + "int depth = 1;\n" + "while (depth != 0) {\n" + "switch (parser.next()) {\n" + "case org.xmlpull.v1.XmlPullParser.END_TAG:\n" + "depth--;\n" + "break;\n" + "case org.xmlpull.v1.XmlPullParser.START_TAG:\n" + "depth++;\n" + "break;\n" + "}\n}\n}\n");
    out.println("}");
}
#end_block

#method_before
public void println() {
    out.println();
    startLine = true;
}
#method_after
public void println(String code) {
    print(code + "\n");
}
#end_block

#method_before
public void print(String code) {
    for (int i = 0; i < code.length(); ++i) {
        char c = code.charAt(i);
        if (c == '{') {
            ++indent;
        } else if (c == '}') {
            --indent;
        }
        if (!startLine || !Character.isWhitespace(c)) {
            if (startLine) {
                printIndent();
            }
            out.print(c);
        }
        if (c == '{' || c == '}' || c == ';') {
            println();
        }
    }
}
#method_after
public void print(String code) {
    String[] lines = code.split("\n", -1);
    for (int i = 0; i < lines.length; ++i) {
        String line = lines[i].trim();
        if (line.startsWith("}")) {
            --indent;
        }
        if (startLine && !line.isEmpty()) {
            printIndent();
        }
        out.print(line);
        if (line.endsWith("{")) {
            ++indent;
        }
        if (i + 1 < lines.length) {
            out.println();
            startLine = true;
        }
    }
}
#end_block

#method_before
public void print(String packageName, CodeWriter out) {
    out.printf("package %s;", packageName);
    out.println();
    print(out, false);
}
#method_after
public void print(String packageName, CodeWriter out) {
    out.printf("package %s;\n\n", packageName);
    print(out, false);
}
#end_block

#method_before
private void print(CodeWriter out, boolean isInner) {
    if (isInner) {
        out.printf("public static class %s ", getName());
    } else {
        out.printf("public class %s ", getName());
    }
    if (base != null) {
        out.printf("extends %s {", base.getName());
    } else {
        out.print("{");
    }
    List<VariableDescriptor> values = new ArrayList<>();
    if (valueType != null) {
        values.add(new VariableDescriptor(valueType, "value", null, true, false));
    }
    printVariables(out, elements);
    printVariables(out, attributes);
    printVariables(out, values);
    printGetterAndSetter(out, elements);
    printGetterAndSetter(out, attributes);
    printGetterAndSetter(out, values);
    out.println();
    printParser(out);
    for (ClassDescriptor descriptor : innerClasses) {
        out.println();
        descriptor.print(out, true);
    }
    out.print("}");
}
#method_after
private void print(CodeWriter out, boolean isInner) {
    if (isInner) {
        out.printf("public static class %s ", getName());
    } else {
        out.printf("public class %s ", getName());
    }
    if (base != null) {
        out.printf("extends %s {\n", base.getName());
    } else {
        out.println("{");
    }
    List<VariableDescriptor> values = new ArrayList<>();
    if (valueType != null) {
        values.add(new VariableDescriptor(valueType, "value", null, true, false));
    }
    printVariables(out, elements);
    printVariables(out, attributes);
    printVariables(out, values);
    printGetterAndSetter(out, elements);
    printGetterAndSetter(out, attributes);
    printGetterAndSetter(out, values);
    out.println();
    printParser(out);
    for (ClassDescriptor descriptor : innerClasses) {
        out.println();
        descriptor.print(out, true);
    }
    out.println("}");
}
#end_block

#method_before
private void printVariables(CodeWriter out, List<VariableDescriptor> variables) {
    for (VariableDescriptor variable : variables) {
        out.printf("protected %s %s;", variable.getFullTypeName(), variable.getName());
    }
}
#method_after
private void printVariables(CodeWriter out, List<VariableDescriptor> variables) {
    for (VariableDescriptor variable : variables) {
        out.printf("protected %s %s;\n", variable.getFullTypeName(), variable.getName());
    }
}
#end_block

#method_before
private void printGetterAndSetter(CodeWriter out, List<VariableDescriptor> variables) {
    for (VariableDescriptor variable : variables) {
        out.println();
        out.printf("public %s get%s() {", variable.getFullTypeName(), Utils.capitalize(variable.getName()));
        if (variable.isMultiple()) {
            out.printf("if (%s == null) {" + "%s = new java.util.ArrayList<>();" + "}", variable.getName(), variable.getName());
        }
        out.printf("return %s; }", variable.getName());
        if (!variable.isMultiple()) {
            out.println();
            out.printf("public void set%s(%s %s) {" + "this.%s = %s;" + "}", Utils.capitalize(variable.getName()), variable.getFullTypeName(), variable.getName(), variable.getName(), variable.getName());
        }
    }
}
#method_after
private void printGetterAndSetter(CodeWriter out, List<VariableDescriptor> variables) {
    for (VariableDescriptor variable : variables) {
        out.println();
        out.printf("public %s get%s() {\n", variable.getFullTypeName(), Utils.capitalize(variable.getName()));
        if (variable.isMultiple()) {
            out.printf("if (%s == null) {\n" + "%s = new java.util.ArrayList<>();\n" + "}\n", variable.getName(), variable.getName());
        }
        out.printf("return %s;\n" + "}\n", variable.getName());
        if (!variable.isMultiple()) {
            out.println();
            out.printf("public void set%s(%s %s) {\n" + "this.%s = %s;\n" + "}\n", Utils.capitalize(variable.getName()), variable.getFullTypeName(), variable.getName(), variable.getName(), variable.getName());
        }
    }
}
#end_block

#method_before
private void printParser(CodeWriter out) {
    out.printf("public static %s read(org.xmlpull.v1.XmlPullParser parser) " + "throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {", name);
    out.printf("%s instance = new %s();" + "String raw = null;", name, name);
    for (VariableDescriptor attribute : getAllAttributes()) {
        out.printf("raw = parser.getAttributeValue(null, \"%s\");" + "if (raw != null) {", attribute.getXmlName());
        out.print(attribute.getType().getParsingExpression());
        out.printf("instance.set%s(value); }", Utils.capitalize(attribute.getName()));
    }
    TypeDescriptor baseValueType = getBaseValueType();
    List<VariableDescriptor> allElements = getAllElements();
    if (baseValueType != null) {
        out.print("raw = XmlParser.readText(parser);" + "if (raw != null) {");
        out.print(baseValueType.getParsingExpression());
        out.print("instance.setValue(value); }");
    } else if (!allElements.isEmpty()) {
        out.print("while (parser.next() != org.xmlpull.v1.XmlPullParser.END_TAG) {" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) " + "continue;" + "String tagName = parser.getName();");
        for (VariableDescriptor element : allElements) {
            out.printf("if (tagName.equals(\"%s\")) {", element.getXmlName());
            if (element.getType().isSimple()) {
                out.print("raw = XmlParser.readText(parser);");
            }
            out.print(element.getType().getParsingExpression());
            if (element.isMultiple()) {
                out.printf("instance.get%s().add(value);", Utils.capitalize(element.getName()));
            } else {
                out.printf("instance.set%s(value);\n", Utils.capitalize(element.getName()));
            }
            out.printf("} else ");
        }
        out.print("{ XmlParser.skip(parser); } }");
    }
    out.print("return instance; }");
}
#method_after
private void printParser(CodeWriter out) {
    out.printf("public static %s read(org.xmlpull.v1.XmlPullParser parser) " + "throws org.xmlpull.v1.XmlPullParserException, java.io.IOException, " + "javax.xml.datatype.DatatypeConfigurationException {\n", name);
    out.printf("%s instance = new %s();\n" + "String raw = null;\n", name, name);
    for (VariableDescriptor attribute : getAllAttributes()) {
        out.printf("raw = parser.getAttributeValue(null, \"%s\");\n" + "if (raw != null) {\n", attribute.getXmlName());
        out.print(attribute.getType().getParsingExpression());
        out.printf("instance.set%s(value);\n" + "}\n", Utils.capitalize(attribute.getName()));
    }
    TypeDescriptor baseValueType = getBaseValueType();
    List<VariableDescriptor> allElements = getAllElements();
    if (baseValueType != null) {
        out.print("raw = XmlParser.readText(parser);\n" + "if (raw != null) {\n");
        out.print(baseValueType.getParsingExpression());
        out.print("instance.setValue(value);\n" + "}\n");
    } else if (!allElements.isEmpty()) {
        out.print("while (parser.next() != org.xmlpull.v1.XmlPullParser.END_TAG) {\n" + "if (parser.getEventType() != org.xmlpull.v1.XmlPullParser.START_TAG) " + "continue;\n" + "String tagName = parser.getName();\n");
        for (VariableDescriptor element : allElements) {
            out.printf("if (tagName.equals(\"%s\")) {\n", element.getXmlName());
            if (element.getType().isSimple()) {
                out.print("raw = XmlParser.readText(parser);\n");
            }
            out.print(element.getType().getParsingExpression());
            if (element.isMultiple()) {
                out.printf("instance.get%s().add(value);\n", Utils.capitalize(element.getName()));
            } else {
                out.printf("instance.set%s(value);\n", Utils.capitalize(element.getName()));
            }
            out.printf("} else ");
        }
        out.print("{\n" + "XmlParser.skip(parser);\n" + "}\n" + "}\n");
    }
    out.print("return instance;\n" + "}\n");
}
#end_block

#method_before
@Override
public void onSubscriptionsChanged() {
    if (DBG)
        log("SubscriptionListener.onSubscriptionInfoChanged");
    // Set the network type, in case the radio does not restore it.
    int subId = mPhone.getSubId();
    if (mSubscriptionManager.isValidSubscriptionId(subId)) {
        registerSettingsObserver();
    }
    if (mSubscriptionManager.isValidSubscriptionId(subId) && mPreviousSubId.getAndSet(subId) != subId) {
        onRecordsLoadedOrSubIdChanged();
    }
}
#method_after
@Override
public void onSubscriptionsChanged() {
    if (DBG)
        log("SubscriptionListener.onSubscriptionInfoChanged");
    // Set the network type, in case the radio does not restore it.
    int subId = mPhone.getSubId();
    if (SubscriptionManager.isValidSubscriptionId(subId)) {
        registerSettingsObserver();
    }
    if (SubscriptionManager.isValidSubscriptionId(subId) && mPreviousSubId.getAndSet(subId) != subId) {
        onRecordsLoadedOrSubIdChanged();
    }
}
#end_block

#method_before
private void doRecovery() {
    if (getOverallState() == DctConstants.State.CONNECTED) {
        // Go through a series of recovery steps, each action transitions to the next action
        final int recoveryAction = getRecoveryAction();
        TelephonyMetrics.getInstance().writeDataStallEvent(mPhone.getPhoneId(), recoveryAction);
        switch(recoveryAction) {
            case RecoveryAction.GET_DATA_CALL_LIST:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_GET_DATA_CALL_LIST, mSentSinceLastRecv);
                if (DBG)
                    log("doRecovery() get data call list");
                mDataServiceManager.getDataCallList(obtainMessage());
                putRecoveryAction(RecoveryAction.CLEANUP);
                break;
            case RecoveryAction.CLEANUP:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_CLEANUP, mSentSinceLastRecv);
                if (DBG)
                    log("doRecovery() cleanup all connections");
                cleanUpAllConnections(Phone.REASON_PDP_RESET);
                putRecoveryAction(RecoveryAction.REREGISTER);
                break;
            case RecoveryAction.REREGISTER:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_REREGISTER, mSentSinceLastRecv);
                if (DBG)
                    log("doRecovery() re-register");
                mPhone.getServiceStateTracker().reRegisterNetwork(null);
                putRecoveryAction(RecoveryAction.RADIO_RESTART);
                break;
            case RecoveryAction.RADIO_RESTART:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_RADIO_RESTART, mSentSinceLastRecv);
                if (DBG)
                    log("restarting radio");
                restartRadio();
                putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
                break;
            default:
                throw new RuntimeException("doRecovery: Invalid recoveryAction=" + recoveryAction);
        }
        mSentSinceLastRecv = 0;
    }
}
#method_after
private void doRecovery() {
    if (getOverallState() == DctConstants.State.CONNECTED) {
        // Go through a series of recovery steps, each action transitions to the next action
        final int recoveryAction = getRecoveryAction();
        TelephonyMetrics.getInstance().writeDataStallEvent(mPhone.getPhoneId(), recoveryAction);
        broadcastDataStallDetected(recoveryAction);
        switch(recoveryAction) {
            case RecoveryAction.GET_DATA_CALL_LIST:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_GET_DATA_CALL_LIST, mSentSinceLastRecv);
                if (DBG)
                    log("doRecovery() get data call list");
                mDataServiceManager.getDataCallList(obtainMessage());
                putRecoveryAction(RecoveryAction.CLEANUP);
                break;
            case RecoveryAction.CLEANUP:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_CLEANUP, mSentSinceLastRecv);
                if (DBG)
                    log("doRecovery() cleanup all connections");
                cleanUpAllConnections(Phone.REASON_PDP_RESET);
                putRecoveryAction(RecoveryAction.REREGISTER);
                break;
            case RecoveryAction.REREGISTER:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_REREGISTER, mSentSinceLastRecv);
                if (DBG)
                    log("doRecovery() re-register");
                mPhone.getServiceStateTracker().reRegisterNetwork(null);
                putRecoveryAction(RecoveryAction.RADIO_RESTART);
                break;
            case RecoveryAction.RADIO_RESTART:
                EventLog.writeEvent(EventLogTags.DATA_STALL_RECOVERY_RADIO_RESTART, mSentSinceLastRecv);
                if (DBG)
                    log("restarting radio");
                restartRadio();
                putRecoveryAction(RecoveryAction.GET_DATA_CALL_LIST);
                break;
            default:
                throw new RuntimeException("doRecovery: Invalid recoveryAction=" + recoveryAction);
        }
        mSentSinceLastRecv = 0;
    }
}
#end_block

#method_before
public void setText(CharSequence text) {
    mText = text;
    markDirty();
}
#method_after
public void setText(@Nullable CharSequence text) {
    mText = text;
    markDirty();
}
#end_block

#method_before
public void setText(CharSequence text) {
    mText = text;
    markDirty();
}
#method_after
public void setText(@NonNull CharSequence text) {
    if (TextUtils.isEmpty(text)) {
        throw new IllegalArgumentException("Text for subheader cannot be empty.");
    }
    mText = text;
    markDirty();
}
#end_block

#method_before
private boolean bindService() {
    int st = BluetoothAdapter.STATE_OFF;
    try {
        mBluetoothLock.readLock().lock();
        if (mBluetooth != null) {
            st = mBluetooth.getState();
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to call getState", e);
        return false;
    } finally {
        mBluetoothLock.readLock().unlock();
    }
    if (!mEnable || st != BluetoothAdapter.STATE_ON) {
        if (DBG) {
            Slog.d(TAG, "Unable to bindService while Bluetooth is disabled");
        }
        return false;
    }
    if (mIntent != null && mService == null && doBind(mIntent, this, 0, UserHandle.CURRENT_OR_SELF)) {
        Message msg = mHandler.obtainMessage(MESSAGE_BIND_PROFILE_SERVICE);
        msg.obj = this;
        mHandler.sendMessageDelayed(msg, TIMEOUT_BIND_MS);
        return true;
    }
    Slog.w(TAG, "Unable to bind with intent: " + mIntent);
    return false;
}
#method_after
private boolean bindService() {
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mBluetoothLock.readLock().lock();
        if (mBluetooth != null) {
            state = mBluetooth.getState();
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to call getState", e);
        return false;
    } finally {
        mBluetoothLock.readLock().unlock();
    }
    if (!mEnable || state != BluetoothAdapter.STATE_ON) {
        if (DBG) {
            Slog.d(TAG, "Unable to bindService while Bluetooth is disabled");
        }
        return false;
    }
    if (mIntent != null && mService == null && doBind(mIntent, this, 0, UserHandle.CURRENT_OR_SELF)) {
        Message msg = mHandler.obtainMessage(MESSAGE_BIND_PROFILE_SERVICE);
        msg.obj = this;
        mHandler.sendMessageDelayed(msg, TIMEOUT_BIND_MS);
        return true;
    }
    Slog.w(TAG, "Unable to bind with intent: " + mIntent);
    return false;
}
#end_block

#method_before
public void binderDied() {
    mBar = null;
    notifyBarAttachChanged();
    unlinkToDeath();
}
#method_after
public void binderDied() {
    mBar.asBinder().unlinkToDeath(this, 0);
    mBar = null;
    notifyBarAttachChanged();
}
#end_block

#method_before
// ================================================================================
// Callbacks from the status bar service.
@Override
public void registerStatusBar(IStatusBar bar, List<String> iconSlots, List<StatusBarIcon> iconList, int[] switches, List<IBinder> binders, Rect fullscreenStackBounds, Rect dockedStackBounds) {
    enforceStatusBarService();
    Slog.i(TAG, "registerStatusBar bar=" + bar);
    mBar = bar;
    try {
        mBar.asBinder().linkToDeath(mDeathRecipient, 0);
    } catch (RemoteException e) {
    }
    notifyBarAttachChanged();
    synchronized (mIcons) {
        for (String slot : mIcons.keySet()) {
            iconSlots.add(slot);
            iconList.add(mIcons.get(slot));
        }
    }
    synchronized (mLock) {
        switches[0] = gatherDisableActionsLocked(mCurrentUserId, 1);
        switches[1] = mSystemUiVisibility;
        switches[2] = mMenuVisible ? 1 : 0;
        switches[3] = mImeWindowVis;
        switches[4] = mImeBackDisposition;
        switches[5] = mShowImeSwitcher ? 1 : 0;
        switches[6] = gatherDisableActionsLocked(mCurrentUserId, 2);
        switches[7] = mFullscreenStackSysUiVisibility;
        switches[8] = mDockedStackSysUiVisibility;
        binders.add(mImeToken);
        fullscreenStackBounds.set(mFullscreenStackBounds);
        dockedStackBounds.set(mDockedStackBounds);
    }
}
#method_after
// ================================================================================
// Callbacks from the status bar service.
@Override
public void registerStatusBar(IStatusBar bar, List<String> iconSlots, List<StatusBarIcon> iconList, int[] switches, List<IBinder> binders, Rect fullscreenStackBounds, Rect dockedStackBounds) {
    enforceStatusBarService();
    Slog.i(TAG, "registerStatusBar bar=" + bar);
    mBar = bar;
    mDeathRecipient.linkToDeath();
    notifyBarAttachChanged();
    synchronized (mIcons) {
        for (String slot : mIcons.keySet()) {
            iconSlots.add(slot);
            iconList.add(mIcons.get(slot));
        }
    }
    synchronized (mLock) {
        switches[0] = gatherDisableActionsLocked(mCurrentUserId, 1);
        switches[1] = mSystemUiVisibility;
        switches[2] = mMenuVisible ? 1 : 0;
        switches[3] = mImeWindowVis;
        switches[4] = mImeBackDisposition;
        switches[5] = mShowImeSwitcher ? 1 : 0;
        switches[6] = gatherDisableActionsLocked(mCurrentUserId, 2);
        switches[7] = mFullscreenStackSysUiVisibility;
        switches[8] = mDockedStackSysUiVisibility;
        binders.add(mImeToken);
        fullscreenStackBounds.set(mFullscreenStackBounds);
        dockedStackBounds.set(mDockedStackBounds);
    }
}
#end_block

#method_before
@Override
public MediaLibrarySession onCreateSession(String sessionId) {
    final MockPlayer player = new MockPlayer(1);
    final SyncHandler handler = (SyncHandler) TestServiceRegistry.getInstance().getHandler();
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            handler.post(runnable);
        }
    };
    SessionCallback callback = TestServiceRegistry.getInstance().getSessionCallback();
    MediaLibrarySessionCallback librarySessionCallback;
    if (callback instanceof MediaLibrarySessionCallback) {
        librarySessionCallback = (MediaLibrarySessionCallback) callback;
    } else {
        // Callback hasn't set. Use default callback
        librarySessionCallback = new TestLibrarySessionCallback();
    }
    mSession = new MediaLibrarySession.Builder(MockMediaLibraryService2.this, executor, librarySessionCallback).setPlayer(player).setId(ID).build();
    return mSession;
}
#method_after
@Override
public MediaLibrarySession onCreateSession() {
    final MockPlayer player = new MockPlayer(1);
    final SyncHandler handler = (SyncHandler) TestServiceRegistry.getInstance().getHandler();
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            handler.post(runnable);
        }
    };
    SessionCallback callback = TestServiceRegistry.getInstance().getSessionCallback();
    MediaLibrarySessionCallback librarySessionCallback;
    if (callback instanceof MediaLibrarySessionCallback) {
        librarySessionCallback = (MediaLibrarySessionCallback) callback;
    } else {
        // Callback hasn't set. Use default callback
        librarySessionCallback = new TestLibrarySessionCallback();
    }
    mSession = new MediaLibrarySession.Builder(MockMediaLibraryService2.this, executor, librarySessionCallback).setPlayer(player).setId(ID).build();
    return mSession;
}
#end_block

#method_before
@Override
public MediaSession2 onCreateSession(String sessionId) {
    return new MediaSession2.Builder(MockMediaSessionService2.this).setId(sessionId).setPlayer(new MockPlayerConnector(0)).setSessionCallback(Executors.newSingleThreadExecutor(), new TestSessionCallback()).build();
}
#method_after
@Override
public MediaSession2 onCreateSession() {
    return new MediaSession2.Builder(MockMediaSessionService2.this).setId(ID).setPlayer(new MockPlayerConnector(0)).setSessionCallback(Executors.newSingleThreadExecutor(), new TestSessionCallback()).build();
}
#end_block

#method_before
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    // Note that it's always main-thread.
    if (DEBUG) {
        Log.d(TAG, "onServiceConnected " + name + " " + this);
    }
    // Sanity check
    if (!mToken.getPackageName().equals(name.getPackageName())) {
        Log.wtf(TAG, "Expected connection to " + mToken.getPackageName() + " but " + name + " was connected");
        return;
    }
    connectToSession(IMediaSession2.Stub.asInterface(service));
}
#method_after
@Override
public void onServiceConnected(ComponentName name, IBinder service) {
    // Note that it's always main-thread.
    if (DEBUG) {
        Log.d(TAG, "onServiceConnected " + name + " " + this);
    }
    // Sanity check
    if (!mToken.getPackageName().equals(name.getPackageName())) {
        Log.wtf(TAG, "Expected connection to " + mToken.getPackageName() + " but is" + " connected to " + name);
        return;
    }
    connectToSession(IMediaSession2.Stub.asInterface(service));
}
#end_block

#method_before
@Override
public MediaLibrarySession onCreateSession(String sessionId) {
    final MockPlayerConnector player = new MockPlayerConnector(1);
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            mHandler.post(runnable);
        }
    };
    mSession = new MediaLibrarySession.Builder(MockMediaLibraryService2.this, executor, new TestLibrarySessionCallback()).setPlayer(player).setId(sessionId).build();
    return mSession;
}
#method_after
@Override
public MediaLibrarySession onCreateSession() {
    final MockPlayerConnector player = new MockPlayerConnector(1);
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            mHandler.post(runnable);
        }
    };
    mSession = new MediaLibrarySession.Builder(MockMediaLibraryService2.this, executor, new TestLibrarySessionCallback()).setPlayer(player).build();
    return mSession;
}
#end_block

#method_before
@Override
public MediaSession2 onCreateSession(String sessionId) {
    final MockPlayer player = new MockPlayer(1);
    final SyncHandler handler = (SyncHandler) TestServiceRegistry.getInstance().getHandler();
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            handler.post(runnable);
        }
    };
    SessionCallback sessionCallback = TestServiceRegistry.getInstance().getSessionCallback();
    if (sessionCallback == null) {
        // Ensures non-null
        sessionCallback = new SessionCallback() {
        };
    }
    mSession = new MediaSession2.Builder(this).setPlayer(player).setSessionCallback(executor, sessionCallback).setId(ID).build();
    return mSession;
}
#method_after
@Override
public MediaSession2 onCreateSession() {
    final MockPlayer player = new MockPlayer(1);
    final SyncHandler handler = (SyncHandler) TestServiceRegistry.getInstance().getHandler();
    final Executor executor = new Executor() {

        @Override
        public void execute(Runnable runnable) {
            handler.post(runnable);
        }
    };
    SessionCallback sessionCallback = TestServiceRegistry.getInstance().getSessionCallback();
    if (sessionCallback == null) {
        // Ensures non-null
        sessionCallback = new SessionCallback() {
        };
    }
    mSession = new MediaSession2.Builder(this).setPlayer(player).setSessionCallback(executor, sessionCallback).setId(ID).build();
    return mSession;
}
#end_block

#method_before
@Test
public void testNotification() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            if (Process.myUid() == controller.getUid()) {
                mSession = session;
                mPlayer = (MockPlayer) session.getPlayerConnector();
                assertEquals(mContext.getPackageName(), controller.getPackageName());
                assertFalse(controller.isTrusted());
                latch.countDown();
            }
            return super.onConnect(session, controller);
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    // Create a controller to start the service.
    MediaController2 controller = createController(TestUtils.getServiceToken(mContext, MockMediaSessionService2.ID));
    // Notification should be shown for NOTIFICATION_SHOW_TIME_MS (ms).
    // The notification will not be removed by swiping horizontally, since the service is
    // running as foreground.
    Toast.makeText(mContext, "Notification will be shown", Toast.LENGTH_SHORT).show();
    mPlayer.notifyPlaybackState(MediaPlayerConnector.PLAYER_STATE_PLAYING);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
    // Notification will still be shown. However, one can swipe the notification horizontally
    // to remove the notification, since the service is no longer a foreground service.
    Toast.makeText(mContext, "Notification will be removed", Toast.LENGTH_SHORT).show();
    mPlayer.notifyPlaybackState(MediaPlayerConnector.PLAYER_STATE_ERROR);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
// Notification will be removed since the test framework stops the test process.
}
#method_after
@Test
public void testNotification() throws InterruptedException {
    prepareLooper();
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaLibrarySessionCallback sessionCallback = new MediaLibrarySessionCallback() {

        @Override
        public SessionCommandGroup2 onConnect(@NonNull MediaSession2 session, @NonNull ControllerInfo controller) {
            if (Process.myUid() == controller.getUid()) {
                mSession = session;
                mPlayer = (MockPlayer) session.getPlayerConnector();
                assertEquals(mContext.getPackageName(), controller.getPackageName());
                assertFalse(controller.isTrusted());
                latch.countDown();
            }
            return super.onConnect(session, controller);
        }
    };
    TestServiceRegistry.getInstance().setSessionCallback(sessionCallback);
    // Create a controller to start the service.
    MediaController2 controller = createController(TestUtils.getServiceToken(mContext, MockMediaSessionService2.ID));
    // Notification should be shown for NOTIFICATION_SHOW_TIME_MS (ms).
    // The notification will not be removed by swiping horizontally, since the service is
    // running as foreground.
    showToast("Notification will be shown");
    mPlayer.notifyPlaybackState(MediaPlayerConnector.PLAYER_STATE_PLAYING);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
    // Notification will still be shown. However, one can swipe the notification horizontally
    // to remove the notification, since the service is no longer a foreground service.
    showToast("Notification can be removable shortly");
    mPlayer.notifyPlaybackState(MediaPlayerConnector.PLAYER_STATE_ERROR);
    Thread.sleep(NOTIFICATION_SHOW_TIME_MS);
    // Notification will be removed since the test framework stops the test process.
    showToast("Notification will be removed");
}
#end_block

#method_before
@Override
public void onPreParceling(boolean isStream) {
    super.onPreParceling(isStream);
    // Although mLegacyToken is Parcelable, we should use toBundle() instead here because
    // extra binder and token2 inside of the mLegacyToken are shared only through the
    // toBundle().
    mLegacyTokenBundle = mLegacyToken == null ? null : mLegacyToken.toBundle();
}
#method_after
@Override
public void onPreParceling(boolean isStream) {
    if (mLegacyToken != null) {
        // Note: token should be null or SessionToken2 whose impl equals to this object.
        VersionedParcelable token = mLegacyToken.getSessionToken2();
        // Temporarily sets the SessionToken2 to null to prevent infinite loop when parceling.
        // Otherwise, this will be called again when mLegacyToken parcelize SessionToken2 in it
        // and it never ends.
        mLegacyToken.setSessionToken2(null);
        // Although mLegacyToken is Parcelable, we should use toBundle() instead here because
        // extra binder inside of the mLegacyToken are shared only through the toBundle().
        mLegacyTokenBundle = mLegacyToken.toBundle();
        // Resets the SessionToken2.
        mLegacyToken.setSessionToken2(token);
    } else {
        mLegacyTokenBundle = null;
    }
}
#end_block

#method_before
@Override
public void onPostParceling() {
    super.onPostParceling();
    // Although mLegacyToken is Parcelable, we should use fromBundle() instead here because
    // extra binder and token2 inside of the mLegacyToken are shared only through the
    // fromBundle().
    mLegacyToken = MediaSessionCompat.Token.fromBundle(mLegacyTokenBundle);
}
#method_after
@Override
public void onPostParceling() {
    // Although mLegacyToken is Parcelable, we should use fromBundle() instead here because
    // extra binder inside of the mLegacyToken are shared only through the fromBundle().
    mLegacyToken = MediaSessionCompat.Token.fromBundle(mLegacyTokenBundle);
    mLegacyTokenBundle = null;
}
#end_block

#method_before
@Override
public void onCreate(final MediaSessionService2 service) {
    // TODO: Revisit this.
    MediaSession2 session = service.onCreateSession(null);
    synchronized (mLock) {
        mSession = session;
    }
    session.getCallback().setOnHandleForegroundServiceListener(new MediaSession2.SessionCallback.OnHandleForegroundServiceListener() {

        @Override
        public void onHandleForegroundService(int state) {
            if (state == MediaPlayerConnector.PLAYER_STATE_IDLE || state == MediaPlayerConnector.PLAYER_STATE_ERROR) {
                service.stopForeground(false);
                return;
            }
            // state is PLAYER_STATE_PLAYING or PLAYER_STATE_PAUSE.
            MediaNotification mediaNotification = service.onUpdateNotification();
            if (mediaNotification == null) {
                return;
            }
            int notificationId = mediaNotification.getNotificationId();
            Notification notification = mediaNotification.getNotification();
            NotificationManagerCompat manager = NotificationManagerCompat.from(service);
            manager.notify(notificationId, notification);
            service.startForeground(notificationId, notification);
        }
    });
}
#method_after
@Override
public void onCreate(final MediaSessionService2 service) {
    MediaSession2 session;
    synchronized (mLock) {
        session = mSession;
    }
    if (session == null) {
        session = service.onCreateSession();
        synchronized (mLock) {
            mSession = session;
        }
    }
    session.getCallback().setOnHandleForegroundServiceListener(new MediaSession2.SessionCallback.OnHandleForegroundServiceListener() {

        @Override
        public void onHandleForegroundService(int state) {
            if (state == MediaPlayerConnector.PLAYER_STATE_IDLE || state == MediaPlayerConnector.PLAYER_STATE_ERROR) {
                service.stopForeground(false);
                return;
            }
            // state is PLAYER_STATE_PLAYING or PLAYER_STATE_PAUSE.
            MediaNotification mediaNotification = service.onUpdateNotification();
            if (mediaNotification == null) {
                return;
            }
            int notificationId = mediaNotification.getNotificationId();
            Notification notification = mediaNotification.getNotification();
            NotificationManagerCompat manager = NotificationManagerCompat.from(service);
            manager.notify(notificationId, notification);
            service.startForeground(notificationId, notification);
        }
    });
}
#end_block

#method_before
@Override
public IBinder getLegacyBrowserServiceBinder() {
    if (mBrowserServiceLegacyStub != null) {
        Intent intent = new Intent(MediaBrowserServiceCompat.SERVICE_INTERFACE);
        return mBrowserServiceLegacyStub.onBind(intent);
    }
    return null;
}
#method_after
@Override
public IBinder getLegacyBrowserServiceBinder() {
    Intent intent = new Intent(MediaBrowserServiceCompat.SERVICE_INTERFACE);
    return mBrowserServiceLegacyStub.onBind(intent);
}
#end_block

#method_before
@Test
public void testSaveRestoreStateXml() {
    Context context = InstrumentationRegistry.getTargetContext();
    NavController navController = new NavController(context);
    TestNavigator navigator = new TestNavigator();
    navController.getNavigatorProvider().addNavigator(navigator);
    navController.setGraph(R.navigation.nav_simple);
    navController.navigate(R.id.second_test);
    Bundle savedState = navController.saveState();
    navController = new NavController(context);
    navController.getNavigatorProvider().addNavigator(navigator);
    // Restore state should automatically re-inflate the graph
    // Since the graph has a set id
    navController.restoreState(savedState);
    assertThat(navController.getCurrentDestination().getId(), is(R.id.second_test));
    assertThat(navigator.mBackStack.size(), is(2));
    // Save state should be called on the navigator exactly once
    assertThat(navigator.mSaveStateCount, is(1));
}
#method_after
@Test
public void testSaveRestoreStateXml() {
    Context context = InstrumentationRegistry.getTargetContext();
    NavController navController = new NavController(context);
    SaveStateTestNavigator navigator = new SaveStateTestNavigator();
    navController.getNavigatorProvider().addNavigator(navigator);
    navController.setGraph(R.navigation.nav_simple);
    navController.navigate(R.id.second_test);
    Bundle savedState = navController.saveState();
    navController = new NavController(context);
    navController.getNavigatorProvider().addNavigator(navigator);
    // Restore state should automatically re-inflate the graph
    // Since the graph has a set id
    navController.restoreState(savedState);
    assertThat(navController.getCurrentDestination().getId(), is(R.id.second_test));
    assertThat(navigator.mBackStack.size(), is(2));
    // Save state should be called on the navigator exactly once
    assertThat(navigator.mSaveStateCount, is(1));
}
#end_block

#method_before
@Override
public RemoteCallback toRemoteCallback() {
    if (!(this instanceof CallbackHandlerRegistry.RemoteCallStub)) {
        throw new IllegalStateException("toRemoteCallback() can only be called in a createRemoteCallback() chain.");
    }
    Intent intent = new Intent(ACTION_BROADCAST_CALLBACK);
    // Superclass because this is being executed in the generated stub.
    String clsName = getClass().getSuperclass().getName();
    intent.setComponent(new ComponentName(mContext.getPackageName(), clsName));
    Bundle args = CallbackHandlerRegistry.sInstance.getArgs((CallbackHandlerRegistry.RemoteCallStub) this);
    intent.putExtras(args);
    return new RemoteCallback(mContext, TYPE_RECEIVER, intent, clsName, args);
}
#method_after
@Override
public RemoteCallback toRemoteCallback(Class<T> cls, Bundle args, String method) {
    Intent intent = new Intent(ACTION_BROADCAST_CALLBACK);
    intent.setComponent(new ComponentName(mContext.getPackageName(), cls.getName()));
    args.putString(EXTRA_METHOD, method);
    intent.putExtras(args);
    return new RemoteCallback(mContext, TYPE_RECEIVER, intent, cls.getName(), args);
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setValue(Context context, int[] ids, int value) {
    Log.d("RemoteCallbackProvider", "setValue " + value);
    AppWidgetManager appWidgetManager = (AppWidgetManager) context.getSystemService(Context.APPWIDGET_SERVICE);
    appWidgetManager.updateAppWidget(ids, createRemoteViews(context, ids, value));
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setValue(Context context, int[] ids, int value) {
    Log.d("RemoteCallbackProvider", "setValue " + value);
    AppWidgetManager appWidgetManager = (AppWidgetManager) context.getSystemService(Context.APPWIDGET_SERVICE);
    appWidgetManager.updateAppWidget(ids, createRemoteViews(context, ids, value));
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setByte(byte i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setByte(byte i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setByteN(Byte i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setByteN(Byte i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setChar(char i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setChar(char i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setCharacter(Character i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setCharacter(Character i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setShort(short i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setShort(short i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setShortN(Short i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setShortN(Short i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setInt(int i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setInt(int i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setInteger(Integer i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setInteger(Integer i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setLong(long i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setLong(long i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setLongN(Long i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setLongN(Long i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setFloat(float i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setFloat(float i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setFloatN(Float i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setFloatN(Float i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setDouble(double i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setDouble(double i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setDoubleN(Double i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setDoubleN(Double i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setBoolean(boolean i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setBoolean(boolean i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setBooleanN(Boolean i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setBooleanN(Boolean i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setString(String i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setString(String i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setUri(Uri i) {
    sParam = i;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setUri(Uri i) {
    sParam = i;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setContext(Context context, int id) {
    Log.d("TestTest", "setContext " + context + " " + getClass(), new Throwable());
    sParam = context;
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setContext(Context context, int id) {
    Log.d("TestTest", "setContext " + context + " " + getClass(), new Throwable());
    sParam = context;
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
public PendingIntent toPendingIntent() {
    mIntent.setData(generateUri(mIntent));
    PendingIntent intent = PendingIntent.getBroadcast(mContext, 0, mIntent, 0);
    return intent;
}
#method_after
public PendingIntent toPendingIntent() {
    mIntent.setData(generateUri(mIntent));
    mIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    PendingIntent intent = PendingIntent.getBroadcast(mContext, 0, mIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    return intent;
}
#end_block

#method_before
@Override
public RemoteCallback toRemoteCallback() {
    if (!(this instanceof CallbackHandlerRegistry.RemoteCallStub)) {
        throw new IllegalStateException("toRemoteCallback() can only be called in a createRemoteCallback() chain.");
    }
    if (mAuthority == null) {
        throw new IllegalStateException("ContentProvider must be attached before creating callbacks");
    }
    Intent intent = new Intent(ACTION_PROVIDER_RELAY);
    intent.setComponent(new ComponentName(mContext.getPackageName(), ProviderRelayReceiver.class.getName()));
    Bundle args = CallbackHandlerRegistry.sInstance.getArgs((CallbackHandlerRegistry.RemoteCallStub) this);
    args.putString(ProviderRelayReceiver.EXTRA_AUTHORITY, mAuthority);
    intent.putExtras(args);
    return new RemoteCallback(mContext, RemoteCallback.TYPE_PROVIDER, intent, getClass().getSuperclass().getName(), args);
}
#method_after
@Override
public RemoteCallback toRemoteCallback(Class<T> cls, Bundle args, String method) {
    if (mAuthority == null) {
        throw new IllegalStateException("ContentProvider must be attached before creating callbacks");
    }
    Intent intent = new Intent(ACTION_PROVIDER_RELAY);
    intent.setComponent(new ComponentName(mContext.getPackageName(), ProviderRelayReceiver.class.getName()));
    args.putString(EXTRA_METHOD, method);
    args.putString(ProviderRelayReceiver.EXTRA_AUTHORITY, mAuthority);
    intent.putExtras(args);
    return new RemoteCallback(mContext, TYPE_PROVIDER, intent, cls.getName(), args);
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setByte(byte[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setByte(byte[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setChar(char[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setChar(char[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setShort(short[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setShort(short[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setInt(int[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setInt(int[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setLong(long[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setLong(long[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setFloat(float[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setFloat(float[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setDouble(double[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setDouble(double[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setBoolean(boolean[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setBoolean(boolean[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setString(String[] i) {
    sParam = i;
    return NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setString(String[] i) {
    sParam = i;
    return LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setMethod(@ExternalInput(EXTRA_ARG) int arg1, int arg2) {
    sArg1 = arg1;
    sArg2 = arg2;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setMethod(@ExternalInput(EXTRA_ARG) int arg1, int arg2) {
    sArg1 = arg1;
    sArg2 = arg2;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback setMethodString(@ExternalInput("extra_arg") int arg1, int arg2) {
    sArg1 = arg1;
    sArg2 = arg2;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback setMethodString(@ExternalInput("extra_arg") int arg1, int arg2) {
    sArg1 = arg1;
    sArg2 = arg2;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback myCallbackMethod(Uri myUri, String myStr, int myInt, Integer myNullableInt) {
    Log.d("BasicProviderTest", "myCallbackMethod " + myUri + " " + myStr + " " + myInt + " " + myNullableInt, new Throwable());
    sUri = myUri;
    sStr = myStr;
    sInt = myInt;
    sNullableInt = myNullableInt;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback myCallbackMethod(Uri myUri, String myStr, int myInt, Integer myNullableInt) {
    Log.d("BasicProviderTest", "myCallbackMethod " + myUri + " " + myStr + " " + myInt + " " + myNullableInt, new Throwable());
    sUri = myUri;
    sStr = myStr;
    sInt = myInt;
    sNullableInt = myNullableInt;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
@Override
public RemoteCallback toRemoteCallback() {
    if (!(this instanceof CallbackHandlerRegistry.RemoteCallStub)) {
        throw new IllegalStateException("toRemoteCallback() can only be called in a createRemoteCallback() chain.");
    }
    Intent intent = new Intent(ACTION_BROADCAST_CALLBACK);
    // Superclass because this is being executed in the generated stub.
    String clsName = getClass().getSuperclass().getName();
    intent.setComponent(new ComponentName(mContext.getPackageName(), clsName));
    Bundle args = CallbackHandlerRegistry.sInstance.getArgs((CallbackHandlerRegistry.RemoteCallStub) this);
    intent.putExtras(args);
    return new RemoteCallback(mContext, TYPE_RECEIVER, intent, clsName, args);
}
#method_after
@Override
public RemoteCallback toRemoteCallback(Class<T> cls, Bundle args, String method) {
    Intent intent = new Intent(ACTION_BROADCAST_CALLBACK);
    intent.setComponent(new ComponentName(mContext.getPackageName(), cls.getName()));
    args.putString(EXTRA_METHOD, method);
    intent.putExtras(args);
    return new RemoteCallback(mContext, TYPE_RECEIVER, intent, cls.getName(), args);
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback myCallbackMethod(Uri myUri, String myStr, int myInt, Integer myNullableInt) {
    Log.d("BasicReceiverTest", "myCallbackMethod " + myUri + " " + myStr + " " + myInt + " " + myNullableInt, new Throwable());
    sUri = myUri;
    sStr = myStr;
    sInt = myInt;
    sNullableInt = myNullableInt;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback myCallbackMethod(Uri myUri, String myStr, int myInt, Integer myNullableInt) {
    Log.d("BasicReceiverTest", "myCallbackMethod " + myUri + " " + myStr + " " + myInt + " " + myNullableInt, new Throwable());
    sUri = myUri;
    sStr = myStr;
    sInt = myInt;
    sNullableInt = myNullableInt;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
public void addMethods(TypeSpec.Builder genClass, MethodSpec.Builder runBuilder, ProcessingEnvironment env, Messager messager) {
    // Validate types
    for (int i = 0; i < mTypes.size(); i++) {
        if (checkType(mTypes.get(i).toString(), messager)) {
            messager.printMessage(Diagnostic.Kind.ERROR, "Invalid type " + mTypes.get(i));
            return;
        }
    }
    if (!"androidx.remotecallback.RemoteCallback".equals(mReturnType.toString())) {
        messager.printMessage(Diagnostic.Kind.ERROR, "RemoteCallable methods must return RemoteCallback.NONE.");
        return;
    }
    ClassName callbackHandlerRegistry = ClassName.get("androidx.remotecallback", "CallbackHandlerRegistry");
    ClassName callbackHandler = ClassName.get("androidx.remotecallback", "CallbackHandlerRegistry.CallbackHandler");
    ClassName remoteInputHolder = ClassName.get("androidx.remotecallback", "RemoteInputHolder");
    ClassName bundle = ClassName.get("android.os", "Bundle");
    ClassName context = ClassName.get("android.content", "Context");
    CodeBlock.Builder code = CodeBlock.builder();
    String methodName = mElement.getSimpleName().toString();
    code.add("$L.registerCallbackHandler($L.class, $S, ", callbackHandlerRegistry, mClsName, methodName);
    code.beginControlFlow("new $L<$L>()", callbackHandler, mClsName);
    // Begin executeCallback implementation ------------------------------------------------
    code.beginControlFlow("  public void executeCallback($L context, $L receiver, $L args)", context, mClsName, bundle);
    StringBuilder methodCall = new StringBuilder();
    methodCall.append("receiver.");
    methodCall.append(mElement.getSimpleName());
    methodCall.append("(");
    for (int i = 0; i < mNames.size(); i++) {
        // Pass the parameter to the method call.
        if (i != 0) {
            methodCall.append(", ");
        }
        methodCall.append("p" + i);
        if (mTypes.get(i).toString().equals(context.toString())) {
            code.addStatement("$L p" + i + " = context", mTypes.get(i));
            continue;
        }
        code.addStatement("$L p" + i, mTypes.get(i));
        String key = mExtInputKeys.get(i) != null ? mExtInputKeys.get(i) : getBundleKey(i);
        // Generate code to extract the value.
        code.addStatement("p$L = $L", i, getBundleParam(mTypes.get(i).toString(), key));
    }
    methodCall.append(")");
    // Add the method call as the last thing.
    code.addStatement(methodCall.toString());
    code.endControlFlow();
    // End executeCallback implementation --------------------------------------------------
    code.endControlFlow();
    code.add(");\n");
    runBuilder.addCode(code.build());
    // Start assembleArguments implementation ----------------------------------------------
    code = CodeBlock.builder();
    ClassName remoteCallback = ClassName.get("androidx.remotecallback", "RemoteCallback");
    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName).returns(remoteCallback).addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("Override")).build()).addModifiers(Modifier.PUBLIC);
    code.beginControlFlow("if (mMethodCalled != null)");
    code.addStatement("throw new IllegalStateException($S)", "Only one remotable method can be called per callback");
    code.endControlFlow();
    code.addStatement("mMethodCalled = $S", methodName);
    code.addStatement("$L b = mMethodArgs", bundle);
    for (int i = 0; i < mNames.size(); i++) {
        builder.addParameter(TypeName.get(mTypes.get(i)), "p" + i);
        if (mTypes.get(i).toString().equals(context.toString())) {
            continue;
        }
        boolean isNative = isNative(mTypes.get(i).toString());
        // Only fill in value if the argument has a value.
        if (!isNative)
            code.beginControlFlow("if (p$L != null)", i);
        // Otherwise just need to place the arg value.
        code.addStatement("b.put$L($L, ($L) p$L)", getTypeMethod(mTypes.get(i).toString()), getBundleKey(i), mTypes.get(i), i);
        // No value present, need an explicit null for security.
        if (!isNative)
            code.nextControlFlow("else");
        if (!isNative)
            code.addStatement("b.putString($L, null)", getBundleKey(i));
        if (!isNative)
            code.endControlFlow();
    }
    code.addStatement("return androidx.remotecallback.CallbackHandlerRegistry.toRemoteCallback(this)");
    builder.addCode(code.build());
    genClass.addMethod(builder.build());
}
#method_after
public void addMethods(TypeSpec.Builder genClass, MethodSpec.Builder runBuilder, ProcessingEnvironment env, Messager messager) {
    // Validate types
    for (int i = 0; i < mTypes.size(); i++) {
        if (checkType(mTypes.get(i).toString(), messager)) {
            messager.printMessage(Diagnostic.Kind.ERROR, "Invalid type " + mTypes.get(i));
            return;
        }
    }
    if (!"androidx.remotecallback.RemoteCallback".equals(mReturnType.toString())) {
        messager.printMessage(Diagnostic.Kind.ERROR, "RemoteCallable methods must return RemoteCallback.LOCAL.");
        return;
    }
    ClassName callbackHandlerRegistry = ClassName.get("androidx.remotecallback", "CallbackHandlerRegistry");
    ClassName callbackHandler = ClassName.get("androidx.remotecallback", "CallbackHandlerRegistry.CallbackHandler");
    ClassName remoteInputHolder = ClassName.get("androidx.remotecallback", "RemoteInputHolder");
    ClassName bundle = ClassName.get("android.os", "Bundle");
    ClassName context = ClassName.get("android.content", "Context");
    CodeBlock.Builder code = CodeBlock.builder();
    String methodName = mElement.getSimpleName().toString();
    code.add("$L.registerCallbackHandler($L.class, $S, ", callbackHandlerRegistry, mClsName, methodName);
    code.beginControlFlow("new $L<$L>()", callbackHandler, mClsName);
    // Begin executeCallback implementation ------------------------------------------------
    code.beginControlFlow("  public void executeCallback($L context, $L receiver, $L args)", context, mClsName, bundle);
    StringBuilder methodCall = new StringBuilder();
    methodCall.append("receiver.");
    methodCall.append(mElement.getSimpleName());
    methodCall.append("(");
    for (int i = 0; i < mNames.size(); i++) {
        // Pass the parameter to the method call.
        if (i != 0) {
            methodCall.append(", ");
        }
        methodCall.append("p" + i);
        if (mTypes.get(i).toString().equals(context.toString())) {
            code.addStatement("$L p" + i + " = context", mTypes.get(i));
            continue;
        }
        code.addStatement("$L p" + i, mTypes.get(i));
        String key = mExtInputKeys.get(i) != null ? mExtInputKeys.get(i) : getBundleKey(i);
        // Generate code to extract the value.
        code.addStatement("p$L = $L", i, getBundleParam(mTypes.get(i).toString(), key));
    }
    methodCall.append(")");
    // Add the method call as the last thing.
    code.addStatement(methodCall.toString());
    code.endControlFlow();
    // End executeCallback implementation --------------------------------------------------
    code.endControlFlow();
    code.add(");\n");
    runBuilder.addCode(code.build());
    // Start assembleArguments implementation ----------------------------------------------
    code = CodeBlock.builder();
    ClassName remoteCallback = ClassName.get("androidx.remotecallback", "RemoteCallback");
    MethodSpec.Builder builder = MethodSpec.methodBuilder(methodName).returns(remoteCallback).addAnnotation(AnnotationSpec.builder(ClassName.bestGuess("Override")).build()).addModifiers(Modifier.PUBLIC);
    code.addStatement("$L b = new $L()", bundle, bundle);
    for (int i = 0; i < mNames.size(); i++) {
        builder.addParameter(TypeName.get(mTypes.get(i)), "p" + i);
        if (mTypes.get(i).toString().equals(context.toString())) {
            continue;
        }
        boolean isNative = isNative(mTypes.get(i).toString());
        // Only fill in value if the argument has a value.
        if (!isNative)
            code.beginControlFlow("if (p$L != null)", i);
        // Otherwise just need to place the arg value.
        code.addStatement("b.put$L($L, ($L) p$L)", getTypeMethod(mTypes.get(i).toString()), getBundleKey(i), mTypes.get(i), i);
        // No value present, need an explicit null for security.
        if (!isNative)
            code.nextControlFlow("else");
        if (!isNative)
            code.addStatement("b.putString($L, null)", getBundleKey(i));
        if (!isNative)
            code.endControlFlow();
    }
    code.addStatement("return androidx.remotecallback.CallbackHandlerRegistry.stubToRemoteCallback(" + "this, $L.class, b, $S)", mClsName, mElement.getSimpleName());
    builder.addCode(code.build());
    genClass.addMethod(builder.build());
}
#end_block

#method_before
public void finish(ProcessingEnvironment env, Messager messager) {
    if (mMethods.size() == 0) {
        messager.printMessage(Diagnostic.Kind.ERROR, "No methods found for " + mClsName);
        return;
    }
    ClassName bundle = ClassName.get("android.os", "Bundle");
    ClassName string = ClassName.get("java.lang", "String");
    FieldSpec currentMethodField = FieldSpec.builder(string, "mMethodCalled", Modifier.PRIVATE).build();
    FieldSpec bundleField = FieldSpec.builder(bundle, "mMethodArgs", Modifier.PRIVATE).build();
    TypeSpec.Builder genClass = TypeSpec.classBuilder(findInitClass(mElement)).superclass(TypeName.get(mElement.asType())).addSuperinterface(ClassName.get("androidx.remotecallback.CallbackHandlerRegistry", "RemoteCallStub")).addField(currentMethodField).addField(bundleField).addModifiers(Modifier.PUBLIC);
    genClass.addMethod(MethodSpec.methodBuilder(RESET).addModifiers(Modifier.PUBLIC).addStatement("mMethodCalled = null").addStatement("mMethodArgs = new $L()", bundle).build());
    genClass.addMethod(MethodSpec.methodBuilder(GET_METHOD).addModifiers(Modifier.PUBLIC).returns(string).addStatement("return mMethodCalled").build());
    genClass.addMethod(MethodSpec.methodBuilder(GET_ARGUMENTS).addModifiers(Modifier.PUBLIC).returns(bundle).addStatement("return mMethodArgs").build());
    MethodSpec.Builder runBuilder = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);
    for (CallableMethod method : mMethods) {
        method.addMethods(genClass, runBuilder, env, messager);
    }
    genClass.addMethod(runBuilder.build());
    try {
        TypeSpec typeSpec = genClass.build();
        String pkg = getPkg(mElement);
        JavaFile.builder(pkg, typeSpec).build().writeTo(mEnv.getFiler());
    } catch (IOException e) {
        messager.printMessage(Diagnostic.Kind.ERROR, "Exception writing " + e);
    }
}
#method_after
public void finish(ProcessingEnvironment env, Messager messager) {
    if (mMethods.size() == 0) {
        messager.printMessage(Diagnostic.Kind.ERROR, "No methods found for " + mClsName);
        return;
    }
    TypeSpec.Builder genClass = TypeSpec.classBuilder(findInitClass(mElement)).superclass(TypeName.get(mElement.asType())).addModifiers(Modifier.PUBLIC);
    MethodSpec.Builder runBuilder = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);
    for (CallableMethod method : mMethods) {
        method.addMethods(genClass, runBuilder, env, messager);
    }
    genClass.addMethod(runBuilder.build());
    try {
        TypeSpec typeSpec = genClass.build();
        String pkg = getPkg(mElement);
        JavaFile.builder(pkg, typeSpec).build().writeTo(mEnv.getFiler());
    } catch (IOException e) {
        messager.printMessage(Diagnostic.Kind.ERROR, "Exception writing " + e);
    }
}
#end_block

#method_before
@RemoteCallable
public RemoteCallback myCallbackMethod(Uri myUri, String myStr, int myInt, Integer myNullableInt) {
    Log.d("BasicWidgetProviderTest", "myCallbackMethod " + myUri + " " + myStr + " " + myInt + " " + myNullableInt, new Throwable());
    sUri = myUri;
    sStr = myStr;
    sInt = myInt;
    sNullableInt = myNullableInt;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.NONE;
}
#method_after
@RemoteCallable
public RemoteCallback myCallbackMethod(Uri myUri, String myStr, int myInt, Integer myNullableInt) {
    Log.d("BasicWidgetProviderTest", "myCallbackMethod " + myUri + " " + myStr + " " + myInt + " " + myNullableInt, new Throwable());
    sUri = myUri;
    sStr = myStr;
    sInt = myInt;
    sNullableInt = myNullableInt;
    if (sLatch != null)
        sLatch.countDown();
    return RemoteCallback.LOCAL;
}
#end_block

#method_before
<T extends CallbackReceiver> T getAndResetStub(Class<? extends CallbackReceiver> cls, Context context, String authority) {
    RemoteCallStub stub = findStub(cls);
    stub.reset();
    initStub(stub, context, authority);
    return (T) stub;
}
#method_after
@SuppressWarnings("TypeParameterUnusedInFormals")
<T extends CallbackReceiver> T getAndResetStub(Class<? extends CallbackReceiver> cls, Context context, String authority) {
    ClsHandler stub = findMap(cls);
    initStub(stub.mCallStub, cls, context, authority);
    return (T) stub.mCallStub;
}
#end_block

#method_before
private void initStub(RemoteCallStub stub, Context context, String authority) {
    if (stub instanceof AppWidgetProviderWithCallbacks) {
        ((AppWidgetProviderWithCallbacks) stub).mContext = context;
    } else if (stub instanceof BroadcastReceiverWithCallbacks) {
        ((BroadcastReceiverWithCallbacks) stub).mContext = context;
    } else if (stub instanceof ContentProviderWithCallbacks) {
        ContentProviderWithCallbacks contentProvider = (ContentProviderWithCallbacks) stub;
        contentProvider.mContext = context;
        if (contentProvider.mAuthority == null) {
            contentProvider.mAuthority = determineAuthority(context, authority, stub.getClass());
        }
    }
}
#method_after
private void initStub(CallbackReceiver stub, Class<? extends CallbackReceiver> cls, Context context, String authority) {
    if (stub instanceof AppWidgetProviderWithCallbacks) {
        ((AppWidgetProviderWithCallbacks) stub).mContext = context;
    } else if (stub instanceof BroadcastReceiverWithCallbacks) {
        ((BroadcastReceiverWithCallbacks) stub).mContext = context;
    } else if (stub instanceof ContentProviderWithCallbacks) {
        ContentProviderWithCallbacks contentProvider = (ContentProviderWithCallbacks) stub;
        contentProvider.mContext = context;
        if (contentProvider.mAuthority == null) {
            contentProvider.mAuthority = determineAuthority(context, authority, cls);
        }
    }
}
#end_block

#method_before
private String determineAuthority(Context context, String authority, Class<?> aClass) {
    if (authority != null) {
        return authority;
    }
    try {
        ProviderInfo info = context.getPackageManager().getProviderInfo(new ComponentName(context.getPackageName(), aClass.getSuperclass().getName()), 0);
        return info.authority;
    } catch (PackageManager.NameNotFoundException e) {
        Log.w(TAG, "Couldn't find provider " + aClass.getSuperclass(), e);
        return null;
    }
}
#method_after
private String determineAuthority(Context context, String authority, Class<?> aClass) {
    if (authority != null) {
        return authority;
    }
    try {
        ProviderInfo info = context.getPackageManager().getProviderInfo(new ComponentName(context.getPackageName(), aClass.getName()), 0);
        return info.authority;
    } catch (PackageManager.NameNotFoundException e) {
        Log.w(TAG, "Couldn't find provider " + aClass, e);
        return null;
    }
}
#end_block

#method_before
<T extends CallbackReceiver> void ensureInitialized(Class<T> cls) {
    if (!mClsLookup.containsKey(cls)) {
        runInit(cls);
    }
}
#method_after
<T extends CallbackReceiver> void ensureInitialized(Class<T> cls) {
    synchronized (this) {
        if (!mClsLookup.containsKey(cls)) {
            runInit(cls);
        }
    }
}
#end_block

#method_before
public <T extends CallbackReceiver> void invokeCallback(Context context, T receiver, Bundle bundle) {
    ArrayMap<String, CallbackHandler<? extends CallbackReceiver>> map = findMap(receiver.getClass());
    if (map == null) {
        Log.e(TAG, "No map found for " + receiver.getClass().getName());
        return;
    }
    String method = bundle.getString(EXTRA_METHOD);
    @SuppressWarnings("unchecked")
    CallbackHandler<T> callbackHandler = (CallbackHandler<T>) map.get(method);
    if (callbackHandler == null) {
        Log.e(TAG, "No handler found for " + method + " on " + receiver.getClass().getName());
        return;
    }
    callbackHandler.executeCallback(context, receiver, bundle);
}
#method_after
public <T extends CallbackReceiver> void invokeCallback(Context context, T receiver, Bundle bundle) {
    ClsHandler map = findMap(receiver.getClass());
    if (map == null) {
        Log.e(TAG, "No map found for " + receiver.getClass().getName());
        return;
    }
    String method = bundle.getString(EXTRA_METHOD);
    @SuppressWarnings("unchecked")
    CallbackHandler<T> callbackHandler = (CallbackHandler<T>) map.mHandlers.get(method);
    if (callbackHandler == null) {
        Log.e(TAG, "No handler found for " + method + " on " + receiver.getClass().getName());
        return;
    }
    callbackHandler.executeCallback(context, receiver, bundle);
}
#end_block

#method_before
private ArrayMap<String, CallbackHandler<? extends CallbackReceiver>> findMap(Class<?> aClass) {
    ClsHandler map = mClsLookup.get(aClass);
    if (map != null) {
        return map.mHandlers;
    }
    if (aClass.getSuperclass() != null) {
        return findMap(aClass.getSuperclass());
    }
    return null;
}
#method_after
private ClsHandler findMap(Class<?> aClass) {
    ClsHandler map;
    synchronized (this) {
        map = mClsLookup.get(aClass);
    }
    if (map != null) {
        return map;
    }
    if (aClass.getSuperclass() != null) {
        return findMap(aClass.getSuperclass());
    }
    return null;
}
#end_block

#method_before
private <T extends CallbackReceiver> void runInit(Class<T> cls) {
    try {
        // This is the only bit of reflection/keeping that needs to exist, one init class
        // per callback receiver.
        ClsHandler clsHandler = new ClsHandler();
        mClsLookup.put(cls, clsHandler);
        clsHandler.mCallStub = (RemoteCallStub) findInitClass(cls).getDeclaredConstructor().newInstance();
    } catch (InstantiationException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (IllegalAccessException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (InvocationTargetException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (NoSuchMethodException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (ClassNotFoundException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    }
}
#method_after
private <T extends CallbackReceiver> void runInit(Class<T> cls) {
    try {
        // This is the only bit of reflection/keeping that needs to exist, one init class
        // per callback receiver.
        ClsHandler clsHandler = new ClsHandler();
        mClsLookup.put(cls, clsHandler);
        clsHandler.mCallStub = (CallbackReceiver) findInitClass(cls).getDeclaredConstructor().newInstance();
    } catch (InstantiationException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (IllegalAccessException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (InvocationTargetException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (NoSuchMethodException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    } catch (ClassNotFoundException e) {
        Log.e(TAG, "Unable to initialize " + cls.getName(), e);
    }
}
#end_block

#method_before
@MainThread
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void dequeueAndCheckForCompletion() {
    Logger.debug(TAG, "Checking if commands are complete.");
    assertMainThread();
    synchronized (mIntents) {
        // an intent. Synchronized to prevent ConcurrentModificationExceptions.
        if (mCurrentIntent != null) {
            Logger.debug(TAG, String.format("Removing command %s", mCurrentIntent));
            mIntents.remove(mCurrentIntent);
            mCurrentIntent = null;
        }
        // has no more pending commands, stop the service.
        if (!mCommandHandler.hasPendingCommands() && mIntents.isEmpty()) {
            Logger.debug(TAG, "No more commands & intents.");
            if (mCompletedListener != null) {
                mCompletedListener.onAllCommandsCompleted();
            }
        } else {
            // process the next command
            processCommand();
        }
    }
}
#method_after
@MainThread
@SuppressWarnings("WeakerAccess")
/* synthetic access */
void dequeueAndCheckForCompletion() {
    Logger.debug(TAG, "Checking if commands are complete.");
    assertMainThread();
    synchronized (mIntents) {
        // an intent. Synchronized to prevent ConcurrentModificationExceptions.
        if (mCurrentIntent != null) {
            Logger.debug(TAG, String.format("Removing command %s", mCurrentIntent));
            if (!mIntents.remove(0).equals(mCurrentIntent)) {
                throw new IllegalStateException("Dequeue-d command is not the first.");
            }
            mCurrentIntent = null;
        }
        // has no more pending commands, stop the service.
        if (!mCommandHandler.hasPendingCommands() && mIntents.isEmpty()) {
            Logger.debug(TAG, "No more commands & intents.");
            if (mCompletedListener != null) {
                mCompletedListener.onAllCommandsCompleted();
            }
        } else {
            // process the next command
            processCommand();
        }
    }
}
#end_block

#method_before
@Test
public void smoothScroll_destinationDeletedDuring_newDestinationReached() throws Throwable {
    /**
     * This test starts a smooth scroll with a target that is towards the end of the
     * RecyclerView and while it's scrolling, removes items from the end.  It then verifies
     * that the RV has found a new target to scroll to, and that it scrolls to that target.
     *
     * This test may flake if the frame rate of the device is so low that by the time the items
     * are removed, the RV is done scrolling.  If this seems to happen, change the values in the
     * top of the Arrange section to give the test more space to pass.
     */
    // Arrange
    int heightOfParent = getActivity().getContainer().getHeight();
    final int itemCount = 500;
    final int firstTargetPosition = 450;
    final int secondTargetPosition = 400;
    // About 25 items on screen.
    final int itemHeight = heightOfParent / 25;
    // Remove items when we've scrolled beyond 2 full screens worth of items.
    final int removeItemsWhenScrolledBeyond = heightOfParent * 2;
    final RecyclerView rv = new RecyclerView(getActivity());
    final TestAdapter testAdapter = new TestAdapter(itemCount, new RecyclerView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, itemHeight));
    rv.setAdapter(testAdapter);
    final CountDownLatch calledOnStart = new CountDownLatch(1);
    final CountDownLatch calledOnStop = new CountDownLatch(1);
    final AtomicInteger atomicInteger = new AtomicInteger(firstTargetPosition);
    rv.setLayoutManager(new LinearLayoutManager(getActivity()) {

        @Override
        public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) {
            LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()) {

                @Override
                protected void onStart() {
                    super.onStart();
                    calledOnStart.countDown();
                }

                @Override
                protected void onStop() {
                    super.onStop();
                    calledOnStop.countDown();
                }

                @Override
                protected void onChildAttachedToWindow(View child) {
                    super.onChildAttachedToWindow(child);
                    atomicInteger.set(getTargetPosition());
                }
            };
            linearSmoothScroller.setTargetPosition(position);
            startSmoothScroll(linearSmoothScroller);
        }
    });
    rv.addOnScrollListener(new RecyclerView.OnScrollListener() {

        int mTotalDy = 0;

        boolean mItemsRemoved = false;

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            mTotalDy += dy;
            if (mTotalDy >= removeItemsWhenScrolledBeyond && !mItemsRemoved) {
                int position = secondTargetPosition + 1;
                int removalCount = itemCount - position;
                for (int i = 0; i < removalCount; i++) {
                    testAdapter.mItems.remove(position);
                }
                testAdapter.notifyItemRangeRemoved(position, removalCount);
                mItemsRemoved = true;
            }
        }
    });
    TestedFrameLayout testedFrameLayout = getActivity().getContainer();
    testedFrameLayout.expectLayouts(1);
    setRecyclerView(rv);
    testedFrameLayout.waitForLayout(2);
    // Act
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            rv.smoothScrollToPosition(firstTargetPosition);
        }
    });
    // testAdapter.deleteAndNotify(secondTargetPosition + 1,
    // testAdapter.getItemCount() - secondTargetPosition - 1);
    // Assert
    assertTrue("onStart should be called quickly ", calledOnStart.await(2, TimeUnit.SECONDS));
    assertTrue("onStop should be called eventually", calledOnStop.await(30, TimeUnit.SECONDS));
    assertNotNull("smoothScrollToPosition should succeed", rv.findViewHolderForLayoutPosition(secondTargetPosition));
    assertEquals(secondTargetPosition, atomicInteger.get());
    checkForMainThreadException();
}
#method_after
@Test
public void smoothScroll_destinationDeletedDuring_newDestinationReached() throws Throwable {
    /**
     * This test starts a smooth scroll with a target that is towards the end of the
     * RecyclerView and while it's scrolling, removes items from the end.  It then verifies
     * that the RV has found a new target to scroll to, and that it scrolls to that target.
     *
     * This test may flake if the frame rate of the device is so low that by the time the items
     * are removed, the RV is done scrolling.  If this seems to happen, change the values in the
     * top of the Arrange section to give the test more space to pass.
     */
    // Arrange
    int heightOfParent = getActivity().getContainer().getHeight();
    final int itemCount = 500;
    final int firstTargetPosition = 450;
    final int secondTargetPosition = 400;
    // About 25 items on screen.
    final int itemHeight = heightOfParent / 25;
    // Remove items when we've scrolled beyond 2 full screens worth of items.
    final int removeItemsWhenScrolledBeyond = heightOfParent * 2;
    final RecyclerView rv = new RecyclerView(getActivity());
    final TestAdapter testAdapter = new TestAdapter(itemCount, new RecyclerView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, itemHeight));
    rv.setAdapter(testAdapter);
    final CountDownLatch calledOnStart = new CountDownLatch(1);
    final CountDownLatch calledOnStop = new CountDownLatch(1);
    final AtomicInteger atomicInteger = new AtomicInteger(firstTargetPosition);
    rv.setLayoutManager(new LinearLayoutManager(getActivity()) {

        @Override
        public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state, int position) {
            LinearSmoothScroller linearSmoothScroller = new LinearSmoothScroller(recyclerView.getContext()) {

                @Override
                protected void onStart() {
                    super.onStart();
                    calledOnStart.countDown();
                }

                @Override
                protected void onStop() {
                    super.onStop();
                    calledOnStop.countDown();
                }

                @Override
                protected void onChildAttachedToWindow(View child) {
                    super.onChildAttachedToWindow(child);
                    atomicInteger.set(getTargetPosition());
                }
            };
            linearSmoothScroller.setTargetPosition(position);
            startSmoothScroll(linearSmoothScroller);
        }
    });
    rv.addOnScrollListener(new RecyclerView.OnScrollListener() {

        int mTotalDy = 0;

        boolean mItemsRemoved = false;

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            mTotalDy += dy;
            if (mTotalDy >= removeItemsWhenScrolledBeyond && !mItemsRemoved) {
                int position = secondTargetPosition + 1;
                int removalCount = itemCount - position;
                for (int i = 0; i < removalCount; i++) {
                    testAdapter.mItems.remove(position);
                }
                testAdapter.notifyItemRangeRemoved(position, removalCount);
                mItemsRemoved = true;
            }
        }
    });
    TestedFrameLayout testedFrameLayout = getActivity().getContainer();
    testedFrameLayout.expectLayouts(1);
    setRecyclerView(rv);
    testedFrameLayout.waitForLayout(2);
    // Act
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            rv.smoothScrollToPosition(firstTargetPosition);
        }
    });
    // Assert
    assertTrue("onStart should be called quickly ", calledOnStart.await(2, TimeUnit.SECONDS));
    assertTrue("onStop should be called eventually", calledOnStop.await(30, TimeUnit.SECONDS));
    assertNotNull("smoothScrollToPosition should succeed", rv.findViewHolderForLayoutPosition(secondTargetPosition));
    assertEquals(secondTargetPosition, atomicInteger.get());
    checkForMainThreadException();
}
#end_block

#method_before
@Test
public void smoothScrollToPosition_calledOnPreviousFinished_scrollsToPosition() throws Throwable {
    final int adapterSize = 3;
    final int firstTargetPosition = 2;
    final int secondTargetPosition = 1;
    final RecyclerView rv = new RecyclerView(getActivity());
    LinearLayoutManager llm = new LinearLayoutManager(getActivity(), LinearLayout.HORIZONTAL, false);
    rv.setLayoutManager(llm);
    TestAdapter testAdapter = new TestAdapter(adapterSize, new RecyclerView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    rv.setAdapter(testAdapter);
    final CountDownLatch goToTargetLatch = new CountDownLatch(1);
    rv.addOnScrollListener(new RecyclerView.OnScrollListener() {

        boolean mMadeItToFirst = false;

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            int childCount = mRecyclerView.getChildCount();
            for (int i = 0; i < childCount; i++) {
                View child = mRecyclerView.getChildAt(i);
                int adapterPosition = mRecyclerView.getChildAdapterPosition(child);
                if (!mMadeItToFirst) {
                    if (adapterPosition == firstTargetPosition) {
                        if (child.getLeft() <= 0) {
                            mRecyclerView.smoothScrollToPosition(secondTargetPosition);
                            mMadeItToFirst = true;
                        }
                    }
                } else {
                    if (adapterPosition == secondTargetPosition) {
                        if (child.getLeft() >= 0) {
                            goToTargetLatch.countDown();
                        }
                    }
                }
            }
        }
    });
    TestedFrameLayout container = getRecyclerViewContainer();
    container.expectLayouts(1);
    setRecyclerView(rv);
    container.waitForLayout(2);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            rv.smoothScrollToPosition(firstTargetPosition);
        }
    });
    assertTrue("Failed to reach target view in time.", goToTargetLatch.await(1, TimeUnit.SECONDS));
}
#method_after
@Test
public void smoothScrollToPosition_calledOnPreviousFinished_scrollsToPosition() throws Throwable {
    final int adapterSize = 3;
    final int firstTargetPosition = 2;
    final int secondTargetPosition = 1;
    final RecyclerView rv = new RecyclerView(getActivity());
    LinearLayoutManager llm = new LinearLayoutManager(getActivity(), LinearLayout.HORIZONTAL, false);
    rv.setLayoutManager(llm);
    TestAdapter testAdapter = new TestAdapter(adapterSize, new RecyclerView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));
    rv.setAdapter(testAdapter);
    final CountDownLatch goToTargetLatch = new CountDownLatch(1);
    rv.addOnScrollListener(new RecyclerView.OnScrollListener() {

        boolean mMadeItToFirst = false;

        @Override
        public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
            int childCount = mRecyclerView.getChildCount();
            for (int i = 0; i < childCount; i++) {
                View child = mRecyclerView.getChildAt(i);
                int adapterPosition = mRecyclerView.getChildAdapterPosition(child);
                if (!mMadeItToFirst) {
                    if (adapterPosition == firstTargetPosition && child.getLeft() <= 0) {
                        // If the child at our first target position is at (or beyond) 0, we are
                        // in the run of ViewFlinger.run() so now trigger a smooth scroll so we
                        // can verify that it is respected.
                        mRecyclerView.smoothScrollToPosition(secondTargetPosition);
                        mMadeItToFirst = true;
                    }
                } else if (adapterPosition == secondTargetPosition && child.getLeft() >= 0) {
                    // We've made it to the second target position! Success!
                    goToTargetLatch.countDown();
                }
            }
        }
    });
    TestedFrameLayout container = getRecyclerViewContainer();
    container.expectLayouts(1);
    setRecyclerView(rv);
    container.waitForLayout(2);
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            rv.smoothScrollToPosition(firstTargetPosition);
        }
    });
    assertTrue("Failed to reach target view in time.", goToTargetLatch.await(1, TimeUnit.SECONDS));
}
#end_block

#method_before
@Override
public Connection dial(String dialString, @NonNull DialArgs dialArgs) throws CallStateException {
    if (!isPhoneTypeGsm() && dialArgs.uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(dialArgs.videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.getInstance(mContext, mPhoneId).isNonTtyOrTtyOnVolteEnabled() && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mPhoneId, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, dialArgs);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(dialArgs.videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(dialArgs.videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, new DialArgs.Builder<>().setIntentExtras(dialArgs.intentExtras).build());
    } else {
        return dialInternal(dialString, dialArgs);
    }
}
#method_after
@Override
public Connection dial(String dialString, @NonNull DialArgs dialArgs) throws CallStateException {
    if (!isPhoneTypeGsm() && dialArgs.uusInfo != null) {
        throw new CallStateException("Sending UUS information NOT supported in CDMA!");
    }
    boolean isEmergency = PhoneNumberUtils.isEmergencyNumber(getSubId(), dialString);
    Phone imsPhone = mImsPhone;
    CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    boolean alwaysTryImsForEmergencyCarrierConfig = configManager.getConfigForSubId(getSubId()).getBoolean(CarrierConfigManager.KEY_CARRIER_USE_IMS_FIRST_FOR_EMERGENCY_BOOL);
    boolean useImsForCall = isImsUseEnabled() && imsPhone != null && (imsPhone.isVolteEnabled() || imsPhone.isWifiCallingEnabled() || (imsPhone.isVideoEnabled() && VideoProfile.isVideo(dialArgs.videoState))) && (imsPhone.getServiceState().getState() == ServiceState.STATE_IN_SERVICE);
    boolean useImsForEmergency = imsPhone != null && isEmergency && alwaysTryImsForEmergencyCarrierConfig && ImsManager.getInstance(mContext, mPhoneId).isNonTtyOrTtyOnVolteEnabled() && imsPhone.isImsAvailable();
    String dialPart = PhoneNumberUtils.extractNetworkPortionAlt(PhoneNumberUtils.stripSeparators(dialString));
    boolean isUt = (dialPart.startsWith("*") || dialPart.startsWith("#")) && dialPart.endsWith("#");
    boolean useImsForUt = imsPhone != null && imsPhone.isUtEnabled();
    if (DBG) {
        logd("useImsForCall=" + useImsForCall + ", useImsForEmergency=" + useImsForEmergency + ", useImsForUt=" + useImsForUt + ", isUt=" + isUt + ", imsPhone=" + imsPhone + ", imsPhone.isVolteEnabled()=" + ((imsPhone != null) ? imsPhone.isVolteEnabled() : "N/A") + ", imsPhone.isVowifiEnabled()=" + ((imsPhone != null) ? imsPhone.isWifiCallingEnabled() : "N/A") + ", imsPhone.isVideoEnabled()=" + ((imsPhone != null) ? imsPhone.isVideoEnabled() : "N/A") + ", imsPhone.getServiceState().getState()=" + ((imsPhone != null) ? imsPhone.getServiceState().getState() : "N/A"));
    }
    Phone.checkWfcWifiOnlyModeBeforeDial(mImsPhone, mPhoneId, mContext);
    if ((useImsForCall && !isUt) || (isUt && useImsForUt) || useImsForEmergency) {
        try {
            if (DBG)
                logd("Trying IMS PS call");
            return imsPhone.dial(dialString, dialArgs);
        } catch (CallStateException e) {
            if (DBG)
                logd("IMS PS call exception " + e + "useImsForCall =" + useImsForCall + ", imsPhone =" + imsPhone);
            // for emergency calls and MMI codes.
            if (Phone.CS_FALLBACK.equals(e.getMessage()) || isEmergency) {
                logi("IMS call failed with Exception: " + e.getMessage() + ". Falling back " + "to CS.");
            } else {
                CallStateException ce = new CallStateException(e.getMessage());
                ce.setStackTrace(e.getStackTrace());
                throw ce;
            }
        }
    }
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && mSST.mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && !isEmergency) {
        throw new CallStateException("cannot dial in current state");
    }
    // Check non-emergency voice CS call - shouldn't dial when POWER_OFF
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_POWER_OFF && /* CS POWER_OFF */
    !VideoProfile.isVideo(dialArgs.videoState) && /* voice call */
    !isEmergency && /* non-emergency call */
    !(isUt && useImsForUt)) /* not UT */
    {
        throw new CallStateException(CallStateException.ERROR_POWER_OFF, "cannot dial voice call in airplane mode");
    }
    // Allow dial only if either CS is camped on any RAT (or) PS is in LTE service.
    if (mSST != null && mSST.mSS.getState() == ServiceState.STATE_OUT_OF_SERVICE && /* CS out of service */
    !(mSST.mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ServiceState.isLte(mSST.mSS.getRilDataRadioTechnology())) && /* PS not in LTE */
    !VideoProfile.isVideo(dialArgs.videoState) && /* voice call */
    !isEmergency) /* non-emergency call */
    {
        throw new CallStateException(CallStateException.ERROR_OUT_OF_SERVICE, "cannot dial voice call in out of service");
    }
    if (DBG)
        logd("Trying (non-IMS) CS call");
    if (isPhoneTypeGsm()) {
        return dialInternal(dialString, new DialArgs.Builder<>().setIntentExtras(dialArgs.intentExtras).build());
    } else {
        return dialInternal(dialString, dialArgs);
    }
}
#end_block

#method_before
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            if (!TextUtils.isEmpty(defaultVmNumber)) {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null && b.getBoolean(CarrierConfigManager.KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#method_after
@Override
public String getVoiceMailNumber() {
    String number = null;
    if (isPhoneTypeGsm()) {
        // Read from the SIM. If its null, try reading from the shared preference area.
        IccRecords r = mIccRecords.get();
        number = (r != null) ? r.getVoiceMailNumber() : "";
        if (TextUtils.isEmpty(number)) {
            SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
            number = sp.getString(VM_NUMBER + getPhoneId(), null);
        }
    } else {
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getContext());
        number = sp.getString(VM_NUMBER_CDMA + getPhoneId(), null);
    }
    if (TextUtils.isEmpty(number)) {
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null) {
            String defaultVmNumber = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_STRING);
            String defaultVmNumberRoaming = b.getString(CarrierConfigManager.KEY_DEFAULT_VM_NUMBER_ROAMING_STRING);
            if (!TextUtils.isEmpty(defaultVmNumberRoaming) && mSST.mSS.getRoaming()) {
                number = defaultVmNumberRoaming;
            } else {
                number = defaultVmNumber;
            }
        }
    }
    if (!isPhoneTypeGsm() && TextUtils.isEmpty(number)) {
        // Read platform settings for dynamic voicemail number
        CarrierConfigManager configManager = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        PersistableBundle b = configManager.getConfig();
        if (b != null && b.getBoolean(CarrierConfigManager.KEY_CONFIG_TELEPHONY_USE_OWN_NUMBER_FOR_VOICEMAIL_BOOL)) {
            number = getLine1Number();
        } else {
            number = "*86";
        }
    }
    return number;
}
#end_block

#method_before
@Override
public String getSubscriberId() {
    if (isPhoneTypeGsm()) {
        IccRecords r = mIccRecords.get();
        return (r != null) ? r.getIMSI() : null;
    } else if (isPhoneTypeCdma()) {
        return mSST.getImsi();
    } else {
        // isPhoneTypeCdmaLte()
        return (mSimRecords != null) ? mSimRecords.getIMSI() : "";
    }
}
#method_after
@Override
@Nullable
public String getSubscriberId() {
    String subscriberId = null;
    if (isPhoneTypeCdma()) {
        subscriberId = mSST.getImsi();
    } else {
        // Both Gsm and CdmaLte get the IMSI from Usim.
        IccRecords iccRecords = mUiccController.getIccRecords(mPhoneId, UiccController.APP_FAM_3GPP);
        if (iccRecords != null) {
            subscriberId = iccRecords.getIMSI();
        }
    }
    return subscriberId;
}
#end_block

#method_before
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext);
}
#method_after
@Override
public void setCarrierInfoForImsiEncryption(ImsiEncryptionInfo imsiEncryptionInfo) {
    CarrierInfoManager.setCarrierInfoForImsiEncryption(imsiEncryptionInfo, mContext, mPhoneId);
}
#end_block

#method_before
@Override
public void setVoiceMailNumber(String alphaTag, String voiceMailNumber, Message onComplete) {
    Message resp;
    mVmNumber = voiceMailNumber;
    resp = obtainMessage(EVENT_SET_VM_NUMBER_DONE, 0, 0, onComplete);
    IccRecords r = mIccRecords.get();
    if (r != null) {
        r.setVoiceMailNumber(alphaTag, mVmNumber, resp);
    }
}
#method_after
@Override
public void setVoiceMailNumber(String alphaTag, String voiceMailNumber, Message onComplete) {
    Message resp;
    mVmNumber = voiceMailNumber;
    resp = obtainMessage(EVENT_SET_VM_NUMBER_DONE, 0, 0, onComplete);
    IccRecords r = mIccRecords.get();
    if (!isPhoneTypeGsm() && mSimRecords != null) {
        r = mSimRecords;
    }
    if (r != null) {
        r.setVoiceMailNumber(alphaTag, mVmNumber, resp);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service if it is available, if it isn't the config will be
            // updated when ImsPhoneCallTracker opens a connection.
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            if (imsManager.isServiceAvailable()) {
                imsManager.updateImsServiceConfig(true);
            } else {
                logd("ImsManager is not available to update CarrierConfig.");
            }
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case CarrierConfigManager.CDMA_ROAMING_MODE_HOME:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case CarrierConfigManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case CarrierConfigManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            mSST.pollState();
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    Message onComplete;
    switch(msg.what) {
        case EVENT_RADIO_AVAILABLE:
            {
                handleRadioAvailable();
            }
            break;
        case EVENT_GET_DEVICE_IDENTITY_DONE:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    break;
                }
                String[] respId = (String[]) ar.result;
                mImei = respId[0];
                mImeiSv = respId[1];
                mEsn = respId[2];
                mMeid = respId[3];
            }
            break;
        case EVENT_EMERGENCY_CALLBACK_MODE_ENTER:
            {
                handleEnterEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_EXIT_EMERGENCY_CALLBACK_RESPONSE:
            {
                handleExitEmergencyCallbackMode(msg);
            }
            break;
        case EVENT_MODEM_RESET:
            {
                logd("Event EVENT_MODEM_RESET Received" + " isInEcm = " + isInEcm() + " isPhoneTypeGsm = " + isPhoneTypeGsm() + " mImsPhone = " + mImsPhone);
                if (isInEcm()) {
                    if (isPhoneTypeGsm()) {
                        if (mImsPhone != null) {
                            mImsPhone.handleExitEmergencyCallbackMode();
                        }
                    } else {
                        handleExitEmergencyCallbackMode(msg);
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            logd("Event EVENT_RUIM_RECORDS_LOADED Received");
            updateCurrentCarrierInProvider();
            break;
        case EVENT_RADIO_ON:
            logd("Event EVENT_RADIO_ON Received");
            handleRadioOn();
            break;
        case EVENT_RIL_CONNECTED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null && ar.result != null) {
                mRilVersion = (Integer) ar.result;
            } else {
                logd("Unexpected exception on EVENT_RIL_CONNECTED");
                mRilVersion = -1;
            }
            break;
        case EVENT_VOICE_RADIO_TECH_CHANGED:
        case EVENT_REQUEST_VOICE_RADIO_TECH_DONE:
            String what = (msg.what == EVENT_VOICE_RADIO_TECH_CHANGED) ? "EVENT_VOICE_RADIO_TECH_CHANGED" : "EVENT_REQUEST_VOICE_RADIO_TECH_DONE";
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                if ((ar.result != null) && (((int[]) ar.result).length != 0)) {
                    int newVoiceTech = ((int[]) ar.result)[0];
                    logd(what + ": newVoiceTech=" + newVoiceTech);
                    phoneObjectUpdater(newVoiceTech);
                } else {
                    loge(what + ": has no tech!");
                }
            } else {
                loge(what + ": exception=" + ar.exception);
            }
            break;
        case EVENT_UPDATE_PHONE_OBJECT:
            phoneObjectUpdater(msg.arg1);
            break;
        case EVENT_CARRIER_CONFIG_CHANGED:
            // registration changes.
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_switch_phone_on_voice_reg_state_change)) {
                mCi.getVoiceRadioTechnology(obtainMessage(EVENT_REQUEST_VOICE_RADIO_TECH_DONE));
            }
            // Force update IMS service if it is available, if it isn't the config will be
            // updated when ImsPhoneCallTracker opens a connection.
            ImsManager imsManager = ImsManager.getInstance(mContext, mPhoneId);
            if (imsManager.isServiceAvailable()) {
                imsManager.updateImsServiceConfig(true);
            } else {
                logd("ImsManager is not available to update CarrierConfig.");
            }
            // Update broadcastEmergencyCallStateChanges
            CarrierConfigManager configMgr = (CarrierConfigManager) getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
            PersistableBundle b = configMgr.getConfigForSubId(getSubId());
            if (b != null) {
                boolean broadcastEmergencyCallStateChanges = b.getBoolean(CarrierConfigManager.KEY_BROADCAST_EMERGENCY_CALL_STATE_CHANGES_BOOL);
                logd("broadcastEmergencyCallStateChanges = " + broadcastEmergencyCallStateChanges);
                setBroadcastEmergencyCallStateChanges(broadcastEmergencyCallStateChanges);
            } else {
                loge("didn't get broadcastEmergencyCallStateChanges from carrier config");
            }
            // Changing the cdma roaming settings based carrier config.
            if (b != null) {
                int config_cdma_roaming_mode = b.getInt(CarrierConfigManager.KEY_CDMA_ROAMING_MODE_INT);
                int current_cdma_roaming_mode = Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.CDMA_ROAMING_MODE, TelephonyManager.CDMA_ROAMING_MODE_RADIO_DEFAULT);
                switch(config_cdma_roaming_mode) {
                    // when carrier's setting is turn off.
                    case TelephonyManager.CDMA_ROAMING_MODE_HOME:
                    case TelephonyManager.CDMA_ROAMING_MODE_AFFILIATED:
                    case TelephonyManager.CDMA_ROAMING_MODE_ANY:
                        logd("cdma_roaming_mode is going to changed to " + config_cdma_roaming_mode);
                        setCdmaRoamingPreference(config_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        break;
                    // previous user's setting
                    case TelephonyManager.CDMA_ROAMING_MODE_RADIO_DEFAULT:
                        if (current_cdma_roaming_mode != config_cdma_roaming_mode) {
                            logd("cdma_roaming_mode is going to changed to " + current_cdma_roaming_mode);
                            setCdmaRoamingPreference(current_cdma_roaming_mode, obtainMessage(EVENT_SET_ROAMING_PREFERENCE_DONE));
                        }
                    default:
                        loge("Invalid cdma_roaming_mode settings: " + config_cdma_roaming_mode);
                }
            } else {
                loge("didn't get the cdma_roaming_mode changes from the carrier config.");
            }
            // Load the ERI based on carrier config. Carrier might have their specific ERI.
            prepareEri();
            mSST.pollState();
            break;
        case EVENT_SET_ROAMING_PREFERENCE_DONE:
            logd("cdma_roaming_mode change is done");
            break;
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            logd("EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED");
            mCdmaSubscriptionSource = mCdmaSSM.getCdmaSubscriptionSource();
            break;
        case EVENT_REGISTERED_TO_NETWORK:
            logd("Event EVENT_REGISTERED_TO_NETWORK Received");
            if (isPhoneTypeGsm()) {
                syncClirSetting();
            }
            break;
        case EVENT_SIM_RECORDS_LOADED:
            updateCurrentCarrierInProvider();
            // Check if this is a different SIM than the previous one. If so unset the
            // voice mail number.
            String imsi = getVmSimImsi();
            String imsiFromSIM = getSubscriberId();
            if ((!isPhoneTypeGsm() || imsi != null) && imsiFromSIM != null && !imsiFromSIM.equals(imsi)) {
                storeVoiceMailNumber(null);
                setVmSimImsi(null);
            }
            mSimRecordsLoadedRegistrants.notifyRegistrants();
            break;
        case EVENT_GET_BASEBAND_VERSION_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            if (DBG)
                logd("Baseband version: " + ar.result);
            TelephonyManager.from(mContext).setBasebandVersionForPhone(getPhoneId(), (String) ar.result);
            break;
        case EVENT_GET_IMEI_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImei = (String) ar.result;
            break;
        case EVENT_GET_IMEISV_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception != null) {
                break;
            }
            mImeiSv = (String) ar.result;
            break;
        case EVENT_USSD:
            ar = (AsyncResult) msg.obj;
            String[] ussdResult = (String[]) ar.result;
            if (ussdResult.length > 1) {
                try {
                    onIncomingUSSD(Integer.parseInt(ussdResult[0]), ussdResult[1]);
                } catch (NumberFormatException e) {
                    Rlog.w(LOG_TAG, "error parsing USSD");
                }
            }
            break;
        case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
            {
                logd("Event EVENT_RADIO_OFF_OR_NOT_AVAILABLE Received");
                handleRadioOffOrNotAvailable();
                break;
            }
        case EVENT_SSN:
            logd("Event EVENT_SSN Received");
            if (isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                SuppServiceNotification not = (SuppServiceNotification) ar.result;
                mSsnRegistrants.notifyRegistrants(ar);
            }
            break;
        case EVENT_SET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            IccRecords r = mIccRecords.get();
            Cfu cfu = (Cfu) ar.userObj;
            if (ar.exception == null && r != null) {
                setVoiceCallForwardingFlag(1, msg.arg1 == 1, cfu.mSetCfNumber);
            }
            if (cfu.mOnComplete != null) {
                AsyncResult.forMessage(cfu.mOnComplete, ar.result, ar.exception);
                cfu.mOnComplete.sendToTarget();
            }
            break;
        case EVENT_SET_VM_NUMBER_DONE:
            ar = (AsyncResult) msg.obj;
            if ((isPhoneTypeGsm() && IccVmNotSupportedException.class.isInstance(ar.exception)) || (!isPhoneTypeGsm() && IccException.class.isInstance(ar.exception))) {
                storeVoiceMailNumber(mVmNumber);
                ar.exception = null;
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_GET_CALL_FORWARD_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                handleCfuQueryResult((CallForwardInfo[]) ar.result);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SET_NETWORK_AUTOMATIC:
            // Automatic network selection from EF_CSP SIM record
            ar = (AsyncResult) msg.obj;
            if (mSST.mSS.getIsManualSelection()) {
                setNetworkSelectionModeAutomatic((Message) ar.result);
                logd("SET_NETWORK_SELECTION_AUTOMATIC: set to automatic");
            } else {
                // prevent duplicate request which will push current PLMN to low priority
                logd("SET_NETWORK_SELECTION_AUTOMATIC: already automatic, ignore");
            }
            break;
        case EVENT_ICC_RECORD_EVENTS:
            ar = (AsyncResult) msg.obj;
            processIccRecordEvents((Integer) ar.result);
            break;
        case EVENT_SET_CLIR_COMPLETE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                saveClirSetting(msg.arg1);
            }
            onComplete = (Message) ar.userObj;
            if (onComplete != null) {
                AsyncResult.forMessage(onComplete, ar.result, ar.exception);
                onComplete.sendToTarget();
            }
            break;
        case EVENT_SS:
            ar = (AsyncResult) msg.obj;
            logd("Event EVENT_SS received");
            if (isPhoneTypeGsm()) {
                // SS data is already being handled through MMI codes.
                // So, this result if processed as MMI response would help
                // in re-using the existing functionality.
                GsmMmiCode mmi = new GsmMmiCode(this, mUiccApplication.get());
                mmi.processSsData(ar);
            }
            break;
        case EVENT_GET_RADIO_CAPABILITY:
            ar = (AsyncResult) msg.obj;
            RadioCapability rc = (RadioCapability) ar.result;
            if (ar.exception != null) {
                Rlog.d(LOG_TAG, "get phone radio capability fail, no need to change " + "mRadioCapability");
            } else {
                radioCapabilityUpdated(rc);
            }
            Rlog.d(LOG_TAG, "EVENT_GET_RADIO_CAPABILITY: phone rc: " + rc);
            break;
        default:
            super.handleMessage(msg);
    }
}
#end_block

#method_before
// todo: check if ICC availability needs to be handled here. mSimRecords should not be needed
// now because APIs can be called directly on UiccProfile, and that should handle the requests
@Override
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = null;
    // Update mIsimUiccRecords
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
        IsimUiccRecords newIsimUiccRecords = null;
        if (newUiccApplication != null) {
            newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
            if (DBG)
                logd("New ISIM application found");
        }
        mIsimUiccRecords = newIsimUiccRecords;
    }
    // Update mSimRecords
    if (mSimRecords != null) {
        mSimRecords.unregisterForRecordsLoaded(this);
    }
    if (isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
        SIMRecords newSimRecords = null;
        if (newUiccApplication != null) {
            newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
        }
        mSimRecords = newSimRecords;
        if (mSimRecords != null) {
            mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    } else {
        mSimRecords = null;
    }
    // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
    newUiccApplication = getUiccCardApplication();
    if (!isPhoneTypeGsm() && newUiccApplication == null) {
        logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
    }
    UiccCardApplication app = mUiccApplication.get();
    if (app != newUiccApplication) {
        if (app != null) {
            if (DBG)
                logd("Removing stale icc objects.");
            if (mIccRecords.get() != null) {
                unregisterForIccRecordEvents();
                mIccPhoneBookIntManager.updateIccRecords(null);
            }
            mIccRecords.set(null);
            mUiccApplication.set(null);
        }
        if (newUiccApplication != null) {
            if (DBG) {
                logd("New Uicc application found. type = " + newUiccApplication.getType());
            }
            mUiccApplication.set(newUiccApplication);
            mIccRecords.set(newUiccApplication.getIccRecords());
            registerForIccRecordEvents();
            mIccPhoneBookIntManager.updateIccRecords(mIccRecords.get());
            final String simOperatorNumberic = mIccRecords.getOperatorNumeric();
            if (DBG) {
                logd("New simOperatorNumberic = " + simOperatorNumberic);
            }
            if (!TextUtils.isEmpty(simOperatorNumberic)) {
                TelephonyManager.from(mContext).setSimOperatorNumericForPhone(mPhoneId, simOperatorNumberic);
            }
        }
    }
}
#method_after
// todo: check if ICC availability needs to be handled here. mSimRecords should not be needed
// now because APIs can be called directly on UiccProfile, and that should handle the requests
@Override
protected void onUpdateIccAvailability() {
    if (mUiccController == null) {
        return;
    }
    UiccCardApplication newUiccApplication = null;
    // Update mIsimUiccRecords
    if (isPhoneTypeGsm() || isPhoneTypeCdmaLte()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_IMS);
        IsimUiccRecords newIsimUiccRecords = null;
        if (newUiccApplication != null) {
            newIsimUiccRecords = (IsimUiccRecords) newUiccApplication.getIccRecords();
            if (DBG)
                logd("New ISIM application found");
        }
        mIsimUiccRecords = newIsimUiccRecords;
    }
    // Update mSimRecords
    if (mSimRecords != null) {
        mSimRecords.unregisterForRecordsLoaded(this);
    }
    if (isPhoneTypeCdmaLte() || isPhoneTypeCdma()) {
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
        SIMRecords newSimRecords = null;
        if (newUiccApplication != null) {
            newSimRecords = (SIMRecords) newUiccApplication.getIccRecords();
        }
        mSimRecords = newSimRecords;
        if (mSimRecords != null) {
            mSimRecords.registerForRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
    } else {
        mSimRecords = null;
    }
    // Update mIccRecords, mUiccApplication, mIccPhoneBookIntManager
    newUiccApplication = getUiccCardApplication();
    if (!isPhoneTypeGsm() && newUiccApplication == null) {
        logd("can't find 3GPP2 application; trying APP_FAM_3GPP");
        newUiccApplication = mUiccController.getUiccCardApplication(mPhoneId, UiccController.APP_FAM_3GPP);
    }
    UiccCardApplication app = mUiccApplication.get();
    if (app != newUiccApplication) {
        if (app != null) {
            if (DBG)
                logd("Removing stale icc objects.");
            if (mIccRecords.get() != null) {
                unregisterForIccRecordEvents();
                mIccPhoneBookIntManager.updateIccRecords(null);
            }
            mIccRecords.set(null);
            mUiccApplication.set(null);
        }
        if (newUiccApplication != null) {
            if (DBG) {
                logd("New Uicc application found. type = " + newUiccApplication.getType());
            }
            final IccRecords iccRecords = newUiccApplication.getIccRecords();
            mUiccApplication.set(newUiccApplication);
            mIccRecords.set(iccRecords);
            registerForIccRecordEvents();
            mIccPhoneBookIntManager.updateIccRecords(iccRecords);
            if (iccRecords != null) {
                final String simOperatorNumeric = iccRecords.getOperatorNumeric();
                if (DBG) {
                    logd("New simOperatorNumeric = " + simOperatorNumeric);
                }
                if (!TextUtils.isEmpty(simOperatorNumeric)) {
                    TelephonyManager.from(mContext).setSimOperatorNumericForPhone(mPhoneId, simOperatorNumeric);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void setNavigationIcon(Drawable icon) {
    mToolbarWeakReference.get().setNavigationIcon(icon);
}
#method_after
@Override
protected void setNavigationIcon(Drawable icon) {
    Toolbar toolbar = mToolbarWeakReference.get();
    if (toolbar != null) {
        toolbar.setNavigationIcon(icon);
    }
}
#end_block

#method_before
@Override
protected void setTitle(CharSequence title) {
    mCollapsingToolbarLayoutWeakReference.get().setTitle(title);
}
#method_after
@Override
protected void setTitle(CharSequence title) {
    CollapsingToolbarLayout collapsingToolbarLayout = mCollapsingToolbarLayoutWeakReference.get();
    if (collapsingToolbarLayout != null) {
        collapsingToolbarLayout.setTitle(title);
    }
}
#end_block

#method_before
@Override
protected void setNavigationIcon(Drawable icon) {
    mToolbarWeakReference.get().setNavigationIcon(icon);
}
#method_after
@Override
protected void setNavigationIcon(Drawable icon) {
    Toolbar toolbar = mToolbarWeakReference.get();
    if (toolbar != null) {
        toolbar.setNavigationIcon(icon);
    }
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks);
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig);
}
#end_block

#method_before
@NonNull
public Request build() {
    return new Request(mText, mStartIndex, mEndIndex, mDefaultLocales, mReferenceTime);
}
#method_after
@NonNull
public TextClassification build() {
    return new TextClassification(mText, mActions, new EntityConfidence(mEntityConfidence), mId);
}
#end_block

#method_before
/**
 * @param referenceTime reference time based on which relative dates (e.g. "tomorrow"
 *      should be interpreted. This should usually be the time when the text was
 *      originally composed. If no reference time is set, now is used.
 *
 * @return this builder
 * @hide
 */
@RestrictTo(RestrictTo.Scope.LIBRARY)
@NonNull
public Builder setReferenceTime(@Nullable Long referenceTime) {
    mReferenceTime = referenceTime;
    return this;
}
#method_after
@NonNull
public Builder setReferenceTime(@Nullable Long referenceTime) {
    mReferenceTime = referenceTime;
    return this;
}
#end_block

#method_before
private void updateLayout(int maxIconNum, int currWidth, int currHeight, int screenWidth, int screenHeight) {
    int bottomBarRightWidthMax = mIconSize * maxIconNum;
    int fullWidth = mTransportControls.getWidth() + mTimeView.getWidth() + bottomBarRightWidthMax;
    int screenMaxLength = Math.max(screenWidth, screenHeight);
    int embeddedWidth = mMaxTimeViewWidth + bottomBarRightWidthMax;
    // TODO: b/111246858
    // If Media type is default, the size of MCV2 is full only when the current width is equal
    // to the max length of the screen (only landscape mode). If Media type is music, however,
    // the size of MCV2 is full when the current width is equal to the current screen width
    // (both landscape and portrait modes).
    boolean isFullSize = (mMediaType == MEDIA_TYPE_DEFAULT) ? currWidth == screenMaxLength : currWidth == screenWidth;
    if (isFullSize) {
        if (mSizeType != SIZE_TYPE_FULL) {
            updateLayoutForSizeChange(SIZE_TYPE_FULL);
            if (mMediaType == MEDIA_TYPE_MUSIC) {
                mTitleView.setVisibility(View.GONE);
            } else {
                mUxState = UX_STATE_EMPTY;
                toggleMediaControlViewVisibility();
            }
        }
    } else if (embeddedWidth <= currWidth) {
        if (mSizeType != SIZE_TYPE_EMBEDDED) {
            updateLayoutForSizeChange(SIZE_TYPE_EMBEDDED);
            if (mMediaType == MEDIA_TYPE_MUSIC) {
                mTitleView.setVisibility(View.VISIBLE);
            }
        }
    } else {
        if (mSizeType != SIZE_TYPE_MINIMAL) {
            updateLayoutForSizeChange(SIZE_TYPE_MINIMAL);
            if (mMediaType == MEDIA_TYPE_MUSIC) {
                mTitleView.setVisibility(View.GONE);
            }
        }
    }
}
#method_after
private void updateLayout(int maxIconNum, int currWidth, int currHeight, int screenWidth, int screenHeight) {
    int bottomBarRightWidthMax = mIconSize * maxIconNum;
    int fullWidth = mTransportControls.getWidth() + mTimeView.getWidth() + bottomBarRightWidthMax;
    int screenMaxLength = Math.max(screenWidth, screenHeight);
    int embeddedWidth = mMaxTimeViewWidth + bottomBarRightWidthMax;
    // If Media type is default, the size of MCV2 is full only when the current width is equal
    // to the max length of the screen (only landscape mode). If Media type is music, however,
    // the size of MCV2 is full when the current width is equal to the current screen width
    // (both landscape and portrait modes).
    boolean isFullSize = (mMediaType == MEDIA_TYPE_DEFAULT) ? currWidth == screenMaxLength : currWidth == screenWidth;
    if (isFullSize) {
        if (mSizeType != SIZE_TYPE_FULL) {
            updateLayoutForSizeChange(SIZE_TYPE_FULL);
            if (mMediaType == MEDIA_TYPE_MUSIC) {
                mTitleView.setVisibility(View.GONE);
            } else {
                mUxState = UX_STATE_EMPTY;
                toggleMediaControlViewVisibility();
            }
        }
    } else if (embeddedWidth <= currWidth) {
        if (mSizeType != SIZE_TYPE_EMBEDDED) {
            updateLayoutForSizeChange(SIZE_TYPE_EMBEDDED);
            if (mMediaType == MEDIA_TYPE_MUSIC) {
                mTitleView.setVisibility(View.VISIBLE);
            }
        }
    } else {
        if (mSizeType != SIZE_TYPE_MINIMAL) {
            updateLayoutForSizeChange(SIZE_TYPE_MINIMAL);
            if (mMediaType == MEDIA_TYPE_MUSIC) {
                mTitleView.setVisibility(View.GONE);
            }
        }
    }
}
#end_block

#method_before
public List<MediaRouteDescriptor> getRoutes() {
    ensureRoutes();
    return mRoutes;
}
#method_after
@NonNull
public List<MediaRouteDescriptor> getRoutes() {
    return mRoutes;
}
#end_block

#method_before
public boolean isValid() {
    ensureRoutes();
    final int routeCount = mRoutes.size();
    for (int i = 0; i < routeCount; i++) {
        MediaRouteDescriptor route = mRoutes.get(i);
        if (route == null || !route.isValid()) {
            return false;
        }
    }
    return true;
}
#method_after
public boolean isValid() {
    final int routeCount = getRoutes().size();
    for (int i = 0; i < routeCount; i++) {
        MediaRouteDescriptor route = mRoutes.get(i);
        if (route == null || !route.isValid()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public Bundle asBundle() {
    if (mBundle.getBoolean(KEY_SUPPORTS_DYNAMIC_ROUTE) != mSupportsDynamicRoute) {
        mBundle.putBoolean(KEY_SUPPORTS_DYNAMIC_ROUTE, mSupportsDynamicRoute);
    }
    return mBundle;
}
#method_after
public Bundle asBundle() {
    if (mBundle != null) {
        return mBundle;
    }
    mBundle = new Bundle();
    if (mRoutes != null && !mRoutes.isEmpty()) {
        final int count = mRoutes.size();
        ArrayList<Bundle> routeBundles = new ArrayList<Bundle>(count);
        for (int i = 0; i < count; i++) {
            routeBundles.add(mRoutes.get(i).asBundle());
        }
        mBundle.putParcelableArrayList(KEY_ROUTES, routeBundles);
    }
    mBundle.putBoolean(KEY_SUPPORTS_DYNAMIC_GROUP_ROUTE, mSupportsDynamicGroupRoute);
    return mBundle;
}
#end_block

#method_before
public static MediaRouteProviderDescriptor fromBundle(Bundle bundle) {
    return bundle != null ? new MediaRouteProviderDescriptor(bundle, null) : null;
}
#method_after
public static MediaRouteProviderDescriptor fromBundle(Bundle bundle) {
    if (bundle == null) {
        return null;
    }
    List<MediaRouteDescriptor> routes = null;
    ArrayList<Bundle> routeBundles = bundle.<Bundle>getParcelableArrayList(KEY_ROUTES);
    if (routeBundles != null && !routeBundles.isEmpty()) {
        final int count = routeBundles.size();
        routes = new ArrayList<MediaRouteDescriptor>(count);
        for (int i = 0; i < count; i++) {
            routes.add(MediaRouteDescriptor.fromBundle(routeBundles.get(i)));
        }
    }
    boolean supportsDynamicGroupRoute = bundle.getBoolean(KEY_SUPPORTS_DYNAMIC_GROUP_ROUTE, false);
    return new MediaRouteProviderDescriptor(routes, supportsDynamicGroupRoute);
}
#end_block

#method_before
Builder setRoutes(Collection<MediaRouteDescriptor> routes) {
    if (routes == null || routes.isEmpty()) {
        mRoutes = null;
        mBundle.remove(KEY_ROUTES);
    } else {
        mRoutes = new ArrayList<>(routes);
    }
    return this;
}
#method_after
Builder setRoutes(Collection<MediaRouteDescriptor> routes) {
    if (routes == null || routes.isEmpty()) {
        mRoutes = null;
    } else {
        mRoutes = new ArrayList<>(routes);
    }
    return this;
}
#end_block

#method_before
public MediaRouteProviderDescriptor build() {
    if (mRoutes != null) {
        final int count = mRoutes.size();
        ArrayList<Bundle> routeBundles = new ArrayList<Bundle>(count);
        for (int i = 0; i < count; i++) {
            routeBundles.add(mRoutes.get(i).asBundle());
        }
        mBundle.putParcelableArrayList(KEY_ROUTES, routeBundles);
    }
    return new MediaRouteProviderDescriptor(mBundle, mRoutes);
}
#method_after
public MediaRouteProviderDescriptor build() {
    return new MediaRouteProviderDescriptor(mRoutes, mSupportsDynamicGroupRoute);
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public final boolean overItem(@NonNull MotionEvent e) {
    return getItemPosition(e) != RecyclerView.NO_POSITION;
}
#method_after
final boolean overItem(@NonNull MotionEvent e) {
    return getItemPosition(e) != RecyclerView.NO_POSITION;
}
#end_block

#method_before
@RestrictTo(LIBRARY_GROUP)
public final boolean overItemWithSelectionKey(@NonNull MotionEvent e) {
    return overItem(e) && hasSelectionKey(getItemDetails(e));
}
#method_after
@RestrictTo(LIBRARY_GROUP)
protected boolean overItemWithSelectionKey(@NonNull MotionEvent e) {
    return overItem(e) && hasSelectionKey(getItemDetails(e));
}
#end_block

#method_before
@Override
public void restoreSelection(@NonNull Selection other) {
    checkArgument(other != null);
    setItemsSelectedQuietly(other.mSelection, true);
    // NOTE: We intentionally don't restore provisional selection. It's provisional.
    notifySelectionRestored();
}
#method_after
@Override
protected void restoreSelection(@NonNull Selection other) {
    checkArgument(other != null);
    setItemsSelectedQuietly(other.mSelection, true);
    // NOTE: We intentionally don't restore provisional selection. It's provisional.
    notifySelectionRestored();
}
#end_block

#method_before
public LinkedHashMap<String, IConfiguration> loadConfigsFromDirectory(File testsDir, Set<IAbi> abis, String suitePrefix, String suiteTag, List<String> patterns, File priorDir) {
    LinkedHashMap<String, IConfiguration> toRun = new LinkedHashMap<>();
    List<File> listConfigFiles = new ArrayList<>();
    List<File> extraTestCasesDirs = Arrays.asList(testsDir);
    listConfigFiles.addAll(ConfigurationUtil.getConfigNamesFileFromDirs(suitePrefix, extraTestCasesDirs, patterns, priorDir));
    // Ensure stable initial order of configurations.
    Collections.sort(listConfigFiles);
    for (File configFile : listConfigFiles) {
        toRun.putAll(loadOneConfig(configFile.getName(), configFile.getAbsolutePath(), abis, suiteTag));
    }
    return toRun;
}
#method_after
public LinkedHashMap<String, IConfiguration> loadConfigsFromDirectory(File testsDir, Set<IAbi> abis, String suitePrefix, String suiteTag, List<String> patterns, boolean prioritizeHostConfig) {
    LinkedHashMap<String, IConfiguration> toRun = new LinkedHashMap<>();
    List<File> listConfigFiles = new ArrayList<>();
    List<File> extraTestCasesDirs = Arrays.asList(testsDir);
    listConfigFiles.addAll(ConfigurationUtil.getConfigNamesFileFromDirs(suitePrefix, extraTestCasesDirs, patterns, prioritizeHostConfig));
    // Ensure stable initial order of configurations.
    Collections.sort(listConfigFiles);
    for (File configFile : listConfigFiles) {
        toRun.putAll(loadOneConfig(configFile.getName(), configFile.getAbsolutePath(), abis, suiteTag));
    }
    return toRun;
}
#end_block

#method_before
public static Set<File> getModuleNamesMatching(File directory, String suitePrefix, String pattern) {
    List<File> extraTestCasesDirs = Arrays.asList(directory);
    List<String> patterns = new ArrayList<>();
    patterns.add(pattern);
    Set<File> modules = ConfigurationUtil.getConfigNamesFileFromDirs(suitePrefix, extraTestCasesDirs, patterns, null);
    return modules;
}
#method_after
public static Set<File> getModuleNamesMatching(File directory, String suitePrefix, String pattern) {
    List<File> extraTestCasesDirs = Arrays.asList(directory);
    List<String> patterns = new ArrayList<>();
    patterns.add(pattern);
    Set<File> modules = ConfigurationUtil.getConfigNamesFileFromDirs(suitePrefix, extraTestCasesDirs, patterns);
    return modules;
}
#end_block

#method_before
@Test
public void testInjectConfigOptions_moduleArgs() throws Exception {
    List<String> moduleArgs = new ArrayList<>();
    moduleArgs.add("module1:simple-string:value1");
    moduleArgs.add("module1:list-string:value2");
    moduleArgs.add("module1:list-string:value3");
    moduleArgs.add("module1:list-string:set-option:moreoption");
    moduleArgs.add("module1:map-string:set-option:=moreoption");
    createModuleConfig("module1");
    mRepo = new SuiteModuleLoader(new LinkedHashMap<String, List<SuiteTestFilter>>(), new LinkedHashMap<String, List<SuiteTestFilter>>(), new ArrayList<>(), moduleArgs);
    List<String> patterns = new ArrayList<>();
    patterns.add(".*.config");
    patterns.add(".*.xml");
    LinkedHashMap<String, IConfiguration> res = mRepo.loadConfigsFromDirectory(mTestsDir, mAbis, null, null, patterns, null);
    assertNotNull(res.get("armeabi-v7a module1"));
    IConfiguration config = res.get("armeabi-v7a module1");
    TestInject checker = (TestInject) config.getTests().get(0);
    assertEquals("value1", checker.test);
    // Check list
    assertTrue(checker.testList.size() == 3);
    assertTrue(checker.testList.contains("value2"));
    assertTrue(checker.testList.contains("value3"));
    assertTrue(checker.testList.contains("set-option:moreoption"));
    // Chech map
    assertTrue(checker.testMap.size() == 1);
    assertEquals("moreoption", checker.testMap.get("set-option"));
}
#method_after
@Test
public void testInjectConfigOptions_moduleArgs() throws Exception {
    List<String> moduleArgs = new ArrayList<>();
    moduleArgs.add("module1:simple-string:value1");
    moduleArgs.add("module1:list-string:value2");
    moduleArgs.add("module1:list-string:value3");
    moduleArgs.add("module1:list-string:set-option:moreoption");
    moduleArgs.add("module1:map-string:set-option:=moreoption");
    createModuleConfig("module1");
    mRepo = new SuiteModuleLoader(new LinkedHashMap<String, List<SuiteTestFilter>>(), new LinkedHashMap<String, List<SuiteTestFilter>>(), new ArrayList<>(), moduleArgs);
    List<String> patterns = new ArrayList<>();
    patterns.add(".*.config");
    patterns.add(".*.xml");
    LinkedHashMap<String, IConfiguration> res = mRepo.loadConfigsFromDirectory(mTestsDir, mAbis, null, null, patterns, false);
    assertNotNull(res.get("armeabi-v7a module1"));
    IConfiguration config = res.get("armeabi-v7a module1");
    TestInject checker = (TestInject) config.getTests().get(0);
    assertEquals("value1", checker.test);
    // Check list
    assertTrue(checker.testList.size() == 3);
    assertTrue(checker.testList.contains("value2"));
    assertTrue(checker.testList.contains("value3"));
    assertTrue(checker.testList.contains("set-option:moreoption"));
    // Chech map
    assertTrue(checker.testMap.size() == 1);
    assertEquals("moreoption", checker.testMap.get("set-option"));
}
#end_block

#method_before
@Test
public void testInjectConfigOptions_testArgs() throws Exception {
    List<String> testArgs = new ArrayList<>();
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "simple-string:value1");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "list-string:value2");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "list-string:value3");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "list-string:set-option:moreoption");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "map-string:set-option:=moreoption");
    createModuleConfig("module1");
    mRepo = new SuiteModuleLoader(new LinkedHashMap<String, List<SuiteTestFilter>>(), new LinkedHashMap<String, List<SuiteTestFilter>>(), testArgs, new ArrayList<>());
    List<String> patterns = new ArrayList<>();
    patterns.add(".*.config");
    patterns.add(".*.xml");
    LinkedHashMap<String, IConfiguration> res = mRepo.loadConfigsFromDirectory(mTestsDir, mAbis, null, null, patterns, null);
    assertNotNull(res.get("armeabi-v7a module1"));
    IConfiguration config = res.get("armeabi-v7a module1");
    TestInject checker = (TestInject) config.getTests().get(0);
    assertEquals("value1", checker.test);
    // Check list
    assertTrue(checker.testList.size() == 3);
    assertTrue(checker.testList.contains("value2"));
    assertTrue(checker.testList.contains("value3"));
    assertTrue(checker.testList.contains("set-option:moreoption"));
    // Chech map
    assertTrue(checker.testMap.size() == 1);
    assertEquals("moreoption", checker.testMap.get("set-option"));
}
#method_after
@Test
public void testInjectConfigOptions_testArgs() throws Exception {
    List<String> testArgs = new ArrayList<>();
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "simple-string:value1");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "list-string:value2");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "list-string:value3");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "list-string:set-option:moreoption");
    testArgs.add("com.android.tradefed.testtype.suite.SuiteModuleLoaderTest$TestInject:" + "map-string:set-option:=moreoption");
    createModuleConfig("module1");
    mRepo = new SuiteModuleLoader(new LinkedHashMap<String, List<SuiteTestFilter>>(), new LinkedHashMap<String, List<SuiteTestFilter>>(), testArgs, new ArrayList<>());
    List<String> patterns = new ArrayList<>();
    patterns.add(".*.config");
    patterns.add(".*.xml");
    LinkedHashMap<String, IConfiguration> res = mRepo.loadConfigsFromDirectory(mTestsDir, mAbis, null, null, patterns, false);
    assertNotNull(res.get("armeabi-v7a module1"));
    IConfiguration config = res.get("armeabi-v7a module1");
    TestInject checker = (TestInject) config.getTests().get(0);
    assertEquals("value1", checker.test);
    // Check list
    assertTrue(checker.testList.size() == 3);
    assertTrue(checker.testList.contains("value2"));
    assertTrue(checker.testList.contains("value3"));
    assertTrue(checker.testList.contains("set-option:moreoption"));
    // Chech map
    assertTrue(checker.testMap.size() == 1);
    assertEquals("moreoption", checker.testMap.get("set-option"));
}
#end_block

#method_before
public static Set<File> getConfigNamesFileFromDirs(String subPath, List<File> dirs) {
    List<String> patterns = new ArrayList<>();
    patterns.add(".*.config");
    patterns.add(".*.xml");
    return getConfigNamesFileFromDirs(subPath, dirs, patterns, null);
}
#method_after
public static Set<File> getConfigNamesFileFromDirs(String subPath, List<File> dirs) {
    List<String> patterns = new ArrayList<>();
    patterns.add(".*.config");
    patterns.add(".*.xml");
    return getConfigNamesFileFromDirs(subPath, dirs, patterns, false);
}
#end_block

#method_before
public static Set<File> getConfigNamesFileFromDirs(String subPath, List<File> dirs, List<String> configNamePatterns) {
    return getConfigNamesFileFromDirs(subPath, dirs, configNamePatterns, null);
}
#method_after
public static Set<File> getConfigNamesFileFromDirs(String subPath, List<File> dirs, List<String> configNamePatterns, boolean prioritizeHostConfig) {
    Set<File> configNames = new HashSet<>();
    for (File dir : dirs) {
        if (subPath != null) {
            dir = new File(dir, subPath);
        }
        if (!dir.isDirectory()) {
            CLog.d("%s doesn't exist or is not a directory.", dir.getAbsolutePath());
            continue;
        }
        try {
            for (String configNamePattern : configNamePatterns) {
                configNames.addAll(FileUtil.findFilesObject(dir, configNamePattern));
            }
        } catch (IOException e) {
            CLog.w("Failed to get test config files from directory %s", dir.getAbsolutePath());
        }
    }
    return dedupFiles(configNames, prioritizeHostConfig);
}
#end_block

#method_before
public static Set<File> getConfigNamesFileFromDirs(String subPath, List<File> dirs, List<String> configNamePatterns) {
    return getConfigNamesFileFromDirs(subPath, dirs, configNamePatterns, null);
}
#method_after
public static Set<File> getConfigNamesFileFromDirs(String subPath, List<File> dirs, List<String> configNamePatterns) {
    return getConfigNamesFileFromDirs(subPath, dirs, configNamePatterns, false);
}
#end_block

#method_before
private static Set<File> dedupFiles(Set<File> origSet, File priorDir) {
    Map<String, File> newMap = new HashMap<>();
    boolean hasPriorDir = (priorDir != null);
    Path priorDirPath = null;
    if (hasPriorDir) {
        priorDirPath = Paths.get(priorDir.getAbsolutePath());
    }
    for (File f : origSet) {
        if (!newMap.keySet().contains(f.getName())) {
            newMap.put(f.getName(), f);
        } else {
            if (hasPriorDir) {
                if (Paths.get(f.getAbsolutePath()).startsWith(priorDirPath)) {
                    newMap.put(f.getName(), f);
                }
            }
        }
    }
    return new HashSet<>(newMap.values());
}
#method_after
private static Set<File> dedupFiles(Set<File> origSet, boolean prioritizeHostConfig) {
    Map<String, File> newMap = new HashMap<>();
    for (File f : origSet) {
        if (!newMap.keySet().contains(f.getName())) {
            newMap.put(f.getName(), f);
        } else {
            if (prioritizeHostConfig && f.getAbsolutePath().contains(BuildInfoFileKey.HOST_LINKED_DIR.toString())) {
                newMap.put(f.getName(), f);
            } else if (!prioritizeHostConfig && f.getAbsolutePath().contains(BuildInfoFileKey.TARGET_LINKED_DIR.toString())) {
                newMap.put(f.getName(), f);
            }
        }
    }
    return new HashSet<>(newMap.values());
}
#end_block

#method_before
public LinkedHashMap<String, IConfiguration> loadingStrategy(Set<IAbi> abis, File testsDir, String suitePrefix, String suiteTag) {
    LinkedHashMap<String, IConfiguration> loadedConfigs = new LinkedHashMap<>();
    // Load configs that are part of the resources
    if (!mSkipJarLoading) {
        loadedConfigs.putAll(getModuleLoader().loadConfigsFromJars(abis, suitePrefix, suiteTag));
    }
    // Load the configs that are part of the tests dir
    if (mConfigPatterns.isEmpty()) {
        // If no special pattern was configured, use the default configuration patterns we know
        mConfigPatterns.add(".*\\.config");
        mConfigPatterns.add(".*\\.xml");
    }
    // If there are duplicate test configs for host/target, prioritize the host config, otherwise use the target config.
    File priorDir = getBuildInfo().getFile(BuildInfoKey.BuildInfoFileKey.TARGET_LINKED_DIR);
    if (mPrioritizeHostConfig) {
        priorDir = getBuildInfo().getFile(BuildInfoKey.BuildInfoFileKey.HOST_LINKED_DIR);
    }
    loadedConfigs.putAll(getModuleLoader().loadConfigsFromDirectory(testsDir, abis, suitePrefix, suiteTag, mConfigPatterns, priorDir));
    return loadedConfigs;
}
#method_after
public LinkedHashMap<String, IConfiguration> loadingStrategy(Set<IAbi> abis, File testsDir, String suitePrefix, String suiteTag) {
    LinkedHashMap<String, IConfiguration> loadedConfigs = new LinkedHashMap<>();
    // Load configs that are part of the resources
    if (!mSkipJarLoading) {
        loadedConfigs.putAll(getModuleLoader().loadConfigsFromJars(abis, suitePrefix, suiteTag));
    }
    // Load the configs that are part of the tests dir
    if (mConfigPatterns.isEmpty()) {
        // If no special pattern was configured, use the default configuration patterns we know
        mConfigPatterns.add(".*\\.config");
        mConfigPatterns.add(".*\\.xml");
    }
    loadedConfigs.putAll(getModuleLoader().loadConfigsFromDirectory(testsDir, abis, suitePrefix, suiteTag, mConfigPatterns, mPrioritizeHostConfig));
    return loadedConfigs;
}
#end_block

#method_before
public int nextJobSchedulerIdWithRange(int minInclusive, int maxInclusive) {
    synchronized (IdGenerator.class) {
        loadPreferences();
        int id = nextId(NEXT_JOB_SCHEDULER_ID_KEY);
        if (id < minInclusive || id > maxInclusive) {
            // outside the range, re-start at minInclusive.
            id = minInclusive;
            update(NEXT_JOB_SCHEDULER_ID_KEY, id + 1);
        }
        return id;
    }
}
#method_after
public int nextJobSchedulerIdWithRange(int minInclusive, int maxInclusive) {
    synchronized (IdGenerator.class) {
        loadPreferencesIfNecessary();
        int id = nextId(NEXT_JOB_SCHEDULER_ID_KEY);
        if (id < minInclusive || id > maxInclusive) {
            // outside the range, re-start at minInclusive.
            id = minInclusive;
            update(NEXT_JOB_SCHEDULER_ID_KEY, id + 1);
        }
        return id;
    }
}
#end_block

#method_before
public int nextFirebaseAlarmId() {
    synchronized (IdGenerator.class) {
        loadPreferences();
        return nextId(NEXT_FIREBASE_ALARM_ID_KEY);
    }
}
#method_after
public int nextFirebaseAlarmId() {
    synchronized (IdGenerator.class) {
        loadPreferencesIfNecessary();
        return nextId(NEXT_FIREBASE_ALARM_ID_KEY);
    }
}
#end_block

#method_before
public int nextAlarmManagerId() {
    synchronized (IdGenerator.class) {
        loadPreferences();
        return nextId(NEXT_ALARM_MANAGER_ID_KEY);
    }
}
#method_after
public int nextAlarmManagerId() {
    synchronized (IdGenerator.class) {
        loadPreferencesIfNecessary();
        return nextId(NEXT_ALARM_MANAGER_ID_KEY);
    }
}
#end_block

#method_before
@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    mTextClassificationManager = new TextClassificationManager(mContext);
    mTextClassificationContext = new TextClassificationContext.Builder(PACKAGE_NAME, TextClassifier.WIDGET_TYPE_TEXTVIEW).build();
    when(mContext.getPackageManager()).thenReturn(mPackageManager);
    when(mContext.getPackageName()).thenReturn(PACKAGE_NAME);
    when(mContext.getApplicationContext()).thenReturn(mContext);
    when(mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE)).thenReturn(InstrumentationRegistry.getTargetContext().getSystemService(Context.TEXT_CLASSIFICATION_SERVICE));
}
#method_after
@Before
public void setup() {
    MockitoAnnotations.initMocks(this);
    mTextClassificationManager = new TextClassificationManager(mContext);
    when(mContext.getPackageManager()).thenReturn(mPackageManager);
    when(mContext.getPackageName()).thenReturn(PACKAGE_NAME);
    when(mContext.getApplicationContext()).thenReturn(mContext);
    when(mContext.getSystemService(Context.TEXT_CLASSIFICATION_SERVICE)).thenReturn(InstrumentationRegistry.getTargetContext().getSystemService(Context.TEXT_CLASSIFICATION_SERVICE));
}
#end_block

#method_before
@Test
public void newTextLinksReplaceOldTextLinkSpans() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("9876543", TextClassifier.TYPE_PHONE, TextClassifier.TYPE_FLIGHT_NUMBER).addText(" ").addEntity("XX 987", TextClassifier.TYPE_FLIGHT_NUMBER, TextClassifier.TYPE_OTHER).build();
    final Spannable text = testObject.getText();
    when(mClassifier.generateLinks(any(TextLinks.Request.class))).thenReturn(testObject.getTextLinks());
    // Insert a TextLinkSpan before calling linkify to verify that the linkify call clears it.
    final TextLinks.TextLink oldLink = new TextLinks.TextLink(0, 7, noEntities(), null);
    final TextLinks.TextLinkSpan oldSpan = new TextLinks.TextLinkSpan(oldLink);
    text.setSpan(oldSpan, oldLink.getStart(), oldLink.getEnd(), 0);
    final TextLinks.TextLinkSpan[] oldSpans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(oldSpans).asList().hasSize(1);
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, PARAMS, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.TextLinkSpan[] spans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(spans).asList().hasSize(2);
    for (TextLinks.TextLinkSpan span : spans) {
        assertThat(text.getSpanStart(span)).isEqualTo(testObject.getStart(span));
        assertThat(text.getSpanEnd(span)).isEqualTo(testObject.getEnd(span));
    }
}
#method_after
@Test
public void newTextLinksReplaceOldTextLinkSpans() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("9876543", TextClassifier.TYPE_PHONE, TextClassifier.TYPE_FLIGHT_NUMBER).addText(" ").addEntity("XX 987", TextClassifier.TYPE_FLIGHT_NUMBER, TextClassifier.TYPE_OTHER).build();
    final Spannable text = testObject.getText();
    when(mClassifier.generateLinks(any(TextLinks.Request.class))).thenReturn(testObject.getTextLinks());
    // Insert a TextLinkSpan before calling linkify to verify that the linkify call clears it.
    final TextLinks.TextLink oldLink = new TextLinks.TextLink(0, 7, noEntities(), null);
    final TextLinks.TextLinkSpan oldSpan = createTextLinkSpan(oldLink);
    text.setSpan(oldSpan, oldLink.getStart(), oldLink.getEnd(), 0);
    final TextLinks.TextLinkSpan[] oldSpans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(oldSpans).asList().hasSize(1);
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, PARAMS, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.TextLinkSpan[] spans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(spans).asList().hasSize(2);
    for (TextLinks.TextLinkSpan span : spans) {
        assertThat(text.getSpanStart(span)).isEqualTo(testObject.getStart(span));
        assertThat(text.getSpanEnd(span)).isEqualTo(testObject.getEnd(span));
    }
}
#end_block

#method_before
@Test
public void useParams() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("email@android.com", TextClassifier.TYPE_EMAIL).build();
    final Spannable text = testObject.getText();
    final ArgumentCaptor<TextLinks.Request> requestCapture = ArgumentCaptor.forClass(TextLinks.Request.class);
    when(mClassifier.generateLinks(requestCapture.capture())).thenReturn(testObject.getTextLinks());
    when(mClassifier.getMaxGenerateLinksTextLength()).thenReturn(text.length());
    final TextLinks.TextLinkSpan span = new TextLinks.TextLinkSpan(null);
    final TextLinksParams params = new TextLinksParams.Builder().setEntityConfig(new TextClassifier.EntityConfig.Builder().build()).setDefaultLocales(LocaleListCompat.create(Locale.CANADA_FRENCH)).setSpanFactory(new TextLinks.SpanFactory() {

        @Override
        public TextLinks.TextLinkSpan createSpan(TextLinks.TextLink textLink) {
            return span;
        }
    }).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.Request request = requestCapture.getValue();
    assertThat(request.getText().toString()).isEqualTo(text.toString());
    assertThat(request.getEntityConfig()).isEqualTo(params.getEntityConfig());
    assertThat(request.getDefaultLocales()).isEqualTo(params.getDefaultLocales());
    final TextLinks.TextLinkSpan insertedSpan = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class)[0];
    assertThat(insertedSpan).isEqualTo(span);
}
#method_after
@Test
public void useParams() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("email@android.com", TextClassifier.TYPE_EMAIL).build();
    final Spannable text = testObject.getText();
    final ArgumentCaptor<TextLinks.Request> requestCapture = ArgumentCaptor.forClass(TextLinks.Request.class);
    when(mClassifier.generateLinks(requestCapture.capture())).thenReturn(testObject.getTextLinks());
    when(mClassifier.getMaxGenerateLinksTextLength()).thenReturn(text.length());
    final TextLinks.TextLinkSpan span = createTextLinkSpan(testObject.getTextLinks().getLinks().iterator().next());
    final SmartLinkifyParams params = new SmartLinkifyParams.Builder().setEntityConfig(new TextClassifier.EntityConfig.Builder().build()).setDefaultLocales(LocaleListCompat.create(Locale.CANADA_FRENCH)).setSpanFactory(new TextLinks.SpanFactory() {

        @Override
        public TextLinks.TextLinkSpan createSpan(TextLinks.TextLinkSpanData textLinkSpanData) {
            return span;
        }
    }).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.Request request = requestCapture.getValue();
    assertThat(request.getText().toString()).isEqualTo(text.toString());
    assertThat(request.getEntityConfig()).isEqualTo(params.getEntityConfig());
    assertThat(request.getDefaultLocales()).isEqualTo(params.getDefaultLocales());
    final TextLinks.TextLinkSpan insertedSpan = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class)[0];
    assertThat(insertedSpan).isEqualTo(span);
}
#end_block

#method_before
@Test
public void ignoreApplyStrategy() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("XX 987", TextClassifier.TYPE_FLIGHT_NUMBER).build();
    final Spannable text = testObject.getText();
    when(mClassifier.generateLinks(any(TextLinks.Request.class))).thenReturn(testObject.getTextLinks());
    // Insert a URLSpan before calling linkify to verify that the smart links are ignored.
    final URLSpan urlSpan = new URLSpan("http://flight.android.com/XX-987");
    text.setSpan(urlSpan, 0, text.length(), 0);
    final URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
    assertThat(urlSpans).asList().hasSize(1);
    final TextLinksParams params = new TextLinksParams.Builder().setApplyStrategy(TextLinks.APPLY_STRATEGY_IGNORE).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_NO_LINKS_APPLIED);
    final TextLinks.TextLinkSpan[] spans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(spans).asList().isEmpty();
}
#method_after
@Test
public void ignoreApplyStrategy() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("XX 987", TextClassifier.TYPE_FLIGHT_NUMBER).build();
    final Spannable text = testObject.getText();
    when(mClassifier.generateLinks(any(TextLinks.Request.class))).thenReturn(testObject.getTextLinks());
    // Insert a URLSpan before calling linkify to verify that the smart links are ignored.
    final URLSpan urlSpan = new URLSpan("http://flight.android.com/XX-987");
    text.setSpan(urlSpan, 0, text.length(), 0);
    final URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
    assertThat(urlSpans).asList().hasSize(1);
    final SmartLinkifyParams params = new SmartLinkifyParams.Builder().setApplyStrategy(TextLinks.APPLY_STRATEGY_IGNORE).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_NO_LINKS_APPLIED);
    final TextLinks.TextLinkSpan[] spans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(spans).asList().isEmpty();
}
#end_block

#method_before
@Test
public void replaceApplyStrategy() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("XX 987", TextClassifier.TYPE_FLIGHT_NUMBER).build();
    final Spannable text = testObject.getText();
    when(mClassifier.generateLinks(any(TextLinks.Request.class))).thenReturn(testObject.getTextLinks());
    // Insert a URLSpan before calling linkify to verify that the smart link replaces it.
    final URLSpan urlSpan = new URLSpan("http://flight.android.com/XX-987");
    text.setSpan(urlSpan, 0, text.length(), 0);
    final URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
    assertThat(urlSpans).asList().hasSize(1);
    final TextLinksParams params = new TextLinksParams.Builder().setApplyStrategy(TextLinks.APPLY_STRATEGY_REPLACE).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.TextLinkSpan[] spans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(spans).asList().hasSize(1);
    final TextLinks.TextLinkSpan span = spans[0];
    assertThat(text.getSpanStart(span)).isEqualTo(testObject.getStart(span));
    assertThat(text.getSpanEnd(span)).isEqualTo(testObject.getEnd(span));
}
#method_after
@Test
public void replaceApplyStrategy() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("XX 987", TextClassifier.TYPE_FLIGHT_NUMBER).build();
    final Spannable text = testObject.getText();
    when(mClassifier.generateLinks(any(TextLinks.Request.class))).thenReturn(testObject.getTextLinks());
    // Insert a URLSpan before calling linkify to verify that the smart link replaces it.
    final URLSpan urlSpan = new URLSpan("http://flight.android.com/XX-987");
    text.setSpan(urlSpan, 0, text.length(), 0);
    final URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
    assertThat(urlSpans).asList().hasSize(1);
    final SmartLinkifyParams params = new SmartLinkifyParams.Builder().setApplyStrategy(TextLinks.APPLY_STRATEGY_REPLACE).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifier, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.TextLinkSpan[] spans = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class);
    assertThat(spans).asList().hasSize(1);
    final TextLinks.TextLinkSpan span = spans[0];
    assertThat(text.getSpanStart(span)).isEqualTo(testObject.getStart(span));
    assertThat(text.getSpanEnd(span)).isEqualTo(testObject.getEnd(span));
}
#end_block

#method_before
int getStart(TextLinks.TextLinkSpan span) {
    for (TextLinks.TextLink link : mTextLinks.getLinks()) {
        if (span.getTextLink() == link) {
            return link.getStart();
        }
    }
    return -1;
}
#method_after
int getStart(TextLinks.TextLinkSpan span) {
    for (TextLinks.TextLink link : mTextLinks.getLinks()) {
        if (span.getTextLinkSpanData().getTextLink() == link) {
            return link.getStart();
        }
    }
    return -1;
}
#end_block

#method_before
int getEnd(TextLinks.TextLinkSpan span) {
    for (TextLinks.TextLink link : mTextLinks.getLinks()) {
        if (span.getTextLink() == link) {
            return link.getEnd();
        }
    }
    return -1;
}
#method_after
int getEnd(TextLinks.TextLinkSpan span) {
    for (TextLinks.TextLink link : mTextLinks.getLinks()) {
        if (span.getTextLinkSpanData().getTextLink() == link) {
            return link.getEnd();
        }
    }
    return -1;
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks);
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig);
}
#end_block

#method_before
@Override
public void onClick(View widget) {
    if (!(widget instanceof TextView)) {
        return;
    }
    final TextView textView = (TextView) widget;
    final CharSequence text = textView.getText();
    if (!(text instanceof Spanned)) {
        return;
    }
    final Spanned spanned = (Spanned) text;
    final int start = spanned.getSpanStart(this);
    final int end = spanned.getSpanEnd(this);
    final TextClassification.Request request = new TextClassification.Request.Builder(text, start, end).setReferenceTime(getReferenceTime()).setDefaultLocales(getLocales(textView)).build();
    final TextClassifier classifier = mTextLink.mTextClassifier;
    // TODO: Truncate the text.
    sWorkerExecutor.execute(new Runnable() {

        @Override
        public void run() {
            final TextClassification classification = classifier.classifyText(request);
            sMainThreadExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    if (!classification.getActions().isEmpty()) {
                        // TODO: Show the toolbar instead.
                        try {
                            classification.getActions().get(0).getActionIntent().send();
                        } catch (PendingIntent.CanceledException e) {
                            Log.e(LOG_TAG, "Error handling TextLinkSpan click", e);
                        }
                    }
                }
            });
        }
    });
}
#method_after
@Override
public void onClick(View widget) {
    if (!(widget instanceof TextView)) {
        return;
    }
    final TextView textView = (TextView) widget;
    final CharSequence text = textView.getText();
    if (!(text instanceof Spanned)) {
        return;
    }
    final Spanned spanned = (Spanned) text;
    final int start = spanned.getSpanStart(this);
    final int end = spanned.getSpanEnd(this);
    final TextClassification.Request request = new TextClassification.Request.Builder(text, start, end).setReferenceTime(mTextLinkSpanData.getReferenceTime()).setDefaultLocales(getLocales(textView)).build();
    final TextClassifier classifier = mTextLinkSpanData.getTextClassifier();
    // TODO: Truncate the text.
    sWorkerExecutor.execute(new Runnable() {

        @Override
        public void run() {
            final TextClassification classification = classifier.classifyText(request);
            sMainThreadExecutor.execute(new Runnable() {

                @Override
                public void run() {
                    if (!classification.getActions().isEmpty()) {
                        // TODO: Show the toolbar instead.
                        try {
                            classification.getActions().get(0).getActionIntent().send();
                        } catch (PendingIntent.CanceledException e) {
                            Log.e(LOG_TAG, "Error handling TextLinkSpan click", e);
                        }
                    }
                }
            });
        }
    });
}
#end_block

#method_before
private static void addLinksAsync(@NonNull Supplier<Spannable> textSupplier, @NonNull Context context, @NonNull String widgetType, @Nullable TextClassifier textClassifier, @Nullable TextLinksParams params, @Nullable CancellationSignal cancel, @Nullable Executor executor, @Nullable Callback callback) {
    final LinkifyTask task = new LinkifyTask(textSupplier, context, widgetType, textClassifier, params, callback);
    if (cancel != null) {
        cancel.setOnCancelListener(task);
    }
    if (executor != null) {
        task.executeOnExecutor(executor);
    } else {
        task.execute();
    }
}
#method_after
public static void addLinksAsync(@NonNull TextView textView, @Nullable SmartLinkifyParams params) {
    addLinksAsync(textView, null, /* classifier */
    params, null, /* cancel */
    null, /* executor */
    null);
}
#end_block

#method_before
@Override
protected TextLinks doInBackground(Void... nil) {
    final TextLinks textLinks = mTextClassifier.generateLinks(mRequest);
    textLinks.setTextClassifier(mTextClassifier);
    textLinks.setReferenceTime(mParams.getReferenceTime());
    return textLinks;
}
#method_after
@Override
protected TextLinks doInBackground(Void... nil) {
    return mTextClassifier.generateLinks(mRequest);
}
#end_block

#method_before
@Override
@UiThread
protected void onPostExecute(TextLinks links) {
    if (links.getLinks().isEmpty()) {
        mStatus = TextLinks.STATUS_NO_LINKS_FOUND;
        mCallback.onLinkify(mText, mStatus);
        return;
    }
    final Spannable text = mTextSupplier.get();
    if (mParams.canApply(text, links)) {
        // Remove old spans only for the part of the text we generated links for.
        final TextLinks.TextLinkSpan[] old = text.getSpans(0, mTruncatedText.length(), TextLinks.TextLinkSpan.class);
        for (int i = old.length - 1; i >= 0; i--) {
            text.removeSpan(old[i]);
        }
    }
    mStatus = mParams.apply(text, links);
    mCallback.onLinkify(text, mStatus);
}
#method_after
@Override
@UiThread
protected void onPostExecute(TextLinks links) {
    if (links.getLinks().isEmpty()) {
        mStatus = TextLinks.STATUS_NO_LINKS_FOUND;
        mCallback.onLinkify(mText, mStatus);
        return;
    }
    final Spannable text = mTextSupplier.get();
    if (mParams.canApply(text, links)) {
        // Remove old spans only for the part of the text we generated links for.
        final TextLinks.TextLinkSpan[] old = text.getSpans(0, mTruncatedText.length(), TextLinks.TextLinkSpan.class);
        for (int i = old.length - 1; i >= 0; i--) {
            text.removeSpan(old[i]);
        }
    }
    mStatus = mParams.apply(text, links, mTextClassifier);
    mCallback.onLinkify(text, mStatus);
}
#end_block

#method_before
@Before
public void setUp() {
    mContext = InstrumentationRegistry.getTargetContext();
    mReceiver = BlockingReceiver.registerForPendingIntent(mContext);
    final PendingIntent intent = mReceiver.getPendingIntent();
    final TextClassifier textClassifier = new TextClassifier() {

        @Override
        public TextClassification classifyText(@NonNull TextClassification.Request r) {
            final RemoteActionCompat remoteAction = new RemoteActionCompat(ICON, "title", "desc", intent);
            remoteAction.setShouldShowIcon(false);
            return new TextClassification.Builder().addAction(remoteAction).build();
        }
    };
    TextClassificationManager.of(mContext).setTextClassifier(textClassifier);
    final Map<String, Float> scores = new ArrayMap<>();
    scores.put(TextClassifier.TYPE_EMAIL, 1f);
    mTextLink = new TextLink(0, ENTITY.length(), scores, null);
    mTextLink.mTextClassifier = textClassifier;
}
#method_after
@Before
public void setUp() {
    mContext = InstrumentationRegistry.getTargetContext();
    mReceiver = BlockingReceiver.registerForPendingIntent(mContext);
    final PendingIntent intent = mReceiver.getPendingIntent();
    mTextClassifier = new TextClassifier() {

        @Override
        public TextClassification classifyText(@NonNull TextClassification.Request r) {
            final RemoteActionCompat remoteAction = new RemoteActionCompat(ICON, "title", "desc", intent);
            remoteAction.setShouldShowIcon(false);
            return new TextClassification.Builder().addAction(remoteAction).build();
        }
    };
    final Map<String, Float> scores = new ArrayMap<>();
    scores.put(TextClassifier.TYPE_EMAIL, 1f);
    mTextLink = new TextLink(0, ENTITY.length(), scores, null);
}
#end_block

#method_before
@Test
public void onClick() throws Exception {
    final TextLinkSpan span = new TextLinkSpan(mTextLink);
    final TextView textView = createTextViewWithSpan(span);
    span.onClick(textView);
    mReceiver.assertIntentReceived();
}
#method_after
@Test
public void onClick() throws Exception {
    final TextLinkSpan span = createTextLinkSpan(mTextLink);
    final TextView textView = createTextViewWithSpan(span);
    span.onClick(textView);
    mReceiver.assertIntentReceived();
}
#end_block

#method_before
@Test
public void onClick_unsupportedWidget() throws Exception {
    new TextLinkSpan(mTextLink).onClick(null);
    new TextLinkSpan(mTextLink).onClick(new View(mContext));
    mReceiver.assertIntentNotReceived();
}
#method_after
@Test
public void onClick_unsupportedWidget() throws Exception {
    createTextLinkSpan(mTextLink).onClick(null);
    createTextLinkSpan(mTextLink).onClick(new View(mContext));
    mReceiver.assertIntentNotReceived();
}
#end_block

#method_before
@Test
public void onClick_nonSpannedText() throws Exception {
    final TextLinkSpan span = new TextLinkSpan(mTextLink);
    final TextView textView = new TextView(mContext);
    textView.setText(TEXT);
    span.onClick(textView);
    mReceiver.assertIntentNotReceived();
}
#method_after
@Test
public void onClick_nonSpannedText() throws Exception {
    final TextLinkSpan span = createTextLinkSpan(mTextLink);
    final TextView textView = new TextView(mContext);
    textView.setText(TEXT);
    span.onClick(textView);
    mReceiver.assertIntentNotReceived();
}
#end_block

#method_before
@Test
public void onClick_noActions() throws Exception {
    final TextLinkSpan span = new TextLinkSpan(mTextLink);
    final TextView textView = createTextViewWithSpan(span);
    mTextLink.mTextClassifier = TextClassifier.NO_OP;
    span.onClick(textView);
    mReceiver.assertIntentNotReceived();
}
#method_after
@Test
public void onClick_noActions() throws Exception {
    mTextClassifier = TextClassifier.NO_OP;
    final TextLinkSpan span = createTextLinkSpan(mTextLink);
    final TextView textView = createTextViewWithSpan(span);
    span.onClick(textView);
    mReceiver.assertIntentNotReceived();
}
#end_block

#method_before
@Override
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(intent.getAction())) {
        // This is called when managed provisioning completes successfully without reboot.
        handleStatusUpdate(RESULT_OK, intent);
    } else if (ACTION_TEST_RESULT.equals(intent.getAction())) {
        handleLaunchTestResult(RESULT_OK, intent.getParcelableExtra(EXTRA_RESULT));
    }
}
#method_after
@Override
protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(intent.getAction())) {
        // This is called when managed provisioning completes successfully without reboot.
        handleStatusUpdate(RESULT_OK, intent);
    } else if (ACTION_TEST_RESULT.equals(intent.getAction())) {
        // Called when subtest cannot communicate test result from the profile via setResult().
        handleLaunchTestResult(RESULT_OK, intent.getParcelableExtra(EXTRA_RESULT));
    }
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) throws RemoteException {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
public void hey() {
    Log.d(TAG, "SERVER: hey");
}
#method_after
public void hey() {
    mCalled = true;
}
#end_block

#method_before
private void runClientSafeUnionTests() throws RemoteException {
    ISafeUnion safeunionInterface = ISafeUnion.getService();
    {
        // SafeUnionNoInitTest
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.hidl_no_init);
    }
    {
        // SafeUnionSimpleTest
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setA(safeUnion, (byte) -5);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.a);
        ExpectTrue(safeUnion.a() == (byte) -5);
        safeUnion = safeunionInterface.setD(safeUnion, Long.MAX_VALUE);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.d);
        ExpectTrue(safeUnion.d() == Long.MAX_VALUE);
    }
    {
        // SafeUnionArrayLikeTypesTest
        long[] testArray = new long[] { 1, -2, 3, -4, 5 };
        ArrayList<Long> testVector = new ArrayList<Long>(Arrays.asList(Long.MAX_VALUE));
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setF(safeUnion, testArray);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.f);
        ExpectDeepEq(testArray, safeUnion.f());
        safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setI(safeUnion, testVector);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.i);
        ExpectDeepEq(testVector, safeUnion.i());
    }
    {
        // SafeUnionStringTypeTest
        String testString = "This is an inordinately long test string.";
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setG(safeUnion, testString);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.g);
        ExpectDeepEq(testString, safeUnion.g());
    }
    {
        // SafeUnionNestedTest
        SmallSafeUnion smallSafeUnion = new SmallSafeUnion();
        smallSafeUnion.a((byte) 1);
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setL(safeUnion, smallSafeUnion);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.l);
        ExpectTrue(safeUnion.l().getDiscriminator() == SmallSafeUnion.hidl_discriminator.a);
        ExpectTrue(safeUnion.l().a() == (byte) 1);
    }
    {
        // SafeUnionInterfaceTest
        byte[] testArray = new byte[] { -1, -2, -3, 0, 1, 2, 3 };
        ArrayList<String> testVector = new ArrayList(Arrays.asList("So", "Many", "Words"));
        String testStringA = "Hello";
        String testStringB = "World";
        IOtherInterface otherInterface = IOtherInterface.getService();
        int[] testFds = new int[] {};
        int[] testInts = new int[] { 2, -32, 10, -4329454, 11, 24 };
        NativeHandle testHandle = new NativeHandle(testFds.clone(), testInts.clone());
        ArrayList<NativeHandle> testHandlesVector = new ArrayList<>();
        for (int i = 0; i < 128; i++) {
            testHandlesVector.add(new NativeHandle(testFds.clone(), testInts.clone()));
        }
        InterfaceTypeSafeUnion safeUnion = safeunionInterface.newInterfaceTypeSafeUnion();
        safeUnion = safeunionInterface.setInterfaceB(safeUnion, testArray);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.b);
        ExpectDeepEq(testArray, safeUnion.b());
        safeUnion.c(otherInterface);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.c);
        ExpectTrue(HidlSupport.interfacesEqual(otherInterface, safeUnion.c()));
        String result = safeUnion.c().concatTwoStrings(testStringA, testStringB);
        Expect(result, testStringA + testStringB);
        safeUnion = safeunionInterface.setInterfaceD(safeUnion, testStringA);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.d);
        Expect(testStringA, safeUnion.d());
        safeUnion = safeunionInterface.setInterfaceE(safeUnion, testVector);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.e);
        ExpectDeepEq(testVector, safeUnion.e());
        safeUnion = safeunionInterface.setInterfaceF(safeUnion, testHandle);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.f);
        ExpectDeepEq(testFds, safeUnion.f().getFdsAsIntArray());
        ExpectDeepEq(testInts, safeUnion.f().getInts());
        safeUnion = safeunionInterface.setInterfaceG(safeUnion, testHandlesVector);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.g);
        ExpectTrue(safeUnion.g().size() == testHandlesVector.size());
        for (int i = 0; i < testHandlesVector.size(); i++) {
            ExpectDeepEq(testFds, safeUnion.g().get(i).getFdsAsIntArray());
            ExpectDeepEq(testInts, safeUnion.g().get(i).getInts());
        }
    }
    {
        // SafeUnionNativeHandleTest
        int[] testFds = new int[] {};
        int[] testInts = new int[] { 2, -32, 10, -4329454, 11, 24 };
        NativeHandle testHandle = new NativeHandle(testFds.clone(), testInts.clone());
        NativeHandle[] testHandlesArray = new NativeHandle[5];
        for (int i = 0; i < testHandlesArray.length; i++) {
            testHandlesArray[i] = new NativeHandle(testFds.clone(), testInts.clone());
        }
        ArrayList<NativeHandle> testHandlesList = new ArrayList<NativeHandle>(Arrays.asList(testHandlesArray));
        HandleTypeSafeUnion safeUnion = safeunionInterface.newHandleTypeSafeUnion();
        safeUnion = safeunionInterface.setHandleA(safeUnion, testHandle);
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.a);
        ExpectDeepEq(testFds, safeUnion.a().getFdsAsIntArray());
        ExpectDeepEq(testInts, safeUnion.a().getInts());
        safeUnion = safeunionInterface.setHandleB(safeUnion, testHandlesArray);
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.b);
        ExpectTrue(safeUnion.b().length == testHandlesArray.length);
        for (int i = 0; i < testHandlesArray.length; i++) {
            ExpectDeepEq(testFds, safeUnion.b()[i].getFdsAsIntArray());
            ExpectDeepEq(testInts, safeUnion.b()[i].getInts());
        }
        safeUnion = safeunionInterface.setHandleC(safeUnion, testHandlesList);
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.c);
        ExpectTrue(safeUnion.c().size() == testHandlesList.size());
        for (int i = 0; i < testHandlesList.size(); i++) {
            ExpectDeepEq(testFds, safeUnion.c().get(i).getFdsAsIntArray());
            ExpectDeepEq(testInts, safeUnion.c().get(i).getInts());
        }
    }
    {
        // SafeUnionEqualityTest
        LargeSafeUnion one = safeunionInterface.newLargeSafeUnion();
        LargeSafeUnion two = safeunionInterface.newLargeSafeUnion();
        ExpectFalse(one.equals(two));
        one = safeunionInterface.setA(one, (byte) 1);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setB(two, (byte) 1);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setA(two, (byte) 2);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setA(two, (byte) 1);
        ExpectTrue(one.equals(two));
    }
    {
        // SafeUnionDeepEqualityTest
        ArrayList<Long> testVectorA = new ArrayList(Arrays.asList(1L, 2L, 3L));
        ArrayList<Long> testVectorB = new ArrayList(Arrays.asList(2L, 1L, 3L));
        LargeSafeUnion one = safeunionInterface.newLargeSafeUnion();
        LargeSafeUnion two = safeunionInterface.newLargeSafeUnion();
        one = safeunionInterface.setI(one, testVectorA);
        two = safeunionInterface.setI(two, testVectorB);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setI(two, (ArrayList<Long>) testVectorA.clone());
        ExpectTrue(one.equals(two));
    }
    {
        // SafeUnionHashCodeTest
        ArrayList<Boolean> testVector = new ArrayList(Arrays.asList(true, false, false, true, true));
        LargeSafeUnion one = safeunionInterface.newLargeSafeUnion();
        LargeSafeUnion two = safeunionInterface.newLargeSafeUnion();
        one = safeunionInterface.setH(one, testVector);
        two = safeunionInterface.setA(two, (byte) -5);
        ExpectFalse(one.hashCode() == two.hashCode());
        two = safeunionInterface.setH(two, (ArrayList<Boolean>) testVector.clone());
        ExpectTrue(one.hashCode() == two.hashCode());
    }
}
#method_after
private void runClientSafeUnionTests() throws RemoteException {
    ISafeUnion safeunionInterface = ISafeUnion.getService();
    {
        // SafeUnionNoInitTest
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.hidl_no_init);
    }
    {
        // SafeUnionSimpleTest
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setA(safeUnion, (byte) -5);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.a);
        ExpectTrue(safeUnion.a() == (byte) -5);
        safeUnion = safeunionInterface.setD(safeUnion, Long.MAX_VALUE);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.d);
        ExpectTrue(safeUnion.d() == Long.MAX_VALUE);
    }
    {
        // SafeUnionArrayLikeTypesTest
        long[] testArray = new long[] { 1, -2, 3, -4, 5 };
        ArrayList<Long> testVector = new ArrayList<Long>(Arrays.asList(Long.MAX_VALUE));
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setF(safeUnion, testArray);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.f);
        ExpectDeepEq(testArray, safeUnion.f());
        safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setI(safeUnion, testVector);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.i);
        ExpectDeepEq(testVector, safeUnion.i());
    }
    {
        // SafeUnionStringTypeTest
        String testString = "This is an inordinately long test string.";
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setG(safeUnion, testString);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.g);
        ExpectDeepEq(testString, safeUnion.g());
    }
    {
        // SafeUnionNestedTest
        SmallSafeUnion smallSafeUnion = new SmallSafeUnion();
        smallSafeUnion.a((byte) 1);
        LargeSafeUnion safeUnion = safeunionInterface.newLargeSafeUnion();
        safeUnion = safeunionInterface.setL(safeUnion, smallSafeUnion);
        ExpectTrue(safeUnion.getDiscriminator() == LargeSafeUnion.hidl_discriminator.l);
        ExpectTrue(safeUnion.l().getDiscriminator() == SmallSafeUnion.hidl_discriminator.a);
        ExpectTrue(safeUnion.l().a() == (byte) 1);
    }
    {
        // SafeUnionInterfaceNullNativeHandleTest
        InterfaceTypeSafeUnion safeUnion = new InterfaceTypeSafeUnion();
        safeUnion = safeunionInterface.setInterfaceF(safeUnion, null);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.f);
        ExpectTrue(safeUnion.f() == null);
    }
    {
        // SafeUnionInterfaceTest
        byte[] testArray = new byte[] { -1, -2, -3, 0, 1, 2, 3 };
        ArrayList<String> testVector = new ArrayList(Arrays.asList("So", "Many", "Words"));
        String testStringA = "Hello";
        String testStringB = "World";
        IOtherInterface otherInterface = IOtherInterface.getService();
        ArrayList<NativeHandle> testHandlesVector = new ArrayList<>();
        for (int i = 0; i < 128; i++) {
            testHandlesVector.add(new NativeHandle());
        }
        InterfaceTypeSafeUnion safeUnion = safeunionInterface.newInterfaceTypeSafeUnion();
        safeUnion = safeunionInterface.setInterfaceB(safeUnion, testArray);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.b);
        ExpectDeepEq(testArray, safeUnion.b());
        safeUnion.c(otherInterface);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.c);
        ExpectTrue(HidlSupport.interfacesEqual(otherInterface, safeUnion.c()));
        String result = safeUnion.c().concatTwoStrings(testStringA, testStringB);
        Expect(result, testStringA + testStringB);
        safeUnion = safeunionInterface.setInterfaceD(safeUnion, testStringA);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.d);
        Expect(testStringA, safeUnion.d());
        safeUnion = safeunionInterface.setInterfaceE(safeUnion, testVector);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.e);
        ExpectDeepEq(testVector, safeUnion.e());
        safeUnion = safeunionInterface.setInterfaceG(safeUnion, testHandlesVector);
        ExpectTrue(safeUnion.getDiscriminator() == InterfaceTypeSafeUnion.hidl_discriminator.g);
        ExpectTrue(safeUnion.g().size() == testHandlesVector.size());
        for (int i = 0; i < testHandlesVector.size(); i++) {
            ExpectFalse(safeUnion.g().get(i).getFd().valid());
        }
    }
    {
        // SafeUnionNullNativeHandleTest
        HandleTypeSafeUnion safeUnion = new HandleTypeSafeUnion();
        safeUnion = safeunionInterface.setHandleA(safeUnion, null);
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.a);
        ExpectTrue(safeUnion.a() == null);
    }
    {
        // SafeUnionDefaultNativeHandleTest
        NativeHandle[] testHandlesArray = new NativeHandle[5];
        for (int i = 0; i < testHandlesArray.length; i++) {
            testHandlesArray[i] = new NativeHandle();
        }
        ArrayList<NativeHandle> testHandlesList = new ArrayList<NativeHandle>(Arrays.asList(testHandlesArray));
        HandleTypeSafeUnion safeUnion = safeunionInterface.newHandleTypeSafeUnion();
        safeUnion = safeunionInterface.setHandleA(safeUnion, new NativeHandle());
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.a);
        ExpectFalse(safeUnion.a().getFd().valid());
        safeUnion = safeunionInterface.setHandleB(safeUnion, testHandlesArray);
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.b);
        ExpectTrue(safeUnion.b().length == testHandlesArray.length);
        for (int i = 0; i < testHandlesArray.length; i++) {
            ExpectFalse(safeUnion.b()[i].getFd().valid());
        }
        safeUnion = safeunionInterface.setHandleC(safeUnion, testHandlesList);
        ExpectTrue(safeUnion.getDiscriminator() == HandleTypeSafeUnion.hidl_discriminator.c);
        ExpectTrue(safeUnion.c().size() == testHandlesList.size());
        for (int i = 0; i < testHandlesList.size(); i++) {
            ExpectFalse(safeUnion.c().get(i).getFd().valid());
        }
    }
    {
        // SafeUnionEqualityTest
        LargeSafeUnion one = safeunionInterface.newLargeSafeUnion();
        LargeSafeUnion two = safeunionInterface.newLargeSafeUnion();
        ExpectFalse(one.equals(two));
        one = safeunionInterface.setA(one, (byte) 1);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setB(two, (byte) 1);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setA(two, (byte) 2);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setA(two, (byte) 1);
        ExpectTrue(one.equals(two));
    }
    {
        // SafeUnionDeepEqualityTest
        ArrayList<Long> testVectorA = new ArrayList(Arrays.asList(1L, 2L, 3L));
        ArrayList<Long> testVectorB = new ArrayList(Arrays.asList(2L, 1L, 3L));
        LargeSafeUnion one = safeunionInterface.newLargeSafeUnion();
        LargeSafeUnion two = safeunionInterface.newLargeSafeUnion();
        one = safeunionInterface.setI(one, testVectorA);
        two = safeunionInterface.setI(two, testVectorB);
        ExpectFalse(one.equals(two));
        two = safeunionInterface.setI(two, (ArrayList<Long>) testVectorA.clone());
        ExpectTrue(one.equals(two));
    }
    {
        // SafeUnionHashCodeTest
        ArrayList<Boolean> testVector = new ArrayList(Arrays.asList(true, false, false, true, true));
        LargeSafeUnion one = safeunionInterface.newLargeSafeUnion();
        LargeSafeUnion two = safeunionInterface.newLargeSafeUnion();
        one = safeunionInterface.setH(one, testVector);
        two = safeunionInterface.setA(two, (byte) -5);
        ExpectFalse(one.hashCode() == two.hashCode());
        two = safeunionInterface.setH(two, (ArrayList<Boolean>) testVector.clone());
        ExpectTrue(one.hashCode() == two.hashCode());
    }
}
#end_block

#method_before
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
            // this should never run
            ExpectTrue(false);
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService();
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService(true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService(false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService();
    proxy.ping();
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // BazHandlesTest
        int[] expectedInts = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, 21, 23 };
        MyHandle myHandle = proxy.createMyHandle();
        ExpectTrue(myHandle.guard == 666);
        ExpectDeepEq(expectedInts, myHandle.h.getInts());
        ExpectDeepEq(new int[0], myHandle.h.getFdsAsIntArray());
        ArrayList<NativeHandle> handles = proxy.createHandles(3);
        ExpectTrue(handles.size() == 3);
        for (int i = 0; i < handles.size(); i++) {
            ExpectDeepEq(expectedInts, handles.get(i).getInts());
            ExpectDeepEq(new int[0], handles.get(0).getFdsAsIntArray());
        }
    }
    {
        // testProxyEquals
        // TODO(b/68727931): test passthrough services as well.
        IBase proxy1 = IBase.getService();
        IBase proxy2 = IBase.getService();
        IBaz proxy3 = IBaz.getService();
        IBazCallback callback1 = new BazCallback();
        IBazCallback callback2 = new BazCallback();
        IServiceManager manager = IServiceManager.getService();
        // test hwbinder proxies
        // same proxy class
        ExpectEqual(proxy1, proxy2);
        // different proxy class
        ExpectEqual(proxy1, proxy3);
        // negative tests
        ExpectNotEqual(proxy1, null);
        // proxy != stub
        ExpectNotEqual(proxy1, callback1);
        ExpectNotEqual(proxy1, manager);
        // HidlSupport.interfacesEqual use overridden .equals for stubs
        ExpectEqual(callback1, callback1);
        ExpectEqual(callback1, callback2);
        callback1.hey();
        ExpectNotEqual(callback1, callback2);
        callback2.hey();
        ExpectEqual(callback1, callback2);
        // test hash for proxies
        java.util.HashSet<IBase> set = new java.util.HashSet<>();
        set.add(proxy1);
        // hash is stable
        ExpectTrue(set.contains(proxy1));
        ExpectTrue(set.contains(proxy2));
        ExpectFalse(set.contains(manager));
    }
    {
        IBaz baz = IBaz.getService();
        ExpectTrue(baz != null);
        IBaz.StructWithInterface swi = new IBaz.StructWithInterface();
        swi.dummy = baz;
        swi.number = 12345678;
        IBaz.StructWithInterface swi_back = baz.haveSomeStructWithInterface(swi);
        ExpectTrue(swi_back != null);
        ExpectTrue(swi_back.dummy != null);
        ExpectTrue(HidlSupport.interfacesEqual(baz, swi_back.dummy));
        ExpectTrue(swi_back.number == 12345678);
    }
    runClientSafeUnionTests();
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    final int cookie3 = 0x1483;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient1, cookie3));
    ExpectTrue(proxy.unlinkToDeath(recipient1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#method_after
private void client() throws RemoteException {
    ExpectDeepEq(null, null);
    ExpectDeepNe(null, new String());
    ExpectDeepNe(new String(), null);
    ExpectDeepEq(new String(), new String());
    ExpectDeepEq("hey", "hey");
    ExpectDeepEq(new int[] { 1, 2 }, new int[] { 1, 2 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 3 });
    ExpectDeepNe(new int[] { 1, 2 }, new int[] { 1, 2, 3 });
    ExpectDeepEq(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new int[][] { { 1, 2 }, { 3, 4 } }, new int[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new Integer[] { 1, 2 }, new Integer[] { 1, 2 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 3 });
    ExpectDeepNe(new Integer[] { 1, 2 }, new Integer[] { 1, 2, 3 });
    ExpectDeepEq(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 5 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2, 3 }, { 4, 5, 6 } });
    ExpectDeepNe(new Integer[][] { { 1, 2 }, { 3, 4 } }, new Integer[][] { { 1, 2 }, { 3, 4, 5 } });
    ExpectDeepEq(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2)));
    ExpectDeepNe(new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(1, 2, 3)));
    ExpectDeepEq(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 4 })), new ArrayList(Arrays.asList(new int[] { 1, 2 }, new int[] { 3, 5 })));
    ExpectDeepEq(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })));
    ExpectDeepNe(new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 4 })), new ArrayList(Arrays.asList(new Integer[] { 1, 2 }, new Integer[] { 3, 5 })));
    ExpectDeepEq(new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) }, new ArrayList[] { new ArrayList(Arrays.asList(1, 2)), new ArrayList(Arrays.asList(3, 4)) });
    {
        // Test proper exceptions are thrown
        try {
            IBase proxy = IBase.getService("this-doesn't-exist");
            // this should never run
            ExpectTrue(false);
        } catch (Exception e) {
            ExpectTrue(e instanceof NoSuchElementException);
        }
    }
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService();
        baseProxy.someBaseMethod();
        IBaz bazProxy = IBaz.castFrom(baseProxy);
        ExpectTrue(bazProxy != null);
        // IQuux is completely unrelated to IBase/IBaz, so the following
        // should fail, i.e. return null.
        IQuux quuxProxy = IQuux.castFrom(baseProxy);
        ExpectTrue(quuxProxy == null);
    }
    {
        // Test waiting API
        IBase baseProxyA = IBaz.getService(true);
        ExpectTrue(baseProxyA != null);
        IBase baseProxyB = IBaz.getService(false);
        ExpectTrue(baseProxyB != null);
    }
    IBaz proxy = IBaz.getService();
    proxy.ping();
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        ExpectTrue(result.equals(foo));
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] expectedOutputArray = new IBase.Foo[2];
        expectedOutputArray[0] = inputArray[1];
        expectedOutputArray[1] = inputArray[0];
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        ExpectTrue(java.util.Objects.deepEquals(outputArray, expectedOutputArray));
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> expectedOutputVec = new ArrayList<IBase.Foo>();
        expectedOutputVec.add(inputVec.get(1));
        expectedOutputVec.add(inputVec.get(0));
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        ExpectTrue(java.util.Objects.deepEquals(outputVec, expectedOutputVec));
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray expectedOut = new IBase.VectorOfArray();
        int n = in.addresses.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.addresses.add(in.addresses.get(n - 1 - i));
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        ExpectTrue(out.equals(expectedOut));
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> expectedOut = new ArrayList<byte[]>();
        int n = in.size();
        for (int i = 0; i < n; ++i) {
            expectedOut.add(in.get(n - 1 - i));
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        ExpectTrue(out.size() == expectedOut.size());
        for (int i = 0; i < n; ++i) {
            ExpectTrue(java.util.Objects.deepEquals(out.get(i), expectedOut.get(i)));
        }
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        IBase.StringMatrix3x5 expectedOut = new IBase.StringMatrix3x5();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut.s[j][i] = in.s[i][j];
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(out.equals(expectedOut));
    }
    {
        String[][] in = new String[5][3];
        String[][] expectedOut = new String[3][5];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
                expectedOut[j][i] = in[i][j];
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        ExpectTrue(java.util.Arrays.deepEquals(out, expectedOut));
    }
    ExpectTrue(proxy.someBoolMethod(true) == false);
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        boolean[] resultArray = proxy.someBoolArrayMethod(someBoolArray);
        ExpectTrue(resultArray[0] == false);
        ExpectTrue(resultArray[1] == true);
        ExpectTrue(resultArray[2] == false);
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        ArrayList<Boolean> resultVec = proxy.someBoolVectorMethod(someBoolVec);
        ExpectTrue(resultVec.get(0) == false);
        ExpectTrue(resultVec.get(1) == true);
        ExpectTrue(resultVec.get(2) == false);
    }
    proxy.doThis(1.0f);
    ExpectTrue(proxy.doThatAndReturnSomething(1) == 666);
    ExpectTrue(proxy.doQuiteABit(1, 2L, 3.0f, 4.0) == 666.5);
    {
        int[] paramArray = new int[15];
        int[] expectedOutArray = new int[32];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        ArrayList<Integer> expectedOutVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
            expectedOutArray[i] = 2 * i;
            expectedOutArray[15 + i] = i;
            expectedOutVec.add(2 * i);
        }
        expectedOutArray[30] = 1;
        expectedOutArray[31] = 2;
        int[] outArray = proxy.doSomethingElse(paramArray);
        ExpectTrue(java.util.Objects.deepEquals(outArray, expectedOutArray));
        ArrayList<Integer> outVec = proxy.mapThisVector(paramVec);
        java.util.Objects.equals(outVec, expectedOutVec);
    }
    Expect(proxy.doStuffAndReturnAString(), "Hello, world!");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    ExpectTrue(proxy.useAnEnum(IBaz.SomeEnum.goober) == -64);
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        String[] expectedOutArray = new String[2];
        expectedOutArray[0] = "Hello";
        expectedOutArray[1] = "World";
        String[] outArray = proxy.haveSomeStrings(stringArray);
        ExpectTrue(java.util.Arrays.deepEquals(outArray, expectedOutArray));
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        ArrayList<String> expectedOutVec = new ArrayList<String>();
        expectedOutVec.add("Hello");
        expectedOutVec.add("World");
        ExpectTrue(expectedOutVec.equals(proxy.haveAStringVec(stringVec)));
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    {
        // Ensure that native parcel is cleared even if the corresponding
        // Java object isn't GC'd.
        ArrayList<Integer> data4K = new ArrayList<>(1024);
        for (int i = 0; i < 1024; i++) {
            data4K.add(i);
        }
        for (int i = 0; i < 1024; i++) {
            // kernel binder buffer, and will fail.
            try {
                proxy.mapThisVector(data4K);
            } catch (RemoteException ex) {
                throw new RuntimeException("Failed at call #" + Integer.toString(i), ex);
            }
        }
    }
    {
        // TestArrays
        IBase.LotsOfPrimitiveArrays in = new IBase.LotsOfPrimitiveArrays();
        for (int i = 0; i < 128; ++i) {
            in.byte1[i] = (byte) i;
            in.boolean1[i] = (i & 4) != 0;
            in.double1[i] = i;
        }
        int m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 128; ++j, ++m) {
                in.byte2[i][j] = (byte) m;
                in.boolean2[i][j] = (m & 4) != 0;
                in.double2[i][j] = m;
            }
        }
        m = 0;
        for (int i = 0; i < 8; ++i) {
            for (int j = 0; j < 16; ++j) {
                for (int k = 0; k < 128; ++k, ++m) {
                    in.byte3[i][j][k] = (byte) m;
                    in.boolean3[i][j][k] = (m & 4) != 0;
                    in.double3[i][j][k] = m;
                }
            }
        }
        IBase.LotsOfPrimitiveArrays out = proxy.testArrays(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testByteVecs
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            byte[] elem = new byte[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (byte) k;
            }
            in.add(elem);
        }
        ArrayList<byte[]> out = proxy.testByteVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testBooleanVecs
        ArrayList<boolean[]> in = new ArrayList<boolean[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            boolean[] elem = new boolean[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = (k & 4) != 0;
            }
            in.add(elem);
        }
        ArrayList<boolean[]> out = proxy.testBooleanVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testDoubleVecs
        ArrayList<double[]> in = new ArrayList<double[]>();
        int k = 0;
        for (int i = 0; i < in.size(); ++i) {
            double[] elem = new double[128];
            for (int j = 0; j < 128; ++j, ++k) {
                elem[j] = k;
            }
            in.add(elem);
        }
        ArrayList<double[]> out = proxy.testDoubleVecs(in);
        ExpectTrue(in.equals(out));
    }
    {
        // testProxyEquals
        // TODO(b/68727931): test passthrough services as well.
        IBase proxy1 = IBase.getService();
        IBase proxy2 = IBase.getService();
        IBaz proxy3 = IBaz.getService();
        IBazCallback callback1 = new BazCallback();
        IBazCallback callback2 = new BazCallback();
        IServiceManager manager = IServiceManager.getService();
        // test hwbinder proxies
        // same proxy class
        ExpectEqual(proxy1, proxy2);
        // different proxy class
        ExpectEqual(proxy1, proxy3);
        // negative tests
        ExpectNotEqual(proxy1, null);
        // proxy != stub
        ExpectNotEqual(proxy1, callback1);
        ExpectNotEqual(proxy1, manager);
        // HidlSupport.interfacesEqual use overridden .equals for stubs
        ExpectEqual(callback1, callback1);
        ExpectEqual(callback1, callback2);
        callback1.hey();
        ExpectNotEqual(callback1, callback2);
        callback2.hey();
        ExpectEqual(callback1, callback2);
        // test hash for proxies
        java.util.HashSet<IBase> set = new java.util.HashSet<>();
        set.add(proxy1);
        // hash is stable
        ExpectTrue(set.contains(proxy1));
        ExpectTrue(set.contains(proxy2));
        ExpectFalse(set.contains(manager));
    }
    {
        IBaz baz = IBaz.getService();
        ExpectTrue(baz != null);
        IBaz.StructWithInterface swi = new IBaz.StructWithInterface();
        swi.dummy = baz;
        swi.number = 12345678;
        IBaz.StructWithInterface swi_back = baz.haveSomeStructWithInterface(swi);
        ExpectTrue(swi_back != null);
        ExpectTrue(swi_back.dummy != null);
        ExpectTrue(HidlSupport.interfacesEqual(baz, swi_back.dummy));
        ExpectTrue(swi_back.number == 12345678);
    }
    runClientSafeUnionTests();
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    final int cookie3 = 0x1483;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient1, cookie3));
    ExpectTrue(proxy.unlinkToDeath(recipient1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#end_block

#method_before
public Bundle toBundle() {
    Bundle bundle = new Bundle();
    bundle.putBundle(EXTRA_ICON, mIcon.toBundle());
    bundle.putCharSequence(EXTRA_TITLE, mTitle);
    bundle.putCharSequence(EXTRA_CONTENT_DESCRIPTION, mContentDescription);
    bundle.putParcelable(EXTRA_ACTION_INTENT, mActionIntent);
    bundle.putBoolean(EXTRA_ENABLED, mEnabled);
    bundle.putBoolean(EXTRA_SHOULD_SHOW_ICON, mShouldShowIcon);
    return bundle;
}
#method_after
@NonNull
public Bundle toBundle() {
    Bundle bundle = new Bundle();
    bundle.putBundle(EXTRA_ICON, mIcon.toBundle());
    bundle.putCharSequence(EXTRA_TITLE, mTitle);
    bundle.putCharSequence(EXTRA_CONTENT_DESCRIPTION, mContentDescription);
    bundle.putParcelable(EXTRA_ACTION_INTENT, mActionIntent);
    bundle.putBoolean(EXTRA_ENABLED, mEnabled);
    bundle.putBoolean(EXTRA_SHOULD_SHOW_ICON, mShouldShowIcon);
    return bundle;
}
#end_block

#method_before
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mRouteForTouchedVolumeSlider to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_STOP_TRACKING_TOUCH), UPDATE_VOLUME_DELAY_MS);
}
#method_after
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mRouteForTouchedVolumeSlider to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    mHandler.sendEmptyMessageDelayed(MSG_STOP_TRACKING_TOUCH, UPDATE_VOLUME_DELAY_MS);
}
#end_block

#method_before
@Override
public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
    if (fromUser || mRouteForClickedMuteButton != null) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        MediaRouteVolumeSliderHolder holder = mVolumeSliderHolderMap.get(route.getId());
        if (holder != null) {
            boolean wasMuted = holder.getMuteButton().isActivated();
            if ((wasMuted && progress > MUTED_VOLUME) || (!wasMuted && progress == MUTED_VOLUME)) {
                holder.toggleMute();
            }
        }
        route.requestSetVolume(progress);
        if (mRouteForClickedMuteButton != null) {
            // Defer resetting mRouteForClickedMuteButton to allow the media route provider
            // a little time to settle into its new state and publish the final
            // volume update.
            mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_CLICK_MUTE_BUTTON), UPDATE_VOLUME_DELAY_MS);
        }
    }
}
#method_after
@Override
public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
    if (fromUser) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        MediaRouteVolumeSliderHolder holder = mVolumeSliderHolderMap.get(route.getId());
        if (holder != null) {
            holder.setMute(progress == MUTED_VOLUME);
        }
        route.requestSetVolume(progress);
    }
}
#end_block

#method_before
public void updateVolume() {
    MediaRouter.RouteInfo route = getRoute();
    ImageButton muteButton = getMuteButton();
    MediaRouteVolumeSlider volumeSlider = getVolumeSlider();
    int volume = route.getVolume();
    boolean isMuted = (volume == MUTED_VOLUME);
    muteButton.setActivated(isMuted);
    volumeSlider.setProgress(volume);
}
#method_after
void updateVolume() {
    int volume = mRoute.getVolume();
    setMute(volume == MUTED_VOLUME);
    mVolumeSlider.setProgress(volume);
}
#end_block

#method_before
public int getUnmutedVolume() {
    MediaRouter.RouteInfo route = getRoute();
    Integer beforeMuteVolume = mBeforeMuteVolumeMap.get(route.getId());
    return (beforeMuteVolume == null) ? MIN_UNMUTED_VOLUME : Math.max(MIN_UNMUTED_VOLUME, beforeMuteVolume);
}
#method_after
int getUnmutedVolume() {
    Integer beforeMuteVolume = mBeforeMuteVolumeMap.get(mRoute.getId());
    return (beforeMuteVolume == null) ? MIN_UNMUTED_VOLUME : Math.max(MIN_UNMUTED_VOLUME, beforeMuteVolume);
}
#end_block

#method_before
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    int volume = route.getVolume();
    boolean isMuted = (volume == MUTED_VOLUME);
    mRoute = route;
    mTextView.setText(route.getName().toUpperCase());
    mMuteButton.setActivated(isMuted);
    setMuteButtonClickListener();
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(volume);
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
}
#method_after
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    super.bindRouteVolumeSliderHolder(route);
    mTextView.setText(route.getName());
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    int volume = route.getVolume();
    boolean isMuted = (volume == MUTED_VOLUME);
    boolean selected = isSelectedRoute(route);
    mRoute = route;
    mImageView.setImageDrawable(getIconDrawable(route));
    mMuteButton.setActivated(isMuted);
    setMuteButtonClickListener();
    mTextView.setText(route.getName());
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(route.getVolume());
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mSelectButtonClickListener);
    // TODO(b/111624415): Make button works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setSelected(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setEnabled(false);
    }
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    boolean selected = isSelectedRoute(route);
    super.bindRouteVolumeSliderHolder(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setChecked(false);
        mCheckBox.setEnabled(false);
    }
}
#end_block

#method_before
@Test
public void testScreenReaderFocusable_propagatesToAccessibilityNodeInfo() {
    if (Build.VERSION.SDK_INT >= 19) {
        assertThat(ViewCompat.isScreenReaderFocusable(mView), is(false));
        assertThat(getCompatForView(mView).isScreenReaderFocusable(), is(false));
        ViewCompat.setScreenReaderFocusable(mView, true);
        assertThat(ViewCompat.isScreenReaderFocusable(mView), is(true));
        assertThat(getCompatForView(mView).isScreenReaderFocusable(), is(true));
        // The value should still propagate even if we attach and detach another delegate compat
        ViewCompat.setAccessibilityDelegate(mView, new AccessibilityDelegateCompat());
        assertThat(getCompatForView(mView).isScreenReaderFocusable(), is(true));
        ViewCompat.setAccessibilityDelegate(mView, null);
        assertThat(getCompatForView(mView).isScreenReaderFocusable(), is(true));
    }
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 19)
public void testScreenReaderFocusable_propagatesToAccessibilityNodeInfo() {
    assertThat(ViewCompat.isScreenReaderFocusable(mView), is(false));
    assertThat(getNodeCompatForView(mView).isScreenReaderFocusable(), is(false));
    ViewCompat.setScreenReaderFocusable(mView, true);
    assertThat(ViewCompat.isScreenReaderFocusable(mView), is(true));
    assertThat(getNodeCompatForView(mView).isScreenReaderFocusable(), is(true));
    // The value should still propagate even if we attach and detach another delegate compat
    ViewCompat.setAccessibilityDelegate(mView, new AccessibilityDelegateCompat());
    assertThat(getNodeCompatForView(mView).isScreenReaderFocusable(), is(true));
    ViewCompat.setAccessibilityDelegate(mView, null);
    assertThat(getNodeCompatForView(mView).isScreenReaderFocusable(), is(true));
}
#end_block

#method_before
@Test
public void testAccessibilityHeading_propagatesToAccessibilityNodeInfo() {
    if (Build.VERSION.SDK_INT >= 19) {
        assertThat(ViewCompat.isAccessibilityHeading(mView), is(false));
        assertThat(getCompatForView(mView).isHeading(), is(false));
        ViewCompat.setAccessibilityHeading(mView, true);
        assertThat(ViewCompat.isAccessibilityHeading(mView), is(true));
        assertThat(getCompatForView(mView).isHeading(), is(true));
        // The value should still propagate even if we attach and detach another delegate compat
        ViewCompat.setAccessibilityDelegate(mView, new AccessibilityDelegateCompat());
        assertThat(getCompatForView(mView).isHeading(), is(true));
        ViewCompat.setAccessibilityDelegate(mView, null);
        assertThat(getCompatForView(mView).isHeading(), is(true));
    }
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 19)
public void testAccessibilityHeading_propagatesToAccessibilityNodeInfo() {
    assertThat(ViewCompat.isAccessibilityHeading(mView), is(false));
    assertThat(getNodeCompatForView(mView).isHeading(), is(false));
    ViewCompat.setAccessibilityHeading(mView, true);
    assertThat(ViewCompat.isAccessibilityHeading(mView), is(true));
    assertThat(getNodeCompatForView(mView).isHeading(), is(true));
    // The value should still propagate even if we attach and detach another delegate compat
    ViewCompat.setAccessibilityDelegate(mView, new AccessibilityDelegateCompat());
    assertThat(getNodeCompatForView(mView).isHeading(), is(true));
    ViewCompat.setAccessibilityDelegate(mView, null);
    assertThat(getNodeCompatForView(mView).isHeading(), is(true));
}
#end_block

#method_before
private void refreshLastUpdatedLabel(boolean visibility) {
    if (mShowLastUpdated && mSliceMetadata != null && !mSliceMetadata.isNeverExpired()) {
        if (visibility) {
            mHandler.postDelayed(mRefreshLastUpdated, mSliceMetadata.isExpired() ? REFRESH_LAST_UPDATED_IN_MILLIS : mSliceMetadata.getTimeToExpiry() + REFRESH_LAST_UPDATED_IN_MILLIS);
        } else {
            mHandler.removeCallbacks(mRefreshLastUpdated);
        }
    }
}
#method_after
private void refreshLastUpdatedLabel(boolean visibility) {
    if (mShowLastUpdated && mSliceMetadata != null && !mSliceMetadata.neverExpires()) {
        if (visibility) {
            mHandler.postDelayed(mRefreshLastUpdated, mSliceMetadata.isExpired() ? REFRESH_LAST_UPDATED_IN_MILLIS : mSliceMetadata.getTimeToExpiry() + REFRESH_LAST_UPDATED_IN_MILLIS);
        } else {
            mHandler.removeCallbacks(mRefreshLastUpdated);
        }
    }
}
#end_block

#method_before
static RILRequest obtain(int request, Message result, WorkSource workSource) {
    RILRequest rr = obtain(request, result);
    if (workSource != null) {
        rr.mWorkSource = workSource;
        rr.mClientId = String.valueOf(workSource.get(0)) + ":" + workSource.getName(0);
    } else {
        Rlog.e(LOG_TAG, "null workSource " + request);
    }
    return rr;
}
#method_after
/**
 * Retrieves a new RILRequest instance from the pool and sets the clientId
 *
 * @param request RIL_REQUEST_*
 * @param result sent when operation completes
 * @param workSource WorkSource to track the client
 * @return a RILRequest instance from the pool.
 */
public static RILRequest obtain(int request, Message result, WorkSource workSource) {
    RILRequest rr = obtain(request, result);
    if (workSource != null) {
        rr.mWorkSource = workSource;
        rr.mClientId = rr.getWorkSourceClientId();
    } else {
        Rlog.e(LOG_TAG, "null workSource " + request);
    }
    return rr;
}
#end_block

#method_before
private void acquireWakeLock(RILRequest rr, int wakeLockType) {
    synchronized (rr) {
        if (rr.mWakeLockType != INVALID_WAKELOCK) {
            Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
            return;
        }
        switch(wakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mWakeLock.acquire();
                    mWakeLockCount++;
                    mWlSequenceNum++;
                    String clientId = getWorkSourceClientId(rr.mWorkSource);
                    if (!mClientWakelockTracker.isClientActive(clientId)) {
                        mActiveWakelockWorkSource.add(rr.mWorkSource);
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                    }
                    mClientWakelockTracker.startTracking(rr.mClientId, rr.mRequest, rr.mSerial, mWakeLockCount);
                    Message msg = mRilHandler.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mWlSequenceNum;
                    mRilHandler.sendMessageDelayed(msg, mWakeLockTimeout);
                }
                break;
            case FOR_ACK_WAKELOCK:
                synchronized (mAckWakeLock) {
                    mAckWakeLock.acquire();
                    mAckWlSequenceNum++;
                    Message msg = mRilHandler.obtainMessage(EVENT_ACK_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mAckWlSequenceNum;
                    mRilHandler.sendMessageDelayed(msg, mAckWakeLockTimeout);
                }
                break;
            default:
                // WTF
                Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                return;
        }
        rr.mWakeLockType = wakeLockType;
    }
}
#method_after
private void acquireWakeLock(RILRequest rr, int wakeLockType) {
    synchronized (rr) {
        if (rr.mWakeLockType != INVALID_WAKELOCK) {
            Rlog.d(RILJ_LOG_TAG, "Failed to aquire wakelock for " + rr.serialString());
            return;
        }
        switch(wakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mWakeLock.acquire();
                    mWakeLockCount++;
                    mWlSequenceNum++;
                    String clientId = rr.getWorkSourceClientId();
                    if (!mClientWakelockTracker.isClientActive(clientId)) {
                        mActiveWakelockWorkSource.add(rr.mWorkSource);
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                    }
                    mClientWakelockTracker.startTracking(rr.mClientId, rr.mRequest, rr.mSerial, mWakeLockCount);
                    Message msg = mRilHandler.obtainMessage(EVENT_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mWlSequenceNum;
                    mRilHandler.sendMessageDelayed(msg, mWakeLockTimeout);
                }
                break;
            case FOR_ACK_WAKELOCK:
                synchronized (mAckWakeLock) {
                    mAckWakeLock.acquire();
                    mAckWlSequenceNum++;
                    Message msg = mRilHandler.obtainMessage(EVENT_ACK_WAKE_LOCK_TIMEOUT);
                    msg.arg1 = mAckWlSequenceNum;
                    mRilHandler.sendMessageDelayed(msg, mAckWakeLockTimeout);
                }
                break;
            default:
                // WTF
                Rlog.w(RILJ_LOG_TAG, "Acquiring Invalid Wakelock type " + wakeLockType);
                return;
        }
        rr.mWakeLockType = wakeLockType;
    }
}
#end_block

#method_before
private void decrementWakeLock(RILRequest rr) {
    synchronized (rr) {
        switch(rr.mWakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mClientWakelockTracker.stopTracking(rr.mClientId, rr.mRequest, rr.mSerial, (mWakeLockCount > 1) ? mWakeLockCount - 1 : 0);
                    String clientId = getWorkSourceClientId(rr.mWorkSource);
                    if (!mClientWakelockTracker.isClientActive(clientId)) {
                        mActiveWakelockWorkSource.remove(rr.mWorkSource);
                        if (mActiveWakelockWorkSource.size() == 0) {
                            mActiveWakelockWorkSource = new WorkSource();
                        }
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                    }
                    if (mWakeLockCount > 1) {
                        mWakeLockCount--;
                    } else {
                        mWakeLockCount = 0;
                        mWakeLock.release();
                    }
                }
                break;
            case FOR_ACK_WAKELOCK:
                // We do not decrement the ACK wakelock
                break;
            case INVALID_WAKELOCK:
                break;
            default:
                Rlog.w(RILJ_LOG_TAG, "Decrementing Invalid Wakelock type " + rr.mWakeLockType);
        }
        rr.mWakeLockType = INVALID_WAKELOCK;
    }
}
#method_after
private void decrementWakeLock(RILRequest rr) {
    synchronized (rr) {
        switch(rr.mWakeLockType) {
            case FOR_WAKELOCK:
                synchronized (mWakeLock) {
                    mClientWakelockTracker.stopTracking(rr.mClientId, rr.mRequest, rr.mSerial, (mWakeLockCount > 1) ? mWakeLockCount - 1 : 0);
                    String clientId = rr.getWorkSourceClientId();
                    if (!mClientWakelockTracker.isClientActive(clientId)) {
                        mActiveWakelockWorkSource.remove(rr.mWorkSource);
                        mWakeLock.setWorkSource(mActiveWakelockWorkSource);
                    }
                    if (mWakeLockCount > 1) {
                        mWakeLockCount--;
                    } else {
                        mWakeLockCount = 0;
                        mWakeLock.release();
                    }
                }
                break;
            case FOR_ACK_WAKELOCK:
                // We do not decrement the ACK wakelock
                break;
            case INVALID_WAKELOCK:
                break;
            default:
                Rlog.w(RILJ_LOG_TAG, "Decrementing Invalid Wakelock type " + rr.mWakeLockType);
        }
        rr.mWakeLockType = INVALID_WAKELOCK;
    }
}
#end_block

#method_before
static Drawable getDefaultDrawableIcon(Context context) {
    if (sDefaultIcon == null) {
        sDefaultIcon = getDrawableIcon(context, 0);
    }
    return sDefaultIcon;
}
#method_after
static Drawable getDefaultDrawableIcon(Context context) {
    return getDrawableIcon(context, R.attr.mediaRouteDefaultIconDrawable);
}
#end_block

#method_before
static Drawable getTvDrawableIcon(Context context) {
    if (sTvIcon == null) {
        sTvIcon = getDrawableIcon(context, 1);
    }
    return sTvIcon;
}
#method_after
static Drawable getTvDrawableIcon(Context context) {
    return getDrawableIcon(context, R.attr.mediaRouteTvIconDrawable);
}
#end_block

#method_before
static Drawable getSpeakerDrawableIcon(Context context) {
    if (sSpeakerIcon == null) {
        sSpeakerIcon = getDrawableIcon(context, 2);
    }
    return sSpeakerIcon;
}
#method_after
static Drawable getSpeakerDrawableIcon(Context context) {
    return getDrawableIcon(context, R.attr.mediaRouteSpeakerIconDrawable);
}
#end_block

#method_before
private static Drawable getDrawableIcon(Context context, int resId) {
    TypedArray styledAttributes = context.obtainStyledAttributes(new int[] { R.attr.mediaRouteDefaultIconDrawable, R.attr.mediaRouteTvIconDrawable, R.attr.mediaRouteSpeakerIconDrawable, R.attr.mediaRouteSpeakerGroupIconDrawable, R.attr.mediaRouteVolumeOnDrawable, R.attr.mediaRouteVolumeOffDrawable });
    Drawable icon = styledAttributes.getDrawable(resId);
    styledAttributes.recycle();
    return icon;
}
#method_after
private static Drawable getDrawableIcon(Context context, int resId) {
    TypedArray styledAttributes = context.obtainStyledAttributes(new int[] { resId });
    Drawable icon = styledAttributes.getDrawable(0);
    // different color icon for LightTheme, change color of the icon for the latter.
    if (USE_SUPPORT_DYNAMIC_GROUP && isLightTheme(context)) {
        int tintColor = context.getResources().getColor(COLOR_DARK_ON_LIGHT_BACKGROUND_RES_ID);
        DrawableCompat.setTint(icon, tintColor);
    }
    styledAttributes.recycle();
    return icon;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mLastVolumes = new HashMap<>();
    mMetadataLayout = findViewById(R.id.mr_cast_meta);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.mr_cast_dialog);
    mCloseButton = findViewById(R.id.mr_cast_close_button);
    mCloseButton.setColorFilter(COLOR_WHITE_ON_DARK_BACKGROUND);
    mCloseButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    mStopCastingButton = findViewById(R.id.mr_cast_stop_button);
    mStopCastingButton.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mStopCastingButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mSelectedRoute.isSelected()) {
                mRouter.unselect(MediaRouter.UNSELECT_REASON_STOPPED);
            }
            dismiss();
        }
    });
    mAdapter = new RecyclerAdapter();
    mRecyclerView = findViewById(R.id.mr_cast_list);
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setLayoutManager(new LinearLayoutManager(mContext));
    mVolumeChangeListener = new VolumeChangeListener();
    mVolumeSliderColor = MediaRouterThemeHelper.getControllerColor(mContext, 0);
    mVolumeSliderHolderMap = new HashMap<>();
    mBeforeMuteVolumeMap = new HashMap<>();
    mMetadataLayout = findViewById(R.id.mr_cast_meta);
    mArtView = findViewById(R.id.mr_cast_meta_art);
    mTitleView = findViewById(R.id.mr_cast_meta_title);
    mTitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    mSubtitleView = findViewById(R.id.mr_cast_meta_subtitle);
    mSubtitleView.setTextColor(COLOR_WHITE_ON_DARK_BACKGROUND);
    Resources res = mContext.getResources();
    mTitlePlaceholder = res.getString(R.string.mr_cast_dialog_title_view_placeholder);
    mCreated = true;
    updateLayout();
}
#end_block

#method_before
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mRouteForTouchedVolumeSlider to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_STOP_TRACKING_TOUCH), UPDATE_VOLUME_DELAY_MS);
}
#method_after
@Override
public void onStopTrackingTouch(SeekBar seekBar) {
    // Defer resetting mRouteForTouchedVolumeSlider to allow the media route provider
    // a little time to settle into its new state and publish the final
    // volume update.
    mHandler.sendEmptyMessageDelayed(MSG_STOP_TRACKING_TOUCH, UPDATE_VOLUME_DELAY_MS);
}
#end_block

#method_before
@Override
public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
    if (fromUser) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        int oldVolume = route.getVolume();
        if (oldVolume > 0 && progress == 0 || oldVolume == 0 && progress > 0) {
            MediaRouteVolumeSliderHolder holder = mVolumeSliderHolderMap.get(route.getId());
            if (holder != null) {
                holder.updateVolumeByProgress(progress);
            }
        }
        // volume can be restored to that value when user unmutes it.
        if (progress == 0) {
            mLastVolumes.put(route.getId(), oldVolume);
        }
        route.requestSetVolume(progress);
    } else if (mRouteForClickedMuteButton != null) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        // volume can be restored to that value when user unmutes it.
        if (progress == 0) {
            mLastVolumes.put(route.getId(), route.getVolume());
        }
        route.requestSetVolume(progress);
        // Defer resetting mRouteForClickedMuteButton to allow the media route provider
        // a little time to settle into its new state and publish the final
        // volume update.
        mHandler.sendMessageDelayed(mHandler.obtainMessage(MSG_CLICK_MUTE_BUTTON), UPDATE_VOLUME_DELAY_MS);
    }
}
#method_after
@Override
public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
    if (fromUser) {
        MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) seekBar.getTag();
        MediaRouteVolumeSliderHolder holder = mVolumeSliderHolderMap.get(route.getId());
        if (holder != null) {
            holder.setMute(progress == MUTED_VOLUME);
        }
        route.requestSetVolume(progress);
    }
}
#end_block

#method_before
void setItems() {
    mItems.clear();
    // Add Group Volume item only when currently casting on a group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        List<MediaRouter.RouteInfo> routes = ((MediaRouter.RouteGroup) mSelectedRoute).getRoutes();
        for (MediaRouter.RouteInfo route : routes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    mAvailableRoutes.clear();
    mAvailableGroups.clear();
    for (MediaRouter.RouteInfo route : mRoutes) {
        // If route is current selected route, skip
        if (isSelectedRoute(route)) {
            continue;
        }
        if (route instanceof MediaRouter.RouteGroup) {
            mAvailableGroups.add(route);
        } else {
            mAvailableRoutes.add(route);
        }
    }
    if (mAvailableRoutes.size() > 0) {
        // Add list items of single device section to mItems
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_device_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableRoutes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    }
    if (mAvailableGroups.size() > 0) {
        // Add list items of group section to mItems
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_route_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableGroups) {
            mItems.add(new Item(route, ITEM_TYPE_GROUP));
        }
    }
    notifyDataSetChanged();
}
#method_after
void setItems() {
    mItems.clear();
    // Add Group Volume item only when currently casting on a group
    if (mSelectedRoute instanceof MediaRouter.RouteGroup) {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_GROUP_VOLUME));
        List<MediaRouter.RouteInfo> routes = ((MediaRouter.RouteGroup) mSelectedRoute).getRoutes();
        for (MediaRouter.RouteInfo route : routes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    } else {
        mItems.add(new Item(mSelectedRoute, ITEM_TYPE_ROUTE));
    }
    mAvailableRoutes.clear();
    mAvailableGroups.clear();
    for (MediaRouter.RouteInfo route : mRoutes) {
        // If route is current selected route, skip
        if (isSelectedRoute(route)) {
            continue;
        }
        if (route instanceof MediaRouter.RouteGroup) {
            mAvailableGroups.add(route);
        } else {
            mAvailableRoutes.add(route);
        }
    }
    // Add list items of available routes section to mItems
    if (mAvailableRoutes.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_groupable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableRoutes) {
            mItems.add(new Item(route, ITEM_TYPE_ROUTE));
        }
    }
    // Add list items of available groups section to mItems
    if (mAvailableGroups.size() > 0) {
        mItems.add(new Item(mContext.getString(R.string.mr_dialog_transferable_header), ITEM_TYPE_HEADER));
        for (MediaRouter.RouteInfo route : mAvailableGroups) {
            mItems.add(new Item(route, ITEM_TYPE_GROUP));
        }
    }
    notifyDataSetChanged();
}
#end_block

#method_before
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    int volume = route.getVolume();
    boolean isMute = (volume == 0);
    mRoute = route;
    mTextView.setText(route.getName().toUpperCase());
    mMuteButton.setTag(isMute);
    mMuteButton.setImageDrawable(isMute ? mVolumeOffIcon : mVolumeOnIcon);
    mMuteButton.setOnClickListener(mMuteButtonClickListener);
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(volume);
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
}
#method_after
public void bindGroupVolumeViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    super.bindRouteVolumeSliderHolder(route);
    mTextView.setText(route.getName());
}
#end_block

#method_before
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    int volume = route.getVolume();
    boolean isMute = (volume == 0);
    boolean selected = isSelectedRoute(route);
    mRoute = route;
    mImageView.setImageDrawable(getIconDrawable(route));
    mMuteButton.setTag(isMute);
    mMuteButton.setImageDrawable(isMute ? mVolumeOffIcon : mVolumeOnIcon);
    mMuteButton.setOnClickListener(mMuteButtonClickListener);
    mTextView.setText(route.getName());
    mVolumeSlider.setTag(route);
    mVolumeSlider.setColor(mVolumeSliderColor);
    mVolumeSlider.setMax(route.getVolumeMax());
    mVolumeSlider.setProgress(route.getVolume());
    mVolumeSlider.setOnSeekBarChangeListener(mVolumeChangeListener);
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setEnabled(false);
    }
}
#method_after
public void bindRouteViewHolder(Item item) {
    MediaRouter.RouteInfo route = (MediaRouter.RouteInfo) item.getData();
    boolean selected = isSelectedRoute(route);
    super.bindRouteVolumeSliderHolder(route);
    mImageView.setImageDrawable(getIconDrawable(route));
    mTextView.setText(route.getName());
    mVolumeSliderLayout.setVisibility(selected ? View.VISIBLE : View.GONE);
    mCheckBox.setOnClickListener(mCheckBoxClickListener);
    // TODO(b/111624415): Make CheckBox works for both selected and unselected routes.
    if (selected) {
        mCheckBox.setChecked(true);
        mCheckBox.setEnabled(true);
    } else {
        mCheckBox.setEnabled(false);
    }
}
#end_block

#method_before
@Override
protected void onCreate(final Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_room_recycler_view);
    final CustomerViewModel viewModel = ViewModelProviders.of(this).get(CustomerViewModel.class);
    mRecyclerView = findViewById(R.id.recyclerview);
    mAdapter = new PagedListCustomerAdapter();
    mRecyclerView.setAdapter(mAdapter);
    LiveData<PagedList<Customer>> livePagedList;
    if (useKeyedQuery()) {
        String key = null;
        if (savedInstanceState != null) {
            key = savedInstanceState.getString(STRING_KEY);
            mAdapter.setScrollToKey(key);
        }
        livePagedList = viewModel.getLivePagedList(key);
    } else {
        int position = 0;
        if (savedInstanceState != null) {
            position = savedInstanceState.getInt(INT_KEY);
            mAdapter.setScrollToPosition(position);
        }
        livePagedList = viewModel.getLivePagedList(position);
    }
    livePagedList.observe(this, items -> mAdapter.submitList(items));
    final Button button = findViewById(R.id.addButton);
    button.setOnClickListener(v -> viewModel.insertCustomer());
}
#method_after
@Override
protected void onCreate(final Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_room_recycler_view);
    final CustomerViewModel viewModel = ViewModelProviders.of(this).get(CustomerViewModel.class);
    mRecyclerView = findViewById(R.id.recyclerview);
    mAdapter = new PagedListCustomerAdapter();
    mRecyclerView.setAdapter(mAdapter);
    LiveData<PagedList<Customer>> livePagedList;
    if (useKeyedQuery()) {
        String key = null;
        if (savedInstanceState != null) {
            key = savedInstanceState.getString(STRING_KEY);
            mAdapter.setScrollToKey(key);
        }
        livePagedList = viewModel.getLivePagedList(key);
    } else {
        int position = 0;
        if (savedInstanceState != null) {
            position = savedInstanceState.getInt(INT_KEY);
            mAdapter.setScrollToPosition(position);
        }
        livePagedList = viewModel.getLivePagedList(position);
    }
    livePagedList.observe(this, items -> mAdapter.submitList(items));
    final Button addButton = findViewById(R.id.addButton);
    addButton.setOnClickListener(v -> viewModel.insertCustomer());
    final Button clearButton = findViewById(R.id.clearButton);
    clearButton.setOnClickListener(v -> viewModel.clearAllCustomers());
}
#end_block

#method_before
public static Slice bindSlice(final Context context, Uri uri, Set<SliceSpec> supportedSpecs) {
    ProviderHolder holder = acquireClient(context.getContentResolver(), uri);
    if (holder.mProvider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        Bundle extras = new Bundle();
        extras.putParcelable(EXTRA_BIND_URI, uri);
        addSpecs(extras, supportedSpecs);
        final Bundle res = holder.mProvider.call(METHOD_SLICE, ARG_SUPPORTS_VERSIONED_PARCELABLE, extras);
        if (res == null) {
            return null;
        }
        synchronized (SliceItemHolder.sSerializeLock) {
            try {
                SliceItemHolder.sHandler = new SliceItemHolder.HolderHandler() {

                    @Override
                    public void handle(SliceItemHolder holder, String format) {
                        if (holder.mVersionedParcelable instanceof IconCompat) {
                            IconCompat icon = (IconCompat) holder.mVersionedParcelable;
                            icon.checkResource(context);
                            if (icon.getType() == Icon.TYPE_RESOURCE && icon.getResId() == 0) {
                                holder.mVersionedParcelable = null;
                            }
                        }
                    }
                };
                res.setClassLoader(SliceProviderCompat.class.getClassLoader());
                Parcelable parcel = res.getParcelable(EXTRA_SLICE);
                if (parcel == null) {
                    return null;
                }
                if (parcel instanceof Bundle) {
                    return new Slice((Bundle) parcel);
                }
                return ParcelUtils.fromParcelable(parcel);
            } finally {
                SliceItemHolder.sHandler = null;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to bind slice", e);
        return null;
    } finally {
    }
}
#method_after
public static Slice bindSlice(Context context, Uri uri, Set<SliceSpec> supportedSpecs) {
    ProviderHolder holder = acquireClient(context.getContentResolver(), uri);
    if (holder.mProvider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        Bundle extras = new Bundle();
        extras.putParcelable(EXTRA_BIND_URI, uri);
        addSpecs(extras, supportedSpecs);
        final Bundle res = holder.mProvider.call(METHOD_SLICE, ARG_SUPPORTS_VERSIONED_PARCELABLE, extras);
        return parseSlice(context, res);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to bind slice", e);
        return null;
    } finally {
    }
}
#end_block

#method_before
public static Slice bindSlice(final Context context, Intent intent, Set<SliceSpec> supportedSpecs) {
    Preconditions.checkNotNull(intent, "intent");
    Preconditions.checkArgument(intent.getComponent() != null || intent.getPackage() != null || intent.getData() != null, String.format("Slice intent must be explicit %s", intent));
    ContentResolver resolver = context.getContentResolver();
    // Check if the intent has data for the slice uri on it and use that
    final Uri intentData = intent.getData();
    if (intentData != null && SLICE_TYPE.equals(resolver.getType(intentData))) {
        return bindSlice(context, intentData, supportedSpecs);
    }
    // Otherwise ask the app
    Intent queryIntent = new Intent(intent);
    if (!queryIntent.hasCategory(CATEGORY_SLICE)) {
        queryIntent.addCategory(CATEGORY_SLICE);
    }
    List<ResolveInfo> providers = context.getPackageManager().queryIntentContentProviders(queryIntent, 0);
    if (providers == null || providers.isEmpty()) {
        // There are no providers, see if this activity has a direct link.
        ResolveInfo resolve = context.getPackageManager().resolveActivity(intent, PackageManager.GET_META_DATA);
        if (resolve != null && resolve.activityInfo != null && resolve.activityInfo.metaData != null && resolve.activityInfo.metaData.containsKey(SLICE_METADATA_KEY)) {
            return bindSlice(context, Uri.parse(resolve.activityInfo.metaData.getString(SLICE_METADATA_KEY)), supportedSpecs);
        }
        return null;
    }
    String authority = providers.get(0).providerInfo.authority;
    Uri uri = new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(authority).build();
    ProviderHolder holder = acquireClient(resolver, uri);
    if (holder.mProvider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        Bundle extras = new Bundle();
        extras.putParcelable(EXTRA_INTENT, intent);
        addSpecs(extras, supportedSpecs);
        final Bundle res = holder.mProvider.call(METHOD_MAP_INTENT, ARG_SUPPORTS_VERSIONED_PARCELABLE, extras);
        if (res == null) {
            return null;
        }
        synchronized (SliceItemHolder.sSerializeLock) {
            try {
                SliceItemHolder.sHandler = new SliceItemHolder.HolderHandler() {

                    @Override
                    public void handle(SliceItemHolder holder, String format) {
                        if (holder.mVersionedParcelable instanceof IconCompat) {
                            IconCompat icon = (IconCompat) holder.mVersionedParcelable;
                            icon.checkResource(context);
                            if (icon.getType() == Icon.TYPE_RESOURCE && icon.getResId() == 0) {
                                holder.mVersionedParcelable = null;
                            }
                        }
                    }
                };
                res.setClassLoader(SliceProviderCompat.class.getClassLoader());
                Parcelable parcel = res.getParcelable(EXTRA_SLICE);
                if (parcel == null) {
                    return null;
                }
                if (parcel instanceof Bundle) {
                    return new Slice((Bundle) parcel);
                }
                return ParcelUtils.fromParcelable(parcel);
            } finally {
                SliceItemHolder.sHandler = null;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to bind slice", e);
        return null;
    }
}
#method_after
public static Slice bindSlice(Context context, Intent intent, Set<SliceSpec> supportedSpecs) {
    Preconditions.checkNotNull(intent, "intent");
    Preconditions.checkArgument(intent.getComponent() != null || intent.getPackage() != null || intent.getData() != null, String.format("Slice intent must be explicit %s", intent));
    ContentResolver resolver = context.getContentResolver();
    // Check if the intent has data for the slice uri on it and use that
    final Uri intentData = intent.getData();
    if (intentData != null && SLICE_TYPE.equals(resolver.getType(intentData))) {
        return bindSlice(context, intentData, supportedSpecs);
    }
    // Otherwise ask the app
    Intent queryIntent = new Intent(intent);
    if (!queryIntent.hasCategory(CATEGORY_SLICE)) {
        queryIntent.addCategory(CATEGORY_SLICE);
    }
    List<ResolveInfo> providers = context.getPackageManager().queryIntentContentProviders(queryIntent, 0);
    if (providers == null || providers.isEmpty()) {
        // There are no providers, see if this activity has a direct link.
        ResolveInfo resolve = context.getPackageManager().resolveActivity(intent, PackageManager.GET_META_DATA);
        if (resolve != null && resolve.activityInfo != null && resolve.activityInfo.metaData != null && resolve.activityInfo.metaData.containsKey(SLICE_METADATA_KEY)) {
            return bindSlice(context, Uri.parse(resolve.activityInfo.metaData.getString(SLICE_METADATA_KEY)), supportedSpecs);
        }
        return null;
    }
    String authority = providers.get(0).providerInfo.authority;
    Uri uri = new Uri.Builder().scheme(ContentResolver.SCHEME_CONTENT).authority(authority).build();
    ProviderHolder holder = acquireClient(resolver, uri);
    if (holder.mProvider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        Bundle extras = new Bundle();
        extras.putParcelable(EXTRA_INTENT, intent);
        addSpecs(extras, supportedSpecs);
        final Bundle res = holder.mProvider.call(METHOD_MAP_INTENT, ARG_SUPPORTS_VERSIONED_PARCELABLE, extras);
        return parseSlice(context, res);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to bind slice", e);
        return null;
    }
}
#end_block

#method_before
public <VH extends ViewHolder> void setAdapter(final Adapter<VH> adapter) {
    mRecyclerView.setAdapter(adapter);
}
#method_after
public void setAdapter(Adapter adapter) {
    mRecyclerView.setAdapter(adapter);
}
#end_block

#method_before
@Nullable
public Parcelable[] saveState() {
    FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();
    for (int i = 0; i < mFragments.size(); i++) {
        removeFragment(mFragments.get(i), i, fragmentTransaction);
    }
    fragmentTransaction.commitNowAllowingStateLoss();
    return mSavedStates.toArray(new Fragment.SavedState[mSavedStates.size()]);
}
#method_after
public Parcelable[] saveState() {
    FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();
    for (int i = 0; i < mFragments.size(); i++) {
        removeFragment(mFragments.get(i), i, fragmentTransaction);
    }
    fragmentTransaction.commitNowAllowingStateLoss();
    return mSavedStates.toArray(new Fragment.SavedState[mSavedStates.size()]);
}
#end_block

#method_before
@Test
public void testAddState() {
    AnimatedStateListDrawableCompat asld = new AnimatedStateListDrawableCompat();
    DrawableContainer.DrawableContainerState cs = (DrawableContainer.DrawableContainerState) asld.getConstantState();
    assertEquals(0, cs.getChildCount());
    try {
        asld.addState(StateSet.WILD_CARD, null, R.id.focused);
        fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // Expected.
    }
    Drawable unfocused = mock(Drawable.class);
    asld.addState(StateSet.WILD_CARD, unfocused, R.id.focused);
    assertEquals(1, cs.getChildCount());
    Drawable focused = mock(Drawable.class);
    asld.addState(STATE_FOCUSED, focused, R.id.unfocused);
    assertEquals(2, cs.getChildCount());
}
#method_after
@Test
public void testAddState() {
    AnimatedStateListDrawableCompat asld = new AnimatedStateListDrawableCompat();
    assertEquals(0, asld.getStateCount());
    try {
        asld.addState(StateSet.WILD_CARD, null, R.id.focused);
        fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // Expected.
    }
    Drawable unfocused = mock(Drawable.class);
    asld.addState(StateSet.WILD_CARD, unfocused, R.id.focused);
    assertEquals(1, asld.getStateCount());
    Drawable focused = mock(Drawable.class);
    asld.addState(STATE_FOCUSED, focused, R.id.unfocused);
    assertEquals(2, asld.getStateCount());
}
#end_block

#method_before
@Test
public void testAddTransition() {
    AnimatedStateListDrawableCompat asld = new AnimatedStateListDrawableCompat();
    DrawableContainer.DrawableContainerState cs = (DrawableContainer.DrawableContainerState) asld.getConstantState();
    Drawable focused = mock(Drawable.class);
    Drawable unfocused = mock(Drawable.class);
    asld.addState(STATE_FOCUSED, focused, R.id.focused);
    asld.addState(StateSet.WILD_CARD, unfocused, R.id.unfocused);
    try {
        asld.addTransition(R.id.focused, R.id.focused, null, false);
        fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // Expected.
    }
    MockTransition focusedToUnfocused = mock(MockTransition.class);
    asld.addTransition(R.id.focused, R.id.unfocused, focusedToUnfocused, false);
    assertEquals(3, cs.getChildCount());
    MockTransition unfocusedToFocused = mock(MockTransition.class);
    asld.addTransition(R.id.unfocused, R.id.focused, unfocusedToFocused, false);
    assertEquals(4, cs.getChildCount());
    MockTransition reversible = mock(MockTransition.class);
    asld.addTransition(R.id.focused, R.id.unfocused, reversible, true);
    assertEquals(5, cs.getChildCount());
}
#method_after
@Test
public void testAddTransition() {
    AnimatedStateListDrawableCompat asld = new AnimatedStateListDrawableCompat();
    Drawable focused = mock(Drawable.class);
    Drawable unfocused = mock(Drawable.class);
    asld.addState(STATE_FOCUSED, focused, R.id.focused);
    asld.addState(StateSet.WILD_CARD, unfocused, R.id.unfocused);
    try {
        asld.addTransition(R.id.focused, R.id.focused, null, false);
        fail("Expected IllegalArgumentException");
    } catch (IllegalArgumentException e) {
    // Expected.
    }
    MockTransition focusedToUnfocused = mock(MockTransition.class);
    asld.addTransition(R.id.focused, R.id.unfocused, focusedToUnfocused, false);
    assertEquals(3, asld.getStateCount());
    MockTransition unfocusedToFocused = mock(MockTransition.class);
    asld.addTransition(R.id.unfocused, R.id.focused, unfocusedToFocused, false);
    assertEquals(4, asld.getStateCount());
    MockTransition reversible = mock(MockTransition.class);
    asld.addTransition(R.id.focused, R.id.unfocused, reversible, true);
    assertEquals(5, asld.getStateCount());
}
#end_block

#method_before
@Test
public void testAnimationDrawableTransition() throws XmlPullParserException, IOException {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.animated_state_list_density, mContext.getTheme());
    DrawableContainer.DrawableContainerState asldState = (DrawableContainer.DrawableContainerState) asld.getConstantState();
    assertTrue(asld.isVisible());
    assertFalse(asldState.isConstantSize());
    assertNull(asldState.getConstantPadding());
    // Check that 4 drawables were parsed
    assertEquals(4, asldState.getChildCount());
}
#method_after
@Test
public void testAnimationDrawableTransition() throws XmlPullParserException, IOException {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.animated_state_list_density, mContext.getTheme());
    assertTrue(asld.isVisible());
    // Missing public API to verify these.
    // assertFalse(asld.isConstantSize());
    // assertNull(asld.getConstantPadding());
    // Check that 4 drawables were parsed
    assertEquals(4, asld.getStateCount());
}
#end_block

#method_before
@Test
public void testAnimatedVectorTransition() {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.asl_heart, mContext.getTheme());
    // Check that 4 drawables were parsed
    assertEquals(4, asld.getChildCount());
}
#method_after
@Test
public void testAnimatedVectorTransition() {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.asl_heart, mContext.getTheme());
    // Check that 4 drawables were parsed
    assertEquals(4, asld.getStateCount());
}
#end_block

#method_before
@Test
public void testChildAnimatedVectorTransition() {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.animated_state_list_with_avd, mContext.getTheme());
    // Check that 6 drawables were parsed
    assertEquals(6, asld.getChildCount());
}
#method_after
@Test
public void testChildAnimatedVectorTransition() {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.animated_state_list_with_avd, mContext.getTheme());
    // Check that 6 drawables were parsed
    assertEquals(6, asld.getStateCount());
}
#end_block

#method_before
@Test
public void testChildVectorItem() {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.asl_heart_embedded, mContext.getTheme());
    // Check that 4 drawables were parsed
    assertEquals(4, asld.getChildCount());
}
#method_after
@Test
public void testChildVectorItem() {
    AnimatedStateListDrawableCompat asld = AnimatedStateListDrawableCompat.create(mContext, R.drawable.asl_heart_embedded, mContext.getTheme());
    // Check that 4 drawables were parsed
    assertEquals(4, asld.getStateCount());
}
#end_block

#method_before
@Override
public ConstantState getConstantState() {
    if (mDrawableContainerState.canConstantState()) {
        mDrawableContainerState.mChangingConfigurations = getChangingConfigurations();
        return mDrawableContainerState;
    }
    return null;
}
#method_after
@Override
public final ConstantState getConstantState() {
    if (mDrawableContainerState.canConstantState()) {
        mDrawableContainerState.mChangingConfigurations = getChangingConfigurations();
        return mDrawableContainerState;
    }
    return null;
}
#end_block

#method_before
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, int duration, int maxExtendedAdvertisingEvents, AdvertisingSetCallback callback, Handler handler) {
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException("callback cannot be null");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException("Legacy advertising data too big");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException("Legacy scan response data too big");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException("Unsupported primary PHY selected");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException("Unsupported secondary PHY selected");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException("Advertising data too big");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException("Scan response data too big");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException("Periodic advertising data too big");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException("Controller does not support LE Periodic Advertising");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException("maxExtendedAdvertisingEvents out of range: " + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException("Can't use maxExtendedAdvertisingEvents with controller that don't support " + "LE Extended Advertising");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException("duration out of range: " + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to get Bluetooth gatt - ", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    if (gatt == null) {
        Log.e(TAG, "Bluetooth gatt is null");
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException("callback instance already associated with advertising");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to start advertising set - ", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}
#method_after
public void startAdvertisingSet(AdvertisingSetParameters parameters, AdvertiseData advertiseData, AdvertiseData scanResponse, PeriodicAdvertisingParameters periodicParameters, AdvertiseData periodicData, int duration, int maxExtendedAdvertisingEvents, AdvertisingSetCallback callback, Handler handler) {
    BluetoothLeUtils.checkAdapterStateOn(mBluetoothAdapter);
    if (callback == null) {
        throw new IllegalArgumentException("callback cannot be null");
    }
    boolean isConnectable = parameters.isConnectable();
    if (parameters.isLegacy()) {
        if (totalBytes(advertiseData, isConnectable) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException("Legacy advertising data too big");
        }
        if (totalBytes(scanResponse, false) > MAX_LEGACY_ADVERTISING_DATA_BYTES) {
            throw new IllegalArgumentException("Legacy scan response data too big");
        }
    } else {
        boolean supportCodedPhy = mBluetoothAdapter.isLeCodedPhySupported();
        boolean support2MPhy = mBluetoothAdapter.isLe2MPhySupported();
        int pphy = parameters.getPrimaryPhy();
        int sphy = parameters.getSecondaryPhy();
        if (pphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) {
            throw new IllegalArgumentException("Unsupported primary PHY selected");
        }
        if ((sphy == BluetoothDevice.PHY_LE_CODED && !supportCodedPhy) || (sphy == BluetoothDevice.PHY_LE_2M && !support2MPhy)) {
            throw new IllegalArgumentException("Unsupported secondary PHY selected");
        }
        int maxData = mBluetoothAdapter.getLeMaximumAdvertisingDataLength();
        if (totalBytes(advertiseData, isConnectable) > maxData) {
            throw new IllegalArgumentException("Advertising data too big");
        }
        if (totalBytes(scanResponse, false) > maxData) {
            throw new IllegalArgumentException("Scan response data too big");
        }
        if (totalBytes(periodicData, false) > maxData) {
            throw new IllegalArgumentException("Periodic advertising data too big");
        }
        boolean supportPeriodic = mBluetoothAdapter.isLePeriodicAdvertisingSupported();
        if (periodicParameters != null && !supportPeriodic) {
            throw new IllegalArgumentException("Controller does not support LE Periodic Advertising");
        }
    }
    if (maxExtendedAdvertisingEvents < 0 || maxExtendedAdvertisingEvents > 255) {
        throw new IllegalArgumentException("maxExtendedAdvertisingEvents out of range: " + maxExtendedAdvertisingEvents);
    }
    if (maxExtendedAdvertisingEvents != 0 && !mBluetoothAdapter.isLePeriodicAdvertisingSupported()) {
        throw new IllegalArgumentException("Can't use maxExtendedAdvertisingEvents with controller that don't support " + "LE Extended Advertising");
    }
    if (duration < 0 || duration > 65535) {
        throw new IllegalArgumentException("duration out of range: " + duration);
    }
    IBluetoothGatt gatt;
    try {
        gatt = mBluetoothManager.getBluetoothGatt();
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to get Bluetooth GATT - ", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    if (gatt == null) {
        Log.e(TAG, "Bluetooth GATT is null");
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
    IAdvertisingSetCallback wrapped = wrap(callback, handler);
    if (mCallbackWrappers.putIfAbsent(callback, wrapped) != null) {
        throw new IllegalArgumentException("callback instance already associated with advertising");
    }
    try {
        gatt.startAdvertisingSet(parameters, advertiseData, scanResponse, periodicParameters, periodicData, duration, maxExtendedAdvertisingEvents, wrapped);
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to start advertising set - ", e);
        postStartSetFailure(handler, callback, AdvertiseCallback.ADVERTISE_FAILED_INTERNAL_ERROR);
        return;
    }
}
#end_block

#method_before
@Override
public void close() {
    try {
        synchronized (mLock) {
            mClosed = true;
            if (mImpl != null) {
                mImpl.close();
            }
        }
    } catch (Exception e) {
    // Should not be here.
    }
}
#method_after
@Override
public void close() {
    try {
        MediaController2Impl impl;
        synchronized (mLock) {
            if (mClosed) {
                return;
            }
            mClosed = true;
            impl = mImpl;
        }
        if (impl != null) {
            impl.close();
        }
    } catch (Exception e) {
    // Should not be here.
    }
}
#end_block

#method_before
@NonNull
public SessionToken2 getSessionToken() {
    return isConnected() ? getImpl().getSessionToken() : null;
}
#method_after
@Nullable
public SessionToken2 getSessionToken() {
    return isConnected() ? getImpl().getSessionToken() : null;
}
#end_block

#method_before
@NonNull
ControllerCallback getCallback() {
    return getImpl().getCallback();
}
#method_after
@NonNull
ControllerCallback getCallback() {
    return isConnected() ? getImpl().getCallback() : null;
}
#end_block

#method_before
@NonNull
Executor getCallbackExecutor() {
    return getImpl().getCallbackExecutor();
}
#method_after
@NonNull
Executor getCallbackExecutor() {
    return isConnected() ? getImpl().getCallbackExecutor() : null;
}
#end_block

#method_before
@Test
public void testControllerCallbackBufferingStarved() throws Exception {
    prepareLooper();
    final List<MediaItem2> testPlaylist = MediaTestUtils.createPlaylist(1);
    final List<QueueItem> testQueue = MediaUtils2.convertToQueueItemList(testPlaylist);
    final MediaMetadataCompat metadata = MediaUtils2.convertToMediaMetadataCompat(testQueue.get(0).getDescription());
    final int testBufferingState = MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_STARVED;
    final long testBufferingPosition = 0;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController2 controller, MediaItem2 item, int state) {
            assertEquals(metadata.getDescription().getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mSession.setMetadata(metadata);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, 100, /* position */
    1f).setBufferedPosition(500).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(0L);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_BUFFERING, 0, /* position */
    1f).setBufferedPosition(testBufferingPosition).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#method_after
@FlakyTest(bugId = 111433579)
@Test
public void testControllerCallbackBufferingStarved() throws Exception {
    prepareLooper();
    final List<MediaItem2> testPlaylist = MediaTestUtils.createPlaylist(1);
    final List<QueueItem> testQueue = MediaUtils2.convertToQueueItemList(testPlaylist);
    final MediaMetadataCompat metadata = MediaUtils2.convertToMediaMetadataCompat(testQueue.get(0).getDescription());
    final int testBufferingState = MediaPlayerConnector.BUFFERING_STATE_BUFFERING_AND_STARVED;
    final long testBufferingPosition = 0;
    final CountDownLatch latch = new CountDownLatch(1);
    final ControllerCallback callback = new ControllerCallback() {

        @Override
        public void onBufferingStateChanged(MediaController2 controller, MediaItem2 item, int state) {
            assertEquals(metadata.getDescription().getMediaId(), item.getMediaId());
            assertEquals(testBufferingState, state);
            assertEquals(testBufferingState, controller.getBufferingState());
            assertEquals(testBufferingPosition, controller.getBufferedPosition());
            latch.countDown();
        }
    };
    mSession.setMetadata(metadata);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_PLAYING, 100, /* position */
    1f).setBufferedPosition(500).build());
    mController = createController(mSession.getSessionToken(), true, callback);
    mController.setTimeDiff(0L);
    mSession.setPlaybackState(new PlaybackStateCompat.Builder().setState(PlaybackStateCompat.STATE_BUFFERING, 0, /* position */
    1f).setBufferedPosition(testBufferingPosition).build());
    assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void useParams() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("email@android.com", TextClassifier.TYPE_EMAIL).build();
    final Spannable text = testObject.getText();
    final ArgumentCaptor<TextLinks.Request> requestCapture = ArgumentCaptor.forClass(TextLinks.Request.class);
    when(mClassifier.generateLinks(requestCapture.capture())).thenReturn(testObject.getTextLinks());
    when(mClassifier.getMaxGenerateLinksTextLength()).thenReturn(text.length());
    final TextLinks.TextLinkSpan span = mock(TextLinks.TextLinkSpan.class);
    final TextLinksParams params = new TextLinksParams.Builder().setEntityConfig(new TextClassifier.EntityConfig.Builder().build()).setDefaultLocales(LocaleListCompat.create(Locale.CANADA_FRENCH)).setSpanFactory(new TextLinks.SpanFactory() {

        @Override
        public TextLinks.TextLinkSpan createSpan(TextLinks.TextLink textLink) {
            return span;
        }
    }).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifierFactory, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.Request request = requestCapture.getValue();
    assertThat(request.getText().toString()).isEqualTo(text.toString());
    assertThat(request.getEntityConfig()).isEqualTo(params.getEntityConfig());
    assertThat(request.getDefaultLocales()).isEqualTo(params.getDefaultLocales());
    final TextLinks.TextLinkSpan insertedSpan = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class)[0];
    assertThat(insertedSpan).isEqualTo(span);
}
#method_after
@Test
public void useParams() {
    final TestLinks testObject = new TestLinks.Builder().addEntity("email@android.com", TextClassifier.TYPE_EMAIL).build();
    final Spannable text = testObject.getText();
    final ArgumentCaptor<TextLinks.Request> requestCapture = ArgumentCaptor.forClass(TextLinks.Request.class);
    when(mClassifier.generateLinks(requestCapture.capture())).thenReturn(testObject.getTextLinks());
    when(mClassifier.getMaxGenerateLinksTextLength()).thenReturn(text.length());
    final TextLinks.TextLinkSpan span = new TextLinks.TextLinkSpan(testObject.getTextLinks().getLinks().iterator().next());
    final TextLinksParams params = new TextLinksParams.Builder().setEntityConfig(new TextClassifier.EntityConfig.Builder().build()).setDefaultLocales(LocaleListCompat.create(Locale.CANADA_FRENCH)).setSpanFactory(new TextLinks.SpanFactory() {

        @Override
        public TextLinks.TextLinkSpan createSpan(TextLinks.TextLink textLink) {
            return span;
        }
    }).build();
    SmartLinkify.addLinksAsync(text, mContext, mClassifierFactory, params, null, /* cancel */
    null, /* executor */
    mCallback);
    // Block for the result.
    mCallback.await(true);
    assertThat(mCallback.getStatus()).isEqualTo(TextLinks.STATUS_LINKS_APPLIED);
    final TextLinks.Request request = requestCapture.getValue();
    assertThat(request.getText().toString()).isEqualTo(text.toString());
    assertThat(request.getEntityConfig()).isEqualTo(params.getEntityConfig());
    assertThat(request.getDefaultLocales()).isEqualTo(params.getDefaultLocales());
    final TextLinks.TextLinkSpan insertedSpan = text.getSpans(0, text.length(), TextLinks.TextLinkSpan.class)[0];
    assertThat(insertedSpan).isEqualTo(span);
}
#end_block

#method_before
@NonNull
public TextLinks build() {
    return new TextLinks(mFullText, mLinks);
}
#method_after
@NonNull
public Request build() {
    return new Request(mText, mDefaultLocales, mEntityConfig);
}
#end_block

#method_before
@Override
@NonNull
public Result doWork() {
    while (!isStopped()) {
        // Adding a log message to work around a check for empty while loops.
        Log.d(TAG, "Working");
    }
    return Result.SUCCESS;
}
#method_after
@Override
@NonNull
public Result doWork() {
    // Workaround repo hook for an empty while loop.
    int x = 0;
    while (!isStopped()) {
        x++;
    }
    return Result.SUCCESS;
}
#end_block

#method_before
private void closeDrawerDelayed(final int gravity, long delayMs) {
    switch(gravity) {
        case Gravity.TOP:
            mMainThreadHandler.removeCallbacks(mCloseTopPeekRunnable);
            mMainThreadHandler.postDelayed(mCloseTopPeekRunnable, delayMs);
            break;
        case Gravity.BOTTOM:
            mMainThreadHandler.removeCallbacks(mCloseBottomPeekRunnable);
            mMainThreadHandler.postDelayed(mCloseBottomPeekRunnable, delayMs);
            break;
        default:
            Log.w(TAG, "Invoked a delayed drawer close with an invalid gravity: " + gravity);
    }
}
#method_after
void closeDrawerDelayed(final int gravity, long delayMs) {
    switch(gravity) {
        case Gravity.TOP:
            mMainThreadHandler.removeCallbacks(mCloseTopPeekRunnable);
            mMainThreadHandler.postDelayed(mCloseTopPeekRunnable, delayMs);
            break;
        case Gravity.BOTTOM:
            mMainThreadHandler.removeCallbacks(mCloseBottomPeekRunnable);
            mMainThreadHandler.postDelayed(mCloseBottomPeekRunnable, delayMs);
            break;
        default:
            Log.w(TAG, "Invoked a delayed drawer close with an invalid gravity: " + gravity);
    }
}
#end_block

#method_before
@Override
public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {
    if (releasedChild == mTopDrawerView) {
        // Settle to final position. Either swipe open or close.
        final float openedPercent = mTopDrawerView.getOpenedPercent();
        final int finalTop;
        if (yvel > 0 || (yvel == 0 && openedPercent > OPENED_PERCENT_THRESHOLD)) {
            // Drawer was being flung open or drawer is mostly open, so finish opening.
            finalTop = 0;
        } else {
            // Drawer animates to its peek state and fully closes after a delay.
            animatePeekVisibleAfterBeingClosed(mTopDrawerView);
            finalTop = mTopDrawerView.getPeekContainer().getHeight() - releasedChild.getHeight();
            closeDrawerDelayed(Gravity.TOP, PEEK_AUTO_CLOSE_DELAY_MS);
        }
        mTopDrawerDragger.settleCapturedViewAt(0, /* finalLeft */
        finalTop);
        invalidate();
    }
}
#method_after
@Override
public void onViewReleased(@NonNull View releasedChild, float xvel, float yvel) {
    if (releasedChild == mTopDrawerView) {
        // Settle to final position. Either swipe open or close.
        final float openedPercent = mTopDrawerView.getOpenedPercent();
        final int finalTop;
        if (yvel > 0 || (yvel == 0 && openedPercent > OPENED_PERCENT_THRESHOLD)) {
            // Drawer was being flung open or drawer is mostly open, so finish opening.
            finalTop = 0;
        } else {
            // Drawer animates to its peek state and fully closes after a delay.
            animatePeekVisibleAfterBeingClosed(mTopDrawerView);
            finalTop = mTopDrawerView.getPeekContainer().getHeight() - releasedChild.getHeight();
            if (mTopDrawerView.isAutoPeekEnabled()) {
                closeDrawerDelayed(Gravity.TOP, PEEK_AUTO_CLOSE_DELAY_MS);
            }
        }
        mTopDrawerDragger.settleCapturedViewAt(0, /* finalLeft */
        finalTop);
        invalidate();
    }
}
#end_block

#method_before
public final void executeOnExecutor(Executor exec) {
    if (mStatus != Status.PENDING) {
        switch(mStatus) {
            case RUNNING:
                throw new IllegalStateException("Cannot execute task:" + " the task is already running.");
            case FINISHED:
                throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)");
            default:
                throw new IllegalStateException("We should never reach this state");
        }
    }
    mStatus = Status.RUNNING;
    exec.execute(mFuture);
}
#method_after
public final void executeOnExecutor(@NonNull Executor exec) {
    if (mStatus != Status.PENDING) {
        switch(mStatus) {
            case RUNNING:
                throw new IllegalStateException("Cannot execute task:" + " the task is already running.");
            case FINISHED:
                throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)");
            default:
                throw new IllegalStateException("We should never reach this state");
        }
    }
    mStatus = Status.RUNNING;
    exec.execute(mFuture);
}
#end_block

#method_before
private void mirror(Drawable drawable, int layoutDirection) {
    if (drawable != null) {
        DrawableCompat.setLayoutDirection(drawable, layoutDirection);
    }
}
#method_after
private void mirror(Drawable drawable, int layoutDirection) {
    if (drawable != null && DrawableCompat.isAutoMirrored(drawable)) {
        DrawableCompat.setLayoutDirection(drawable, layoutDirection);
    }
}
#end_block

#method_before
@Nullable
public Class<? extends Fragment> getFragmentClass() {
    return mFragmentClass;
}
#method_after
@NonNull
public Class<? extends Fragment> getFragmentClass() {
    if (mFragmentClass == null) {
        throw new IllegalStateException("fragment class not set");
    }
    return mFragmentClass;
}
#end_block

#method_before
@SuppressWarnings("ClassNewInstance")
@NonNull
public Fragment createFragment(@Nullable Bundle args) {
    Class<? extends Fragment> clazz = getFragmentClass();
    if (clazz == null) {
        throw new IllegalStateException("fragment class not set");
    }
    Fragment f;
    try {
        f = clazz.newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    if (args != null) {
        f.setArguments(args);
    }
    return f;
}
#method_after
@SuppressWarnings("ClassNewInstance")
@NonNull
public Fragment createFragment(@Nullable Bundle args) {
    Class<? extends Fragment> clazz = getFragmentClass();
    Fragment f;
    try {
        f = clazz.newInstance();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
    if (args != null) {
        f.setArguments(args);
    }
    return f;
}
#end_block

#method_before
@NonNull
public Destination setIntent(@NonNull Intent intent) {
    mIntent = intent;
    return this;
}
#method_after
@NonNull
public Destination setIntent(@Nullable Intent intent) {
    mIntent = intent;
    return this;
}
#end_block

#method_before
@NonNull
public Destination setComponentName(@NonNull ComponentName name) {
    if (mIntent == null) {
        mIntent = new Intent();
    }
    mIntent.setComponent(name);
    return this;
}
#method_after
@NonNull
public Destination setComponentName(@Nullable ComponentName name) {
    if (mIntent == null) {
        mIntent = new Intent();
    }
    mIntent.setComponent(name);
    return this;
}
#end_block

#method_before
@NonNull
public Destination setAction(@NonNull String action) {
    if (mIntent == null) {
        mIntent = new Intent();
    }
    mIntent.setAction(action);
    return this;
}
#method_after
@NonNull
public Destination setAction(@Nullable String action) {
    if (mIntent == null) {
        mIntent = new Intent();
    }
    mIntent.setAction(action);
    return this;
}
#end_block

#method_before
@NonNull
public Destination setData(@NonNull Uri data) {
    if (mIntent == null) {
        mIntent = new Intent();
    }
    mIntent.setData(data);
    return this;
}
#method_after
@NonNull
public Destination setData(@Nullable Uri data) {
    if (mIntent == null) {
        mIntent = new Intent();
    }
    mIntent.setData(data);
    return this;
}
#end_block

#method_before
@NonNull
public Destination setDataPattern(@NonNull String dataPattern) {
    mDataPattern = dataPattern;
    return this;
}
#method_after
@NonNull
public Destination setDataPattern(@Nullable String dataPattern) {
    mDataPattern = dataPattern;
    return this;
}
#end_block

#method_before
@Nullable
public NavGraph getGraph() {
    return mGraph;
}
#method_after
// TODO https://b.corp.google.com/issues/112243286
@SuppressWarnings("UnknownNullness")
public NavGraph getGraph() {
    return mGraph;
}
#end_block

#method_before
@Override
public Socket createSocket(Socket k, String host, int port, boolean close) throws IOException {
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    } else {
        s.startHandshake();
    }
    return s;
}
#method_after
@Override
public Socket createSocket(Socket k, String host, int port, boolean close) throws IOException {
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(k, host, port, close);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}
#end_block

#method_before
@Override
public Socket createSocket(String host, int port, InetAddress localAddr, int localPort) throws IOException {
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    } else {
        s.startHandshake();
    }
    return s;
}
#method_after
@Override
public Socket createSocket(String host, int port, InetAddress localAddr, int localPort) throws IOException {
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port, localAddr, localPort);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}
#end_block

#method_before
@Override
public Socket createSocket(String host, int port) throws IOException {
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    } else {
        s.startHandshake();
    }
    return s;
}
#method_after
@Override
public Socket createSocket(String host, int port) throws IOException {
    OpenSSLSocketImpl s = (OpenSSLSocketImpl) getDelegate().createSocket(host, port);
    s.setNpnProtocols(mNpnProtocols);
    s.setAlpnProtocols(mAlpnProtocols);
    s.setHandshakeTimeout(mHandshakeTimeoutMillis);
    s.setChannelIdPrivateKey(mChannelIdPrivateKey);
    if (mSecure) {
        verifyHostname(s, host);
    }
    return s;
}
#end_block

#method_before
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = MainHandlerExecutor.getExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mFileSchemeMediaItem = createTestMediaItem2("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_file_scheme_video);
    mHttpsSchemeMediaItem = createTestMediaItem2(mContext.getResources().getString(R.string.test_https_scheme_video));
    mHttpSchemeMediaItem = createTestMediaItem2(mContext.getResources().getString(R.string.test_http_scheme_video));
    setKeepScreenOn();
    checkAttachedToWindow();
}
#method_after
@Before
public void setup() throws Throwable {
    mContext = InstrumentationRegistry.getTargetContext();
    mMainHandlerExecutor = MainHandlerExecutor.getExecutor(mContext);
    mInstrumentation = InstrumentationRegistry.getInstrumentation();
    mActivity = mActivityRule.getActivity();
    mVideoView = mActivity.findViewById(R.id.videoview);
    mFileSchemeUri = Uri.parse("android.resource://" + mContext.getPackageName() + "/" + R.raw.test_file_scheme_video);
    mHttpsSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_https_scheme_video));
    mHttpSchemeUri = Uri.parse(mContext.getResources().getString(R.string.test_http_scheme_video));
    mFileSchemeMediaItem = createTestMediaItem2(mFileSchemeUri);
    mHttpsSchemeMediaItem = createTestMediaItem2(mHttpsSchemeUri);
    mHttpSchemeMediaItem = createTestMediaItem2(mHttpSchemeUri);
    setKeepScreenOn();
    checkAttachedToWindow();
}
#end_block

#method_before
@Test
public void testPlayPauseButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayPauseButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            switch((int) latch.getCount()) {
                case 2:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PAUSED);
                    break;
                case 1:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PLAYING);
            }
            latch.countDown();
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testPlayPauseButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayPauseButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            switch((int) latch.getCount()) {
                case 2:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PAUSED);
                    break;
                case 1:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PLAYING);
            }
            latch.countDown();
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testFfwdButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testFfwdButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onSeekCompleted(@NonNull MediaController2 controller, long position) {
            if (position >= FFWD_MS) {
                latch.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.ffwd)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testFfwdButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testFfwdButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onSeekCompleted(@NonNull MediaController2 controller, long position) {
            if (position >= FFWD_MS) {
                latch.countDown();
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.ffwd)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testRewButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testRewButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(3);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            if (state == MediaPlayerConnector.PLAYER_STATE_PAUSED) {
                controller.seekTo(FFWD_MS);
                latch.countDown();
            }
        }

        @Override
        public void onSeekCompleted(@NonNull MediaController2 controller, long position) {
            switch((int) latch.getCount()) {
                case 2:
                    if (position == FFWD_MS) {
                        latch.countDown();
                    }
                    break;
                case 1:
                    if (position == FFWD_MS - REW_MS) {
                        latch.countDown();
                    }
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.rew)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
@FlakyTest
public void testRewButtonClick() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mFileSchemeUri)) {
        Log.i(TAG, "SKIPPING testRewButtonClick(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(3);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            if (state == MediaPlayerConnector.PLAYER_STATE_PAUSED) {
                controller.seekTo(FFWD_MS);
                latch.countDown();
            }
        }

        @Override
        public void onSeekCompleted(@NonNull MediaController2 controller, long position) {
            switch((int) latch.getCount()) {
                case 2:
                    if (position == FFWD_MS) {
                        latch.countDown();
                    }
                    break;
                case 1:
                    if (position == FFWD_MS - REW_MS) {
                        latch.countDown();
                    }
            }
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mFileSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
    onView(withId(R.id.rew)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testPlayHttpsSchemeVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayHttpsSchemeVideo(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            switch((int) latch.getCount()) {
                case 2:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PAUSED);
                    break;
                case 1:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PLAYING);
            }
            latch.countDown();
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mHttpsSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS * 5, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS * 5, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testPlayHttpsSchemeVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mHttpsSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayHttpsSchemeVideo(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(2);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            switch((int) latch.getCount()) {
                case 2:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PAUSED);
                    break;
                case 1:
                    assertEquals(state, MediaPlayerConnector.PLAYER_STATE_PLAYING);
            }
            latch.countDown();
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mHttpsSchemeMediaItem);
        }
    });
    assertFalse(latch.await(WAIT_TIME_MS * 5, TimeUnit.MILLISECONDS));
    onView(withId(R.id.pause)).perform(click());
    assertTrue(latch.await(WAIT_TIME_MS * 5, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
@Test
public void testPlayHttpSchemeVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec()) {
        Log.i(TAG, "SKIPPING testPlayHttpSchemeVideo(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            latch.countDown();
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mHttpSchemeMediaItem);
        }
    });
    assertFalse(latch.await(HTTPS_WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#method_after
@Test
public void testPlayHttpSchemeVideo() throws Throwable {
    // Don't run the test if the codec isn't supported.
    if (!hasCodec(mHttpSchemeUri)) {
        Log.i(TAG, "SKIPPING testPlayHttpSchemeVideo(): codec is not supported");
        return;
    }
    final CountDownLatch latch = new CountDownLatch(1);
    final MediaController2 controller = createController(new MediaController2.ControllerCallback() {

        @Override
        public void onPlayerStateChanged(@NonNull MediaController2 controller, int state) {
            latch.countDown();
        }
    });
    mActivityRule.runOnUiThread(new Runnable() {

        @Override
        public void run() {
            mVideoView.setMediaItem2(mHttpSchemeMediaItem);
        }
    });
    assertFalse(latch.await(HTTPS_WAIT_TIME_MS, TimeUnit.MILLISECONDS));
}
#end_block

#method_before
private MediaItem2 createTestMediaItem2(String uriString) {
    Uri testVideoUri = Uri.parse(uriString);
    DataSourceDesc2 dsd = new UriDataSourceDesc2.Builder(mVideoView.getContext(), testVideoUri).build();
    return new MediaItem2.Builder(MediaItem2.FLAG_PLAYABLE).setDataSourceDesc(dsd).build();
}
#method_after
private MediaItem2 createTestMediaItem2(Uri uri) {
    DataSourceDesc2 dsd = new UriDataSourceDesc2.Builder(mVideoView.getContext(), uri).build();
    return new MediaItem2.Builder(MediaItem2.FLAG_PLAYABLE).setDataSourceDesc(dsd).build();
}
#end_block

#method_before
private boolean hasCodec() {
    return MediaUtils2.hasCodecsForResource(mActivity, R.raw.testvideo);
}
#method_after
private boolean hasCodec(Uri uri) {
    return TestUtils.hasCodecsForUri(mActivity, uri);
}
#end_block

#method_before
@RequiresApi(24)
@NonNull
public static LocaleListCompat wrap(LocaleList localeList) {
    return new LocaleListCompat(new LocaleListPlatformWrapper(localeList));
}
#method_after
@RequiresApi(24)
@NonNull
public static LocaleListCompat wrap(@NonNull LocaleList localeList) {
    return new LocaleListCompat(new LocaleListPlatformWrapper(localeList));
}
#end_block

#method_before
public List<SessionToken2> getSessionServiceTokens() {
    return new ArrayList<>(mSessionServiceTokens);
}
#method_after
@NonNull
public List<SessionToken2> getSessionServiceTokens() {
    ArraySet<SessionToken2> sessionServiceTokens = new ArraySet<>();
    PackageManager pm = mContext.getPackageManager();
    List<ResolveInfo> services = new ArrayList<>();
    // If multiple actions are declared for a service, browser gets higher priority.
    List<ResolveInfo> libraryServices = pm.queryIntentServices(new Intent(MediaLibraryService2.SERVICE_INTERFACE), PackageManager.GET_META_DATA);
    if (libraryServices != null) {
        services.addAll(libraryServices);
    }
    List<ResolveInfo> sessionServices = pm.queryIntentServices(new Intent(MediaSessionService2.SERVICE_INTERFACE), PackageManager.GET_META_DATA);
    if (sessionServices != null) {
        services.addAll(sessionServices);
    }
    List<ResolveInfo> browserServices = pm.queryIntentServices(new Intent(MediaBrowserServiceCompat.SERVICE_INTERFACE), PackageManager.GET_META_DATA);
    if (browserServices != null) {
        services.addAll(browserServices);
    }
    for (ResolveInfo service : services) {
        if (service == null || service.serviceInfo == null) {
            continue;
        }
        ServiceInfo serviceInfo = service.serviceInfo;
        SessionToken2 token = new SessionToken2(mContext, new ComponentName(serviceInfo.packageName, serviceInfo.name));
        sessionServiceTokens.add(token);
    }
    if (DEBUG) {
        Log.d(TAG, "Found " + sessionServiceTokens.size() + " session services");
        for (SessionToken2 token : sessionServiceTokens) {
            Log.d(TAG, "   " + token);
        }
    }
    return new ArrayList<>(sessionServiceTokens);
}
#end_block

#method_before
@Test
public void testGetSessionServiceTokens() {
    prepareLooper();
    boolean hasMockBrowserServiceCompat = false;
    boolean hasMockSessionService2 = false;
    boolean hasMockLibraryService2 = false;
    MediaSessionManager2 sessionManager2 = MediaSessionManager2.getSessionManager2(mContext);
    List<SessionToken2> serviceTokens = sessionManager2.getSessionServiceTokens();
    for (SessionToken2 token2 : serviceTokens) {
        if (COMP_MOCK_BROWSER_SERVICE_COMPAT.equals(token2.getComponentName())) {
            hasMockBrowserServiceCompat = true;
        } else if (COMP_MOCK_SESSION_SERVICE2.equals(token2.getComponentName())) {
            hasMockSessionService2 = true;
        } else if (COMP_MOCK_LIBRARY_SERVICE2.equals(token2.getComponentName())) {
            hasMockLibraryService2 = true;
        }
    }
    assertTrue(hasMockBrowserServiceCompat);
    assertTrue(hasMockSessionService2);
    assertTrue(hasMockLibraryService2);
}
#method_after
@Test
public void testGetSessionServiceTokens() {
    prepareLooper();
    boolean hasMockBrowserServiceCompat = false;
    boolean hasMockSessionService2 = false;
    boolean hasMockLibraryService2 = false;
    MediaSessionManager2 sessionManager2 = MediaSessionManager2.getInstance(mContext);
    List<SessionToken2> serviceTokens = sessionManager2.getSessionServiceTokens();
    for (SessionToken2 token2 : serviceTokens) {
        ComponentName componentName = token2.getComponentName();
        if (!TEST_PACKAGE_NAME.equals(componentName.getPackageName())) {
            continue;
        }
        String className = componentName.getClassName();
        if (MOCK_BROWSER_SERVICE_COMPAT_NAME.equals(className)) {
            hasMockBrowserServiceCompat = true;
        } else if (MOCK_SESSION_SERVICE2_NAME.equals(className)) {
            hasMockSessionService2 = true;
        } else if (MOCK_LIBRARY_SERVICE2_NAME.equals(className)) {
            hasMockLibraryService2 = true;
        }
    }
    assertTrue(hasMockBrowserServiceCompat);
    assertTrue(hasMockSessionService2);
    assertTrue(hasMockLibraryService2);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    return mType + prime * (mUid + prime * (mPackageName.hashCode() + prime * (mId.hashCode() + prime * (mComponentName != null ? mComponentName.hashCode() : 0) + prime * (mLegacyToken != null ? mLegacyToken.hashCode() : 0))));
}
#method_after
@Override
public int hashCode() {
    return ObjectsCompat.hash(mType, mComponentName, mLegacyToken);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SessionToken2ImplLegacy)) {
        return false;
    }
    SessionToken2ImplLegacy other = (SessionToken2ImplLegacy) obj;
    if (mLegacyToken == null && other.mLegacyToken == null) {
        return ObjectsCompat.equals(mComponentName, other.mComponentName);
    }
    return ObjectsCompat.equals(mLegacyToken, other.mLegacyToken);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (!(obj instanceof SessionToken2ImplLegacy)) {
        return false;
    }
    SessionToken2ImplLegacy other = (SessionToken2ImplLegacy) obj;
    if (mType != other.mType) {
        return false;
    }
    switch(mType) {
        case TYPE_SESSION_LEGACY:
            return ObjectsCompat.equals(mLegacyToken, other.mLegacyToken);
        case TYPE_BROWSER_SERVICE_LEGACY:
            return ObjectsCompat.equals(mComponentName, other.mComponentName);
    }
    return false;
}
#end_block

#method_before
@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
@SuppressWarnings("WeakerAccess")
/* synthetic access */
boolean isBackStackEqual() {
    int fragmentBackStackCount = mFragmentManager.getBackStackEntryCount();
    // Initial fragment won't be on the FragmentManager's back stack so +1 its count.
    if (mBackStack.size() != fragmentBackStackCount + 1) {
        return false;
    }
    // From top to bottom verify destination ids match in both back stacks/
    Iterator<Integer> backStackIterator = mBackStack.descendingIterator();
    int fragmentBackStackIndex = fragmentBackStackCount - 1;
    while (backStackIterator.hasNext() && fragmentBackStackIndex >= 0) {
        int destId = backStackIterator.next();
        int fragmentDestId = Integer.valueOf(mFragmentManager.getBackStackEntryAt(fragmentBackStackIndex--).getName());
        if (destId != fragmentDestId) {
            return false;
        }
    }
    return true;
}
#method_after
@SuppressWarnings("WeakerAccess")
/* synthetic access */
boolean isBackStackEqual() {
    int fragmentBackStackCount = mFragmentManager.getBackStackEntryCount();
    // Initial fragment won't be on the FragmentManager's back stack so +1 its count.
    if (mBackStack.size() != fragmentBackStackCount + 1) {
        return false;
    }
    // From top to bottom verify destination ids match in both back stacks/
    Iterator<Integer> backStackIterator = mBackStack.descendingIterator();
    int fragmentBackStackIndex = fragmentBackStackCount - 1;
    while (backStackIterator.hasNext() && fragmentBackStackIndex >= 0) {
        int destId = backStackIterator.next();
        int fragmentDestId = Integer.valueOf(mFragmentManager.getBackStackEntryAt(fragmentBackStackIndex--).getName());
        if (destId != fragmentDestId) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsMet() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    Constraints constraints = new Constraints.Builder().setRequiresBatteryNotLow(true).build();
    String delegateName = EchoingWorker.class.getName();
    Data input = new Data.Builder().putString(ConstraintTrackingWorker.ARGUMENT_CLASS_NAME, delegateName).putBoolean(TEST_ARGUMENT_NAME, true).build();
    final OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(ConstraintTrackingWorker.class).setInputData(input).setConstraints(constraints).build();
    insertWork(work);
    String workSpecId = work.getStringId();
    ConstraintTrackingWorker worker = (ConstraintTrackingWorker) WorkerWrapper.workerFromClassName(mContext, ConstraintTrackingWorker.class.getName(), work.getId(), new Extras(input, Collections.<String>emptyList(), mRuntimeExtras, 1));
    mWorker = spy(worker);
    when(mWorker.getWorkDatabase()).thenReturn(mDatabase);
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, workSpecId);
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(workSpecId);
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.SUCCEEDED));
    Data output = workSpec.output;
    assertThat(output.getBoolean(TEST_ARGUMENT_NAME, false), is(true));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsMet() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    setupDelegateForExecution(EchoingWorker.class.getName());
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, mWork.getStringId());
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.SUCCEEDED));
    Data output = workSpec.output;
    assertThat(output.getBoolean(TEST_ARGUMENT_NAME, false), is(true));
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsNotMet() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(false);
    Constraints constraints = new Constraints.Builder().setRequiresBatteryNotLow(true).build();
    String delegateName = TestWorker.class.getName();
    Data input = new Data.Builder().putString(ConstraintTrackingWorker.ARGUMENT_CLASS_NAME, delegateName).build();
    final OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(ConstraintTrackingWorker.class).setConstraints(constraints).build();
    insertWork(work);
    String workSpecId = work.getStringId();
    ConstraintTrackingWorker worker = (ConstraintTrackingWorker) WorkerWrapper.workerFromClassName(mContext, ConstraintTrackingWorker.class.getName(), work.getId(), new Extras(input, Collections.<String>emptyList(), mRuntimeExtras, 1));
    mWorker = spy(worker);
    when(mWorker.getWorkDatabase()).thenReturn(mDatabase);
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, workSpecId);
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(workSpecId);
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsNotMet() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(false);
    setupDelegateForExecution(TestWorker.class.getName());
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, mWork.getStringId());
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsChanged() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    Constraints constraints = new Constraints.Builder().setRequiresBatteryNotLow(true).build();
    String delegateName = SleepTestWorker.class.getName();
    Data input = new Data.Builder().putString(ConstraintTrackingWorker.ARGUMENT_CLASS_NAME, delegateName).build();
    final OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(ConstraintTrackingWorker.class).setConstraints(constraints).build();
    insertWork(work);
    String workSpecId = work.getStringId();
    ConstraintTrackingWorker worker = (ConstraintTrackingWorker) WorkerWrapper.workerFromClassName(mContext, ConstraintTrackingWorker.class.getName(), work.getId(), new Extras(input, Collections.<String>emptyList(), mRuntimeExtras, 1));
    mWorker = spy(worker);
    when(mWorker.getWorkDatabase()).thenReturn(mDatabase);
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, workSpecId);
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            mBatteryNotLowTracker.setState(false);
        }
    }, DELAY_IN_MILLIS);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(workSpecId);
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsChanged() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    setupDelegateForExecution(SleepTestWorker.class.getName());
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, mWork.getStringId());
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            mBatteryNotLowTracker.setState(false);
        }
    }, DELAY_IN_MILLIS);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#end_block

#method_before
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsChangedTwice() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    Constraints constraints = new Constraints.Builder().setRequiresBatteryNotLow(true).build();
    String delegateName = SleepTestWorker.class.getName();
    Data input = new Data.Builder().putString(ConstraintTrackingWorker.ARGUMENT_CLASS_NAME, delegateName).build();
    final OneTimeWorkRequest work = new OneTimeWorkRequest.Builder(ConstraintTrackingWorker.class).setConstraints(constraints).build();
    insertWork(work);
    String workSpecId = work.getStringId();
    ConstraintTrackingWorker worker = (ConstraintTrackingWorker) WorkerWrapper.workerFromClassName(mContext, ConstraintTrackingWorker.class.getName(), work.getId(), new Extras(input, Collections.<String>emptyList(), mRuntimeExtras, 1));
    mWorker = spy(worker);
    when(mWorker.getWorkDatabase()).thenReturn(mDatabase);
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, workSpecId);
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            mBatteryNotLowTracker.setState(false);
        }
    }, DELAY_IN_MILLIS);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            mBatteryNotLowTracker.setState(true);
        }
    }, DELAY_IN_MILLIS);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(workSpecId);
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#method_after
@Test
@SdkSuppress(minSdkVersion = 23, maxSdkVersion = 25)
public void testConstraintTrackingWorker_onConstraintsChangedTwice() throws InterruptedException {
    when(mBatteryNotLowTracker.getInitialState()).thenReturn(true);
    setupDelegateForExecution(SleepTestWorker.class.getName());
    WorkerWrapper.Builder builder = new WorkerWrapper.Builder(mContext, mConfiguration, mDatabase, mWork.getStringId());
    builder.withWorker(mWorker).withListener(// set on ConstraintTrackingWorker
    null).withSchedulers(Collections.singletonList(mScheduler));
    mWorkerWrapper = builder.build();
    mExecutorService.submit(mWorkerWrapper);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            mBatteryNotLowTracker.setState(false);
        }
    }, DELAY_IN_MILLIS);
    mHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            mBatteryNotLowTracker.setState(true);
        }
    }, DELAY_IN_MILLIS);
    mLatch.await(TEST_TIMEOUT_IN_SECONDS, TimeUnit.SECONDS);
    WorkSpec workSpec = mDatabase.workSpecDao().getWorkSpec(mWork.getStringId());
    assertThat(mLatch.getCount(), is(0L));
    assertThat(workSpec.state, is(State.ENQUEUED));
}
#end_block

#method_before
public void testCurrencySymbolSpacing() {
    for (Locale locale : Locale.getAvailableLocales()) {
        DecimalFormatSymbols dfs = new DecimalFormatSymbols(locale);
        Currency currency = Currency.getInstance(Locale.US);
        String formattedZero = new DecimalFormat("0", dfs).format(0);
        DecimalFormat df = new DecimalFormat("¤¤0", dfs);
        df.setCurrency(currency);
        df.setMaximumFractionDigits(0);
        String expected = currency.getCurrencyCode() + formattedZero;
        assertEquals("This locale has extra spacing:" + locale, expected, df.format(0));
        df = new DecimalFormat("0¤¤", dfs);
        df.setCurrency(currency);
        df.setMaximumFractionDigits(0);
        expected = formattedZero + currency.getCurrencyCode();
        assertEquals("This locale has extra spacing:" + locale, expected, df.format(0));
        df = new DecimalFormat("¤0", dfs);
        df.setCurrency(currency);
        df.setMaximumFractionDigits(0);
        expected = currency.getSymbol(locale) + formattedZero;
        assertEquals("This locale has extra spacing:" + locale, expected, df.format(0));
        df = new DecimalFormat("0¤", dfs);
        df.setCurrency(currency);
        df.setMaximumFractionDigits(0);
        expected = formattedZero + currency.getSymbol(locale);
        assertEquals("This locale has extra spacing:" + locale, expected, df.format(0));
    }
}
#method_after
public void testCurrencySymbolSpacing() {
    Currency currency = Currency.getInstance(Locale.US);
    for (Locale locale : Locale.getAvailableLocales()) {
        DecimalFormatSymbols dfs = new DecimalFormatSymbols(locale);
        String formattedZero = new DecimalFormat("0", dfs).format(0);
        assertCurrencyFormat("USD" + formattedZero, "\u00a4\u00a40", dfs, currency, locale);
        assertCurrencyFormat(formattedZero + "USD", "0\u00a4\u00a4", dfs, currency, locale);
        assertCurrencyFormat(currency.getSymbol(locale) + formattedZero, "\u00a40", dfs, currency, locale);
        assertCurrencyFormat(formattedZero + currency.getSymbol(locale), "0\u00a4", dfs, currency, locale);
    }
}
#end_block

#method_before
// Test that getMaximumIntegerDigits should return value >= 309 by default, even though a
// leading optional digit # is provided in the input pattern. The java doc specifies that
// "For formatting numbers other than BigInteger and BigDecimal objects, the lower of the return
// value and 309 is used". The default return value of getMaximumIntegerDigits should be larger
public void testDefaultGetMaximumIntegerDigits() {
    Locale originalLocale = Locale.getDefault();
    try {
        Locale.setDefault(Locale.US);
        DecimalFormat df = new DecimalFormat();
        int maxIntegerDigits = df.getMaximumIntegerDigits();
        assertTrue("getMaximumIntegerDigits should be >= 309, but returns " + maxIntegerDigits, maxIntegerDigits >= 309);
        String[] patterns = new String[] { "0", "#0", "#.", "#", ".#", "#.#", "#,##0.00", "#,##0.00%", "#,##0.00%" };
        for (String pattern : patterns) {
            df = new DecimalFormat(pattern);
            maxIntegerDigits = df.getMaximumIntegerDigits();
            assertTrue("getMaximumIntegerDigits should be >= 309, but returns " + maxIntegerDigits, maxIntegerDigits >= 309);
        }
    } finally {
        Locale.setDefault(originalLocale);
    }
}
#method_after
// Test that getMaximumIntegerDigits should return value >= 309 by default, even though a
// leading optional digit # is provided in the input pattern. 309 is chosen because
// it is the upper limit of integer digits when formatting numbers other than BigInteger
public void testDefaultGetMaximumIntegerDigits() {
    Locale originalLocale = Locale.getDefault();
    try {
        Locale.setDefault(Locale.US);
        DecimalFormat df = new DecimalFormat();
        int maxIntegerDigits = df.getMaximumIntegerDigits();
        assertTrue("getMaximumIntegerDigits should be >= 309, but returns " + maxIntegerDigits, maxIntegerDigits >= 309);
        String[] patterns = new String[] { "0", "#0", "#.", "#", ".#", "#.#", "#,##0.00", "#,##0.00%", "#,##0.00%", "¤#,##0.00%", "#00.00", "#,#00.00" };
        for (String pattern : patterns) {
            df = new DecimalFormat(pattern);
            maxIntegerDigits = df.getMaximumIntegerDigits();
            assertTrue("getMaximumIntegerDigits should be >= 309, but returns " + maxIntegerDigits, maxIntegerDigits >= 309);
        }
    } finally {
        Locale.setDefault(originalLocale);
    }
}
#end_block

#method_before
@Before
public void setup() throws IOException {
    System.out.println("\n======= STARTING TEST: " + mTestName.getMethodName() + " =======\n");
    mStatus = mock(Status.class, withSettings().verboseLogging());
    mJavac = new Javac();
    mJavac.addSource("annotation.Anno", Joiner.on('\n').join("package annotation;", "import static java.lang.annotation.RetentionPolicy.CLASS;", "import java.lang.annotation.Retention;", "import java.lang.annotation.Target;", "@Retention(CLASS)", "public @interface Anno {", "  String expectedSignature() default \"\";", "}"));
}
#method_after
@Before
public void setup() throws IOException {
    System.out.println(String.format("\n============== STARTING TEST: %s ==============\n", mTestName.getMethodName()));
    mStatus = mock(Status.class, withSettings().verboseLogging());
    mJavac = new Javac();
    mJavac.addSource("annotation.Anno", Joiner.on('\n').join("package annotation;", "import static java.lang.annotation.RetentionPolicy.CLASS;", "import java.lang.annotation.Retention;", "import java.lang.annotation.Target;", "@Retention(CLASS)", "public @interface Anno {", "  String expectedSignature() default \"\";", "}"));
}
#end_block

#method_before
@Test
public void testOverrideMethodWithBridge() throws IOException {
    mJavac.addSource("a.b.Base", Joiner.on('\n').join("package a.b;", "abstract class Base<T> {", "  protected abstract void method(T arg);", "}"));
    mJavac.addSource("a.b.Class", Joiner.on('\n').join("package a.b;", "import annotation.Anno;", "public class Class<T extends String> extends Base<T> {", "  @Override", "  @Anno(expectedSignature=\"La/b/Class;->method(Ljava/lang/String;)V\")", "  public void method(T arg) {}", "}"));
    assertThat(mJavac.compile()).isTrue();
    new AnnotationVisitor(mJavac.getCompiledClass("a.b.Class"), ANNOTATION, mStatus).visit();
    assertNoErrors();
    ArgumentCaptor<String> greylist = ArgumentCaptor.forClass(String.class);
    // A bridge method is generated for the above, so we expect 2 greylist entries.
    verify(mStatus, times(2)).greylistEntry(greylist.capture());
    assertThat(greylist.getAllValues()).containsExactly("La/b/Class;->method(Ljava/lang/Object;)V", "La/b/Class;->method(Ljava/lang/String;)V");
}
#method_after
@Test
public void testOverrideMethodWithBridge() throws IOException {
    mJavac.addSource("a.b.Base", Joiner.on('\n').join("package a.b;", "abstract class Base<T> {", "  protected abstract void method(T arg);", "}"));
    mJavac.addSource("a.b.Class", Joiner.on('\n').join("package a.b;", "import annotation.Anno;", "public class Class<T extends String> extends Base<T> {", "  @Override", "  @Anno(expectedSignature=\"La/b/Class;->method(Ljava/lang/String;)V\")", "  public void method(T arg) {}", "}"));
    assertThat(mJavac.compile()).isTrue();
    new AnnotationVisitor(mJavac.getCompiledClass("a.b.Base"), ANNOTATION, mStatus).visit();
    new AnnotationVisitor(mJavac.getCompiledClass("a.b.Class"), ANNOTATION, mStatus).visit();
    assertNoErrors();
    ArgumentCaptor<String> greylist = ArgumentCaptor.forClass(String.class);
    // A bridge method is generated for the above, so we expect 2 greylist entries.
    verify(mStatus, times(2)).greylistEntry(greylist.capture());
    assertThat(greylist.getAllValues()).containsExactly("La/b/Class;->method(Ljava/lang/Object;)V", "La/b/Class;->method(Ljava/lang/String;)V");
}
#end_block

#method_before
private void generateSetting(Customizations customizations, boolean isLowRamDevice) {
    if (ShadowOverlayContainer.supportsDynamicShadow()) {
        mPreferStaticShadows = false;
        if (customizations != null) {
            mPreferStaticShadows = customizations.getBoolean("leanback_prefer_static_shadows", mPreferStaticShadows);
        }
    } else {
        mPreferStaticShadows = true;
    }
    if (Build.VERSION.SDK_INT >= 21) {
        mOutlineClippingDisabled = isLowRamDevice;
        if (customizations != null) {
            mOutlineClippingDisabled = customizations.getBoolean("leanback_outline_clipping_disabled", mOutlineClippingDisabled);
        }
    } else {
        mOutlineClippingDisabled = true;
    }
    if (DEBUG)
        Log.v(TAG, "generated preference " + PREFER_STATIC_SHADOWS + ": " + mPreferStaticShadows + " " + OUTLINE_CLIPPING_DISABLED + " : " + mOutlineClippingDisabled);
}
#method_after
private void generateSetting(Customizations customizations, Context context) {
    if (ShadowOverlayContainer.supportsDynamicShadow()) {
        mPreferStaticShadows = false;
        if (customizations != null) {
            mPreferStaticShadows = customizations.getBoolean("leanback_prefer_static_shadows", mPreferStaticShadows);
        }
    } else {
        mPreferStaticShadows = true;
    }
    if (Build.VERSION.SDK_INT >= 21) {
        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        mOutlineClippingDisabled = activityManager.isLowRamDevice();
        if (customizations != null) {
            mOutlineClippingDisabled = customizations.getBoolean("leanback_outline_clipping_disabled", mOutlineClippingDisabled);
        }
    } else {
        mOutlineClippingDisabled = true;
    }
    if (DEBUG)
        Log.v(TAG, "generated preference " + PREFER_STATIC_SHADOWS + ": " + mPreferStaticShadows + " " + OUTLINE_CLIPPING_DISABLED + " : " + mOutlineClippingDisabled);
}
#end_block

#method_before
void setItems() {
    mItems.clear();
    // Add list items of route section to mItems
    mItems.add(new Item(mContext.getString(R.string.mr_chooser_title)));
    for (MediaRouter.RouteInfo route : mRoutes) {
        mItems.add(new Item(route));
    }
    notifyDataSetChanged();
}
#method_after
void setItems() {
    mItems.clear();
    mItems.add(new Item(mContext.getString(R.string.mr_chooser_title)));
    for (MediaRouter.RouteInfo route : mRoutes) {
        mItems.add(new Item(route));
    }
    notifyDataSetChanged();
}
#end_block

