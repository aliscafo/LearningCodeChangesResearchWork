473
#method_before
public boolean poll(Guid hostId) {
    waitBetweenPolls();
    LOGGER.trace("Request to do poll for {}.", hostId);
    FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.Poll, new VdsIdVDSCommandParametersBase(hostId));
    LOGGER.trace("task executed.");
    boolean succeeded = getValue(task);
    LOGGER.trace("task result={}", succeeded);
    return succeeded;
}
#method_after
public boolean poll(Guid hostId) {
    waitBetweenPolls();
    LOGGER.trace("Request to do poll for host {}.", hostId);
    FutureVDSCall<VDSReturnValue> task = Backend.getInstance().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.Poll, new VdsIdVDSCommandParametersBase(hostId));
    LOGGER.trace("FutureVDSCommandType.Poll executed for host{}.", hostId);
    boolean succeeded = getValue(task);
    LOGGER.trace("Result of FutureVDSCommandType.Poll for host {}: {}", hostId, succeeded);
    timestampOfEndOfPreviousInvocation = currentTimestamp();
    return succeeded;
}
#end_block

#method_before
private void waitBetweenPolls() {
    /*
         * Please notice, that thread sleep does not guarantee to return *only after* required time period passed.
         * It may return sooner. When testing with required 500ms sleep, thread awaken after ~ 200ms, which is not even
         * close.
        * */
    while (lastTimeBeforePoll != null && System.currentTimeMillis() - lastTimeBeforePoll < POLLING_BREAK) {
        try {
            Thread.sleep(POLLING_BREAK);
        } catch (InterruptedException e) {
        // ignore.
        }
    }
    lastTimeBeforePoll = System.currentTimeMillis();
}
#method_after
private void waitBetweenPolls() {
    /*
         * Please notice, that thread sleep does not guarantee to return *only after* required time period passed.
         * It may return sooner. When testing with required 500ms sleep, thread awaken after ~ 200ms, which is not even
         * close.
        * */
    while (timestampOfEndOfPreviousInvocation != null && currentTimestamp() - timestampOfEndOfPreviousInvocation < POLLING_BREAK_IN_NANOS) {
        try {
            Thread.sleep(POLLING_BREAK);
        } catch (InterruptedException e) {
        // ignore.
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    return false;
                }
            }
        }
    }
    vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    return false;
                }
            }
        }
    }
    vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static ArrayList<VmNetworkInterface> buildVmNetworkInterfacesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<VmNetworkInterface> nics = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get("devices");
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.VM_INTERFACE_DEVICE_TYPE.equals(deviceMap.get(VdsProperties.Type))) {
                VmNetworkInterface nic = new VmNetworkInterface();
                nic.setId(deviceMap.get(VdsProperties.DeviceId) != null ? new Guid((String) deviceMap.get(VdsProperties.DeviceId)) : null);
                nic.setMacAddress((String) deviceMap.get(VdsProperties.MAC_ADDR));
                nic.setName((String) deviceMap.get(VdsProperties.Name));
                // FIXME we can't deduce the network profile by the network name. its many to many.
                nic.setNetworkName((String) deviceMap.get(VdsProperties.NETWORK));
                nic.setType(VmInterfaceType.valueOf((String) deviceMap.get(VdsProperties.NIC_TYPE)).getValue());
                if (deviceMap.containsKey(VdsProperties.Model)) {
                    String model = (String) deviceMap.get(VdsProperties.Model);
                    for (VmInterfaceType type : VmInterfaceType.values()) {
                        if (model.equals(type.getInternalName())) {
                            nic.setType(type.getValue());
                            break;
                        }
                    }
                }
                nics.add(nic);
            }
        }
    }
    return nics;
}
#method_after
public static ArrayList<VmNetworkInterface> buildVmNetworkInterfacesFromDevices(Map<String, Object> vmStruct) {
    ArrayList<VmNetworkInterface> nics = new ArrayList<>();
    Object[] devices = (Object[]) vmStruct.get(VdsProperties.Devices);
    if (devices != null) {
        for (Object device : devices) {
            Map<String, Object> deviceMap = (Map<String, Object>) device;
            if (VdsProperties.VM_INTERFACE_DEVICE_TYPE.equals(deviceMap.get(VdsProperties.Type))) {
                VmNetworkInterface nic = new VmNetworkInterface();
                nic.setId(Guid.createGuidFromString((String) deviceMap.get(VdsProperties.DeviceId)));
                nic.setMacAddress((String) deviceMap.get(VdsProperties.MAC_ADDR));
                nic.setName((String) deviceMap.get(VdsProperties.Name));
                // FIXME we can't deduce the network profile by the network name. its many to many.
                nic.setNetworkName((String) deviceMap.get(VdsProperties.NETWORK));
                nic.setType(VmInterfaceType.valueOf((String) deviceMap.get(VdsProperties.NIC_TYPE)).getValue());
                if (deviceMap.containsKey(VdsProperties.Model)) {
                    String model = (String) deviceMap.get(VdsProperties.Model);
                    for (VmInterfaceType type : VmInterfaceType.values()) {
                        if (model.equals(type.getInternalName())) {
                            nic.setType(type.getValue());
                            break;
                        }
                    }
                }
                nics.add(nic);
            }
        }
    }
    return nics;
}
#end_block

#method_before
private void removeUserRemovedNetworkAttachments(List<NetworkAttachment> existingNetworkAttachments) {
    for (Guid attachmentId : userRemovedNetworkAttachments) {
        networkAttachmentDao.remove(attachmentId);
    }
    // Remove the attachment from the existing attachments list
    for (Iterator<NetworkAttachment> iterator = existingNetworkAttachments.iterator(); iterator.hasNext(); ) {
        Guid networkAttachmentId = iterator.next().getId();
        if (networkAttachmentId != null && userRemovedNetworkAttachments.contains(networkAttachmentId)) {
            iterator.remove();
            break;
        }
    }
}
#method_after
private void removeUserRemovedNetworkAttachments(List<NetworkAttachment> existingNetworkAttachments) {
    for (Guid attachmentId : userRemovedNetworkAttachments) {
        networkAttachmentDao.remove(attachmentId);
    }
    // Remove the attachment from the existing attachments list
    for (Iterator<NetworkAttachment> iterator = existingNetworkAttachments.iterator(); iterator.hasNext(); ) {
        Guid networkAttachmentId = iterator.next().getId();
        if (userRemovedNetworkAttachments.contains(networkAttachmentId)) {
            iterator.remove();
        }
    }
}
#end_block

#method_before
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit, PendingResourceManager pendingResourceManager) {
    switch(policyUnit.getName()) {
        case "Migration":
            return new MigrationPolicyUnit(policyUnit, pendingResourceManager);
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit, pendingResourceManager);
        case "CPU":
            return new CPUPolicyUnit(policyUnit, pendingResourceManager);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit, pendingResourceManager);
        case "Network":
            return new NetworkPolicyUnit(policyUnit, pendingResourceManager);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForHaReservation":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HaReservationWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new HaReservationBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit, pendingResourceManager);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new NoneWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new NoneBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new PowerSavingWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new PowerSavingBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenDistributionWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenDistributionBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "VmAffinityGroups":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new VmAffinityFilterPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new VmAffinityWeightPolicyUnit(policyUnit, pendingResourceManager);
            }
        case "Emulated-Machine":
            return new EmulatedMachineFilterPolicyUnit(policyUnit, pendingResourceManager);
        case "HostDevice":
            return new HostDeviceFilterPolicyUnit(policyUnit, pendingResourceManager);
        case "InClusterUpgrade":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new InClusterUpgradeFilterPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new InClusterUpgradeWeightPolicyUnit(policyUnit, pendingResourceManager);
            }
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#method_after
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit, PendingResourceManager pendingResourceManager) {
    switch(policyUnit.getName()) {
        case "Migration":
            return new MigrationPolicyUnit(policyUnit, pendingResourceManager);
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit, pendingResourceManager);
        case "CPU":
            return new CPUPolicyUnit(policyUnit, pendingResourceManager);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit, pendingResourceManager);
        case "Network":
            return new NetworkPolicyUnit(policyUnit, pendingResourceManager);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForHaReservation":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new HaReservationWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new HaReservationBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit, pendingResourceManager);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new NoneWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new NoneBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new PowerSavingWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new PowerSavingBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenDistributionWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenDistributionBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "OptimalForEvenGuestDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new EvenGuestDistributionWeightPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LOAD_BALANCING) {
                return new EvenGuestDistributionBalancePolicyUnit(policyUnit, pendingResourceManager);
            }
            break;
        case "VmAffinityGroups":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new VmAffinityFilterPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new VmAffinityWeightPolicyUnit(policyUnit, pendingResourceManager);
            }
        case "Emulated-Machine":
            return new EmulatedMachineFilterPolicyUnit(policyUnit, pendingResourceManager);
        case "HostDevice":
            return new HostDeviceFilterPolicyUnit(policyUnit, pendingResourceManager);
        case "CpuPinning":
            return new CpuPinningPolicyUnit(policyUnit, pendingResourceManager);
        case "InClusterUpgrade":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.FILTER) {
                return new InClusterUpgradeFilterPolicyUnit(policyUnit, pendingResourceManager);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.WEIGHT) {
                return new InClusterUpgradeWeightPolicyUnit(policyUnit, pendingResourceManager);
            }
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    final VdsDynamic lastHost = getLastHost(vm);
    if (lastHost == null) {
        return noWeights(hosts);
    }
    final OS lastHostOs = OS.fromPackageVersionString(lastHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Reference host {} provides an invalid or incomplete OS identifier. Found {}.", lastHost.getId(), lastHost.getHostOs());
        return noWeights(hosts);
    }
    final List<Pair<Guid, Integer>> weights = new ArrayList<>();
    for (final VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provides an invalid or incomplete OS identifier. Found {}.", host.getId(), host.getHostOs());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BETTER_WEIGHT));
        } else {
            weights.add(toWeight(host, BEST_WEIGHT));
        }
    }
    return weights;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    final VdsDynamic sourceHost = getLastHost(vm);
    if (sourceHost == null) {
        return noWeights(hosts);
    }
    final OS lastHostOs = OS.fromPackageVersionString(sourceHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Source host {} does not provide a valid OS identifier. Found {}.", sourceHost.getId(), sourceHost.getHostOs());
        return noWeights(hosts);
    }
    final List<Pair<Guid, Integer>> weights = new ArrayList<>();
    for (final VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provide a valid OS identifier. Found {}.", host.getId(), host.getHostOs());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BETTER_WEIGHT));
        } else {
            weights.add(toWeight(host, BEST_WEIGHT));
        }
    }
    return weights;
}
#end_block

#method_before
public boolean isNewerThan(final OS os) {
    return getVersion().compareTo(os.getVersion()) > 0;
}
#method_after
public boolean isNewerThan(final OS os) {
    return getVersion().greater(os.getVersion());
}
#end_block

#method_before
public boolean isOlderThan(final OS os) {
    return getVersion().compareTo(os.getVersion()) < 0;
}
#method_after
public boolean isOlderThan(final OS os) {
    return getVersion().less(os.getVersion());
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    final VdsDynamic lastHost = getLastHost(vm);
    if (lastHost == null) {
        return hosts;
    }
    final OS lastHostOs = OS.fromPackageVersionString(lastHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Reference host {} does not provide a valid and complete OS identifier. Found {}.", lastHost.getId(), lastHost.getHostOs());
        return hosts;
    }
    final List<VDS> notOlderHosts = new ArrayList();
    for (VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provides a valid and complete OS identifier. Found {}.", host.getId(), host.getHostOs());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__INVALID_OS.name());
            messages.addMessage(host.getId(), String.format("$os %1$s", host.getHostOs()));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__WRONG_OS.name());
            messages.addMessage(host.getId(), String.format("$expected %1$s", lastHostOs.getName()));
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            log.debug("Host {} runs a too old OS version. Found {}", host.getId(), hostOs.getName());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__OLD_OS.name());
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else {
            notOlderHosts.add(host);
        }
    }
    return notOlderHosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    final VdsDynamic sourceHost = getLastHost(vm);
    if (sourceHost == null) {
        return hosts;
    }
    final OS lastHostOs = OS.fromPackageVersionString(sourceHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Source host {} does not provide a valid and complete OS identifier. Found {}.", sourceHost.getId(), sourceHost.getHostOs());
        return hosts;
    }
    final List<VDS> notOlderHosts = new ArrayList();
    for (VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provides a valid and complete OS identifier. Found {}.", host.getId(), host.getHostOs());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__INVALID_OS.name());
            messages.addMessage(host.getId(), String.format("$os %1$s", host.getHostOs()));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__WRONG_OS.name());
            messages.addMessage(host.getId(), String.format("$expected %1$s", lastHostOs.getName()));
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            log.debug("Host {} runs a too old OS version. Found {}", host.getId(), host.getHostOs());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__OLD_OS.name());
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else {
            notOlderHosts.add(host);
        }
    }
    return notOlderHosts;
}
#end_block

#method_before
@Before
public void setUp() {
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 5.0 - 1.el5");
    currentHost = newHost("RHEL - 6.1 - 1.el6");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(VdsDynamicDao.class, vdsDynamicDao);
    inClusterUpgradeFilterPolicyUnit = new InClusterUpgradeFilterPolicyUnit(null, null);
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 5.0 - 1.el5");
    currentHost = newHost("RHEL - 6.1 - 1.el6");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#end_block

#method_before
@Before
public void setUp() {
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 5.0 - 1.el5");
    currentHost = newHost("RHEL - 6.1 - 1.el6");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#method_after
@Before
public void setUp() {
    injectorRule.bind(VdsDynamicDao.class, vdsDynamicDao);
    inClusterUpgradeWeightPolicyUnit = new InClusterUpgradeWeightPolicyUnit(null, null);
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 5.0 - 1.el5");
    currentHost = newHost("RHEL - 6.1 - 1.el6");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#end_block

#method_before
@Override
public /**
 */
List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    VdsDynamic referenceHost = getLastHost(vm);
    boolean isVmStartup = false;
    // Check if the VM is starting
    if (referenceHost == null) {
        isVmStartup = true;
        final Map<String, Version> highestVersions = new HashMap<>();
        for (VDS host : hosts) {
            OS os = OS.fromPackageVersionString(host.getHostOs());
            if (!os.isValid()) {
                continue;
            }
            Version version = highestVersions.get(os.getOsFamily());
            if (version == null || version.getMajor() < os.getVersion().getMajor()) {
                highestVersions.put(os.getOsFamily(), version);
                referenceHost = host.getDynamicData();
            }
        }
        if (highestVersions.isEmpty()) {
            log.debug("No valid OS descriptors detected. Will not weight hosts on VM startup.");
            return noWeights(hosts);
        } else if (highestVersions.size() > 1) {
            log.debug("More than one OS family detected. Will not weight hosts on VM startup.");
            return noWeights(hosts);
        }
    }
    final OS lastHostOs = OS.fromPackageVersionString(referenceHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Reference host {} provides an invalid or incomplete OS identifier. Found {}.", referenceHost.getId(), referenceHost.getHostOs());
        return noWeights(hosts);
    }
    final List<Pair<Guid, Integer>> weights = new ArrayList<>();
    for (final VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provides an invalid or incomplete OS identifier. Found {}.", host.getId(), host.getHostOs());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isSameOsFamily(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isSameMajorVersion(lastHostOs) && !isVmStartup) {
            weights.add(toWeight(host, BETTER_WEIGHT));
        } else {
            weights.add(toWeight(host, BEST_WEIGHT));
        }
    }
    return weights;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    VdsDynamic referenceHost = getLastHost(vm);
    boolean isVmStartup = false;
    // Check if the VM is starting
    if (referenceHost == null) {
        isVmStartup = true;
        final Map<String, Version> highestVersions = new HashMap<>();
        for (VDS host : hosts) {
            OS os = OS.fromPackageVersionString(host.getHostOs());
            if (!os.isValid()) {
                continue;
            }
            Version version = highestVersions.get(os.getOsFamily());
            if (version == null || version.getMajor() < os.getVersion().getMajor()) {
                highestVersions.put(os.getOsFamily(), version);
                referenceHost = host.getDynamicData();
            }
        }
        if (highestVersions.isEmpty()) {
            log.debug("No valid OS descriptors detected. Will not weight hosts on VM startup.");
            return noWeights(hosts);
        } else if (highestVersions.size() > 1) {
            log.debug("More than one OS family detected. Will not weight hosts on VM startup.");
            return noWeights(hosts);
        }
    }
    final OS lastHostOs = OS.fromPackageVersionString(referenceHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Reference host {} provides an invalid or incomplete OS identifier. Found {}.", referenceHost.getId(), referenceHost.getHostOs());
        return noWeights(hosts);
    }
    final List<Pair<Guid, Integer>> weights = new ArrayList<>();
    for (final VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provide an valid OS identifier. Found {}.", host.getId(), host.getHostOs());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isSameOsFamily(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isSameMajorVersion(lastHostOs) && !isVmStartup) {
            weights.add(toWeight(host, BETTER_WEIGHT));
        } else {
            weights.add(toWeight(host, BEST_WEIGHT));
        }
    }
    return weights;
}
#end_block

#method_before
@OnTimerMethodAnnotation("refresh")
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    final List<VM> vmCandidates = new ArrayList<>();
    for (VDSGroup cluster : vdsGroupDao.getWithoutMigratingVms()) {
        if (!cluster.isInUpgradeMode()) {
            final VM candidate = rulesEnforcer.chooseNextVmToMigrate(cluster);
            if (candidate != null) {
                vmCandidates.add(candidate);
            }
        }
    }
    // Trigger migrations
    for (VM vm : vmCandidates) {
        migrateVM(vm);
    }
}
#method_after
@OnTimerMethodAnnotation("refresh")
public void refresh() {
    log.debug("Affinity Rules Enforcement Manager interval reached.");
    final List<VM> vmCandidates = new ArrayList<>();
    for (Cluster cluster : clusterDao.getWithoutMigratingVms()) {
        if (!cluster.isInUpgradeMode()) {
            final VM candidate = rulesEnforcer.chooseNextVmToMigrate(cluster);
            if (candidate != null) {
                vmCandidates.add(candidate);
            }
        }
    }
    // Trigger migrations
    for (VM vm : vmCandidates) {
        migrateVM(vm);
    }
}
#end_block

#method_before
private void scheduleJobs(long regularInterval, long longInterval) {
    scheduler.scheduleAFixedDelayJob(this, "refresh", new Class[] {}, new Object[] {}, regularInterval, longInterval, TimeUnit.MINUTES);
}
#method_after
private void scheduleJobs(long regularInterval, long initialInterval) {
    scheduler.scheduleAFixedDelayJob(this, "refresh", new Class[] {}, new Object[] {}, initialInterval, regularInterval, TimeUnit.MINUTES);
}
#end_block

#method_before
@Before
public void setup() {
    vdsGroup1 = createVdsGroup();
    vdsGroup2 = createVdsGroup();
    when(vdsGroupDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(vdsGroup1, vdsGroup2));
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup1))).thenReturn(vm1);
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup2))).thenReturn(vm2);
    arem.wakeup();
}
#method_after
@Before
public void setup() {
    cluster1 = createCluster();
    cluster2 = createCluster();
    when(clusterDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(cluster1, cluster2));
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster1))).thenReturn(vm1);
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster2))).thenReturn(vm2);
    arem.wakeup();
}
#end_block

#method_before
@Test
public void shouldMigrateOneVmPerCluster() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup1))).thenReturn(vm1, mock(VM.class), mock(VM.class));
    arem.refresh();
    verify(arem, times(1)).migrateVM(eq(vm1));
    verify(arem, times(1)).migrateVM(eq(vm2));
    verify(arem, times(2)).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldMigrateOneVmPerCluster() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster1))).thenReturn(vm1, mock(VM.class), mock(VM.class));
    arem.refresh();
    verify(arem, times(1)).migrateVM(eq(vm1));
    verify(arem, times(1)).migrateVM(eq(vm2));
    verify(arem, times(2)).migrateVM(any(VM.class));
}
#end_block

#method_before
@Test
public void shouldNotMigrateVmOnClusterTwoWhileMigrating() {
    final VM migratingVM = new VM();
    migratingVM.setVdsGroupId(vdsGroup2.getId());
    when(vdsGroupDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(vdsGroup1));
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldNotMigrateVmOnClusterTwoWhileMigrating() {
    final VM migratingVM = new VM();
    migratingVM.setClusterId(cluster2.getId());
    when(clusterDao.getWithoutMigratingVms()).thenReturn(Arrays.asList(cluster1));
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
}
#end_block

#method_before
@Test
public void shouldNotMigrateVmOnClusterTwoWhileInUpgradeMode() {
    vdsGroup2.setClusterPolicyId(ClusterPolicy.UPGRADE_POLICY_GUID);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
    verify(arem, times(0)).migrateVM(eq(vm2));
}
#method_after
@Test
public void shouldNotMigrateVmOnClusterTwoWhileInUpgradeMode() {
    cluster2.setClusterPolicyId(ClusterPolicy.UPGRADE_POLICY_GUID);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
    verify(arem, times(0)).migrateVM(eq(vm2));
}
#end_block

#method_before
@Test
public void shouldNotMigrateVmOnClusterTwoWhenEnforced() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(vdsGroup2))).thenReturn(null);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldNotMigrateVmOnClusterTwoWhenEnforced() {
    when(rulesEnforcer.chooseNextVmToMigrate(eq(cluster2))).thenReturn(null);
    arem.refresh();
    verify(arem).migrateVM(vm1);
    verify(arem, times(1)).migrateVM(any(VM.class));
}
#end_block

#method_before
@Test
public void shouldHaveNotingToMigrate() {
    when(rulesEnforcer.chooseNextVmToMigrate(any(VDSGroup.class))).thenReturn(null);
    verify(arem, never()).migrateVM(any(VM.class));
}
#method_after
@Test
public void shouldHaveNotingToMigrate() {
    when(rulesEnforcer.chooseNextVmToMigrate(any(Cluster.class))).thenReturn(null);
    verify(arem, never()).migrateVM(any(VM.class));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, compatVersion, compatibilityVersion, cpuName, description, maxVdsMemoryOverCommit, countThreadsAsCores, migrateOnError, name, storagePoolId, storagePoolName, transparentHugepages, virtService, glusterService, glusterCliBasedSchedulingOn, tunnelMigration, emulatedMachine, trustedService, haReservation, clusterPolicyName, clusterPolicyProperties, requiredRngSources, enableKsm, enableBallooning, optimizationType, serialNumberPolicy, customSerialNumber, groupHostsAndVms, fencingPolicy, autoConverge, migrateCompressed, glusterTunedProfile, addtionalFeaturesSupported, maintenanceReasonRequired, ksmMergeAcrossNumaNodes);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, compatVersion, compatibilityVersion, cpuName, description, maxVdsMemoryOverCommit, countThreadsAsCores, migrateOnError, name, storagePoolId, storagePoolName, transparentHugepages, virtService, glusterService, glusterCliBasedSchedulingOn, tunnelMigration, emulatedMachine, trustedService, haReservation, clusterPolicyName, clusterPolicyProperties, requiredRngSources, enableKsm, enableBallooning, optimizationType, serialNumberPolicy, customSerialNumber, groupHostsAndVms, fencingPolicy, autoConverge, migrateCompressed, glusterTunedProfile, addtionalFeaturesSupported, maintenanceReasonRequired, ksmMergeAcrossNumaNodes, customMigrationNetworkBandwidth, migrationBandwidthLimitType);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Cluster)) {
        return false;
    }
    Cluster other = (Cluster) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return Objects.equals(id, other.id) && Objects.equals(compatVersion, other.compatVersion) && Objects.equals(compatibilityVersion, other.compatibilityVersion) && Objects.equals(cpuName, other.cpuName) && Objects.equals(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && Objects.equals(name, other.name) && Objects.equals(storagePoolId, other.storagePoolId) && Objects.equals(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && Objects.equals(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && Objects.equals(clusterPolicyId, other.clusterPolicyId) && Objects.equals(clusterPolicyName, other.clusterPolicyName) && Objects.equals(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && Objects.equals(groupHostsAndVms, other.groupHostsAndVms) && Objects.equals(requiredRngSources, other.requiredRngSources) && Objects.equals(fencingPolicy, other.fencingPolicy) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(glusterTunedProfile, other.glusterTunedProfile) && Objects.equals(maintenanceReasonRequired, other.maintenanceReasonRequired) && Objects.equals(addtionalFeaturesSupported, other.addtionalFeaturesSupported) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Cluster)) {
        return false;
    }
    Cluster other = (Cluster) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return Objects.equals(id, other.id) && Objects.equals(compatVersion, other.compatVersion) && Objects.equals(compatibilityVersion, other.compatibilityVersion) && Objects.equals(cpuName, other.cpuName) && Objects.equals(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && Objects.equals(name, other.name) && Objects.equals(storagePoolId, other.storagePoolId) && Objects.equals(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && glusterCliBasedSchedulingOn == other.glusterCliBasedSchedulingOn && tunnelMigration == other.tunnelMigration && Objects.equals(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && Objects.equals(clusterPolicyId, other.clusterPolicyId) && Objects.equals(clusterPolicyName, other.clusterPolicyName) && Objects.equals(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType && serialNumberPolicy == other.serialNumberPolicy && Objects.equals(customSerialNumber, other.customSerialNumber) && Objects.equals(groupHostsAndVms, other.groupHostsAndVms) && Objects.equals(requiredRngSources, other.requiredRngSources) && Objects.equals(fencingPolicy, other.fencingPolicy) && Objects.equals(autoConverge, other.autoConverge) && Objects.equals(migrateCompressed, other.migrateCompressed) && Objects.equals(glusterTunedProfile, other.glusterTunedProfile) && Objects.equals(maintenanceReasonRequired, other.maintenanceReasonRequired) && Objects.equals(addtionalFeaturesSupported, other.addtionalFeaturesSupported) && ksmMergeAcrossNumaNodes == other.ksmMergeAcrossNumaNodes && Objects.equals(customMigrationNetworkBandwidth, other.customMigrationNetworkBandwidth) && Objects.equals(migrationBandwidthLimitType, other.migrationBandwidthLimitType);
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    final VdsDynamic lastHost = getLastHost(vm, hosts);
    if (lastHost == null) {
        return noWeights(hosts);
    }
    final OS lastHostOs = OS.fromPackageVersionString(lastHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Reference host {} provides an invalid or incomplete OS identifier. Found {}.", lastHost.getId(), lastHost.getHostOs());
        return noWeights(hosts);
    }
    final List<Pair<Guid, Integer>> weights = new ArrayList<>();
    for (final VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provides an invalid or incomplete OS identifier. Found {}.", host.getId(), host.getHostOs());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isOlderThan(lastHostOs)) {
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isNewerThan(lastHostOs)) {
            weights.add(toWeight(host, BETTER_WEIGHT));
        } else {
            weights.add(toWeight(host, BEST_WEIGHT));
        }
    }
    return weights;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(List<VDS> hosts, VM vm, Map<String, String> parameters) {
    final VdsDynamic lastHost = getLastHost(vm);
    if (lastHost == null) {
        return noWeights(hosts);
    }
    final OS lastHostOs = OS.fromPackageVersionString(lastHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Source host {} does not provide a valid OS identifier. Found {}.", lastHost.getId(), lastHost.getHostOs());
        return noWeights(hosts);
    }
    final List<Pair<Guid, Integer>> weights = new ArrayList<>();
    for (final VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provide an valid OS identifier. Found {}.", host.getId(), host.getHostOs());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BAD_WEIGHT));
        } else if (hostOs.isSameMajorVersion(lastHostOs)) {
            weights.add(toWeight(host, BETTER_WEIGHT));
        } else {
            weights.add(toWeight(host, BEST_WEIGHT));
        }
    }
    return weights;
}
#end_block

#method_before
public boolean isNewerThan(final OS os) {
    return getVersion().compareTo(os.getVersion()) > 0;
}
#method_after
public boolean isNewerThan(final OS os) {
    return getVersion().greater(os.getVersion());
}
#end_block

#method_before
public boolean isOlderThan(final OS os) {
    return getVersion().compareTo(os.getVersion()) < 0;
}
#method_after
public boolean isOlderThan(final OS os) {
    return getVersion().less(os.getVersion());
}
#end_block

#method_before
@Before
public void setUp() {
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 7.0 - 1.el7");
    currentHost = newHost("RHEL - 7.1 - 1.el7");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#method_after
@Before
public void setUp() {
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 5.0 - 1.el5");
    currentHost = newHost("RHEL - 6.1 - 1.el6");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#end_block

#method_before
@Before
public void setUp() {
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 7.0 - 1.el7");
    currentHost = newHost("RHEL - 7.1 - 1.el7");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#method_after
@Before
public void setUp() {
    newEnoughHost = newHost("RHEL - 7.2 - 1.el7");
    tooOldHost = newHost("RHEL - 5.0 - 1.el5");
    currentHost = newHost("RHEL - 6.1 - 1.el6");
    runningVm = new VM();
    runningVm.setRunOnVds(currentHost.getId());
    when(vdsDynamicDao.get(eq(currentHost.getId()))).thenReturn(currentHost.getDynamicData());
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    final VdsDynamic lastHost = getLastHost(vm, hosts);
    if (lastHost == null) {
        return hosts;
    }
    final OS lastHostOs = OS.fromPackageVersionString(lastHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Reference host {} does not provide a valid and complete OS identifier. Found {}.", lastHost.getId(), lastHost.getHostOs());
        messages.addMessage(lastHost.getId(), EngineMessage.VAR__DETAIL__INVALID_OS.name());
        messages.addMessage(lastHost.getId(), String.format("$os %1$s", lastHost.getHostOs()));
        return hosts;
    }
    final List<VDS> notOlderHosts = new ArrayList();
    for (VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provides a valid and complete OS identifier. Found {}.", host.getId(), host.getHostOs());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__INVALID_OS.name());
            messages.addMessage(host.getId(), String.format("$os %1$s", host.getHostOs()));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__WRONG_OS.name());
            messages.addMessage(host.getId(), String.format("$expected %1$s", lastHostOs.getName()));
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else if (!hostOs.isOlderThan(lastHostOs)) {
            notOlderHosts.add(host);
        }
    }
    return notOlderHosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    final VdsDynamic sourceHost = getLastHost(vm);
    if (sourceHost == null) {
        return hosts;
    }
    final OS lastHostOs = OS.fromPackageVersionString(sourceHost.getHostOs());
    if (!lastHostOs.isValid()) {
        log.debug("Source host {} does not provide a valid and complete OS identifier. Found {}.", sourceHost.getId(), sourceHost.getHostOs());
        return hosts;
    }
    final List<VDS> notOlderHosts = new ArrayList();
    for (VDS host : hosts) {
        final OS hostOs = OS.fromPackageVersionString(host.getHostOs());
        if (!hostOs.isValid()) {
            log.debug("Host {} does not provide a valid OS identifier. Found {}.", host.getId(), host.getHostOs());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__INVALID_OS.name());
            messages.addMessage(host.getId(), String.format("$os %1$s", host.getHostOs()));
        } else if (!hostOs.isSameOs(lastHostOs)) {
            log.debug("Host {} does not run the same operating system. Expected {}, found {}", host.getId(), lastHostOs.getName(), hostOs.getName());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__WRONG_OS.name());
            messages.addMessage(host.getId(), String.format("$expected %1$s", lastHostOs.getName()));
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else if (hostOs.isOlderThan(lastHostOs) && !hostOs.isSameMajorVersion(lastHostOs)) {
            log.debug("Host {} runs a too old OS version. Found {}", host.getId(), host.getHostOs());
            messages.addMessage(host.getId(), EngineMessage.VAR__DETAIL__OLD_OS.name());
            messages.addMessage(host.getId(), String.format("$found %1$s", hostOs.getName()));
        } else {
            notOlderHosts.add(host);
        }
    }
    return notOlderHosts;
}
#end_block

#method_before
public Pair<List<Guid>, Guid> balance(VDSGroup cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.error("Policy unit '{}' balance is not implemented", getPolicyUnit().getName());
    return null;
}
#method_after
public Pair<List<Guid>, Guid> balance(Cluster cluster, List<VDS> hosts, Map<String, String> parameters, ArrayList<String> messages) {
    log.error("Policy unit '{}' balance is not implemented", getPolicyUnit().getName());
    return null;
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getParameters().getStorageDomainId() != null) {
        return Collections.singletonMap(getParameters().getStorageDomainId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.STORAGE, EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    } else {
        return Collections.EMPTY_MAP;
    }
}
#end_block

#method_before
private void scanDisks() {
    StorageDomain storageDomain = getSelectedItem();
    Frontend.getInstance().runAction(VdcActionType.ScanStorageForUnregisteredDisks, new StorageDomainParametersBase(storageDomain.getStoragePoolId(), storageDomain.getId()));
}
#method_after
private void scanDisks() {
    StorageDomain storageDomain = getSelectedItem();
    if (storageDomain != null) {
        Frontend.getInstance().runAction(VdcActionType.ScanStorageForUnregisteredDisks, new StorageDomainParametersBase(storageDomain.getStoragePoolId(), storageDomain.getId()));
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<DiskImage> disks = getSelectedItems() != null ? Linq.<DiskImage>cast(getSelectedItems()) : new ArrayList<DiskImage>();
    getRegisterCommand().setIsExecutionAllowed(disks.size() > 0);
}
#method_after
private void updateActionAvailability() {
    ArrayList<DiskImage> disks = getSelectedItems() != null ? Linq.<DiskImage>cast(getSelectedItems()) : new ArrayList<DiskImage>();
    getRegisterCommand().setIsExecutionAllowed(disks.size() > 0 && getEntity().getStatus() == StorageDomainStatus.Active);
}
#end_block

#method_before
private void register() {
    if (getWindow() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> parametersList = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        DiskImage disk = (DiskImage) item;
        RegisterDiskParameters parameters = new RegisterDiskParameters(disk, getEntity().getId());
        parametersList.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.RegisterDisk, parametersList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#method_after
private void register() {
    if (getWindow() != null) {
        return;
    }
    for (Object item : getSelectedItems()) {
        DiskImage disk = (DiskImage) item;
        GetUnregisteredDiskQueryParameters parameters = new GetUnregisteredDiskQueryParameters(disk.getId(), getEntity().getId(), getEntity().getStoragePoolId());
        Frontend.getInstance().runQuery(VdcQueryType.GetUnregisteredDisk, parameters, new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object ReturnValue) {
                DiskImage diskImage = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                RegisterDiskParameters registerDiskParams = new RegisterDiskParameters(diskImage, getEntity().getId());
                Frontend.getInstance().runAction(VdcActionType.RegisterDisk, registerDiskParams);
            }
        }));
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getRegisterCommand()) {
        register();
    } else if ("OnRegister".equals(command.getName())) {
        // $NON-NLS-1$
        onRegister();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getRegisterCommand()) {
        register();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    }
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    VmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData(), getCluster());
    VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (isVmExist()) {
        Version compatibilityVersion = getEffectiveCompatibilityVersion();
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getParameters().getVmStaticData());
        getVmPropertiesUtils().separateCustomPropertiesToUserAndPredefined(compatibilityVersion, getVm().getStaticData());
    }
    VmHandler.updateDefaultTimeZone(getParameters().getVmStaticData());
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    updateParametersVmFromInstanceType();
    // we always need to verify new or existing numa nodes with the updated VM configuration
    if (!getParameters().isUpdateNuma()) {
        getParameters().getVm().setvNumaNodeList(getDbFacade().getVmNumaNodeDao().getAllVmNumaNodeByVmId(getParameters().getVmId()));
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int threadsPerCpu = newVmStatic.getThreadsPerCpu();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets, threadsPerCpu);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int threadsPerCpu = newVmStatic.getThreadsPerCpu();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets, threadsPerCpu);
        updateCurrentMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetMemory(int newAmountOfMemory) {
    int currentMemory = getVm().getMemSizeMb();
    if (getVm().getStatus() == VMStatus.Down) {
        newVmStatic.setMemSizeMb(newAmountOfMemory);
        return;
    }
    if (getVm().getStatus() == VMStatus.Up && currentMemory != newAmountOfMemory) {
        HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
        0);
        VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
        hotSetMemlog(params, setAmountOfMemoryResult);
        return;
    }
    newVmStatic.setMemSizeMb(currentMemory);
}
#method_after
private void hotSetMemory(int newAmountOfMemory) {
    int currentMemory = getVm().getMemSizeMb();
    HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
    0);
    VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
    newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
    hotSetMemlog(params, setAmountOfMemoryResult);
}
#end_block

#method_before
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void hotSetMemlog(HotSetAmountOfMemoryParameters params, VdcReturnValueBase setAmountOfMemoryResult) {
    if (!setAmountOfMemoryResult.isValid()) {
        AuditLogableBase logable = new HotSetAmountOfMemoryCommand<>(params, null);
        List<String> validationMessages = getBackend().getErrorsTranslator().translateErrorText(setAmountOfMemoryResult.getValidationMessages());
        logable.addCustomValue(HotSetAmountOfMemoryCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(validationMessages, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_MEMORY);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getEffectiveCompatibilityVersion())) {
            return failValidation(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    return !getVm().isHostedEngine() && getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator);
    return validator.validate();
}
#end_block

#method_before
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#method_after
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet))) {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator);
    return validator.validate();
}
#end_block

#method_before
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#method_after
private boolean defaultRouteSupported() {
    boolean defaultRouteSupported = false;
    Set<Version> supportedClusterVersionsSet = getVds().getSupportedClusterVersionsSet();
    if (supportedClusterVersionsSet == null || supportedClusterVersionsSet.isEmpty()) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, " + "therefore 'defaultRoute' will not be sent via the SetupNetworks", getVdsName(), getVdsId());
    } else if (FeatureSupported.defaultRoute(Collections.max(supportedClusterVersionsSet))) {
        defaultRouteSupported = true;
    }
    return defaultRouteSupported;
}
#end_block

#method_before
private void updateReportedNetworkAttachmentsNotMentionedInRequest(List<NetworkAttachment> networkAttachments) {
    for (VdsNetworkInterface nic : nicsByName.values()) {
        String networkName = nic.getNetworkName();
        if (networkName != null && clusterNetworks.containsKey(networkName)) {
            NetworkAttachment networkAttachmentRelatedToNetwork = getNetworkAttachmentRelatedToNetwork(networkAttachments, clusterNetworks.get(networkName));
            boolean networkAttachmentRelatedToNetworkExist = networkAttachmentRelatedToNetwork != null;
            if (networkAttachmentRelatedToNetworkExist) {
                VdsNetworkInterface baseInterfaceNicOrThis = getBaseInterfaceNicOrThis(nic);
                boolean shouldUpdateExistingAttachment = !baseInterfaceNicOrThis.getId().equals(networkAttachmentRelatedToNetwork.getNicId());
                if (shouldUpdateExistingAttachment) {
                    networkAttachmentRelatedToNetwork.setNicId(baseInterfaceNicOrThis.getId());
                    networkAttachmentRelatedToNetwork.setNicName(baseInterfaceNicOrThis.getName());
                    networkAttachmentDao.update(networkAttachmentRelatedToNetwork);
                }
            } else {
                if (!nic.isPartOfBond()) {
                    createNetworkAttachmentForReportedNetworksNotHavingOne(nic, networkName);
                }
            }
        }
    }
}
#method_after
private void updateReportedNetworkAttachmentsNotMentionedInRequest(List<NetworkAttachment> networkAttachments) {
    for (VdsNetworkInterface nic : nicsByName.values()) {
        String networkName = nic.getNetworkName();
        if (networkName != null && clusterNetworks.containsKey(networkName)) {
            NetworkAttachment networkAttachmentRelatedToNetwork = getNetworkAttachmentRelatedToNetwork(networkAttachments, clusterNetworks.get(networkName));
            boolean networkAttachmentRelatedToNetworkExist = networkAttachmentRelatedToNetwork != null;
            if (networkAttachmentRelatedToNetworkExist) {
                syncNetworkAttachmentPropertiesWithNic(nic, networkAttachmentRelatedToNetwork);
            } else {
                if (!nic.isPartOfBond()) {
                    createNetworkAttachmentForReportedNetworksNotHavingOne(nic, networkName);
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void testPersistNetworkAttachmentsWhenNetworkMovedToDifferentNic() throws Exception {
    NetworkAttachment networkAttachmentForClusterNetworkA = createNetworkAttachment(clusterNetworkA);
    // make network attachment out of sync, by setting different nicId and nicName
    Guid notUpToDateNicId = Guid.newGuid();
    networkAttachmentForClusterNetworkA.setNicId(notUpToDateNicId);
    networkAttachmentForClusterNetworkA.setNicName("nonsense");
    IpConfiguration ipConfiguration = NetworkUtils.createIpConfigurationFromVdsNetworkInterface(interfaceWithAttachedClusterNetworkA);
    networkAttachmentForClusterNetworkA.setIpConfiguration(ipConfiguration);
    networkAttachmentForClusterNetworkA.setProperties(customPropertiesForNics.getCustomPropertiesFor(interfaceWithAttachedClusterNetworkA));
    callPersistNetworkAttachmentsAndVerifyThatNetworkAttachmentIsSynced(networkAttachmentForClusterNetworkA, createPersister(Collections.<NetworkAttachment>emptyList()));
}
#method_after
@Test
public void testPersistNetworkAttachmentsWhenNetworkMovedToDifferentNic() throws Exception {
    NetworkAttachment networkAttachmentForClusterNetworkA = createNetworkAttachment(clusterNetworkA);
    // make network attachment out of sync, by setting different nicId and nicName
    Guid notUpToDateNicId = Guid.newGuid();
    networkAttachmentForClusterNetworkA.setNicId(notUpToDateNicId);
    networkAttachmentForClusterNetworkA.setNicName("nonsense");
    IpConfiguration ipConfiguration = NetworkUtils.createIpConfigurationFromVdsNetworkInterface(interfaceWithAttachedClusterNetworkA);
    networkAttachmentForClusterNetworkA.setIpConfiguration(ipConfiguration);
    networkAttachmentForClusterNetworkA.setProperties(customPropertiesForNics.getCustomPropertiesFor(interfaceWithAttachedClusterNetworkA));
    callPersistNetworkAttachmentsAndVerifyThatNetworkAttachmentIsSynced(networkAttachmentForClusterNetworkA);
}
#end_block

#method_before
private void callPersistNetworkAttachmentsAndVerifyThatNetworkAttachmentIsSynced(NetworkAttachment attachment, HostNetworkAttachmentsPersister persister) {
    when(networkAttachmentDao.getAllForHost(eq(hostId))).thenReturn(Collections.singletonList(attachment));
    persister.persistNetworkAttachments();
    verify(networkAttachmentDao).getAllForHost(any(Guid.class));
    verify(networkAttachmentDao).update(argThat(new ArgumentMatcher<NetworkAttachment>() {

        @Override
        public boolean matches(Object o) {
            if (!(o instanceof NetworkAttachment)) {
                return false;
            }
            IpConfiguration ipConfiguration = NetworkUtils.createIpConfigurationFromVdsNetworkInterface(interfaceWithAttachedClusterNetworkA);
            NetworkAttachment networkAttachment = (NetworkAttachment) o;
            return networkAttachment.getId() != null && networkAttachment.getId().equals(attachment.getId()) && networkAttachment.getNicId() != null && networkAttachment.getNicId().equals(interfaceWithAttachedClusterNetworkA.getId()) && Objects.equals(networkAttachment.getIpConfiguration(), ipConfiguration) && Objects.equals(networkAttachment.getProperties(), customPropertiesForNics.getCustomPropertiesFor(interfaceWithAttachedClusterNetworkA));
        }
    }));
    verifyNoMoreInteractions(networkAttachmentDao);
}
#method_after
private void callPersistNetworkAttachmentsAndVerifyThatNetworkAttachmentIsSynced(NetworkAttachment attachment) {
    HostNetworkAttachmentsPersister persister = createPersister(Collections.<NetworkAttachment>emptyList());
    when(networkAttachmentDao.getAllForHost(eq(hostId))).thenReturn(Collections.singletonList(attachment));
    persister.persistNetworkAttachments();
    verify(networkAttachmentDao).getAllForHost(any(Guid.class));
    verify(networkAttachmentDao).update(argThat(new ArgumentMatcher<NetworkAttachment>() {

        @Override
        public boolean matches(Object o) {
            if (!(o instanceof NetworkAttachment)) {
                return false;
            }
            IpConfiguration ipConfiguration = NetworkUtils.createIpConfigurationFromVdsNetworkInterface(interfaceWithAttachedClusterNetworkA);
            NetworkAttachment networkAttachment = (NetworkAttachment) o;
            return networkAttachment.getId() != null && networkAttachment.getId().equals(attachment.getId()) && networkAttachment.getNicId() != null && networkAttachment.getNicId().equals(interfaceWithAttachedClusterNetworkA.getId()) && Objects.equals(networkAttachment.getIpConfiguration(), ipConfiguration) && Objects.equals(networkAttachment.getProperties(), customPropertiesForNics.getCustomPropertiesFor(interfaceWithAttachedClusterNetworkA));
        }
    }));
    verifyNoMoreInteractions(networkAttachmentDao);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isCpuSupported(vmFromParams)) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        // check if pool vm - if not, the field is not legal and command will fail later on
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        }
    }
    if (getVdsGroup() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isCpuSupported(vmFromParams)) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(EngineMessage.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine newer uses Next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses Next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
private void toggleActive() {
    if (vm != null && !VmActionValidator.isCommandAllowed(vm.getOrigin(), VdcActionType.UpdateVmDisk)) {
        active = false;
    }
}
#method_after
private void toggleActive() {
    if (vm != null && !VmActionByVmOriginTypeValidator.isCommandAllowed(vm, VdcActionType.UpdateVmDisk)) {
        active = false;
    }
}
#end_block

#method_before
private boolean isDiskUpdateAllowed(VM vm) {
    return VmActionValidator.isCommandAllowed(vm.getOrigin(), VdcActionType.UpdateVmDisk);
}
#method_after
private boolean isDiskUpdateAllowed(VM vm) {
    return VmActionByVmOriginTypeValidator.isCommandAllowed(vm, VdcActionType.UpdateVmDisk);
}
#end_block

#method_before
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getClusterId(), vm.getCompatibilityVersion(), vm.getCpuProfileId());
        }
    });
}
#method_after
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics(vm.getId());
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getClusterId(), vm.getCpuProfileId());
        }
    });
}
#end_block

#method_before
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getCompatibilityVersion(), vm.getCpuProfileId());
        if (isInStateWithMemoryVolume(getVm()) && !isRestoreMemoryVolumeSupported()) {
            getModel().getEditingEnabled().setMessage(getModel().constants.suspendedVMsWhenClusterChange());
        }
    }
}
#method_after
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), vm.getCpuProfileId());
        if (isInStateWithMemoryVolume(getVm()) && !isRestoreMemoryVolumeSupported()) {
            getModel().getEditingEnabled().setMessage(getModel().constants.suspendedVMsWhenClusterChange());
        }
    }
}
#end_block

#method_before
private void updateInstanceImages() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<InstanceImageLineModel> imageLineModels = new ArrayList<>();
            boolean isChangeable = vm == null || VmActionValidator.isCommandAllowed(vm.getOrigin(), VdcActionType.UpdateVmDisk);
            for (Disk disk : (ArrayList<Disk>) returnValue) {
                InstanceImageLineModel lineModel = new InstanceImageLineModel(getModel().getInstanceImages());
                lineModel.initialize(disk, getVm());
                lineModel.setEnabled(isChangeable);
                imageLineModels.add(lineModel);
            }
            getModel().getInstanceImages().setIsChangeable(isChangeable);
            getModel().getInstanceImages().setItems(imageLineModels);
            getModel().getInstanceImages().setVm(getVm());
        }
    }), getVm().getId());
}
#method_after
private void updateInstanceImages() {
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<InstanceImageLineModel> imageLineModels = new ArrayList<>();
            boolean isChangeable = vm == null || VmActionByVmOriginTypeValidator.isCommandAllowed(vm, VdcActionType.UpdateVmDisk);
            for (Disk disk : (ArrayList<Disk>) returnValue) {
                InstanceImageLineModel lineModel = new InstanceImageLineModel(getModel().getInstanceImages());
                lineModel.initialize(disk, getVm());
                lineModel.setEnabled(isChangeable);
                imageLineModels.add(lineModel);
            }
            getModel().getInstanceImages().setIsChangeable(isChangeable);
            getModel().getInstanceImages().setItems(imageLineModels);
            getModel().getInstanceImages().setVm(getVm());
        }
    }), getVm().getId());
}
#end_block

#method_before
public boolean isHotSetCpuSupported() {
    Cluster selectedCluster = getModel().getSelectedCluster();
    Version compatibilityVersion = getModel().getCompatibilityVersion();
    Boolean hotplugEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, compatibilityVersion.getValue());
    boolean hotplugCpuSupported = Boolean.parseBoolean(((Map<String, String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugCpuSupported, compatibilityVersion.getValue())).get(selectedCluster.getArchitecture().name()));
    return getVm().getStatus() == VMStatus.Up && hotplugEnabled && hotplugCpuSupported;
}
#method_after
public boolean isHotSetCpuSupported() {
    Cluster selectedCluster = getModel().getSelectedCluster();
    Version compatibilityVersion = getModel().getCompatibilityVersion();
    boolean hotplugCpuSupported = Boolean.parseBoolean(((Map<String, String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HotPlugCpuSupported, compatibilityVersion.getValue())).get(selectedCluster.getArchitecture().name()));
    return getVm().getStatus() == VMStatus.Up && hotplugCpuSupported;
}
#end_block

#method_before
private ImportVmParameters createImportParams(VM vm, StorageDomain sd) {
    ImportVmParameters parameters = new ImportVmParameters(vm, sd.getId(), sd.getId(), sd.getStoragePoolId(), vm.getClusterId());
    // assumption is that there's only 1 profile for hosted engine domain. its an unmanged domain.
    Guid sdProfileId = diskProfileDao.getAllForStorageDomain(sd.getId()).get(0).getId();
    for (DiskImage image : vm.getImages()) {
        image.setDiskProfileId(sdProfileId);
        image.setStorageIds(new ArrayList(Arrays.asList(sd.getId())));
        image.setVmSnapshotId(Guid.newGuid());
    }
    // disks are there already(the vm is running)
    parameters.setImagesExistOnTargetStorageDomain(true);
    // distinguish from "regular" he vm.
    vm.setOrigin(OriginType.MANAGED_HOSTED_ENGINE);
    // architecture is a missing attribute from vdsm structure. relying on the cluster is perfectly reliable.
    Cluster cluster = clusterDAO.get(vm.getClusterId());
    vm.setClusterArch(cluster.getArchitecture());
    vm.setVmCreationDate(new Date());
    vm.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    vm.setVmOs(osRepository.getLinuxOss().stream().sorted().findFirst().get());
    vm.setPriority(1);
    vm.setTimeZone(TimeZone.getDefault().getID());
    return parameters;
}
#method_after
private ImportVmParameters createImportParams(VM vm, StorageDomain sd) {
    ImportVmParameters parameters = new ImportVmParameters(vm, sd.getId(), sd.getId(), sd.getStoragePoolId(), vm.getClusterId());
    // assumption is that there's only 1 profile for hosted engine domain. its an unmanged domain.
    Guid sdProfileId = diskProfileDao.getAllForStorageDomain(sd.getId()).get(0).getId();
    for (DiskImage image : vm.getImages()) {
        image.setDiskProfileId(sdProfileId);
        image.setStorageIds(new ArrayList(Arrays.asList(sd.getId())));
        image.setVmSnapshotId(Guid.newGuid());
    }
    // disks are there already(the vm is running)
    parameters.setImagesExistOnTargetStorageDomain(true);
    // distinguish from "regular" he vm.
    vm.setOrigin(OriginType.MANAGED_HOSTED_ENGINE);
    // architecture is a missing attribute from vdsm structure. relying on the cluster is perfectly reliable.
    Cluster cluster = clusterDAO.get(vm.getClusterId());
    vm.setClusterArch(cluster.getArchitecture());
    vm.setVmCreationDate(new Date());
    vm.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    vm.setVmOs(osRepository.getLinuxOss().stream().sorted().findFirst().get());
    vm.setPriority(1);
    VmHandler.updateDefaultTimeZone(vm.getStaticData());
    return parameters;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine newer uses Next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#method_after
private boolean isRunningConfigurationNeeded() {
    if (getVm().isHostedEngine()) {
        // Hosted Engine never uses the next run configuration
        return false;
    }
    return getVm().isNextRunConfigurationExists() || !VmHandler.isUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus(), isHotSetEnabled()) || !VmHandler.isUpdateValidForVmDevices(getVmId(), getVm().getStatus(), getParameters());
}
#end_block

#method_before
private void registerOvfStoreDisks() {
    for (final Guid storageDomainId : getParameters().getStorages()) {
        if (getStorageDomainStaticDao().get(storageDomainId).getStorageDomainType().isDataDomain()) {
            resetOvfStoreDisks();
            TransactionSupport.executeInNewTransaction(() -> {
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(storageDomainId, getStoragePool().getId());
                registerAllOvfDisks(ovfStoreDiskImages, storageDomainId);
                // Update unregistered entities
                for (OvfEntityData ovf : getEntitiesFromStorageOvfDisk(storageDomainId, getStoragePool().getId())) {
                    getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(ovf);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                }
                return null;
            });
        }
    }
}
#method_after
private void registerOvfStoreDisks() {
    for (final Guid storageDomainId : getParameters().getStorages()) {
        if (getStorageDomainStaticDao().get(storageDomainId).getStorageDomainType().isDataDomain()) {
            resetOvfStoreAndUnregisteredDisks();
            TransactionSupport.executeInNewTransaction(() -> {
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(storageDomainId, getStoragePool().getId());
                registerAllOvfDisks(ovfStoreDiskImages, storageDomainId);
                List<OvfEntityData> entitiesFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(storageDomainId, getStoragePool().getId());
                // Update unregistered entities
                for (Object ovf : entitiesFromStorageOvfDisk) {
                    OvfEntityData ovfEntityData = (OvfEntityData) ovf;
                    getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(ovfEntityData);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovfEntityData.getEntityId(), ovfEntityData.getEntityName());
                }
                initUnregisteredDisksToDB(storageDomainId);
                return null;
            });
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid hostId = getParameters().getId();
    List<NetworkAttachment> networkAttachments = networkAttachmentDao.getAllForHost(hostId);
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(hostDao.get(hostId).getClusterId()));
    reportedConfigurationsFiller.fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments, hostId);
    completeNicNames(allInterfacesForHost, networkAttachments);
    completeNetworkNames(networkMap, networkAttachments);
    getQueryReturnValue().setReturnValue(networkAttachments);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid hostId = getParameters().getId();
    List<NetworkAttachment> networkAttachments = networkAttachmentDao.getAllForHost(hostId);
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(hostDao.get(hostId).getClusterId()));
    reportedConfigurationsFiller.fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments);
    completeNicNames(networkAttachments, allInterfacesForHost);
    completeNetworkNames(networkAttachments, networkMap);
    getQueryReturnValue().setReturnValue(networkAttachments);
}
#end_block

#method_before
private void completeNicNames(List<VdsNetworkInterface> allInterfacesForHost, List<NetworkAttachment> attachments) {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(allInterfacesForHost);
    nicNameNicIdCompleter.completeNetworkAttachments(attachments);
}
#method_after
private void completeNicNames(List<NetworkAttachment> attachments, List<VdsNetworkInterface> allInterfacesForHost) {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(allInterfacesForHost);
    nicNameNicIdCompleter.completeNetworkAttachments(attachments);
}
#end_block

#method_before
private void completeNetworkNames(BusinessEntityMap<Network> networkMap, List<NetworkAttachment> attachments) {
    networkIdNetworkNameCompleter.completeNetworkAttachments(attachments, networkMap);
}
#method_after
private void completeNetworkNames(List<NetworkAttachment> attachments, BusinessEntityMap<Network> networkMap) {
    networkIdNetworkNameCompleter.completeNetworkAttachments(attachments, networkMap);
}
#end_block

#method_before
private void fillReportedConfigurations(Map<String, VdsNetworkInterface> networkNameToNicMap, BusinessEntityMap<Network> networkMap, NetworkAttachment networkAttachment) {
    Network network = networkMap.get(networkAttachment.getNetworkId());
    VdsNetworkInterface nic = getNicToWhichIsNetworkAttached(networkNameToNicMap, networkMap, networkAttachment);
    if (nic != null) {
        ReportedConfigurations reportedConfigurations = createNetworkInSyncWithVdsNetworkInterface(networkAttachment, nic, network).reportConfigurationsOnHost();
        networkAttachment.setReportedConfigurations(reportedConfigurations);
    }
}
#method_after
public void fillReportedConfigurations(List<VdsNetworkInterface> allInterfacesForHost, BusinessEntityMap<Network> networkMap, List<NetworkAttachment> networkAttachments) {
    Map<String, VdsNetworkInterface> networkNameToNicMap = nicsByNetworkId(allInterfacesForHost);
    for (NetworkAttachment networkAttachment : networkAttachments) {
        fillReportedConfigurations(networkNameToNicMap, networkMap, networkAttachment);
    }
}
#end_block

#method_before
public void fillReportedConfigurations(List<NetworkAttachment> networkAttachments, Guid hostId) {
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(vdsDao.get(hostId).getClusterId()));
    fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments, hostId);
}
#method_after
public void fillReportedConfigurations(List<NetworkAttachment> networkAttachments, Guid hostId) {
    List<VdsNetworkInterface> allInterfacesForHost = interfaceDao.getAllInterfacesForVds(hostId);
    BusinessEntityMap<Network> networkMap = new BusinessEntityMap<>(networkDao.getAllForCluster(vdsDao.get(hostId).getClusterId()));
    fillReportedConfigurations(allInterfacesForHost, networkMap, networkAttachments);
}
#end_block

#method_before
@Override
protected Disk addLinks(Disk model, String... subCollectionMembersToExclude) {
    Snapshot snapshotInfo = model.getSnapshot();
    model.setSnapshot(null);
    super.addLinks(model, subCollectionMembersToExclude);
    if (snapshotInfo != null) {
        org.ovirt.engine.core.common.businessentities.Snapshot snapshot = getEntity(org.ovirt.engine.core.common.businessentities.Snapshot.class, VdcQueryType.GetSnapshotBySnapshotId, new IdQueryParameters(asGuid(snapshotInfo.getId())), snapshotInfo.getId());
        Vm vm = new Vm();
        vm.setId(snapshot.getVmId().toString());
        snapshotInfo.setVm(vm);
        model.setSnapshot(snapshotInfo);
        LinkHelper.addLinks(getUriInfo(), snapshotInfo, null, false);
        model.setSnapshot(snapshotInfo);
    }
    return model;
}
#method_after
@Override
protected Disk addLinks(Disk model, String... subCollectionMembersToExclude) {
    Snapshot snapshotInfo = model.getSnapshot();
    model.setSnapshot(null);
    super.addLinks(model, subCollectionMembersToExclude);
    if (snapshotInfo != null) {
        org.ovirt.engine.core.common.businessentities.Snapshot snapshot = getEntity(org.ovirt.engine.core.common.businessentities.Snapshot.class, VdcQueryType.GetSnapshotBySnapshotId, new IdQueryParameters(asGuid(snapshotInfo.getId())), snapshotInfo.getId());
        Vm vm = new Vm();
        vm.setId(snapshot.getVmId().toString());
        snapshotInfo.setVm(vm);
        model.setSnapshot(snapshotInfo);
        LinkHelper.addLinks(snapshotInfo, null, false);
        model.setSnapshot(snapshotInfo);
    }
    return model;
}
#end_block

#method_before
private void addStatistics(Disk model, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    model.setStatistics(new Statistics());
    DiskStatisticalQuery query = new DiskStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(uriInfo, statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#method_after
private void addStatistics(Disk model, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    model.setStatistics(new Statistics());
    DiskStatisticalQuery query = new DiskStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#end_block

#method_before
private boolean isNextRunRequested() {
    return QueryHelper.getBooleanMatrixParameter(uriInfo, NEXT_RUN, true, false);
}
#method_after
private boolean isNextRunRequested() {
    return ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, NEXT_RUN, true, false);
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    boolean force = QueryHelper.getBooleanMatrixParameter(uriInfo, FORCE, true, false);
    RemoveVmParameters params = new RemoveVmParameters(guid, force);
    // If detach only is set we do not remove the VM disks
    boolean detachOnly = QueryHelper.getBooleanMatrixParameter(uriInfo, DETACH_ONLY, true, false);
    if (detachOnly) {
        params.setRemoveDisks(false);
    }
    return performAction(VdcActionType.RemoveVm, params);
}
#method_after
@Override
public Response remove() {
    get();
    boolean force = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FORCE, true, false);
    RemoveVmParameters params = new RemoveVmParameters(guid, force);
    // If detach only is set we do not remove the VM disks
    boolean detachOnly = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, DETACH_ONLY, true, false);
    if (detachOnly) {
        params.setRemoveDisks(false);
    }
    return performAction(VdcActionType.RemoveVm, params);
}
#end_block

#method_before
@Override
protected Vm deprecatedPopulate(Vm model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    parent.addInlineDetails(details, model);
    if (details.contains("statistics")) {
        addStatistics(model, entity, uriInfo);
    }
    parent.setPayload(model);
    parent.setCertificateInfo(model);
    MemoryPolicyHelper.setupMemoryBalloon(model, this);
    return model;
}
#method_after
@Override
protected Vm deprecatedPopulate(Vm model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    parent.addInlineDetails(details, model);
    if (details.contains("statistics")) {
        addStatistics(model, entity);
    }
    parent.setPayload(model);
    parent.setCertificateInfo(model);
    MemoryPolicyHelper.setupMemoryBalloon(model, this);
    return model;
}
#end_block

#method_before
private void addStatistics(Vm model, org.ovirt.engine.core.common.businessentities.VM entity, UriInfo ui) {
    model.setStatistics(new Statistics());
    VmStatisticalQuery query = new VmStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(ui, statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#method_after
private void addStatistics(Vm model, org.ovirt.engine.core.common.businessentities.VM entity) {
    model.setStatistics(new Statistics());
    VmStatisticalQuery query = new VmStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#end_block

#method_before
public static VmStatic map(VmTemplate entity, VmStatic template, Version version) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    Version clusterVersion = version == null ? Version.getLast() : version;
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setClusterId(entity.getClusterId());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setVmType(entity.getVmType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setVmInit(entity.getVmInit());
    if (FeatureSupported.serialNumberPolicy(clusterVersion)) {
        staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
        staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    }
    if (FeatureSupported.isSpiceFileTransferToggleSupported(clusterVersion)) {
        staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    }
    if (FeatureSupported.isSpiceCopyPasteToggleSupported(clusterVersion)) {
        staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    }
    staticVm.setRunAndPause(entity.isRunAndPause());
    staticVm.setCpuProfileId(entity.getCpuProfileId());
    if (FeatureSupported.autoConvergence(clusterVersion)) {
        staticVm.setAutoConverge(entity.getAutoConverge());
    }
    if (FeatureSupported.migrationCompression(clusterVersion)) {
        staticVm.setMigrateCompressed(entity.getMigrateCompressed());
    }
    staticVm.setCustomProperties(entity.getCustomProperties());
    staticVm.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    staticVm.setCustomCpuName(entity.getCustomCpuName());
    staticVm.setConsoleDisconnectAction(entity.getConsoleDisconnectAction());
    staticVm.setSmallIconId(entity.getSmallIconId());
    staticVm.setLargeIconId(entity.getLargeIconId());
    return doMapVmBaseHwPartToVmStatic(entity, staticVm, version);
}
#method_after
public static VmStatic map(VmTemplate entity, VmStatic template, Version version) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    Version clusterVersion = version == null ? Version.getLast() : version;
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setClusterId(entity.getClusterId());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setVmType(entity.getVmType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    if (FeatureSupported.isSpiceFileTransferToggleSupported(clusterVersion)) {
        staticVm.setSpiceFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    }
    staticVm.setSpiceCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    staticVm.setRunAndPause(entity.isRunAndPause());
    staticVm.setCpuProfileId(entity.getCpuProfileId());
    if (FeatureSupported.autoConvergence(clusterVersion)) {
        staticVm.setAutoConverge(entity.getAutoConverge());
    }
    if (FeatureSupported.migrationCompression(clusterVersion)) {
        staticVm.setMigrateCompressed(entity.getMigrateCompressed());
    }
    staticVm.setCustomProperties(entity.getCustomProperties());
    staticVm.setCustomEmulatedMachine(entity.getCustomEmulatedMachine());
    staticVm.setCustomCpuName(entity.getCustomCpuName());
    staticVm.setConsoleDisconnectAction(entity.getConsoleDisconnectAction());
    staticVm.setSmallIconId(entity.getSmallIconId());
    staticVm.setLargeIconId(entity.getLargeIconId());
    return doMapVmBaseHwPartToVmStatic(entity, staticVm, version);
}
#end_block

#method_before
public static Vm map(org.ovirt.engine.core.common.businessentities.VM entity, Vm template, boolean showDynamicInfo) {
    Vm model = template != null ? template : new Vm();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependencyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH);
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    } else {
        if (model.getOs() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasFqdn) {
            model.setFqdn(entity.getVmFQDN());
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromKernelVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null));
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (model.getPlacementPolicy() == null) {
        model.setPlacementPolicy(new VmPlacementPolicy());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity);
    }
    if (!entity.getDedicatedVmForVdsList().isEmpty()) {
        Hosts hostsList = new Hosts();
        for (Guid hostGuid : entity.getDedicatedVmForVdsList()) {
            Host newHost = new Host();
            newHost.setId(hostGuid.toString());
            hostsList.getHosts().add(newHost);
        }
        model.getPlacementPolicy().setHosts(hostsList);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(InitializationMapper.map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#method_after
public static Vm map(org.ovirt.engine.core.common.businessentities.VM entity, Vm template, boolean showDynamicInfo) {
    Vm model = template != null ? template : new Vm();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependencyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH);
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    } else {
        if (model.getOs() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasFqdn) {
            model.setFqdn(entity.getVmFQDN());
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null));
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (model.getPlacementPolicy() == null) {
        model.setPlacementPolicy(new VmPlacementPolicy());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity);
    }
    if (!entity.getDedicatedVmForVdsList().isEmpty()) {
        Hosts hostsList = new Hosts();
        for (Guid hostGuid : entity.getDedicatedVmForVdsList()) {
            Host newHost = new Host();
            newHost.setId(hostGuid.toString());
            hostsList.getHosts().add(newHost);
        }
        model.getPlacementPolicy().setHosts(hostsList);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(InitializationMapper.map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#end_block

#method_before
static void verifyModelSpecific(StorageDomain model, int index) {
    assertEquals(getSafeEntry(index, GUIDS).toString(), model.getId());
    assertEquals(getSafeEntry(index, NAMES), model.getName());
    // REVIST No descriptions for storage domains
    // assertEquals(DESCRIPTIONS[index], model.getDescription());
    assertEquals(getSafeEntry(index, TYPES), model.getType());
    assertNotNull(model.getStorage());
    assertEquals(getSafeEntry(index, STORAGE_TYPES), model.getStorage().getType());
    if (index != LOCAL_IDX && index != POSIX_IDX) {
        assertEquals(getSafeEntry(index, ADDRESSES), model.getStorage().getAddress());
    }
    assertEquals(PATHS[index], model.getStorage().getPath());
    assertEquals("permissions", model.getLinks().get(0).getRel());
    if (model.getType() == StorageDomainType.ISO) {
        assertEquals(5, model.getLinks().size());
        assertEquals("files", model.getLinks().get(1).getRel());
    } else if (model.getType().equals(TYPES[2].value())) {
        assertEquals(7, model.getLinks().size());
        assertEquals("templates", model.getLinks().get(1).getRel());
        assertEquals("vms", model.getLinks().get(2).getRel());
    }
    assertNotNull(model.getLinks().get(0).getHref());
}
#method_after
static void verifyModelSpecific(StorageDomain model, int index) {
    assertEquals(getSafeEntry(index, GUIDS).toString(), model.getId());
    assertEquals(getSafeEntry(index, NAMES), model.getName());
    // REVIST No descriptions for storage domains
    // assertEquals(DESCRIPTIONS[index], model.getDescription());
    assertEquals(getSafeEntry(index, TYPES), model.getType());
    assertNotNull(model.getStorage());
    assertEquals(getSafeEntry(index, STORAGE_TYPES), model.getStorage().getType());
    if (index != LOCAL_IDX && index != POSIX_IDX) {
        assertEquals(getSafeEntry(index, ADDRESSES), model.getStorage().getAddress());
    }
    assertEquals(PATHS[index], model.getStorage().getPath());
    assertEquals("permissions", model.getLinks().get(0).getRel());
    if (model.getType() == StorageDomainType.ISO) {
        assertEquals(5, model.getLinks().size());
        assertEquals("files", model.getLinks().get(1).getRel());
    } else if (model.getType().equals(TYPES[2])) {
        assertEquals(7, model.getLinks().size());
        assertEquals("templates", model.getLinks().get(1).getRel());
        assertEquals("vms", model.getLinks().get(2).getRel());
    }
    assertNotNull(model.getLinks().get(0).getHref());
}
#end_block

#method_before
void setupCloneVmPermissions(AddVmTemplateParameters params) {
    boolean clonePermissions = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyVmPermissions(clonePermissions);
    }
}
#method_after
void setupCloneVmPermissions(AddVmTemplateParameters params) {
    boolean clonePermissions = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyVmPermissions(clonePermissions);
    }
}
#end_block

#method_before
@Override
public Response doImport(Action action) {
    validateParameters(action, "cluster.id|name", "storageDomain.id|name");
    Guid destStorageDomainId = getDestStorageDomainId(action);
    ImportVmParameters params = new ImportVmParameters(getEntity(), parent.getStorageDomainId(), destStorageDomainId, parent.getDataCenterId(destStorageDomainId), getClusterId(action));
    params.setImageToDestinationDomainMap(getDiskToDestinationMap(action));
    params.setForceOverride(action.isSetExclusive() ? action.isExclusive() : false);
    boolean collapseSnapshots = QueryHelper.getBooleanMatrixParameter(uriInfo, COLLAPSE_SNAPSHOTS, true, false);
    if (collapseSnapshots) {
        params.setCopyCollapse(collapseSnapshots);
    }
    setVolumesTypeFormat(action);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    return doAction(VdcActionType.ImportVm, params, action);
}
#method_after
@Override
public Response doImport(Action action) {
    validateParameters(action, "cluster.id|name", "storageDomain.id|name");
    Guid destStorageDomainId = getDestStorageDomainId(action);
    ImportVmParameters params = new ImportVmParameters(getEntity(), parent.getStorageDomainId(), destStorageDomainId, parent.getDataCenterId(destStorageDomainId), getClusterId(action));
    params.setImageToDestinationDomainMap(getDiskToDestinationMap(action));
    params.setForceOverride(action.isSetExclusive() ? action.isExclusive() : false);
    boolean collapseSnapshots = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, COLLAPSE_SNAPSHOTS, true, false);
    if (collapseSnapshots) {
        params.setCopyCollapse(collapseSnapshots);
    }
    setVolumesTypeFormat(action);
    if (action.isSetClone()) {
        params.setImportAsNewEntity(action.isClone());
        if (action.isSetVm() && action.getVm().isSetName()) {
            params.getVm().setName(action.getVm().getName());
        }
    }
    return doAction(VdcActionType.ImportVm, params, action);
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    StoragePoolParametersBase params = new StoragePoolParametersBase(asGuid(id));
    boolean force = QueryHelper.getBooleanMatrixParameter(uriInfo, FORCE, true, false);
    if (force) {
        params.setForceDelete(force);
    }
    return performAction(VdcActionType.RemoveStoragePool, params);
}
#method_after
@Override
public Response remove() {
    get();
    StoragePoolParametersBase params = new StoragePoolParametersBase(asGuid(id));
    boolean force = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FORCE, true, false);
    if (force) {
        params.setForceDelete(force);
    }
    return performAction(VdcActionType.RemoveStoragePool, params);
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#end_block

#method_before
protected boolean isFiltered() {
    List<String> filterVar = getHttpHeaders().getRequestHeader(USER_FILTER_HEADER);
    if (filterVar != null && filterVar.size() > 0) {
        return Boolean.valueOf(filterVar.iterator().next());
    } else {
        return false;
    }
}
#method_after
protected boolean isFiltered() {
    return ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FILTER, true, false);
}
#end_block

#method_before
private String getConstraint() {
    StringBuilder buffer = new StringBuilder();
    buffer.append("Providers: type=");
    buffer.append(ProviderType.OPENSTACK_NETWORK.name());
    String query = QueryHelper.getConstraint(getUriInfo(), null, modelType, false);
    if (StringUtils.isNotBlank(query)) {
        buffer.append(" AND (");
        buffer.append(query);
        buffer.append(")");
    }
    return buffer.toString();
}
#method_after
private String getConstraint() {
    StringBuilder buffer = new StringBuilder();
    buffer.append("Providers: type=");
    buffer.append(ProviderType.OPENSTACK_NETWORK.name());
    String query = QueryHelper.getConstraint(httpHeaders, uriInfo, null, modelType, false);
    if (StringUtils.isNotBlank(query)) {
        buffer.append(" AND (");
        buffer.append(query);
        buffer.append(")");
    }
    return buffer.toString();
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER.value();
        case NFS:
            return AccessProtocol.NFS.value();
        case CIFS:
            return AccessProtocol.CIFS.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol.class, to = AccessProtocol.class)
public static AccessProtocol map(org.ovirt.engine.core.common.businessentities.gluster.AccessProtocol accessProtocol, String template) {
    switch(accessProtocol) {
        case GLUSTER:
            return AccessProtocol.GLUSTER;
        case NFS:
            return AccessProtocol.NFS;
        case CIFS:
            return AccessProtocol.CIFS;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = Event.class, to = AuditLog.class)
public static AuditLog map(Event event, AuditLog entity) {
    AuditLog auditLog = (entity != null) ? entity : new AuditLog();
    auditLog.setSeverity(map(event.getSeverity(), null));
    auditLog.setLogTime(event.isSetTime() ? event.getTime().toGregorianCalendar().getTime() : new Date(Calendar.getInstance().getTimeInMillis()));
    auditLog.setMessage(event.getDescription());
    Guid guid = event.isSetUser() ? GuidUtils.asGuid(event.getUser().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setUserId(guid);
    }
    guid = event.isSetVm() ? GuidUtils.asGuid(event.getVm().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setVmId(guid);
    }
    guid = event.isSetStorageDomain() ? GuidUtils.asGuid(event.getStorageDomain().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setStorageDomainId(guid);
    }
    guid = event.isSetHost() ? GuidUtils.asGuid(event.getHost().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setVdsId(guid);
    }
    guid = event.isSetTemplate() ? GuidUtils.asGuid(event.getTemplate().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setVmTemplateId(guid);
    }
    guid = event.isSetCluster() ? GuidUtils.asGuid(event.getCluster().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setClusterId(guid);
    }
    guid = event.isSetDataCenter() ? GuidUtils.asGuid(event.getDataCenter().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setStoragePoolId(guid);
    }
    if (event.isSetCorrelationId()) {
        auditLog.setCorrelationId(event.getCorrelationId());
    }
    if (event.isSetOrigin()) {
        auditLog.setOrigin(event.getOrigin());
    }
    if (event.isSetCustomId()) {
        auditLog.setCustomEventId(event.getCustomId());
    }
    if (event.isSetFloodRate()) {
        auditLog.setEventFloodInSec(event.getFloodRate());
    }
    if (event.isSetCustomData()) {
        auditLog.setCustomData(event.getCustomData());
    }
    return auditLog;
}
#method_after
@Mapping(from = Event.class, to = AuditLog.class)
public static AuditLog map(Event event, AuditLog entity) {
    AuditLog auditLog = (entity != null) ? entity : new AuditLog();
    AuditLogSeverity severity = map(event.getSeverity(), null);
    if (severity != null) {
        auditLog.setSeverity(severity);
    }
    auditLog.setLogTime(event.isSetTime() ? event.getTime().toGregorianCalendar().getTime() : new Date(Calendar.getInstance().getTimeInMillis()));
    auditLog.setMessage(event.getDescription());
    Guid guid = event.isSetUser() ? GuidUtils.asGuid(event.getUser().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setUserId(guid);
    }
    guid = event.isSetVm() ? GuidUtils.asGuid(event.getVm().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setVmId(guid);
    }
    guid = event.isSetStorageDomain() ? GuidUtils.asGuid(event.getStorageDomain().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setStorageDomainId(guid);
    }
    guid = event.isSetHost() ? GuidUtils.asGuid(event.getHost().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setVdsId(guid);
    }
    guid = event.isSetTemplate() ? GuidUtils.asGuid(event.getTemplate().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setVmTemplateId(guid);
    }
    guid = event.isSetCluster() ? GuidUtils.asGuid(event.getCluster().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setClusterId(guid);
    }
    guid = event.isSetDataCenter() ? GuidUtils.asGuid(event.getDataCenter().getId()) : Guid.Empty;
    if (!guid.equals(Guid.Empty)) {
        auditLog.setStoragePoolId(guid);
    }
    if (event.isSetCorrelationId()) {
        auditLog.setCorrelationId(event.getCorrelationId());
    }
    if (event.isSetOrigin()) {
        auditLog.setOrigin(event.getOrigin());
    }
    if (event.isSetCustomId()) {
        auditLog.setCustomEventId(event.getCustomId());
    }
    if (event.isSetFloodRate()) {
        auditLog.setEventFloodInSec(event.getFloodRate());
    }
    if (event.isSetCustomData()) {
        auditLog.setCustomData(event.getCustomData());
    }
    return auditLog;
}
#end_block

#method_before
public void addStatistics(Host model, VDS entity) {
    model.setStatistics(new Statistics());
    HostStatisticalQuery query = new HostStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(uriInfo, statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#method_after
public void addStatistics(Host model, VDS entity) {
    model.setStatistics(new Statistics());
    HostStatisticalQuery query = new HostStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new Cpus());
        for (ServerCpu sc : getServerCpuList(v)) {
            Cpu cpu = new Cpu();
            cpu.setType(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCpus().add(cpu);
        }
        addPowerManagementAgents(version, getPowerManagementAgents(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addGraphicsTypes(version, GraphicsType.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addVmPoolTypes(version, VmPoolType.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    addConsoleDisconnectActions(version, ConsoleDisconnectAction.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    addQuotaModeTypes(version);
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new Cpus());
        for (ServerCpu sc : getServerCpuList(v)) {
            Cpu cpu = new Cpu();
            cpu.setType(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCpus().add(cpu);
        }
        addPowerManagementAgents(version, getPowerManagementAgents(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addGraphicsTypes(version, GraphicsType.values());
    addDiskStorageTypes(version, DiskStorageType.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addKdumpStates(version, KdumpStatus.values());
    addSupportedQosTypes(version);
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addExternalStates(version, EntityExternalStatus.values());
    addHostProtocols(version, HostProtocol.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    addSELinuxModes(version, SELinuxMode.values());
    addRngSources(version, RngSource.values());
    addPolicyUnitTypes(version, PolicyUnitType.values());
    addSpmStates(version, SpmState.values());
    addVmPoolTypes(version, VmPoolType.values());
    addNetworkPluginTypes(version, NetworkPluginType.values());
    addMessageBrokerTypes(version, MessageBrokerType.values());
    addConsoleDisconnectActions(version, ConsoleDisconnectAction.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    addInheritableBooleans(version, InheritableBoolean.values());
    addQuotaModeTypes(version);
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(version);
    return version;
}
#end_block

#method_before
private void addSnapshotStatuses(VersionCaps version, SnapshotStatus[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) {
        version.setSnapshotStatuses(new SnapshotStatuses());
        for (SnapshotStatus mode : values) {
            version.getSnapshotStatuses().getSnapshotStatuses().add(mode.value());
        }
    }
}
#method_after
private void addSnapshotStatuses(VersionCaps version, SnapshotStatus[] values) {
    version.setSnapshotStatuses(new SnapshotStatuses());
    for (SnapshotStatus mode : values) {
        version.getSnapshotStatuses().getSnapshotStatuses().add(mode.value());
    }
}
#end_block

#method_before
private void addPayloadEncodings(VersionCaps version, PayloadEncoding[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.setPayloadEncodings(new PayloadEncodings());
        for (PayloadEncoding mode : values) {
            version.getPayloadEncodings().getPayloadEncodings().add(mode.value());
        }
    }
}
#method_after
private void addPayloadEncodings(VersionCaps version, PayloadEncoding[] values) {
    version.setPayloadEncodings(new PayloadEncodings());
    for (PayloadEncoding mode : values) {
        version.getPayloadEncodings().getPayloadEncodings().add(mode.value());
    }
}
#end_block

#method_before
private void addCpuModes(VersionCaps version, CpuMode[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) {
        version.setCpuModes(new CpuModes());
        for (CpuMode mode : values) {
            version.getCpuModes().getCpuModes().add(mode.value());
        }
    }
}
#method_after
private void addCpuModes(VersionCaps version, CpuMode[] values) {
    version.setCpuModes(new CpuModes());
    for (CpuMode mode : values) {
        version.getCpuModes().getCpuModes().add(mode.value());
    }
}
#end_block

#method_before
private void addScsiGenericIoOptions(VersionCaps version, ScsiGenericIO[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.setSgioOptions(new ScsiGenericIoOptions());
        for (ScsiGenericIO mode : values) {
            version.getSgioOptions().getScsiGenericIoOptions().add(mode.value());
        }
    }
}
#method_after
private void addScsiGenericIoOptions(VersionCaps version, ScsiGenericIO[] values) {
    version.setSgioOptions(new ScsiGenericIoOptions());
    for (ScsiGenericIO mode : values) {
        version.getSgioOptions().getScsiGenericIoOptions().add(mode.value());
    }
}
#end_block

#method_before
private void addWatchdogModels(VersionCaps version, WatchdogModel[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.setWatchdogModels(new WatchdogModels());
        for (WatchdogModel watchdogModel : values) {
            version.getWatchdogModels().getWatchdogModels().add(watchdogModel.value());
        }
    }
}
#method_after
private void addWatchdogModels(VersionCaps version, WatchdogModel[] values) {
    version.setWatchdogModels(new WatchdogModels());
    for (WatchdogModel watchdogModel : values) {
        version.getWatchdogModels().getWatchdogModels().add(watchdogModel.value());
    }
}
#end_block

#method_before
private void addWatchdogActions(VersionCaps version, WatchdogAction[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.setWatchdogActions(new WatchdogActions());
        for (WatchdogAction watchdogAction : values) {
            version.getWatchdogActions().getWatchdogActions().add(watchdogAction.value());
        }
    }
}
#method_after
private void addWatchdogActions(VersionCaps version, WatchdogAction[] values) {
    version.setWatchdogActions(new WatchdogActions());
    for (WatchdogAction watchdogAction : values) {
        version.getWatchdogActions().getWatchdogActions().add(watchdogAction.value());
    }
}
#end_block

#method_before
private void addReportedDeviceTypes(VersionCaps version, ReportedDeviceType[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) {
        version.setReportedDeviceTypes(new ReportedDeviceTypes());
        for (ReportedDeviceType reportedDeviceType : values) {
            version.getReportedDeviceTypes().getReportedDeviceTypes().add(reportedDeviceType.value());
        }
    }
}
#method_after
private void addReportedDeviceTypes(VersionCaps version, ReportedDeviceType[] values) {
    version.setReportedDeviceTypes(new ReportedDeviceTypes());
    for (ReportedDeviceType reportedDeviceType : values) {
        version.getReportedDeviceTypes().getReportedDeviceTypes().add(reportedDeviceType.value());
    }
}
#end_block

#method_before
private void addIpVersions(VersionCaps version, IpVersion[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) {
        version.setIpVersions(new IpVersions());
        for (IpVersion ipVersion : values) {
            version.getIpVersions().getIpVersions().add(ipVersion.value());
        }
    }
}
#method_after
private void addIpVersions(VersionCaps version, IpVersion[] values) {
    version.setIpVersions(new IpVersions());
    for (IpVersion ipVersion : values) {
        version.getIpVersions().getIpVersions().add(ipVersion.value());
    }
}
#end_block

#method_before
private void addNetworkUsages(VersionCaps version, NetworkUsage[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        version.setUsages(new Usages());
        for (NetworkUsage usage : values) {
            version.getUsages().getUsages().add(usage.value());
        }
    }
}
#method_after
private void addNetworkUsages(VersionCaps version, NetworkUsage[] values) {
    version.setUsages(new Usages());
    for (NetworkUsage usage : values) {
        version.getUsages().getUsages().add(usage.value());
    }
}
#end_block

#method_before
private void addGlusterTypesAndStates(VersionCaps version) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        addGlusterVolumeTypes(version, GlusterVolumeType.values());
        addTransportTypes(version, TransportType.values());
        addGlusterVolumeStates(version, GlusterState.values());
        addGlusterBrickStates(version, GlusterState.values());
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        addGlusterHookContentTypes(version, HookContentType.values());
        addStages(version, HookStage.values());
        addGlusterHookStates(version, HookStatus.values());
    }
}
#method_after
private void addGlusterTypesAndStates(VersionCaps version) {
    addGlusterVolumeTypes(version, GlusterVolumeType.values());
    addTransportTypes(version, TransportType.values());
    addGlusterVolumeStates(version, GlusterState.values());
    addGlusterBrickStates(version, GlusterState.values());
    addGlusterHookContentTypes(version, HookContentType.values());
    addStages(version, HookStage.values());
    addGlusterHookStates(version, HookStatus.values());
}
#end_block

#method_before
private void addOsTypes(VersionCaps version) {
    version.setOsTypes(new OsTypes());
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.getOsTypes().getOsTypes().addAll(OsTypeUtils.getAllValues());
    } else {
        for (OsType type : OsType.values()) {
            version.getOsTypes().getOsTypes().add(type.name());
        }
    }
}
#method_after
private void addOsTypes(VersionCaps version) {
    version.setOsTypes(new OsTypes());
    version.getOsTypes().getOsTypes().addAll(OsTypeUtils.getAllValues());
}
#end_block

#method_before
private void addNfsVersions(VersionCaps version, NfsVersion[] nfsVersions) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        version.setNfsVersions(new NfsVersions());
        for (NfsVersion nfsVersion : nfsVersions) {
            version.getNfsVersions().getNfsVersions().add(nfsVersion.value());
        }
    }
}
#method_after
private void addNfsVersions(VersionCaps version, NfsVersion[] nfsVersions) {
    version.setNfsVersions(new NfsVersions());
    for (NfsVersion nfsVersion : nfsVersions) {
        version.getNfsVersions().getNfsVersions().add(nfsVersion.value());
    }
}
#end_block

#method_before
private void addVmAffinities(VersionCaps version, VmAffinity[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_0)) {
        version.setVmAffinities(new VmAffinities());
        for (VmAffinity affinity : values) {
            version.getVmAffinities().getVmAffinities().add(affinity.value());
        }
    }
}
#method_after
private void addVmAffinities(VersionCaps version, VmAffinity[] values) {
    version.setVmAffinities(new VmAffinities());
    for (VmAffinity affinity : values) {
        version.getVmAffinities().getVmAffinities().add(affinity.value());
    }
}
#end_block

#method_before
private void addVmDeviceType(VersionCaps version, VmDeviceType[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        version.setVmDeviceTypes(new VmDeviceTypes());
        for (VmDeviceType type : values) {
            version.getVmDeviceTypes().getVmDeviceTypes().add(type.value());
        }
    }
}
#method_after
private void addVmDeviceType(VersionCaps version, VmDeviceType[] values) {
    version.setVmDeviceTypes(new VmDeviceTypes());
    for (VmDeviceType type : values) {
        version.getVmDeviceTypes().getVmDeviceTypes().add(type.value());
    }
}
#end_block

#method_before
private void addConfigurationTypes(VersionCaps version, ConfigurationType[] types) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.setConfigurationTypes(new ConfigurationTypes());
        for (ConfigurationType type : types) {
            version.getConfigurationTypes().getConfigurationTypes().add(type.value());
        }
    }
}
#method_after
private void addConfigurationTypes(VersionCaps version, ConfigurationType[] types) {
    version.setConfigurationTypes(new ConfigurationTypes());
    for (ConfigurationType type : types) {
        version.getConfigurationTypes().getConfigurationTypes().add(type.value());
    }
}
#end_block

#method_before
private List<StorageType> getStorageTypes(Version version) {
    List<StorageType> ret = new ArrayList<>();
    ret.add(StorageType.ISCSI);
    ret.add(StorageType.FCP);
    ret.add(StorageType.NFS);
    if (VersionUtils.greaterOrEqual(version, VERSION_3_0)) {
        ret.add(StorageType.LOCALFS);
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_1)) {
        ret.add(StorageType.POSIXFS);
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        ret.add(StorageType.GLUSTERFS);
    }
    return ret;
}
#method_after
private List<StorageType> getStorageTypes(Version version) {
    List<StorageType> ret = new ArrayList<>();
    ret.add(StorageType.ISCSI);
    ret.add(StorageType.FCP);
    ret.add(StorageType.NFS);
    ret.add(StorageType.LOCALFS);
    ret.add(StorageType.POSIXFS);
    ret.add(StorageType.GLUSTERFS);
    return ret;
}
#end_block

#method_before
private void addMigrateOnErrorOptions(VersionCaps version, MigrateOnError[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_0)) {
        version.setErrorHandling(new org.ovirt.engine.api.model.ErrorHandlingOptions());
        for (MigrateOnError option : values) {
            version.getErrorHandling().getErrorHandling().add(option.value());
        }
    }
}
#method_after
private void addMigrateOnErrorOptions(VersionCaps version, MigrateOnError[] values) {
    version.setErrorHandling(new org.ovirt.engine.api.model.ErrorHandlingOptions());
    for (MigrateOnError option : values) {
        version.getErrorHandling().getErrorHandling().add(option.value());
    }
}
#end_block

#method_before
private void addStorageFormatOptions(VersionCaps version, StorageFormat... formats) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_0)) {
        version.setStorageFormats(new StorageFormats());
        for (StorageFormat format : formats) {
            version.getStorageFormats().getStorageFormats().add(format.value());
        }
    }
}
#method_after
private void addStorageFormatOptions(VersionCaps version, StorageFormat... formats) {
    version.setStorageFormats(new StorageFormats());
    for (StorageFormat format : formats) {
        version.getStorageFormats().getStorageFormats().add(format.value());
    }
}
#end_block

#method_before
private void addPmProxyTypes(VersionCaps version, PmProxyType[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_2)) {
        version.setPmProxyTypes(new PmProxyTypes());
        for (PmProxyType pmProxyType : values) {
            version.getPmProxyTypes().getPmProxyTypes().add(pmProxyType.value());
        }
    }
}
#method_after
private void addPmProxyTypes(VersionCaps version, PmProxyType[] values) {
    version.setPmProxyTypes(new PmProxyTypes());
    for (PmProxyType pmProxyType : values) {
        version.getPmProxyTypes().getPmProxyTypes().add(pmProxyType.value());
    }
}
#end_block

#method_before
private void addAuthenticationMethods(VersionCaps version, AuthenticationMethod[] values) {
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        version.setAuthenticationMethods(new org.ovirt.engine.api.model.AuthenticationMethod());
        for (AuthenticationMethod authType : values) {
            version.getAuthenticationMethods().getAuthenticationMethod().add(authType.value());
        }
    }
}
#method_after
private void addAuthenticationMethods(VersionCaps version, AuthenticationMethod[] values) {
    version.setAuthenticationMethods(new org.ovirt.engine.api.model.AuthenticationMethods());
    for (AuthenticationMethod authType : values) {
        version.getAuthenticationMethods().getAuthenticationMethod().add(authType.value());
    }
}
#end_block

#method_before
private void addSupportedQosTypes(VersionCaps version) {
    version.setQosTypes(new QosTypes());
    if (VersionUtils.greaterOrEqual(version, VERSION_3_3)) {
        addQosTypes(version, QosType.NETWORK);
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_5)) {
        addQosTypes(version, QosType.STORAGE, QosType.CPU);
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_6)) {
        addQosTypes(version, QosType.HOSTNETWORK);
    }
}
#method_after
private void addSupportedQosTypes(VersionCaps version) {
    version.setQosTypes(new QosTypes());
    addQosTypes(version, QosType.NETWORK);
    if (VersionUtils.greaterOrEqual(version, VERSION_3_5)) {
        addQosTypes(version, QosType.STORAGE, QosType.CPU);
    }
    if (VersionUtils.greaterOrEqual(version, VERSION_3_6)) {
        addQosTypes(version, QosType.HOSTNETWORK);
    }
}
#end_block

#method_before
@Override
protected Nic deprecatedPopulate(Nic model, VmNetworkInterface entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    BackendNicHelper.addReportedDevices(this, model, entity);
    if (details.contains("statistics")) {
        BackendNicHelper.addStatistics(this, model, entity);
    }
    return model;
}
#method_after
@Override
protected Nic deprecatedPopulate(Nic model, VmNetworkInterface entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    BackendNicHelper.addReportedDevices(this, model, entity);
    if (details.contains("statistics")) {
        BackendNicHelper.addStatistics(model, entity);
    }
    return model;
}
#end_block

#method_before
@Override
protected Nic deprecatedPopulate(Nic model, VmNetworkInterface entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    BackendNicHelper.addReportedDevices(this, model, entity);
    if (details.contains("statistics")) {
        BackendNicHelper.addStatistics(this, model, entity);
    }
    return model;
}
#method_after
@Override
protected Nic deprecatedPopulate(Nic model, VmNetworkInterface entity) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    BackendNicHelper.addReportedDevices(this, model, entity);
    if (details.contains("statistics")) {
        BackendNicHelper.addStatistics(model, entity);
    }
    return model;
}
#end_block

#method_before
@Override
public Response remove() {
    String host = QueryHelper.getMatrixConstraint(uriInfo, HOST);
    if (host == null) {
        Fault fault = new Fault();
        fault.setReason("host parameter is missing");
        throw new WebApplicationException(Response.status(Status.BAD_REQUEST).entity(fault).build());
    }
    get();
    Guid hostId = getHostId(host);
    boolean destroy = QueryHelper.getBooleanMatrixParameter(uriInfo, DESTROY, true, false);
    boolean format = QueryHelper.getBooleanMatrixParameter(uriInfo, FORMAT, true, false);
    if (destroy) {
        StorageDomainParametersBase parameters = new StorageDomainParametersBase(guid);
        parameters.setVdsId(hostId);
        return performAction(VdcActionType.ForceRemoveStorageDomain, parameters);
    } else {
        RemoveStorageDomainParameters parameters = new RemoveStorageDomainParameters(guid);
        parameters.setVdsId(hostId);
        parameters.setDoFormat(format);
        return performAction(VdcActionType.RemoveStorageDomain, parameters);
    }
}
#method_after
@Override
public Response remove() {
    String host = ParametersHelper.getParameter(httpHeaders, uriInfo, HOST);
    if (host == null) {
        Fault fault = new Fault();
        fault.setReason("host parameter is missing");
        throw new WebApplicationException(Response.status(Status.BAD_REQUEST).entity(fault).build());
    }
    get();
    Guid hostId = getHostId(host);
    boolean destroy = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, DESTROY, true, false);
    boolean format = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FORMAT, true, false);
    if (destroy) {
        StorageDomainParametersBase parameters = new StorageDomainParametersBase(guid);
        parameters.setVdsId(hostId);
        return performAction(VdcActionType.ForceRemoveStorageDomain, parameters);
    } else {
        RemoveStorageDomainParameters parameters = new RemoveStorageDomainParameters(guid);
        parameters.setVdsId(hostId);
        parameters.setDoFormat(format);
        return performAction(VdcActionType.RemoveStorageDomain, parameters);
    }
}
#end_block

#method_before
private ExtendSANStorageDomainParameters createParameters(Guid storageDomainId, List<LogicalUnit> newLuns, boolean force) {
    ExtendSANStorageDomainParameters params = new ExtendSANStorageDomainParameters();
    params.setStorageDomainId(storageDomainId);
    ArrayList<String> lunIds = new ArrayList<>();
    for (LogicalUnit newLun : newLuns) {
        lunIds.add(newLun.getId());
    }
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#method_after
private ExtendSANStorageDomainParameters createParameters(Guid storageDomainId, List<LogicalUnit> newLuns, boolean force) {
    ExtendSANStorageDomainParameters params = new ExtendSANStorageDomainParameters();
    params.setStorageDomainId(storageDomainId);
    ArrayList<String> lunIds = newLuns.stream().map(LogicalUnit::getId).collect(toCollection(ArrayList::new));
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#end_block

#method_before
private HostSetupNetworksParameters toParameters(Action action) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(guid);
    Map<Guid, NetworkAttachment> attachmentsById = getBackendNetworkAttachments();
    if (action.isSetModifiedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getModifiedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getNetworkAttachments().add(attachment);
        }
    }
    if (action.isSetSynchronizedNetworkAttachments()) {
        Map<Guid, NetworkAttachment> networkAttachmentFromParams = Entities.businessEntitiesById(parameters.getNetworkAttachments());
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getSynchronizedNetworkAttachments().getNetworkAttachments()) {
            if (model.isSetId()) {
                Guid networkAttachmentId = asGuid(model.getId());
                if (networkAttachmentFromParams.containsKey(networkAttachmentId)) {
                    networkAttachmentFromParams.get(networkAttachmentId).setOverrideConfiguration(true);
                } else if (attachmentsById.containsKey(networkAttachmentId)) {
                    NetworkAttachment networkAttachment = attachmentsById.get(networkAttachmentId);
                    networkAttachment.setOverrideConfiguration(true);
                    parameters.getNetworkAttachments().add(networkAttachment);
                } else {
                    return handleError(new EntityNotFoundException("NetworkAttachment.id: " + model.getId()), true);
                }
            }
        }
    }
    if (action.isSetModifiedLabels()) {
        for (Label label : action.getModifiedLabels().getLabels()) {
            NicLabel nicLabel = new NicLabel();
            nicLabel.setLabel(label.getId());
            if (label.isSetHostNic()) {
                nicLabel.setNicId(label.getHostNic().isSetId() ? asGuid(label.getHostNic().getId()) : null);
                nicLabel.setNicName(label.getHostNic().getName());
            }
            parameters.getLabels().add(nicLabel);
        }
    }
    if (action.isSetRemovedLabels()) {
        for (Label label : action.getRemovedLabels().getLabels()) {
            parameters.getRemovedLabels().add(label.getId());
        }
    }
    if (action.isSetRemovedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getRemovedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getRemovedNetworkAttachments().add(attachment.getId());
        }
    }
    BusinessEntityMap<Bond> bonds = getBackendHostBonds();
    if (action.isSetModifiedBonds()) {
        BusinessEntityMap<VdsNetworkInterface> nicsFromBackend = getBackendNics();
        for (HostNic bond : action.getModifiedBonds().getHostNics()) {
            completeSlaveNames(nicsFromBackend, bond);
            parameters.getBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetRemovedBonds()) {
        for (HostNic bond : action.getRemovedBonds().getHostNics()) {
            parameters.getRemovedBonds().add(mapBonds(bonds, bond).getId());
        }
    }
    if (action.isSetCheckConnectivity()) {
        parameters.setRollbackOnFailure(action.isCheckConnectivity());
    }
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    return parameters;
}
#method_after
private HostSetupNetworksParameters toParameters(Action action) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(guid);
    Map<Guid, NetworkAttachment> attachmentsById = getBackendNetworkAttachments();
    if (action.isSetModifiedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getModifiedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getNetworkAttachments().add(attachment);
        }
    }
    if (action.isSetSynchronizedNetworkAttachments()) {
        Map<Guid, NetworkAttachment> networkAttachmentFromParams = Entities.businessEntitiesById(parameters.getNetworkAttachments());
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getSynchronizedNetworkAttachments().getNetworkAttachments()) {
            if (model.isSetId()) {
                Guid networkAttachmentId = asGuid(model.getId());
                if (networkAttachmentFromParams.containsKey(networkAttachmentId)) {
                    networkAttachmentFromParams.get(networkAttachmentId).setOverrideConfiguration(true);
                } else if (attachmentsById.containsKey(networkAttachmentId)) {
                    NetworkAttachment networkAttachment = attachmentsById.get(networkAttachmentId);
                    networkAttachment.setOverrideConfiguration(true);
                    parameters.getNetworkAttachments().add(networkAttachment);
                } else {
                    return handleError(new EntityNotFoundException("NetworkAttachment.id: " + model.getId()), true);
                }
            }
        }
    }
    if (action.isSetModifiedLabels()) {
        for (Label label : action.getModifiedLabels().getLabels()) {
            NicLabel nicLabel = new NicLabel();
            nicLabel.setLabel(label.getId());
            if (label.isSetHostNic()) {
                nicLabel.setNicId(label.getHostNic().isSetId() ? asGuid(label.getHostNic().getId()) : null);
                nicLabel.setNicName(label.getHostNic().getName());
            }
            parameters.getLabels().add(nicLabel);
        }
    }
    if (action.isSetRemovedLabels()) {
        for (Label label : action.getRemovedLabels().getLabels()) {
            parameters.getRemovedLabels().add(label.getId());
        }
    }
    if (action.isSetRemovedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getRemovedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getRemovedNetworkAttachments().add(attachment.getId());
        }
    }
    BusinessEntityMap<Bond> bonds = getBackendHostBonds();
    if (action.isSetModifiedBonds()) {
        BusinessEntityMap<VdsNetworkInterface> nicsFromBackend = getBackendNics();
        for (HostNic bond : action.getModifiedBonds().getHostNics()) {
            completeSlaveNames(nicsFromBackend, bond);
            parameters.getCreateOrUpdateBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetRemovedBonds()) {
        for (HostNic bond : action.getRemovedBonds().getHostNics()) {
            parameters.getRemovedBonds().add(mapBonds(bonds, bond).getId());
        }
    }
    if (action.isSetCheckConnectivity()) {
        parameters.setRollbackOnFailure(action.isCheckConnectivity());
    }
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    return parameters;
}
#end_block

#method_before
public Bond mapBonds(BusinessEntityMap<Bond> bonds, HostNic model) {
    Mapper<HostNic, Bond> hostNicMapper = getMapper(HostNic.class, Bond.class);
    Bond bond;
    if (model.isSetId()) {
        Guid nicId = asGuid(model.getId());
        bond = hostNicMapper.map(model, bonds.get(nicId));
    } else {
        Bond template = model.isSetName() ? bonds.get(model.getName()) : null;
        bond = hostNicMapper.map(model, template);
    }
    return bond;
}
#method_after
public CreateOrUpdateBond mapBonds(BusinessEntityMap<Bond> bonds, HostNic model) {
    Mapper<HostNic, Bond> hostNicMapper = getMapper(HostNic.class, Bond.class);
    Bond bond;
    if (model.isSetId()) {
        Guid nicId = asGuid(model.getId());
        bond = hostNicMapper.map(model, bonds.get(nicId));
    } else {
        Bond template = model.isSetName() ? bonds.get(model.getName()) : null;
        bond = hostNicMapper.map(model, template);
    }
    return CreateOrUpdateBond.fromBond(bond);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    return doAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(asList(guid), false, action.isSetReason() ? action.getReason() : null), action);
}
#method_after
@Override
public Response deactivate(Action action) {
    boolean stopGlusterService = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, STOP_GLUSTER_SERVICE, true, false);
    return doAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(asList(guid), false, action.isSetReason() ? action.getReason() : null, stopGlusterService), action);
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    boolean force = QueryHelper.getBooleanMatrixParameter(uriInfo, FORCE, true, false);
    return performAction(VdcActionType.RemoveVds, new RemoveVdsParameters(guid, force));
}
#method_after
@Override
public Response remove() {
    get();
    boolean force = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FORCE, true, false);
    return performAction(VdcActionType.RemoveVds, new RemoveVdsParameters(guid, force));
}
#end_block

#method_before
private void addStatistics(Disk model, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    model.setStatistics(new Statistics());
    DiskStatisticalQuery query = new DiskStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(uriInfo, statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#method_after
private void addStatistics(Disk model, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    model.setStatistics(new Statistics());
    DiskStatisticalQuery query = new DiskStatisticalQuery(newModel(model.getId()));
    List<Statistic> statistics = query.getStatistics(entity);
    for (Statistic statistic : statistics) {
        LinkHelper.addLinks(statistic, query.getParentType());
    }
    model.getStatistics().getStatistics().addAll(statistics);
}
#end_block

#method_before
@Override
protected Disk addLinks(Disk model, String... subCollectionMembersToExclude) {
    Snapshot snapshotInfo = model.getSnapshot();
    model.setSnapshot(null);
    super.addLinks(model, subCollectionMembersToExclude);
    if (snapshotInfo != null) {
        org.ovirt.engine.core.common.businessentities.Snapshot snapshot = getEntity(org.ovirt.engine.core.common.businessentities.Snapshot.class, VdcQueryType.GetSnapshotBySnapshotId, new IdQueryParameters(asGuid(snapshotInfo.getId())), snapshotInfo.getId());
        Vm vm = new Vm();
        vm.setId(snapshot.getVmId().toString());
        snapshotInfo.setVm(vm);
        model.setSnapshot(snapshotInfo);
        LinkHelper.addLinks(getUriInfo(), snapshotInfo, null, false);
        model.setSnapshot(snapshotInfo);
    }
    return model;
}
#method_after
@Override
protected Disk addLinks(Disk model, String... subCollectionMembersToExclude) {
    Snapshot snapshotInfo = model.getSnapshot();
    model.setSnapshot(null);
    super.addLinks(model, subCollectionMembersToExclude);
    if (snapshotInfo != null) {
        org.ovirt.engine.core.common.businessentities.Snapshot snapshot = getEntity(org.ovirt.engine.core.common.businessentities.Snapshot.class, VdcQueryType.GetSnapshotBySnapshotId, new IdQueryParameters(asGuid(snapshotInfo.getId())), snapshotInfo.getId());
        Vm vm = new Vm();
        vm.setId(snapshot.getVmId().toString());
        snapshotInfo.setVm(vm);
        model.setSnapshot(snapshotInfo);
        LinkHelper.addLinks(snapshotInfo, null, false);
        model.setSnapshot(snapshotInfo);
    }
    return model;
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    boolean detach = QueryHelper.getBooleanMatrixParameter(uriInfo, DETACH_ONLY, true, false);
    if (detach) {
        return performAction(VdcActionType.DetachDiskFromVm, new AttachDetachVmDiskParameters(vmId, guid));
    } else {
        return performAction(VdcActionType.RemoveDisk, new RemoveDiskParameters(guid));
    }
}
#method_after
@Override
public Response remove() {
    get();
    boolean detach = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, DETACH_ONLY, true, false);
    if (detach) {
        return performAction(VdcActionType.DetachDiskFromVm, new AttachDetachVmDiskParameters(vmId, guid));
    } else {
        return performAction(VdcActionType.RemoveDisk, new RemoveDiskParameters(guid));
    }
}
#end_block

#method_before
@Test
public void testListIncludeStatistics() throws Exception {
    try {
        accepts.add("application/xml; detail=statistics");
        UriInfo uriInfo = setUpActionsUriExpectations();
        setGetVdsQueryExpectations(1);
        setGetNetworksQueryExpectations(1);
        setUpQueryExpectations("");
        collection.setUriInfo(uriInfo);
        List<HostNic> nics = getCollection();
        assertTrue(nics.get(0).isSetStatistics());
        verifyCollection(nics);
    } finally {
        accepts.clear();
    }
}
#method_after
@Test
public void testListIncludeStatistics() throws Exception {
    try {
        accepts.add("application/xml; detail=statistics");
        UriInfo uriInfo = setUpBasicUriExpectations();
        setGetVdsQueryExpectations(1);
        setGetNetworksQueryExpectations(1);
        setUpQueryExpectations("");
        collection.setUriInfo(uriInfo);
        List<HostNic> nics = getCollection();
        assertTrue(nics.get(0).isSetStatistics());
        verifyCollection(nics);
    } finally {
        accepts.clear();
    }
}
#end_block

#method_before
@Override
@Test
public void testList() throws Exception {
    UriInfo uriInfo = setUpActionsUriExpectations();
    setGetVdsQueryExpectations(1);
    setGetNetworksQueryExpectations(1);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
@Override
@Test
public void testList() throws Exception {
    UriInfo uriInfo = setUpBasicUriExpectations();
    setGetVdsQueryExpectations(1);
    setGetNetworksQueryExpectations(1);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Test
public void testCloneVm() throws Exception {
    org.ovirt.engine.core.common.businessentities.VM mockedVm = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    VmStatic vmStatic = control.createMock(VmStatic.class);
    expect(mockedVm.getStaticData()).andReturn(vmStatic).anyTimes();
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, mockedVm);
    setUriInfo(setUpActionExpectations(VdcActionType.CloneVm, CloneVmParameters.class, new String[] { "VmStaticData", "NewName" }, new Object[] { vmStatic, "someNewName" }));
    Action action = new Action();
    Vm vm = new Vm();
    vm.setName("someNewName");
    action.setVm(vm);
    Response response = resource.clone(action);
    verifyActionResponse(response);
    Action actionResponse = (Action) response.getEntity();
    assertTrue(actionResponse.isSetStatus());
}
#method_after
@Test
public void testCloneVm() throws Exception {
    org.ovirt.engine.core.common.businessentities.VM mockedVm = control.createMock(org.ovirt.engine.core.common.businessentities.VM.class);
    VmStatic vmStatic = control.createMock(VmStatic.class);
    expect(mockedVm.getStaticData()).andReturn(vmStatic).anyTimes();
    setUpGetEntityExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, mockedVm);
    setUriInfo(setUpActionExpectations(VdcActionType.CloneVm, CloneVmParameters.class, new String[] { "VmStaticData", "NewName" }, new Object[] { vmStatic, "someNewName" }));
    Action action = new Action();
    Vm vm = new Vm();
    vm.setName("someNewName");
    action.setVm(vm);
    Response response = resource.doClone(action);
    verifyActionResponse(response);
    Action actionResponse = (Action) response.getEntity();
    assertTrue(actionResponse.isSetStatus());
}
#end_block

#method_before
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHostName()) {
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        List<VmInitNetwork> networks = new ArrayList<>();
        for (NicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        entity.setUserName(model.getActiveDirectoryOu());
    }
    if (model.isSetOrgName()) {
        entity.setOrgName(model.getOrgName());
    }
    return entity;
}
#method_after
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHostName()) {
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        List<VmInitNetwork> networks = new ArrayList<>();
        for (NicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        entity.setUserName(model.getActiveDirectoryOu());
    }
    if (model.isSetOrgName()) {
        entity.setOrgName(model.getOrgName());
    }
    if (model.isSetCloudInit()) {
        VmMapper.map(model.getCloudInit(), entity);
    }
    return entity;
}
#end_block

#method_before
@Override
public GlusterVolumes list() {
    String constraint = QueryHelper.getConstraint(getUriInfo(), "cluster = " + parent.get().getName(), GlusterVolume.class);
    return mapCollection(getBackendCollection(SearchType.GlusterVolume, constraint));
}
#method_after
@Override
public GlusterVolumes list() {
    String constraint = QueryHelper.getConstraint(httpHeaders, uriInfo, "cluster = " + parent.get().getName(), GlusterVolume.class);
    return mapCollection(getBackendCollection(SearchType.GlusterVolume, constraint));
}
#end_block

#method_before
@Override
public Response add(Vm vm) {
    validateParameters(vm, "cluster.id|name");
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Cluster cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !Objects.equals(Objects.toString(template.getClusterId(), null), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(Vm.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setClusterId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            boolean clone = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE, true, false);
            if (clone) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    Vm result = (Vm) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#method_after
@Override
public Response add(Vm vm) {
    validateParameters(vm, "cluster.id|name");
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Cluster cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !Objects.equals(Objects.toString(template.getClusterId(), null), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(Vm.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setClusterId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            boolean clone = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE, true, false);
            if (clone) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    Vm result = (Vm) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, int osId, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(osId, cluster.getCompatibilityVersion()), templateId, instanceTypeId)) {
        // it is not defined on the template
        params.setBalloonEnabled(instanceTypeId != null ? !VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId) : null);
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setConsoleEnabled(instanceTypeId != null ? !getConsoleDevicesForEntity(instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        List<VmRngDevice> devices = VmHelper.getRngDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId);
        if (devices != null && !devices.isEmpty()) {
            boolean supported = cluster.getRequiredRngSources().contains(devices.get(0).getSource()) && FeatureSupported.virtIoRngSupported(cluster.getCompatibilityVersion());
            if (shouldCopyDevice(supported, templateId, instanceTypeId)) {
                params.setUpdateRngDevice(true);
                params.setRngDevice(!devices.isEmpty() ? devices.iterator().next() : null);
            }
        }
    }
}
#method_after
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, int osId, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(osId, cluster.getCompatibilityVersion()), templateId, instanceTypeId)) {
        // it is not defined on the template
        params.setBalloonEnabled(instanceTypeId != null ? !VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId) : null);
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setConsoleEnabled(instanceTypeId != null ? !getConsoleDevicesForEntity(instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        List<VmRngDevice> devices = VmHelper.getRngDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId);
        if (devices != null && !devices.isEmpty()) {
            boolean supported = cluster.getRequiredRngSources().contains(devices.get(0).getSource());
            if (shouldCopyDevice(supported, templateId, instanceTypeId)) {
                params.setUpdateRngDevice(true);
                params.setRngDevice(!devices.isEmpty() ? devices.iterator().next() : null);
            }
        }
    }
}
#end_block

#method_before
void setupCloneTemplatePermissions(VmManagementParametersBase params) {
    boolean clonePermissions = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyTemplatePermissions(clonePermissions);
    }
}
#method_after
void setupCloneTemplatePermissions(VmManagementParametersBase params) {
    boolean clonePermissions = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyTemplatePermissions(clonePermissions);
    }
}
#end_block

#method_before
protected <T> List<T> getBackendCollection(Class<T> clz, VdcQueryType query, VdcQueryParametersBase queryParams) {
    try {
        List<T> results = asCollection(clz, new ArrayList<T>());
        VdcQueryReturnValue result = runQuery(query, queryParams);
        if (result != null) {
            if (!result.getSucceeded()) {
                backendFailure(result.getExceptionString());
            }
            results = asCollection(clz, result.getReturnValue());
            if (getMaxResults() != NO_LIMIT && getMaxResults() < results.size()) {
                results = results.subList(0, getMaxResults());
            }
        }
        return results;
    } catch (Exception e) {
        return handleError(e, false);
    }
}
#method_after
protected <T> List<T> getBackendCollection(Class<T> clz, VdcQueryType query, VdcQueryParametersBase queryParams) {
    try {
        List<T> results = asCollection(clz, new ArrayList<T>());
        VdcQueryReturnValue result = runQuery(query, queryParams);
        if (result != null) {
            if (!result.getSucceeded()) {
                backendFailure(result.getExceptionString());
            }
            results = asCollection(clz, result.getReturnValue());
            int max = ParametersHelper.getIntegerParameter(httpHeaders, uriInfo, MAX, NO_LIMIT, NO_LIMIT);
            if (max != NO_LIMIT && max < results.size()) {
                results = results.subList(0, max);
            }
        }
        return results;
    } catch (Exception e) {
        return handleError(e, false);
    }
}
#end_block

#method_before
protected void setJobLink(final Action action, VdcReturnValueBase actionResult) {
    Job job = new Job();
    job.setId(actionResult.getJobId().toString());
    LinkHelper.addLinks(getUriInfo(), job, null, false);
    action.setJob(job);
}
#method_after
protected void setJobLink(final Action action, VdcReturnValueBase actionResult) {
    Job job = new Job();
    job.setId(actionResult.getJobId().toString());
    LinkHelper.addLinks(job, null, false);
    action.setJob(job);
}
#end_block

#method_before
protected boolean isAsync() {
    return getBooleanMatrixConstraint(ASYNC_CONSTRAINT);
}
#method_after
protected boolean isAsync() {
    return ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, ASYNC_CONSTRAINT, true, false);
}
#end_block

#method_before
protected boolean isForce() {
    return getBooleanMatrixConstraint(FORCE_CONSTRAINT);
}
#method_after
protected boolean isForce() {
    return ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, FORCE_CONSTRAINT, true, false);
}
#end_block

#method_before
private void setJobOrStepId(VdcActionParametersBase params) {
    if (QueryHelper.hasMatrixParam(uriInfo, JOB_ID_CONSTRAINT)) {
        String value = QueryHelper.getMatrixConstraint(uriInfo, JOB_ID_CONSTRAINT);
        params.setJobId(asGuid(value));
    }
    if (QueryHelper.hasMatrixParam(uriInfo, STEP_ID_CONSTRAINT)) {
        String value = QueryHelper.getMatrixConstraint(uriInfo, STEP_ID_CONSTRAINT);
        params.setJobId(asGuid(value));
    }
}
#method_after
private void setJobOrStepId(VdcActionParametersBase params) {
    String jobId = ParametersHelper.getParameter(httpHeaders, uriInfo, JOB_ID_CONSTRAINT);
    if (jobId != null) {
        params.setJobId(asGuid(jobId));
    }
    String stepId = ParametersHelper.getParameter(httpHeaders, uriInfo, STEP_ID_CONSTRAINT);
    if (stepId != null) {
        params.setJobId(asGuid(stepId));
    }
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(id);
    String host = QueryHelper.getMatrixConstraint(uriInfo, HOST);
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = getHostId(host);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    return performAction(VdcActionType.RemoveStorageServerConnection, parameters);
}
#method_after
@Override
public Response remove() {
    get();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(id);
    String host = ParametersHelper.getParameter(httpHeaders, uriInfo, HOST);
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = getHostId(host);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    return performAction(VdcActionType.RemoveStorageServerConnection, parameters);
}
#end_block

#method_before
@Before
public void setUp() {
    control = EasyMock.createNiceControl();
    backend = control.createMock(BackendLocal.class);
    DbUser currentUser = new DbUser();
    currentUser.setFirstName(USER);
    currentUser.setLastName(USER);
    currentUser.setDomain(DOMAIN);
    currentUser.setNamespace(NAMESPACE);
    currentUser.setId(GUIDS[0]);
    Current current = new Current();
    current.setUser(currentUser);
    current.setSessionId(SESSION_ID);
    CurrentManager.put(current);
    httpHeaders = control.createMock(HttpHeaders.class);
    locales = new ArrayList<>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    accepts = new ArrayList<>();
    expect(httpHeaders.getRequestHeader("Accept")).andReturn(accepts).anyTimes();
    List<String> filterValue = new ArrayList<>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    mapperLocator = new MappingLocator();
    mapperLocator.populate();
    locale = Locale.getDefault();
    Locale.setDefault(Locale.GERMANY);
    messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    init();
}
#method_after
@Before
public void setUp() {
    control = EasyMock.createNiceControl();
    backend = control.createMock(BackendLocal.class);
    DbUser currentUser = new DbUser();
    currentUser.setFirstName(USER);
    currentUser.setLastName(USER);
    currentUser.setDomain(DOMAIN);
    currentUser.setNamespace(NAMESPACE);
    currentUser.setId(GUIDS[0]);
    Current current = new Current();
    current.setUser(currentUser);
    current.setSessionId(SESSION_ID);
    current.setRoot(URI_ROOT);
    current.setPrefix(BASE_PATH);
    current.setPath("");
    current.setVersion("4");
    current.setVersionSource(VersionSource.DEFAULT);
    CurrentManager.put(current);
    httpHeaders = control.createMock(HttpHeaders.class);
    locales = new ArrayList<>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    accepts = new ArrayList<>();
    expect(httpHeaders.getRequestHeader("Accept")).andReturn(accepts).anyTimes();
    List<String> filterValue = new ArrayList<>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    mapperLocator = new MappingLocator();
    mapperLocator.populate();
    locale = Locale.getDefault();
    Locale.setDefault(Locale.GERMANY);
    messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    init();
}
#end_block

#method_before
protected UriInfo setUpBasicUriExpectations(String path) {
    UriInfo uriInfo = control.createMock(UriInfo.class);
    URI baseUri = URI.create(URI_BASE + '/');
    expect(uriInfo.getBaseUri()).andReturn(baseUri).anyTimes();
    expect(uriInfo.getPath()).andReturn(path).anyTimes();
    return uriInfo;
}
#method_after
protected UriInfo setUpBasicUriExpectations(String path) {
    UriInfo uriInfo = control.createMock(UriInfo.class);
    URI baseUri = URI.create(URI_BASE + '/');
    expect(uriInfo.getBaseUri()).andReturn(baseUri).anyTimes();
    expect(uriInfo.getPath()).andReturn(path).anyTimes();
    Current current = CurrentManager.get();
    current.setPath(path);
    return uriInfo;
}
#end_block

#method_before
protected UriInfo setUpGetMatrixConstraintsExpectations(String matrixConstraint, boolean matrixConstraintExist, String matrixConstraintValue, UriInfo uriInfo, boolean replay) {
    List<PathSegment> psl = new ArrayList<>();
    PathSegment ps = control.createMock(PathSegment.class);
    MultivaluedMap<String, String> matrixParams = control.createMock(MultivaluedMap.class);
    expect(matrixParams.isEmpty()).andReturn(!matrixConstraintExist);
    expect(ps.getMatrixParameters()).andReturn(matrixParams).anyTimes();
    if (matrixConstraintExist) {
        expect(matrixParams.containsKey(matrixConstraint)).andReturn(matrixConstraintExist).anyTimes();
        List<String> matrixParamsList = control.createMock(List.class);
        expect(matrixParams.get(matrixConstraint)).andReturn(matrixParamsList).anyTimes();
        expect(matrixParamsList.size()).andReturn(1);
        expect(matrixParamsList.get(0)).andReturn(matrixConstraintValue);
    }
    psl.add(ps);
    expect(uriInfo.getPathSegments()).andReturn(psl).anyTimes();
    if (replay) {
        control.replay();
    }
    return uriInfo;
}
#method_after
protected UriInfo setUpGetMatrixConstraintsExpectations(String matrixConstraint, boolean matrixConstraintExist, String matrixConstraintValue, UriInfo uriInfo, boolean replay) {
    List<PathSegment> psl = new ArrayList<>();
    PathSegment ps = control.createMock(PathSegment.class);
    MultivaluedMap<String, String> matrixParams = control.createMock(MultivaluedMap.class);
    expect(matrixParams.isEmpty()).andReturn(!matrixConstraintExist);
    expect(ps.getMatrixParameters()).andReturn(matrixParams).anyTimes();
    if (matrixConstraintExist) {
        expect(matrixParams.containsKey(matrixConstraint)).andReturn(matrixConstraintExist).anyTimes();
        expect(matrixParams.getFirst(matrixConstraint)).andReturn(matrixConstraintValue).anyTimes();
    }
    psl.add(ps);
    expect(uriInfo.getPathSegments()).andReturn(psl).anyTimes();
    if (replay) {
        control.replay();
    }
    return uriInfo;
}
#end_block

#method_before
@Mapping(from = QosBase.class, to = Qos.class)
public static Qos map(QosBase entity, Qos template) {
    Qos model = template != null ? template : new Qos();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    Guid storagePoolId = entity.getStoragePoolId();
    if (storagePoolId != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(storagePoolId.toString());
        model.setDataCenter(dataCenter);
    }
    model.setDescription(entity.getDescription());
    mapQosTypeToModel(entity, model);
    if (entity.getQosType() != null) {
        // !!
        // !!
        model.setType(QosTypeMapper.map(entity.getQosType(), null));
    }
    // !!
    return model;
}
#method_after
@Mapping(from = QosBase.class, to = Qos.class)
public static Qos map(QosBase entity, Qos template) {
    Qos model = template != null ? template : new Qos();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    Guid storagePoolId = entity.getStoragePoolId();
    if (storagePoolId != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(storagePoolId.toString());
        model.setDataCenter(dataCenter);
    }
    model.setDescription(entity.getDescription());
    mapQosTypeToModel(entity, model);
    if (entity.getQosType() != null) {
        model.setType(QosTypeMapper.map(entity.getQosType(), null));
    }
    return model;
}
#end_block

#method_before
private static void mapQosToEntity(Qos model, QosBase entity) {
    QosType qosType = model.getType() == null ? entity.getQosType() == null ? null : QosTypeMapper.map(entity.getQosType(), null) : model.getType();
    switch(qosType) {
        case STORAGE:
            mapStorageQosToEntity(model, (StorageQos) entity);
            break;
        case CPU:
            mapCpuQosToEntity(model, (CpuQos) entity);
            break;
        case NETWORK:
            mapNetworkQosToEntity(model, (NetworkQoS) entity);
            break;
        case HOSTNETWORK:
            mapHostNetworkQosToEntity(model, (HostNetworkQos) entity);
            break;
        default:
            break;
    }
}
#method_after
private static void mapQosToEntity(Qos model, QosBase entity) {
    QosType qosType = model.getType();
    if (qosType == null && entity.getQosType() != null) {
        qosType = QosTypeMapper.map(entity.getQosType(), null);
    }
    if (qosType != null) {
        switch(qosType) {
            case STORAGE:
                mapStorageQosToEntity(model, (StorageQos) entity);
                break;
            case CPU:
                mapCpuQosToEntity(model, (CpuQos) entity);
                break;
            case NETWORK:
                mapNetworkQosToEntity(model, (NetworkQoS) entity);
                break;
            case HOSTNETWORK:
                mapHostNetworkQosToEntity(model, (HostNetworkQos) entity);
                break;
            default:
                break;
        }
    }
}
#end_block

#method_before
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!VmActionByVmOriginValidator.isCommandAllowed(vm, actionType)) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#method_after
public static ValidationResult canRunActionOnNonManagedVm(VM vm, VdcActionType actionType) {
    ValidationResult validationResult = ValidationResult.VALID;
    if (!VmActionByVmOriginTypeValidator.isCommandAllowed(vm, actionType)) {
        validationResult = new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RUN_ACTION_ON_NON_MANAGED_VM);
    }
    return validationResult;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        handleCinderDomain();
        return;
    }
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
        StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Collections.singletonList(getStorageDomain().getId()), getParameters().getSessionId());
        parameters.setIsInternal(true);
        parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            getReturnValue().setFault(returnValue.getFault());
        }
    } else {
        map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
        if (map == null) {
            executeInNewTransaction(() -> {
                map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                getStoragePoolIsoMapDao().save(map);
                getCompensationContext().snapshotNewEntity(map);
                getCompensationContext().stateChanged();
                return null;
            });
            connectHostsInUpToDomainStorageServer();
            // Forcibly detach only data storage domains.
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                @SuppressWarnings("unchecked")
                Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                // If the storage domain is already related to another Storage Pool, detach it by force.
                Guid storagePoolId = domainFromIrs.getSecond();
                if (storagePoolId != null) {
                    if (FeatureSupported.importDataStorageDomain(getStoragePool().getCompatibilityVersion())) {
                        // Master domain version is not relevant since force remove at
                        // DetachStorageDomainVdsCommand does not use it.
                        // Storage pool id can be empty
                        DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getStoragePoolIdFromVds(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                        detachParams.setForce(true);
                        detachParams.setDetachFromOldStoragePool(true);
                        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                        if (!returnValue.getSucceeded()) {
                            log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                            throw new EngineException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : EngineError.ENGINE, returnValue.getExceptionString());
                        }
                    }
                }
                createDefaultDiskProfile();
            }
            runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
            final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = new ArrayList<>();
            if (getStorageDomain().getStorageDomainType().isDataDomain()) {
                List<OvfEntityData> returnValueFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                unregisteredEntitiesFromOvfDisk.addAll(returnValueFromStorageOvfDisk);
            }
            executeInNewTransaction(() -> {
                final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                map.setStatus(StorageDomainStatus.Maintenance);
                getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
                if (sdType == StorageDomainType.Master) {
                    calcStoragePoolStatusByDomainsStatus();
                }
                // upgrade the domain format to the storage pool format
                updateStorageDomainFormatIfNeeded(getStorageDomain());
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                registerAllOvfDisks(ovfStoreDiskImages, getParameters().getStorageDomainId());
                // Update unregistered entities
                for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                    getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                    getUnregisteredOVFDataDao().saveOVFData(ovf);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                }
                initUnregisteredDisksToDB(getParameters().getStorageDomainId(), unregisteredDisks);
                return null;
            });
            if (getParameters().getActivate()) {
                attemptToActivateDomain();
            }
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        handleCinderDomain();
        return;
    }
    if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
        StoragePoolWithStoragesParameter parameters = new StoragePoolWithStoragesParameter(getStoragePool(), Collections.singletonList(getStorageDomain().getId()), getParameters().getSessionId());
        parameters.setIsInternal(true);
        parameters.setTransactionScopeOption(TransactionScopeOption.Suppress);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddStoragePoolWithStorages, parameters);
        setSucceeded(returnValue.getSucceeded());
        if (!returnValue.getSucceeded()) {
            getReturnValue().setFault(returnValue.getFault());
        }
    } else {
        map = getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getParameters().getStoragePoolId()));
        if (map == null) {
            executeInNewTransaction(() -> {
                map = new StoragePoolIsoMap(getStorageDomain().getId(), getParameters().getStoragePoolId(), StorageDomainStatus.Locked);
                getStoragePoolIsoMapDao().save(map);
                getCompensationContext().snapshotNewEntity(map);
                getCompensationContext().stateChanged();
                return null;
            });
            connectHostsInUpToDomainStorageServer();
            // Forcibly detach only data storage domains.
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Data) {
                @SuppressWarnings("unchecked")
                Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getVdsId(), getParameters().getStorageDomainId())).getReturnValue();
                // If the storage domain is already related to another Storage Pool, detach it by force.
                Guid storagePoolId = domainFromIrs.getSecond();
                if (storagePoolId != null) {
                    // Master domain version is not relevant since force remove at
                    // DetachStorageDomainVdsCommand does not use it.
                    // Storage pool id can be empty
                    DetachStorageDomainVDSCommandParameters detachParams = new DetachStorageDomainVDSCommandParameters(getStoragePoolIdFromVds(), getParameters().getStorageDomainId(), Guid.Empty, 0);
                    detachParams.setForce(true);
                    detachParams.setDetachFromOldStoragePool(true);
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DetachStorageDomain, detachParams);
                    if (!returnValue.getSucceeded()) {
                        log.warn("Detaching Storage Domain '{}' from it's previous storage pool '{}'" + " has failed. The meta data of the Storage Domain might still" + " indicate that it is attached to a different Storage Pool.", getParameters().getStorageDomainId(), Guid.Empty, 0);
                        throw new EngineException(returnValue.getVdsError() != null ? returnValue.getVdsError().getCode() : EngineError.ENGINE, returnValue.getExceptionString());
                    }
                }
                createDefaultDiskProfile();
            }
            runVdsCommand(VDSCommandType.AttachStorageDomain, new AttachStorageDomainVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId()));
            final List<OvfEntityData> unregisteredEntitiesFromOvfDisk = new ArrayList<>();
            if (getStorageDomain().getStorageDomainType().isDataDomain()) {
                List<OvfEntityData> returnValueFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                unregisteredEntitiesFromOvfDisk.addAll(returnValueFromStorageOvfDisk);
            }
            executeInNewTransaction(() -> {
                final StorageDomainType sdType = getStorageDomain().getStorageDomainType();
                map.setStatus(StorageDomainStatus.Maintenance);
                getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
                if (sdType == StorageDomainType.Master) {
                    calcStoragePoolStatusByDomainsStatus();
                }
                // upgrade the domain format to the storage pool format
                updateStorageDomainFormatIfNeeded(getStorageDomain());
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(getParameters().getStorageDomainId(), getStoragePoolIdFromVds());
                registerAllOvfDisks(ovfStoreDiskImages, getParameters().getStorageDomainId());
                // Update unregistered entities
                for (OvfEntityData ovf : unregisteredEntitiesFromOvfDisk) {
                    getUnregisteredOVFDataDao().removeEntity(ovf.getEntityId(), getParameters().getStorageDomainId());
                    getUnregisteredOVFDataDao().saveOVFData(ovf);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovf.getEntityId(), ovf.getEntityName());
                }
                initUnregisteredDisksToDB(getParameters().getStorageDomainId());
                return null;
            });
            if (getParameters().getActivate()) {
                attemptToActivateDomain();
            }
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
private void createDefaultDiskProfile() {
    if (FeatureSupported.storageQoS(getStoragePool().getCompatibilityVersion()) && getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        final DiskProfile diskProfile = DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        executeInNewTransaction(() -> {
            getDiskProfileDao().save(diskProfile);
            getCompensationContext().snapshotNewEntity(diskProfile);
            getCompensationContext().stateChanged();
            return null;
        });
    }
}
#method_after
private void createDefaultDiskProfile() {
    if (getDiskProfileDao().getAllForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        final DiskProfile diskProfile = DiskProfileHelper.createDiskProfile(getStorageDomain().getId(), getStorageDomainName());
        executeInNewTransaction(() -> {
            getDiskProfileDao().save(diskProfile);
            getCompensationContext().snapshotNewEntity(diskProfile);
            getCompensationContext().stateChanged();
            return null;
        });
    }
}
#end_block

#method_before
protected void castDiskImagesToUnregisteredDisks(Guid storageDomainId, List<DiskImage> disksFromStorage) {
    if (disksFromStorage != null) {
        for (DiskImage disk : disksFromStorage) {
            UnregisteredDisk unregisteredDisk = new UnregisteredDisk();
            unregisteredDisk.setDiskId(disk.getId());
            unregisteredDisk.setDiskAlias(disk.getDiskAlias());
            unregisteredDisk.setDiskDescription(disk.getDiskDescription());
            unregisteredDisk.setStorageDomainId(storageDomainId);
            unregisteredDisks.add(unregisteredDisk);
        }
    }
}
#method_after
protected void castDiskImagesToUnregisteredDisks(List<DiskImage> disksFromStorage) {
    for (DiskImage disk : disksFromStorage) {
        UnregisteredDisk unregisteredDisk = new UnregisteredDisk(disk);
        unregisteredDisks.add(unregisteredDisk);
    }
}
#end_block

#method_before
protected List<DiskImage> getAllOVFDisks(Guid storageDomainId, Guid storagePoolId) {
    // fetched yet.
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<DiskImage> disksFromStorage = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(storageDomainId, storagePoolId)).getReturnValue();
        castDiskImagesToUnregisteredDisks(storageDomainId, disksFromStorage);
        if (disksFromStorage == null) {
            log.error("An error occurred while fetching unregistered disks from Storage Domain id '{}'", storageDomainId);
            return ovfDisks;
        }
        for (Disk disk : disksFromStorage) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDescription = ovfStoreDisk.getDescription();
            if (diskDescription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDescription);
                } catch (IOException e) {
                    log.warn("Exception while generating json containing ovf store info: {}", e.getMessage());
                    log.debug("Exception", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, storageDomainId)) {
                    log.warn("The disk description does not contain the storage domain id '{}'", storageDomainId);
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#method_after
protected List<DiskImage> getAllOVFDisks(Guid storageDomainId, Guid storagePoolId) {
    // fetched yet.
    if (ovfDisks == null) {
        ovfDisks = new ArrayList<>();
        // Get all unregistered disks.
        List<DiskImage> disksFromStorage = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisks, new GetUnregisteredDisksQueryParameters(storageDomainId, storagePoolId)).getReturnValue();
        if (disksFromStorage == null) {
            log.error("An error occurred while fetching unregistered disks from Storage Domain id '{}'", storageDomainId);
            return ovfDisks;
        } else {
            castDiskImagesToUnregisteredDisks(disksFromStorage);
        }
        for (Disk disk : disksFromStorage) {
            DiskImage ovfStoreDisk = (DiskImage) disk;
            String diskDescription = ovfStoreDisk.getDescription();
            if (diskDescription.contains(OvfInfoFileConstants.OvfStoreDescriptionLabel)) {
                Map<String, Object> diskDescriptionMap;
                try {
                    diskDescriptionMap = JsonHelper.jsonToMap(diskDescription);
                } catch (IOException e) {
                    log.warn("Exception while generating json containing ovf store info: {}", e.getMessage());
                    log.debug("Exception", e);
                    continue;
                }
                // Domain.
                if (!isDomainExistsInDiskDescription(diskDescriptionMap, storageDomainId)) {
                    log.warn("The disk description does not contain the storage domain id '{}'", storageDomainId);
                    continue;
                }
                ovfDisks.add(ovfStoreDisk);
            }
        }
    }
    return ovfDisks;
}
#end_block

#method_before
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        if (!FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getCompatibilityVersion())) {
            auditLogDirector.log(this, AuditLogType.RETRIEVE_UNREGISTERED_ENTITIES_NOT_SUPPORTED_IN_DC_VERSION);
            return new ArrayList<>();
        }
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(vdcReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogableBase logable = new AuditLogableBase();
        logable.setStorageDomainId(storageDomainId);
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
        auditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return new ArrayList<>();
}
#method_after
protected List<OvfEntityData> getEntitiesFromStorageOvfDisk(Guid storageDomainId, Guid storagePoolId) {
    // Initialize a new ArrayList with all the ovfDisks in the specified Storage Domain,
    // so the entities can be removed from the list every time we register the latest OVF disk and we can keep the
    // ovfDisks cache list updated.
    List<DiskImage> ovfStoreDiskImages = new ArrayList<>(getAllOVFDisks(storageDomainId, storagePoolId));
    if (!ovfStoreDiskImages.isEmpty()) {
        while (!ovfStoreDiskImages.isEmpty()) {
            Pair<DiskImage, Long> ovfDiskAndSize = getLatestOVFDisk(ovfStoreDiskImages);
            DiskImage ovfDisk = ovfDiskAndSize.getFirst();
            if (ovfDisk != null) {
                try {
                    VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RetrieveImageData, new RetrieveImageDataParameters(getParameters().getStoragePoolId(), storageDomainId, ovfDisk.getId(), ovfDisk.getImage().getId(), ovfDiskAndSize.getSecond()), cloneContextAndDetachFromParent());
                    getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    if (vdcReturnValue.getSucceeded()) {
                        List<OvfEntityData> returnedMap = OvfUtils.getOvfEntities(vdcReturnValue.getActionReturnValue(), unregisteredDisks, storageDomainId);
                        return returnedMap;
                    } else {
                        log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}'", ovfDisk.getId(), storageDomainId);
                    }
                } catch (RuntimeException e) {
                    // We are catching RuntimeException, since the call for OvfUtils.getOvfEntities will throw
                    // a RuntimeException if there is a problem to untar the file.
                    log.error("Image data could not be retrieved for disk id '{}' in storage domain id '{}': {}", ovfDisk.getId(), storageDomainId, e.getMessage());
                    log.debug("Exception", e);
                }
                ovfStoreDiskImages.remove(ovfDisk);
            }
        }
        AuditLogableBase logable = new AuditLogableBase();
        logable.setStorageDomainId(storageDomainId);
        auditLogDirector.log(logable, AuditLogType.RETRIEVE_OVF_STORE_FAILED);
    } else {
        log.warn("There are no OVF_STORE disks on storage domain id {}", storageDomainId);
        auditLogDirector.log(this, AuditLogType.OVF_STORE_DOES_NOT_EXISTS);
    }
    return new ArrayList<>();
}
#end_block

#method_before
protected void initUnregisteredDisksToDB(Guid storageDomainId, List entitiesFromStorageOvfDisk) {
    List<DiskImage> existingDisks = getDiskImageDao().getAllForStorageDomain(getStorageDomainId());
    for (Object unregisteredDiskObj : entitiesFromStorageOvfDisk) {
        UnregisteredDisk unregisteredDisk = (UnregisteredDisk) unregisteredDiskObj;
        if (existingDisks.stream().anyMatch(diskImage -> diskImage.getId().equals(unregisteredDisk.getDiskId()))) {
            log.info("Disk {} with id '{}' already exists in the engine, therefore will not be " + "part of the unregistered disks.", unregisteredDisk.getDiskAlias(), unregisteredDisk.getDiskId());
            continue;
        }
        unregisteredDisksDao.removeUnregisteredDisk(unregisteredDisk.getDiskId(), storageDomainId);
        unregisteredDisksDao.saveUnregisteredDisk(unregisteredDisk);
        log.info("Adding unregistered disk of disk id '{}' and disk alias '{}'", unregisteredDisk.getDiskId(), unregisteredDisk.getDiskAlias());
    }
}
#method_after
protected void initUnregisteredDisksToDB(Guid storageDomainId) {
    List<DiskImage> existingDisks = getDiskImageDao().getAllForStorageDomain(getStorageDomainId());
    for (Object unregisteredDiskObj : unregisteredDisks) {
        UnregisteredDisk unregisteredDisk = (UnregisteredDisk) unregisteredDiskObj;
        if (existingDisks.stream().anyMatch(diskImage -> diskImage.getId().equals(unregisteredDisk.getId()))) {
            log.info("Disk {} with id '{}' already exists in the engine, therefore will not be " + "part of the unregistered disks.", unregisteredDisk.getDiskAlias(), unregisteredDisk.getId());
            continue;
        }
        unregisteredDisksDao.removeUnregisteredDisk(unregisteredDisk.getId(), storageDomainId);
        unregisteredDisksDao.saveUnregisteredDisk(unregisteredDisk);
        log.info("Adding unregistered disk of disk id '{}' and disk alias '{}'", unregisteredDisk.getId(), unregisteredDisk.getDiskAlias());
    }
}
#end_block

#method_before
@Test
public void testUpdateUnregisteredDisksWithVMsWithInitializedUnregDisks() throws IOException {
    try {
        XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
        List<UnregisteredDisk> unregDisks = new ArrayList<>();
        UnregisteredDisk unregDisk = new UnregisteredDisk();
        unregDisk.setDiskId(Guid.createGuidFromString("f934b12c-1e22-4ad8-bbce-ec0b2a5defa4"));
        unregDisk.setStorageDomainId(Guid.createGuidFromString("7e2a7eac-3b76-4d45-a7dd-caae8fe0f588"));
        unregDisks.add(unregDisk);
        OvfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
        assertTrue("The list of disks should not be empty", !unregDisks.isEmpty());
        assertTrue("The VMs id is set in the unregisteterd disks", !unregDisks.get(0).getVmsId().isEmpty());
        assertTrue("The VMs name is set in the unregisteterd disks", !unregDisks.get(0).getVmsName().isEmpty());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#method_after
@Test
public void testUpdateUnregisteredDisksWithVMsWithInitializedUnregDisks() throws IOException {
    try {
        XmlDocument xmlDocument = new XmlDocument(getXmlOvfData());
        List<UnregisteredDisk> unregDisks = new ArrayList<>();
        UnregisteredDisk unregDisk = new UnregisteredDisk();
        unregDisk.getDiskImage().setId(Guid.createGuidFromString("f934b12c-1e22-4ad8-bbce-ec0b2a5defa4"));
        unregDisk.getDiskImage().setStorageIds(new ArrayList<>(Collections.singletonList(Guid.createGuidFromString("7e2a7eac-3b76-4d45-a7dd-caae8fe0f588"))));
        unregDisks.add(unregDisk);
        OvfUtils.updateUnregisteredDisksWithVMs(unregDisks, Guid.newGuid(), "TestVM", xmlDocument);
        assertTrue("The list of disks should not be empty", !unregDisks.isEmpty());
        assertTrue("The VMs id is set in the unregisteterd disks", !unregDisks.get(0).getVms().isEmpty());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
private void registerOvfStoreDisks() {
    for (final Guid storageDomainId : getParameters().getStorages()) {
        if (getStorageDomainStaticDao().get(storageDomainId).getStorageDomainType().isDataDomain()) {
            resetOvfStoreAndUnregisteredDisks();
            TransactionSupport.executeInNewTransaction(() -> {
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(storageDomainId, getStoragePool().getId());
                registerAllOvfDisks(ovfStoreDiskImages, storageDomainId);
                List<OvfEntityData> entitiesFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(storageDomainId, getStoragePool().getId());
                // Update unregistered entities
                for (Object ovf : entitiesFromStorageOvfDisk) {
                    OvfEntityData ovfEntityData = (OvfEntityData) ovf;
                    getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(ovfEntityData);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovfEntityData.getEntityId(), ovfEntityData.getEntityName());
                }
                initUnregisteredDisksToDB(storageDomainId, unregisteredDisks);
                return null;
            });
        }
    }
}
#method_after
private void registerOvfStoreDisks() {
    for (final Guid storageDomainId : getParameters().getStorages()) {
        if (getStorageDomainStaticDao().get(storageDomainId).getStorageDomainType().isDataDomain()) {
            resetOvfStoreAndUnregisteredDisks();
            TransactionSupport.executeInNewTransaction(() -> {
                List<DiskImage> ovfStoreDiskImages = getAllOVFDisks(storageDomainId, getStoragePool().getId());
                registerAllOvfDisks(ovfStoreDiskImages, storageDomainId);
                List<OvfEntityData> entitiesFromStorageOvfDisk = getEntitiesFromStorageOvfDisk(storageDomainId, getStoragePool().getId());
                // Update unregistered entities
                for (Object ovf : entitiesFromStorageOvfDisk) {
                    OvfEntityData ovfEntityData = (OvfEntityData) ovf;
                    getUnregisteredOVFDataDao().removeEntity(ovfEntityData.getEntityId(), storageDomainId);
                    getUnregisteredOVFDataDao().saveOVFData(ovfEntityData);
                    log.info("Adding OVF data of entity id '{}' and entity name '{}'", ovfEntityData.getEntityId(), ovfEntityData.getEntityName());
                }
                initUnregisteredDisksToDB(storageDomainId);
                return null;
            });
        }
    }
}
#end_block

#method_before
public static void updateUnregisteredDisksWithVMs(List<UnregisteredDisk> unregisteredDisks, Guid entityId, String vmName, XmlDocument xmlDocument) {
    for (Guid diskId : fetchVmDisks(xmlDocument)) {
        UnregisteredDisk unregisterDisk = unregisteredDisks.stream().filter(unregrDisk -> diskId.equals(unregrDisk.getDiskId())).findAny().orElse(null);
        if (unregisterDisk != null) {
            unregisterDisk.getVmsId().add(entityId.toString());
            unregisterDisk.getVmsName().add(vmName);
        }
    }
}
#method_after
public static void updateUnregisteredDisksWithVMs(List<UnregisteredDisk> unregisteredDisks, Guid entityId, String vmName, XmlDocument xmlDocument) {
    for (Guid diskId : fetchVmDisks(xmlDocument)) {
        UnregisteredDisk unregisterDisk = unregisteredDisks.stream().filter(unregrDisk -> diskId.equals(unregrDisk.getId())).findAny().orElse(null);
        VmBase vm = new VmBase();
        vm.setId(entityId);
        vm.setName(vmName);
        if (unregisterDisk != null) {
            unregisterDisk.getVms().add(vm);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (isCpuProfileIdChanged(vmFromDB, vmFromParams) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(getVmTemplateDao().getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = getVmTemplateDao().get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = getVmTemplateDao().get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), vmFromParams.getThreadsPerCpu(), getEffectiveCompatibilityVersion().toString(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId()) && !setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(NumaValidator.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
public boolean isVMWithMemoryCompatible(VM vm) {
    if (vm == null) {
        return true;
    }
    Version recentClusterVersion = vm.getClusterCompatibilityVersion();
    // the cluster version in which the memory snapshot was taken
    Version originalClusterVersion = vm.getClusterCompatibilityVersionOrigin();
    if (vm.getCustomCompatibilityVersion() != null) {
        return true;
    }
    return originalClusterVersion != null && recentClusterVersion.getMajor() == originalClusterVersion.getMajor() && recentClusterVersion.getMinor() == originalClusterVersion.getMinor();
}
#method_after
public boolean isVMWithMemoryCompatible(VM vm) {
    if (vm == null || vm.getCustomCompatibilityVersion() != null) {
        return true;
    }
    Version recentClusterVersion = vm.getClusterCompatibilityVersion();
    // the cluster version in which the memory snapshot was taken
    Version originalClusterVersion = vm.getClusterCompatibilityVersionOrigin();
    return originalClusterVersion != null && recentClusterVersion.getMajor() == originalClusterVersion.getMajor() && recentClusterVersion.getMinor() == originalClusterVersion.getMinor();
}
#end_block

#method_before
private void updateWarnings() {
    List<DiskImage> selectedDisks = previewSnapshotModel.getSelectedDisks();
    List<DiskImage> disksOfSelectedSnapshot = previewSnapshotModel.getSnapshotModel().getEntity().getDiskImages();
    List<DiskImage> disksOfActiveSnapshot;
    if (previewSnapshotModel.getActiveSnapshotModel() != null) {
        disksOfActiveSnapshot = previewSnapshotModel.getActiveSnapshotModel().getEntity().getDiskImages();
    } else {
        disksOfActiveSnapshot = Collections.emptyList();
    }
    SnapshotModel selectedModel = previewSnapshotModel.getSnapshotModel();
    boolean includeAllDisksOfSnapshot = selectedDisks.containsAll(disksOfSelectedSnapshot);
    boolean includeMemory = selectedModel.getMemory().getEntity();
    boolean includeMemoryDifferentClusterVersion = includeMemory && !selectedModel.isVMWithMemoryCompatible();
    SafeHtml warningImage = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.logWarningImage()).getHTML());
    String warningText = "";
    if (includeMemoryDifferentClusterVersion) {
        // Show warning when snapshot with memory originates in different cluster version
        warningText += constants.snapshotPreviewWithMemoryFromDifferentClusterVersion();
    }
    if (!includeAllDisksOfSnapshot && includeMemory) {
        // Show warning in case of previewing a memory snapshot and excluding disks of the selected snapshot.
        warningText += constants.snapshotPreviewWithMemoryAndPartialDisksWarning();
    } else if (isDisksExcluded(disksOfActiveSnapshot, selectedDisks)) {
        // Show warning when excluding disks.
        warningText += constants.snapshotPreviewWithExcludedDisksWarning();
    }
    warningPanel.clear();
    if (!warningText.isEmpty()) {
        warningPanel.add(new HTML(templates.iconWithText(warningImage, warningText)));
        warningPanel.setVisible(true);
    } else {
        warningPanel.setVisible(false);
    }
}
#method_after
private void updateWarnings() {
    List<DiskImage> selectedDisks = previewSnapshotModel.getSelectedDisks();
    List<DiskImage> disksOfSelectedSnapshot = previewSnapshotModel.getSnapshotModel().getEntity().getDiskImages();
    List<DiskImage> disksOfActiveSnapshot;
    if (previewSnapshotModel.getActiveSnapshotModel() != null) {
        disksOfActiveSnapshot = previewSnapshotModel.getActiveSnapshotModel().getEntity().getDiskImages();
    } else {
        disksOfActiveSnapshot = Collections.emptyList();
    }
    SnapshotModel selectedModel = previewSnapshotModel.getSnapshotModel();
    boolean includeAllDisksOfSnapshot = selectedDisks.containsAll(disksOfSelectedSnapshot);
    boolean includeMemory = selectedModel.getMemory().getEntity();
    boolean includeMemoryDifferentClusterVersion = includeMemory && !selectedModel.isVMWithMemoryCompatible();
    SafeHtml warningImage = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(resources.logWarningImage()).getHTML());
    // $NON-NLS-1$
    String warningText = "";
    if (includeMemoryDifferentClusterVersion) {
        // Show warning when snapshot with memory originates in different cluster version
        warningText += constants.snapshotPreviewWithMemoryFromDifferentClusterVersion();
    }
    if (!includeAllDisksOfSnapshot && includeMemory) {
        // Show warning in case of previewing a memory snapshot and excluding disks of the selected snapshot.
        warningText += constants.snapshotPreviewWithMemoryAndPartialDisksWarning();
    } else if (isDisksExcluded(disksOfActiveSnapshot, selectedDisks)) {
        // Show warning when excluding disks.
        warningText += constants.snapshotPreviewWithExcludedDisksWarning();
    }
    warningPanel.clear();
    if (!warningText.isEmpty()) {
        warningPanel.add(new HTML(templates.iconWithText(warningImage, warningText)));
        warningPanel.setVisible(true);
    } else {
        warningPanel.setVisible(false);
    }
}
#end_block

#method_before
private void updateIsLiveMergeSupported(Object entity) {
    if (entity == null) {
        return;
    }
    VM vm = (VM) entity;
    if (vm.getRunOnVds() == null || !AsyncDataProvider.getInstance().isLiveMergeSupported(vm)) {
        setLiveMergeSupported(false);
        return;
    }
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) model;
            VDS vds = (VDS) returnValue;
            vmSnapshotListModel.setLiveMergeSupported(vds.getLiveMergeSupport());
        }
    });
    AsyncDataProvider.getInstance().getHostById(query, vm.getRunOnVds());
}
#method_after
private void updateIsLiveMergeSupported(Object entity) {
    if (entity == null) {
        return;
    }
    VM vm = (VM) entity;
    if (vm.getRunOnVds() == null) {
        setLiveMergeSupported(false);
        return;
    }
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) model;
            VDS vds = (VDS) returnValue;
            vmSnapshotListModel.setLiveMergeSupported(vds.getLiveMergeSupport());
        }
    });
    AsyncDataProvider.getInstance().getHostById(query, vm.getRunOnVds());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    DiskSnapshotsValidator diskSnapshotsValidator = createDiskSnapshotsValidator(getImages());
    if (!validate(diskSnapshotsValidator.diskSnapshotsNotExist(getParameters().getImageIds())) || !validate(diskSnapshotsValidator.diskImagesBelongToSameImageGroup()) || !validate(diskSnapshotsValidator.imagesAreSnapshots())) {
        return false;
    }
    // Validate all chain of images in the disk
    if (!validateAllDiskImages()) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(getImages());
    if (!validate(diskImagesValidator.diskImagesSnapshotsNotAttachedToOtherVms(false))) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (isDiskPlugged()) {
        VmValidator vmValidator = createVmValidator(getVm());
        if (isLiveMergeSupported() ? (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) : !validate(vmValidator.vmDown())) {
            return false;
        }
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateStorageDomainActive()) {
        return false;
    }
    if (!validateStorageDomainAvailableSpace()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    DiskSnapshotsValidator diskSnapshotsValidator = createDiskSnapshotsValidator(getImages());
    if (!validate(diskSnapshotsValidator.diskSnapshotsNotExist(getParameters().getImageIds())) || !validate(diskSnapshotsValidator.diskImagesBelongToSameImageGroup()) || !validate(diskSnapshotsValidator.imagesAreSnapshots())) {
        return false;
    }
    // Validate all chain of images in the disk
    if (!validateAllDiskImages()) {
        return false;
    }
    DiskImagesValidator diskImagesValidator = createDiskImageValidator(getImages());
    if (!validate(diskImagesValidator.diskImagesSnapshotsNotAttachedToOtherVms(false))) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (isDiskPlugged()) {
        VmValidator vmValidator = createVmValidator(getVm());
        if (!validate(vmValidator.vmQualifiedForSnapshotMerge()) || !validate(vmValidator.vmHostCanLiveMerge())) {
            return false;
        }
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validateVmNotDuringSnapshot() || !validateVmNotInPreview() || !validateSnapshotExists() || !validateStorageDomainActive()) {
        return false;
    }
    if (!validateStorageDomainAvailableSpace()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected Guid getImageGroupId() {
    return getRepresentativeImage().map(img -> img.getId()).orElse(Guid.Empty);
}
#method_after
@Override
protected Guid getImageGroupId() {
    return getRepresentativeImage().map(DiskImage::getId).orElse(Guid.Empty);
}
#end_block

#method_before
@Override
public Response add(Vm vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(Vm.class, vm);
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Cluster cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !Objects.equals(Objects.toString(template.getClusterId(), null), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(Vm.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setClusterId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            boolean clone = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE, true, false);
            if (clone) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    Vm result = (Vm) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#method_after
@Override
public Response add(Vm vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(Vm.class, vm);
    validateIconParameters(vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            validateSnapshotExistence(vm);
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Cluster cluster = getCluster(vm);
            VmTemplate template = lookupTemplate(vm.getTemplate(), cluster.getStoragePoolId());
            VmStatic builtFromTemplate = VmMapper.map(template, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !Objects.equals(Objects.toString(template.getClusterId(), null), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                instanceTypeEntity = lookupInstance(vm.getInstanceType());
                builtFromInstanceType = VmMapper.map(instanceTypeEntity, builtFromTemplate, cluster.getCompatibilityVersion());
                builtFromInstanceType.setInstanceTypeId(instanceTypeEntity.getId());
            }
            VmStatic staticVm = getMapper(Vm.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setClusterId(cluster.getId());
            }
            if (Guid.Empty.equals(template.getId()) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb()));
            if (!isFiltered() && vm.isSetPlacementPolicy()) {
                Set<Guid> hostGuidsSet = validateAndUpdateHostsInPlacementPolicy(vm.getPlacementPolicy());
                staticVm.setDedicatedVmForVdsList(new LinkedList<>(hostGuidsSet));
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && template.getId().equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            boolean clone = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE, true, false);
            if (clone) {
                response = cloneVmFromTemplate(staticVm, vm, template, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(template.getId())) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, template, instanceTypeEntity, cluster);
            }
        }
    }
    Vm result = (Vm) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
void setupCloneTemplatePermissions(VmManagementParametersBase params) {
    boolean clonePermissions = QueryHelper.getBooleanMatrixParameter(uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyTemplatePermissions(clonePermissions);
    }
}
#method_after
void setupCloneTemplatePermissions(VmManagementParametersBase params) {
    boolean clonePermissions = ParametersHelper.getBooleanParameter(httpHeaders, uriInfo, CLONE_PERMISSIONS, true, false);
    if (clonePermissions) {
        params.setCopyTemplatePermissions(clonePermissions);
    }
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getClusterCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable(true);
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
        customPropertiesModel.setIsAvailable(true);
        Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
        // to backend and frontend (lvernia)
        if (!network.isVmNetwork()) {
            // $NON-NLS-1$
            validProperties.remove("bridge_opts");
        }
        validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
        customPropertiesModel.setKeyValueMap(validProperties);
        customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getClusterCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel();
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel();
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getGateway().setIsAvailable(true);
        }
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
        customPropertiesModel.setIsAvailable(true);
        Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
        // to backend and frontend (lvernia)
        if (!network.isVmNetwork()) {
            // $NON-NLS-1$
            validProperties.remove("bridge_opts");
        }
        validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
        customPropertiesModel.setKeyValueMap(validProperties);
        customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
@Override
protected BackendInternal getBackend() {
    return Backend.getInstance();
}
#method_after
@Override
protected BackendInternal getBackend() {
    return super.getBackend();
}
#end_block

#method_before
private Map<String, String> createMigrationInfo() {
    Map<String, String> migrationInfo = new HashMap<>();
    P parameters = getParameters();
    migrationInfo.put(VdsProperties.vm_guid, parameters.getVmId().toString());
    migrationInfo.put(VdsProperties.src, String.format("%1$s", parameters.getSrcHost()));
    migrationInfo.put(VdsProperties.dst, String.format("%1$s", parameters.getDstHost()));
    migrationInfo.put(VdsProperties.method, VdsProperties.migrationMethodtoString(parameters.getMigrationMethod()));
    migrationInfo.put("abortOnError", Boolean.TRUE.toString());
    migrationInfo.put(VdsProperties.TUNNELED, Boolean.toString(parameters.isTunnelMigration()));
    if (StringUtils.isNotBlank(parameters.getDstQemu())) {
        migrationInfo.put(VdsProperties.DST_QEMU, parameters.getDstQemu());
    }
    if (parameters.getMigrationDowntime() != 0) {
        migrationInfo.put(VdsProperties.MIGRATION_DOWNTIME, Integer.toString(parameters.getMigrationDowntime()));
    }
    if (parameters.getAutoConverge() != null) {
        migrationInfo.put(VdsProperties.AUTO_CONVERGE, parameters.getAutoConverge().toString());
    }
    if (parameters.getMigrateCompressed() != null) {
        migrationInfo.put(VdsProperties.MIGRATE_COMPRESSED, parameters.getMigrateCompressed().toString());
    }
    if (parameters.getConsoleAddress() != null) {
        migrationInfo.put(VdsProperties.CONSOLE_ADDRESS, parameters.getConsoleAddress());
    }
    return migrationInfo;
}
#method_after
private Map<String, String> createMigrationInfo() {
    Map<String, String> migrationInfo = new HashMap<>();
    P parameters = getParameters();
    migrationInfo.put(VdsProperties.vm_guid, parameters.getVmId().toString());
    migrationInfo.put(VdsProperties.src, String.format("%1$s", parameters.getSrcHost()));
    migrationInfo.put(VdsProperties.dst, String.format("%1$s", parameters.getDstHost()));
    migrationInfo.put(VdsProperties.method, VdsProperties.migrationMethodtoString(parameters.getMigrationMethod()));
    migrationInfo.put(VdsProperties.TUNNELED, Boolean.toString(parameters.isTunnelMigration()));
    migrationInfo.put("abortOnError", Boolean.TRUE.toString());
    if (StringUtils.isNotBlank(parameters.getDstQemu())) {
        migrationInfo.put(VdsProperties.DST_QEMU, parameters.getDstQemu());
    }
    if (parameters.getMigrationDowntime() != 0) {
        migrationInfo.put(VdsProperties.MIGRATION_DOWNTIME, Integer.toString(parameters.getMigrationDowntime()));
    }
    if (parameters.getAutoConverge() != null) {
        migrationInfo.put(VdsProperties.AUTO_CONVERGE, parameters.getAutoConverge().toString());
    }
    if (parameters.getMigrateCompressed() != null) {
        migrationInfo.put(VdsProperties.MIGRATE_COMPRESSED, parameters.getMigrateCompressed().toString());
    }
    if (parameters.getConsoleAddress() != null) {
        migrationInfo.put(VdsProperties.CONSOLE_ADDRESS, parameters.getConsoleAddress());
    }
    return migrationInfo;
}
#end_block

#method_before
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    final int HOURS_TO_MINUTES = 60;
    long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "availableUpdates", new Class[0], new Object[0], RandomUtils.nextInt(HOURS_TO_MINUTES) + 1, rateInMinutes, TimeUnit.MINUTES));
    vmsRefresher = getRefresherFactory().create(this);
    vmsRefresher.startMonitoring();
}
#method_after
public void scheduleJobs() {
    SchedulerUtil sched = getSchedulUtil();
    int refreshRate = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], refreshRate, refreshRate, TimeUnit.MILLISECONDS));
    double availableUpdatesRefreshRate = Config.<Double>getValue(ConfigValues.HostPackagesUpdateTimeInHours);
    final int HOURS_TO_MINUTES = 60;
    long rateInMinutes = Math.round(availableUpdatesRefreshRate * HOURS_TO_MINUTES);
    registeredJobs.add(sched.scheduleAFixedDelayJob(this, "availableUpdates", new Class[0], new Object[0], RandomUtils.nextInt(HOURS_TO_MINUTES) + 1, rateInMinutes, TimeUnit.MINUTES));
    vmsRefresher = getRefresherFactory().create(this);
    vmsRefresher.startMonitoring();
    hostRefresher = new HostConnectionRefresher(this, resourceManager);
    hostRefresher.start();
}
#end_block

#method_before
public void refreshHost(VDS vds) {
    try {
        refreshCapabilities(new AtomicBoolean(), vds);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void refreshHost() {
    refreshHost(cachedVds);
}
#end_block

#method_before
public void dispose() {
    log.info("vdsManager::disposing");
    for (String jobId : registeredJobs) {
        getSchedulUtil().deleteJob(jobId);
    }
    vmsRefresher.stopMonitoring();
    vdsProxy.close();
}
#method_after
public void dispose() {
    log.info("vdsManager::disposing");
    for (String jobId : registeredJobs) {
        getSchedulUtil().deleteJob(jobId);
    }
    vmsRefresher.stopMonitoring();
    hostRefresher.stop();
    vdsProxy.close();
}
#end_block

#method_before
@Override
public void close() throws Exception {
    if (fallbackTriggered) {
        setFallbackProtocol(VdsProtocol.STOMP);
        VdsDynamic host = vdsDynamicDao.get(vds.getId());
        // warn if host supports jsonrpc in cluster which supports only jsonrpc, and fallback was triggered
        if (isJsonProtocolSupported(host) && vds.getClusterCompatibilityVersion().greaterOrEquals(Version.v3_6)) {
            // Report an error for protocol incompatibility
            AuditLogableBase event = new AuditLogableBase();
            event.setVds(vds);
            auditLogDirector.log(event, AuditLogType.HOST_PROTOCOL_INCOMPATIBLE_WITH_CLUSTER);
        }
    }
}
#method_after
@Override
public void close() throws Exception {
    if (fallbackTriggered) {
        setFallbackProtocol(VdsProtocol.STOMP);
        // warn if host supports jsonrpc in cluster which supports only jsonrpc, and fallback was triggered
        if (vds.getClusterCompatibilityVersion().greaterOrEquals(Version.v3_6)) {
            // Report an error for protocol incompatibility
            AuditLogableBase event = new AuditLogableBase();
            event.setVds(vds);
            auditLogDirector.log(event, AuditLogType.HOST_PROTOCOL_INCOMPATIBLE_WITH_CLUSTER);
        }
    }
}
#end_block

#method_before
private void updateProblematicVdsData(final Guid vdsId, final String vdsName, Map<Guid, DomainMonitoringResult> problematicDomains) {
    // for all problematic domains
    // update cache of _domainsInProblem
    // and _vdssInProblem and add a new
    // timer for new domains in problem
    boolean newDomainUnreachableByHost = false;
    List<Guid> domainsUnreachableByHost = new LinkedList<>();
    for (Map.Entry<Guid, DomainMonitoringResult> entry : problematicDomains.entrySet()) {
        Guid domainId = entry.getKey();
        DomainMonitoringResult domainMonitoringResult = entry.getValue();
        HashSet<Guid> hostsReportedDomainAsProblematic = _domainsInProblem.get(domainId);
        boolean domainNotFound = domainMonitoringResult == DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        if (domainNotFound) {
            domainsUnreachableByHost.add(domainId);
        }
        if (hostsReportedDomainAsProblematic != null) {
            if (!hostsReportedDomainAsProblematic.contains(vdsId) && domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // existing domains in problem
            updateDomainInProblemData(domainId, vdsId, vdsName);
        } else {
            if (domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // new domains in problems
            addDomainInProblemData(domainId, vdsId, vdsName);
        }
    }
    if (domainsUnreachableByHost.isEmpty()) {
        Guid clearedReport = clearVdsReportInfoOnUnseenDomain(vdsId);
        if (clearedReport != null) {
            log.info("Host '{}' no longer storage access problem to any relevant domain " + " clearing it's report (report id: '{}')", vdsId, clearedReport);
        }
    } else if (newDomainUnreachableByHost) {
        Guid newReportId = Guid.newGuid();
        log.info("Host '{}' has reported new storage access problem to the following domains '{}'" + " marking it for storage connections and pool metadata refresh (report id: '{}')", vdsId, StringUtils.join(domainsUnreachableByHost, ","), newReportId);
        vdsReportsOnUnseenDomain.put(vdsId, newReportId);
    }
    Set<Guid> notReportedDomainsByHost = new HashSet<>(_domainsInProblem.keySet());
    notReportedDomainsByHost.removeAll(problematicDomains.keySet());
    for (Guid domainId : notReportedDomainsByHost) {
        Set<Guid> vdsForDomain = _domainsInProblem.get(domainId);
        if (vdsForDomain != null && vdsForDomain.contains(vdsId)) {
            domainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#method_after
private void updateProblematicVdsData(final Guid vdsId, final String vdsName, Map<Guid, DomainMonitoringResult> problematicDomains) {
    // for all problematic domains
    // update cache of _domainsInProblem
    // and _vdssInProblem and add a new
    // timer for new domains in problem
    boolean newDomainUnreachableByHost = false;
    List<Guid> domainsUnreachableByHost = new LinkedList<>();
    for (Map.Entry<Guid, DomainMonitoringResult> entry : problematicDomains.entrySet()) {
        Guid domainId = entry.getKey();
        DomainMonitoringResult domainMonitoringResult = entry.getValue();
        HashSet<Guid> hostsReportedDomainAsProblematic = _domainsInProblem.get(domainId);
        boolean domainNotFound = domainMonitoringResult == DomainMonitoringResult.STORAGE_ACCCESS_ERROR;
        if (domainNotFound) {
            domainsUnreachableByHost.add(domainId);
        }
        if (hostsReportedDomainAsProblematic != null) {
            if (!hostsReportedDomainAsProblematic.contains(vdsId) && domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // existing domains in problem
            updateDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        } else {
            if (domainNotFound) {
                newDomainUnreachableByHost = true;
            }
            // new domains in problems
            addDomainInProblemData(domainId, vdsId, vdsName, domainMonitoringResult);
        }
    }
    if (domainsUnreachableByHost.isEmpty()) {
        Guid clearedReport = clearVdsReportInfoOnUnseenDomain(vdsId);
        if (clearedReport != null) {
            log.info("Host '{}' no longer storage access problem to any relevant domain " + " clearing it's report (report id: '{}')", vdsId, clearedReport);
        }
    } else if (newDomainUnreachableByHost) {
        Guid newReportId = Guid.newGuid();
        log.info("Host '{}' has reported new storage access problem to the following domains '{}'" + " marking it for storage connections and pool metadata refresh (report id: '{}')", vdsId, StringUtils.join(domainsUnreachableByHost, ","), newReportId);
        vdsReportsOnUnseenDomain.put(vdsId, newReportId);
    }
    Set<Guid> notReportedDomainsByHost = new HashSet<>(_domainsInProblem.keySet());
    notReportedDomainsByHost.removeAll(problematicDomains.keySet());
    for (Guid domainId : notReportedDomainsByHost) {
        Set<Guid> vdsForDomain = _domainsInProblem.get(domainId);
        if (vdsForDomain != null && vdsForDomain.contains(vdsId)) {
            domainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new HashSet<>(Arrays.asList(vdsId)));
    log.warn("domain '{}' in problem. vds: '{}'", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    _domainsInProblem.put(domainId, new HashSet<>(Arrays.asList(vdsId)));
    log.warn("domain '{}' in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFailureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#end_block

#method_before
private void updateDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    log.debug("domain '{}' still in problem. vds: '{}'", getDomainIdTuple(domainId), vdsName);
    _domainsInProblem.get(domainId).add(vdsId);
}
#method_after
private void updateDomainInProblemData(Guid domainId, Guid vdsId, String vdsName, DomainMonitoringResult domainMonitoringResult) {
    log.debug("domain '{}' still in problem '{}'. vds: '{}'", getDomainIdTuple(domainId), domainMonitoringResult, vdsName);
    _domainsInProblem.get(domainId).add(vdsId);
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getClusterCompatibilityVersion());
    Set<Version> supportedClusterVersionsSet = host.getSupportedClusterVersionsSet();
    boolean supportedClusterVersionsAvailable = supportedClusterVersionsSet != null && supportedClusterVersionsSet.isEmpty();
    if (!supportedClusterVersionsAvailable) {
        log.warn("Host '{}' ('{}') doesn't contain Supported Cluster Versions, therefore 'defaultRoute'" + " will not be sent via the SetupNetworks", host.getName(), host.getId());
    }
    CustomPropertiesForVdsNetworkInterface customProperties = getParameters().getCustomProperties();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        iface.setVdsId(host.getId());
        VdsNetworkInterface baseNic = calculateBaseNic.getBaseNic(iface);
        // baseNic can have null-valued id, since iface can be newly created interface without vlan passed from client.
        boolean unableToObtainNetworkAttachment = baseNic == null || baseNic.getId() == null;
        NetworkAttachment networkAttachment = unableToObtainNetworkAttachment ? null : networkAttachmentDao.getNetworkAttachmentByNicIdAndNetworkId(baseNic.getId(), network.getId());
        if (hostNetworkQosSupported && NetworkUtils.qosConfiguredOnInterface(networkAttachment, network)) {
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
            new HostNetworkQosMapper(opts).serialize(hostNetworkQos);
        }
        if (supportedClusterVersionsAvailable && managementNetworkUtil.isManagementNetwork(network.getId(), host.getClusterId()) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (customProperties.hasCustomPropertiesFor(iface)) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, customProperties.getCustomPropertiesFor(iface));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    VDS host = getParameters().getVds();
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(host.getClusterCompatibilityVersion());
    CustomPropertiesForVdsNetworkInterface customProperties = getParameters().getCustomProperties();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface);
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() == 0) {
            opts.put("mtu", NetworkUtils.getDefaultMtu().toString());
        } else {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        iface.setVdsId(host.getId());
        VdsNetworkInterface baseNic = calculateBaseNic.getBaseNic(iface);
        // baseNic can have null-valued id, since iface can be newly created interface without vlan passed from client.
        boolean unableToObtainNetworkAttachment = baseNic == null || baseNic.getId() == null;
        NetworkAttachment networkAttachment = unableToObtainNetworkAttachment ? null : networkAttachmentDao.getNetworkAttachmentByNicIdAndNetworkId(baseNic.getId(), network.getId());
        if (hostNetworkQosSupported && NetworkUtils.qosConfiguredOnInterface(networkAttachment, network)) {
            HostNetworkQos hostNetworkQos = effectiveHostNetworkQos.getQos(networkAttachment, network);
            new HostNetworkQosMapper(opts).serialize(hostNetworkQos);
        }
        if (managementNetworkUtil.isManagementNetwork(network.getId(), host.getClusterId()) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (customProperties.hasCustomPropertiesFor(iface)) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, customProperties.getCustomPropertiesFor(iface));
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(Collections.singletonList(getEntity()), getEntity());
    model.getDataCenter().setIsChangeable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (clusterModel.getSelectedItem() != null) {
                    if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                        model.getProtocol().setIsAvailable(false);
                    } else {
                        model.getProtocol().setIsAvailable(true);
                    }
                }
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
                if (jsonSupported) {
                    model.getProtocol().setEntity(true);
                } else {
                    model.getProtocol().setEntity(false);
                    model.getProtocol().setIsChangeable(false);
                }
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(Collections.singletonList(getEntity()), getEntity());
    model.getDataCenter().setIsChangeable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (clusterModel.getSelectedItem() != null) {
                    if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                        model.getProtocol().setIsAvailable(false);
                    } else {
                        model.getProtocol().setIsAvailable(true);
                    }
                }
                model.getProtocol().setEntity(true);
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        getNetworkDao().update(getNetwork());
        for (NetworkCluster clusterAttachment : getNetworkClusterDao().getAllForNetwork(getNetwork().getId())) {
            NetworkClusterHelper.setStatus(clusterAttachment.getClusterId(), getNetwork());
        }
        if (networkChangedToNonVmNetwork()) {
            removeVnicProfiles();
        }
        return null;
    });
    if (!getNetwork().isExternal()) {
        if (NetworkHelper.setupNetworkSupported(getStoragePool().getCompatibilityVersion())) {
            applyNetworkChangesToHosts();
        } else if (!onlyPermittedFieldsChanged() || !allowedNetworkLabelManipulation()) {
            List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getNetwork().getId());
            if (!nics.isEmpty()) {
                auditLogDirector.log(this, AuditLogType.MULTI_UPDATE_NETWORK_NOT_POSSIBLE);
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(() -> {
        getNetworkDao().update(getNetwork());
        for (NetworkCluster clusterAttachment : getNetworkClusterDao().getAllForNetwork(getNetwork().getId())) {
            NetworkClusterHelper.setStatus(clusterAttachment.getClusterId(), getNetwork());
        }
        if (networkChangedToNonVmNetwork()) {
            removeVnicProfiles();
        }
        return null;
    });
    if (!getNetwork().isExternal()) {
        applyNetworkChangesToHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                hostModel.getOverrideIpTables().setIsAvailable(true);
                hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                    hostModel.getProtocol().setIsAvailable(false);
                    hostModel.getProtocol().setIsChangeable(false);
                } else {
                    hostModel.getProtocol().setIsAvailable(true);
                    hostModel.getProtocol().setIsChangeable(true);
                }
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
                if (jsonSupported) {
                    hostModel.getProtocol().setEntity(true);
                    hostModel.getProtocol().setIsChangeable(true);
                } else {
                    hostModel.getProtocol().setEntity(false);
                    hostModel.getProtocol().setIsChangeable(false);
                }
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        Cluster cluster = (Cluster) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(cancelCommand);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    hostModel.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                hostModel.getOverrideIpTables().setIsAvailable(true);
                hostModel.getOverrideIpTables().setEntity(updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Cluster> clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Cluster cluster = clusterModel.getSelectedItem();
                if (Version.v3_6.compareTo(cluster.getCompatibilityVersion()) <= 0) {
                    hostModel.getProtocol().setIsAvailable(false);
                    hostModel.getProtocol().setIsChangeable(false);
                } else {
                    hostModel.getProtocol().setIsAvailable(true);
                    hostModel.getProtocol().setIsChangeable(true);
                }
                hostModel.getProtocol().setEntity(true);
                hostModel.getProtocol().setIsChangeable(true);
            }
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel<Void> hostListModel = (HostListModel<Void>) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangeable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        Cluster cluster = (Cluster) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangeable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangeable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrNull(dataCenters));
            }
            // $NON-NLS-1$
            UICommand onSaveFalseCommand = UICommand.createDefaultOkUiCommand("OnSaveFalse", hostListModel);
            innerHostModel.getCommands().add(onSaveFalseCommand);
            // $NON-NLS-1$
            UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", hostListModel);
            innerHostModel.getCommands().add(cancelCommand);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
@Before
public void mockConfig() {
    HashSet<Version> supportedClusters = new HashSet<>();
    supportedClusters.add(version);
    when(host.getSupportedClusterVersionsSet()).thenReturn(supportedClusters);
    when(host.getClusterCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.DefaultMTU, 1500);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, false);
}
#method_after
@Before
public void mockConfig() {
    when(host.getClusterCompatibilityVersion()).thenReturn(version);
    configRule.mockConfigValue(ConfigValues.DefaultMTU, 1500);
    configRule.mockConfigValue(ConfigValues.HostNetworkQosSupported, version, false);
}
#end_block

#method_before
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDao vdsStaticDao = mock(VdsStaticDao.class);
    final VdsDao vdsDao = mock(VdsDao.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(vdsDao.get(any(Guid.class))).thenReturn(host);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> result = new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }
    };
    result.networkAttachmentDao = networkAttachmentDao;
    result.effectiveHostNetworkQos = effectiveHostNetworkQos;
    result.calculateBaseNic = calculateBaseNic;
    return result;
}
#method_after
private SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> createCommand(SetupNetworksVdsCommandParameters parameters) {
    final DbFacade dbFacade = mock(DbFacade.class);
    final VdsStaticDao vdsStaticDao = mock(VdsStaticDao.class);
    final VdsDao vdsDao = mock(VdsDao.class);
    when(dbFacade.getVdsStaticDao()).thenReturn(vdsStaticDao);
    when(vdsDao.get(any(Guid.class))).thenReturn(host);
    // No way to avoid these calls by regular mocking, so must implement anonymously.
    SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters> result = new SetupNetworksVDSCommand<SetupNetworksVdsCommandParameters>(parameters) {

        @Override
        protected IVdsServer initializeVdsBroker(Guid vdsId) {
            return server;
        }

        @Override
        protected DbFacade getDbFacade() {
            return dbFacade;
        }
    };
    result.networkAttachmentDao = networkAttachmentDao;
    result.effectiveHostNetworkQos = effectiveHostNetworkQos;
    result.calculateBaseNic = calculateBaseNic;
    result.managementNetworkUtil = managementNetworkUtil;
    return result;
}
#end_block

#method_before
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionListDependingOnNetwork(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem, boolean hasVmNetworkAttached) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<>();
    for (BondMode mode : BondMode.values()) {
        if (!mode.isBondModeValidForVmNetwork() && hasVmNetworkAttached) {
            continue;
        }
        KeyValuePairCompat<String, EntityModel<String>> bondOption = getBondOption(mode);
        list.add(bondOption);
        if (mode.equals(BondMode.BOND4)) {
            defaultItem.argvalue = bondOption;
        }
    }
    EntityModel<String> entityModel = new EntityModel<>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    list.add(new KeyValuePairCompat<>(HostBondInterfaceModel.CUSTOM_BONDING_MODE, entityModel));
    return list;
}
#method_after
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionListDependingOnNetwork(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem, boolean hasVmNetworkAttached) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<>();
    for (BondMode mode : BondMode.values()) {
        if (!mode.isBondModeValidForVmNetwork() && hasVmNetworkAttached) {
            continue;
        }
        KeyValuePairCompat<String, EntityModel<String>> bondOption = getBondOption(mode);
        list.add(bondOption);
        if (mode.equals(BondMode.BOND4)) {
            defaultItem.argvalue = bondOption;
        }
    }
    EntityModel<String> entityModel = new EntityModel<>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    list.add(new KeyValuePairCompat<>(SetupNetworksBondModel.CUSTOM_BONDING_MODE, entityModel));
    return list;
}
#end_block

#method_before
public static Vm map(org.ovirt.engine.core.common.businessentities.VM entity, Vm template, boolean showDynamicInfo) {
    Vm model = template != null ? template : new Vm();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependencyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    } else {
        if (model.getOs() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasFqdn) {
            model.setFqdn(entity.getVmFQDN());
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromKernelVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (model.getPlacementPolicy() == null) {
        model.setPlacementPolicy(new VmPlacementPolicy());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (!entity.getDedicatedVmForVdsList().isEmpty()) {
        Hosts hostsList = new Hosts();
        for (Guid hostGuid : entity.getDedicatedVmForVdsList()) {
            Host newHost = new Host();
            newHost.setId(hostGuid.toString());
            hostsList.getHosts().add(newHost);
        }
        model.getPlacementPolicy().setHosts(hostsList);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(InitializationMapper.map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#method_after
public static Vm map(org.ovirt.engine.core.common.businessentities.VM entity, Vm template, boolean showDynamicInfo) {
    Vm model = template != null ? template : new Vm();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependencyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    } else {
        if (model.getOs() != null) {
            Boot boot = map(entity.getBootSequence(), null);
            model.getOs().setBoot(boot);
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasFqdn) {
            model.setFqdn(entity.getVmFQDN());
        }
        final boolean hasGuestOsVersion = entity.getGuestOsVersion() != null && !entity.getGuestOsVersion().isEmpty();
        if (hasGuestOsVersion) {
            GuestOperatingSystem os = model.getGuestOperatingSystem();
            if (os == null) {
                os = new GuestOperatingSystem();
                model.setGuestOperatingSystem(os);
            }
            os.setArchitecture(entity.getGuestOsArch().name());
            os.setCodename(entity.getGuestOsCodename());
            os.setDistribution(entity.getGuestOsDistribution());
            String kernelVersionString = entity.getGuestOsKernelVersion();
            if (StringUtils.isNotEmpty(kernelVersionString)) {
                org.ovirt.engine.api.model.Version kernelVersion = VersionMapper.fromVersionString(kernelVersionString);
                if (kernelVersion != null) {
                    if (os.getKernel() == null) {
                        os.setKernel(new Kernel());
                    }
                    os.getKernel().setVersion(kernelVersion);
                    os.getKernel().getVersion().setFullVersion(entity.getGuestOsKernelVersion());
                }
            }
            String osVersionString = entity.getGuestOsVersion();
            if (StringUtils.isNotEmpty(osVersionString)) {
                os.setVersion(VersionMapper.fromVersionString(osVersionString));
                if (os.getVersion() != null) {
                    os.getVersion().setFullVersion(entity.getGuestOsVersion());
                }
            }
            os.setFamily(entity.getGuestOsType().name());
        }
        final boolean hasTimezoneName = entity.getGuestOsTimezoneName() != null && !entity.getGuestOsTimezoneName().isEmpty();
        if (hasTimezoneName) {
            TimeZone guestTz = model.getGuestTimeZone();
            if (guestTz == null) {
                guestTz = new TimeZone();
                model.setGuestTimeZone(guestTz);
            }
            guestTz.setName(entity.getGuestOsTimezoneName());
            guestTz.setUtcOffset(TimeZoneMapper.mapUtcOffsetToDisplayString(entity.getGuestOsTimezoneOffset()));
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.getDisplay().setDisconnectAction(map(entity.getConsoleDisconnectAction(), null).toString());
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (model.getPlacementPolicy() == null) {
        model.setPlacementPolicy(new VmPlacementPolicy());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (!entity.getDedicatedVmForVdsList().isEmpty()) {
        Hosts hostsList = new Hosts();
        for (Guid hostGuid : entity.getDedicatedVmForVdsList()) {
            Host newHost = new Host();
            newHost.setId(hostGuid.toString());
            hostsList.getHosts().add(newHost);
        }
        model.getPlacementPolicy().setHosts(hostsList);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(InitializationMapper.map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#end_block

#method_before
@Override
public void edit(final AbstractDiskModel disk) {
    driver.edit(disk);
    disk.getIsDirectLunDiskAvaialable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isDirectLunDiskAvaialable = ((EntityModel<Boolean>) sender).getEntity();
            externalDiskPanel.setVisible(isDirectLunDiskAvaialable);
        }
    });
    disk.getIsUsingScsiReservation().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            scsiReservationInfoIcon.setVisible(disk.getIsUsingScsiReservation().getEntity());
        }
    });
    disk.getIsVirtioScsiEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (disk.getVm() == null) {
                // not relevant for floating disks
                return;
            }
            boolean isVirtioScsiEnabled = Boolean.TRUE.equals(((EntityModel) sender).getEntity());
            // Show the info icon if VirtIO-SCSI is supported by the cluster but disabled for the VM
            interfaceInfoIcon.setVisible(!isVirtioScsiEnabled);
        }
    });
    disk.getCinderVolumeType().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Collection<String> volumeTypes = disk.getCinderVolumeType().getItems();
            cinderVolumeTypeInfoIcon.setVisible(volumeTypes == null || volumeTypes.isEmpty());
        }
    });
    disk.getIsModelDisabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (disk.getIsModelDisabled().getEntity()) {
                disableWidget(getWidget());
                enableWidget(diskTypePanel);
                enableWidget(datacenterEditor);
                disk.getDefaultCommand().setIsExecutionAllowed(false);
                disk.setIsChangeable(false);
            } else {
                enableWidget(getWidget());
                disk.getDefaultCommand().setIsExecutionAllowed(true);
                disk.setIsChangeable(true);
            }
        }
    });
    diskTypePanel.addRadioButton(constants.imageDisk(), disk.getDisk() == null || disk.getDisk().getDiskStorageType() == DiskStorageType.IMAGE, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.directLunDisk(), disk.getDisk() != null && disk.getDisk().getDiskStorageType() == DiskStorageType.LUN, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.LUN);
            revealStorageView(disk);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.cinderDisk(), disk.getDisk() != null && disk.getDisk().getDiskStorageType() == DiskStorageType.CINDER, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.CINDER);
            revealDiskPanel(disk);
        }
    });
    if (disk.getStorageModel() == null) {
        storageModel = new StorageModel(new NewEditStorageModelBehavior());
        // Create IscsiStorageModel
        iscsiStorageModel = new IscsiStorageModel();
        iscsiStorageModel.setContainer(storageModel);
        iscsiStorageModel.setIsGrouppedByTarget(true);
        iscsiStorageModel.setIgnoreGrayedOut(true);
        // Create FcpStorageModel
        fcpStorageModel = new FcpStorageModel();
        fcpStorageModel.setContainer(storageModel);
        fcpStorageModel.setIsGrouppedByTarget(false);
        fcpStorageModel.setIgnoreGrayedOut(true);
        // Set 'StorageModel' items
        ArrayList<IStorageModel> items = new ArrayList<>();
        items.add(iscsiStorageModel);
        items.add(fcpStorageModel);
        storageModel.setStorageModels(items);
        storageModel.setHost(disk.getHost());
        disk.setStorageModel(storageModel);
    } else {
        storageModel = disk.getStorageModel();
        iscsiStorageModel = Linq.findByType(storageModel.getStorageModels(), IscsiStorageModel.class);
        iscsiStorageModel.getPropertyChangedEvent().clearListeners();
        fcpStorageModel = Linq.findByType(storageModel.getStorageModels(), FcpStorageModel.class);
        fcpStorageModel.getPropertyChangedEvent().clearListeners();
    }
    iscsiStorageView = new IscsiStorageView(false, 115, 214, 244, 275, 142, 55, -67);
    iscsiStorageView.edit(iscsiStorageModel);
    fcpStorageView = new FcpStorageView(false, 278, 240);
    fcpStorageView.edit(fcpStorageModel);
    // SelectedItemChangedEvent handlers
    disk.getStorageType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    disk.getHost().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    disk.getDiskStorageType().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                if (disk.getDiskStorageType().getIsChangable()) {
                    enableWidget(diskTypePanel);
                } else {
                    disableWidget(diskTypePanel);
                }
            }
        }
    });
    revealStorageView(disk);
    revealDiskPanel(disk);
}
#method_after
@Override
public void edit(final AbstractDiskModel disk) {
    driver.edit(disk);
    disk.getIsDirectLunDiskAvaialable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isDirectLunDiskAvaialable = ((EntityModel<Boolean>) sender).getEntity();
            externalDiskPanel.setVisible(isDirectLunDiskAvaialable);
        }
    });
    disk.getIsUsingScsiReservation().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            scsiReservationInfoIcon.setVisible(disk.getIsUsingScsiReservation().getEntity());
        }
    });
    disk.getIsVirtioScsiEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (disk.getVm() == null) {
                // not relevant for floating disks
                return;
            }
            boolean isVirtioScsiEnabled = Boolean.TRUE.equals(((EntityModel) sender).getEntity());
            // Show the info icon if VirtIO-SCSI is supported by the cluster but disabled for the VM
            interfaceInfoIcon.setVisible(!isVirtioScsiEnabled);
        }
    });
    disk.getCinderVolumeType().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Collection<String> volumeTypes = disk.getCinderVolumeType().getItems();
            cinderVolumeTypeInfoIcon.setVisible(volumeTypes == null || volumeTypes.isEmpty());
        }
    });
    disk.getIsModelDisabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (disk.getIsModelDisabled().getEntity()) {
                disableWidget(getWidget());
                enableWidget(diskTypePanel);
                enableWidget(datacenterEditor);
                disk.getDefaultCommand().setIsExecutionAllowed(false);
                disk.setIsChangeable(false);
            } else {
                enableWidget(getWidget());
                disk.getDefaultCommand().setIsExecutionAllowed(true);
                disk.setIsChangeable(true);
            }
        }
    });
    diskTypePanel.addRadioButton(constants.imageDisk(), disk.getDisk() == null || disk.getDisk().getDiskStorageType() == DiskStorageType.IMAGE, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.IMAGE);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.directLunDisk(), disk.getDisk() != null && disk.getDisk().getDiskStorageType() == DiskStorageType.LUN, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.LUN);
            revealStorageView(disk);
            revealDiskPanel(disk);
        }
    });
    diskTypePanel.addRadioButton(constants.cinderDisk(), disk.getDisk() != null && disk.getDisk().getDiskStorageType() == DiskStorageType.CINDER, disk.getIsNew(), new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            disk.getDiskStorageType().setEntity(DiskStorageType.CINDER);
            revealDiskPanel(disk);
        }
    });
    if (disk.getStorageModel() == null) {
        storageModel = new StorageModel(new NewEditStorageModelBehavior());
        // Create IscsiStorageModel
        iscsiStorageModel = new IscsiStorageModel();
        iscsiStorageModel.setContainer(storageModel);
        iscsiStorageModel.setIsGrouppedByTarget(true);
        iscsiStorageModel.setIgnoreGrayedOut(true);
        // Create FcpStorageModel
        fcpStorageModel = new FcpStorageModel();
        fcpStorageModel.setContainer(storageModel);
        fcpStorageModel.setIsGrouppedByTarget(false);
        fcpStorageModel.setIgnoreGrayedOut(true);
        // Set 'StorageModel' items
        ArrayList<IStorageModel> items = new ArrayList<>();
        items.add(iscsiStorageModel);
        items.add(fcpStorageModel);
        storageModel.setStorageModels(items);
        storageModel.setHost(disk.getHost());
        disk.setStorageModel(storageModel);
    } else {
        storageModel = disk.getStorageModel();
        iscsiStorageModel = Linq.findByType(storageModel.getStorageModels(), IscsiStorageModel.class);
        iscsiStorageModel.getPropertyChangedEvent().clearListeners();
        fcpStorageModel = Linq.findByType(storageModel.getStorageModels(), FcpStorageModel.class);
        fcpStorageModel.getPropertyChangedEvent().clearListeners();
    }
    iscsiStorageView = new IscsiStorageView(false, 115, 214, 244, 275, 142, 55, -67);
    iscsiStorageView.edit(iscsiStorageModel);
    fcpStorageView = new FcpStorageView(false, 278, 240);
    fcpStorageView.edit(fcpStorageModel);
    // SelectedItemChangedEvent handlers
    disk.getStorageType().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    disk.getHost().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            revealStorageView(disk);
        }
    });
    disk.getDiskStorageType().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                if (disk.getDiskStorageType().getIsChangable() && disk.isEditEnabled()) {
                    enableWidget(diskTypePanel);
                } else {
                    disableWidget(diskTypePanel);
                }
            }
        }
    });
    if (!disk.isEditEnabled()) {
        disableWidget(getWidget());
        disableWidget(diskTypePanel);
    }
    revealStorageView(disk);
    revealDiskPanel(disk);
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernelParameters().setEntity(vm.getKernelParams());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInitModel().init(vm.getStaticData());
    updateDomainList();
    updateSystemTabLists();
    updateIsoList();
    updateUnknownTypeImagesList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
    AsyncDataProvider.isFloppySupported(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isFloppySupported = (Boolean) returnValue;
            if (!isFloppySupported.booleanValue()) {
                getAttachFloppy().setIsAvailable(false);
                getFloppyImage().setIsAvailable(false);
            }
        }
    }), vm.getOs(), vm.getCompatibilityVersion());
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_once_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_once_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernelParameters().setEntity(vm.getKernelParams());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInitModel().init(vm.getStaticData());
    updateDomainList();
    updateSystemTabLists();
    updateIsoList();
    updateUnknownTypeImagesList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
    AsyncDataProvider.isFloppySupported(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isFloppySupported = (Boolean) returnValue;
            if (!isFloppySupported.booleanValue()) {
                getAttachFloppy().setIsAvailable(false);
                getFloppyImage().setIsAvailable(false);
            }
        }
    }), vm.getOs(), vm.getCompatibilityVersion());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    getModel().getCpuSharesAmount().setEntity(template.getCpuShares());
    updateCpuSharesSelection();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), template.getCpuProfileId());
    }
    updateCustomPropertySheet();
    getModel().getCustomPropertySheet().deserialize(template.getCustomProperties());
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateGraphics(template.getId());
    updateDefaultHost();
    updateNumOfSockets();
    updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    getModel().getCpuSharesAmount().setEntity(template.getCpuShares());
    updateCpuSharesSelection();
    updateVirtioScsiAvailability();
    updateMigrationForLocalSD();
    updateOSValues();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), template.getCpuProfileId());
    }
    updateCustomPropertySheet();
    getModel().getCustomPropertySheet().deserialize(template.getCustomProperties());
}
#end_block

#method_before
protected boolean isEditEnabled() {
    return (getIsFloating() || getIsNew() || getVm().isDown() || !getDisk().getPlugged()) && getIsChangable();
}
#method_after
public boolean isEditEnabled() {
    return (getIsFloating() || getIsNew() || getVm().isDown() || !getDisk().getPlugged()) && getIsChangable();
}
#end_block

#method_before
protected void updateReadOnlyChangeability() {
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(constants.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangeable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    boolean isScsiPassthrough = getIsScsiPassthrough().getEntity();
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN && isScsiPassthrough) {
        getIsReadOnly().setChangeProhibitionReason(constants.cannotEnableReadonlyWhenScsiPassthroughEnabled());
        getIsReadOnly().setIsChangeable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    if (isVmAttachedToPool() && !getIsNew()) {
        getIsReadOnly().setIsChangeable(false);
    } else {
        getIsReadOnly().setIsChangeable(isEditEnabled());
    }
    getIsReadOnly().setEntity(getIsNew() ? Boolean.FALSE : getDisk().getReadOnly());
}
#method_after
protected void updateReadOnlyChangeability() {
    if (getVm() == null) {
        // read-only is a characteristic of a VM device, not a disk
        getIsReadOnly().setIsAvailable(false);
        getIsReadOnly().setEntity(false);
        getIsReadOnly().setIsChangeable(false);
        return;
    }
    DiskInterface diskInterface = getDiskInterface().getSelectedItem();
    if (diskInterface == DiskInterface.IDE) {
        getIsReadOnly().setChangeProhibitionReason(constants.cannotEnableIdeInterfaceForReadOnlyDisk());
        getIsReadOnly().setIsChangeable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    boolean isDirectLUN = getDiskStorageType().getEntity() == DiskStorageType.LUN;
    boolean isScsiPassthrough = getIsScsiPassthrough().getEntity();
    if (diskInterface == DiskInterface.VirtIO_SCSI && isDirectLUN && isScsiPassthrough) {
        getIsReadOnly().setChangeProhibitionReason(constants.cannotEnableReadonlyWhenScsiPassthroughEnabled());
        getIsReadOnly().setIsChangeable(false);
        getIsReadOnly().setEntity(false);
        return;
    }
    if (isVmAttachedToPool() && !getIsNew()) {
        getIsReadOnly().setIsChangeable(false);
    } else {
        getIsReadOnly().setIsChangeable(isEditEnabled());
    }
    getIsReadOnly().setEntity(getIsNew() ? Boolean.FALSE : getDisk().getReadOnly());
}
#end_block

#method_before
@Override
protected boolean validate() {
    VDS vds = getVds();
    if (vds == null) {
        addValidationMessage(EngineMessage.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.canUpdateField(vds, "clusterId", vds.getStatus())) {
        addValidationMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForCluster(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForCluster(getParameters().getClusterId()).isEmpty()) {
            addValidationMessage(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getCluster().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addValidationMessage(EngineMessage.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), targetClusterCompatibilityVersion));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failValidation(EngineMessage.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!(VDSStatus.PendingApproval == vds.getStatus() || isDetachedSourceCluster() || isSameManagementNetwork())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_CLUSTER_DIFFERENT_MANAGEMENT_NETWORKS);
    }
    if (FeatureSupported.hostNetworkQos(sourceClusterCompatibilityVersion) && !FeatureSupported.hostNetworkQos(targetClusterCompatibilityVersion)) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    VDS vds = getVds();
    if (vds == null) {
        addValidationMessage(EngineMessage.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.canUpdateField(vds, "clusterId", vds.getStatus())) {
        addValidationMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForCluster(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForCluster(getParameters().getClusterId()).isEmpty()) {
            addValidationMessage(EngineMessage.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getCluster().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addValidationMessage(EngineMessage.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), targetClusterCompatibilityVersion));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failValidation(EngineMessage.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!(VDSStatus.PendingApproval == vds.getStatus() || isDetachedSourceCluster() || isSameManagementNetwork())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_CLUSTER_DIFFERENT_MANAGEMENT_NETWORKS);
    }
    if (FeatureSupported.hostNetworkQos(sourceClusterCompatibilityVersion) && !FeatureSupported.hostNetworkQos(targetClusterCompatibilityVersion)) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(() -> {
        VdsStatic staticData = getVds().getStaticData();
        getCompensationContext().snapshotEntity(staticData);
        staticData.setClusterId(targetClusterId);
        DbFacade.getInstance().getVdsStaticDao().update(staticData);
        getCompensationContext().stateChanged();
        // remove the server from resource manager and add it back
        initializeVds();
        return null;
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDao().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), Collections.<NetworkAttachment>emptyList(), getTargetClusterNetworks());
    persister.persistNetworkAttachments();
    if (targetClusterSupportsSetupNetworks() && VDSStatus.PendingApproval != getVds().getStatus()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(() -> {
        VdsStatic staticData = getVds().getStaticData();
        getCompensationContext().snapshotEntity(staticData);
        staticData.setClusterId(targetClusterId);
        DbFacade.getInstance().getVdsStaticDao().update(staticData);
        getCompensationContext().stateChanged();
        // remove the server from resource manager and add it back
        initializeVds();
        return null;
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, cloneContext().withoutLock().withoutExecutionContext());
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDao().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    HostNetworkAttachmentsPersister persister = new HostNetworkAttachmentsPersister(this.networkAttachmentDao, getVdsId(), interfaceDao.getAllInterfacesForVds(getVdsId()), Collections.<NetworkAttachment>emptyList(), getTargetClusterNetworks());
    persister.persistNetworkAttachments();
    if (VDSStatus.PendingApproval != getVds().getStatus()) {
        configureNetworks();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics();
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getClusterId(), vm.getCpuProfileId());
        }
    });
}
#method_after
@Override
public void templateWithVersion_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    buildModel(vm.getStaticData(), new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
            getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
            updateCpuSharesSelection();
            updateRngDevice(getVm().getId());
            updateTimeZone(vm.getTimeZone());
            updateGraphics(vm.getId());
            getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
            // Storage domain and provisioning are not available for an existing VM.
            getModel().getStorageDomain().setIsChangeable(false);
            getModel().getProvisioning().setIsAvailable(false);
            getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
            getModel().getCpuPinning().setEntity(vm.getCpuPinning());
            getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
            if (isHotSetCpuSupported()) {
                // cancel related events while fetching data
                getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
                getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getThreadsPerCore().getSelectedItemChangedEvent().removeListener(getModel());
                getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
                AsyncDataProvider.getInstance().getHostById(new AsyncQuery(new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        runningOnHost = (VDS) returnValue;
                        hostCpu = calculateHostCpus();
                        updateNumOfSockets();
                    }
                }), vm.getRunOnVds());
            }
            updateCpuProfile(vm.getClusterId(), vm.getCpuProfileId());
        }
    });
}
#end_block

#method_before
public static Version getCompatibilityVersion(VmBase vmBase) {
    return vmBase.getClusterId() != null ? getInstance().getClusterDao().get(vmBase.getClusterId()).getCompatibilityVersion() : Version.v3_6;
}
#method_after
public static Version getCompatibilityVersion(VmBase vmBase) {
    return vmBase.getClusterId() != null ? getInstance().getClusterDao().get(vmBase.getClusterId()).getCompatibilityVersion() : Version.v3_5;
}
#end_block

#method_before
public Set<EngineError> getExpectedEngineErrors() {
    return expectedEngineErrors.orElse(Collections.EMPTY_SET);
}
#method_after
public Set<EngineError> getExpectedEngineErrors() {
    return expectedEngineErrors.orElse(Collections.<EngineError>emptySet());
}
#end_block

#method_before
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return tsb.append("runAsync", runAsync);
}
#method_after
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    if (!getExpectedEngineErrors().isEmpty()) {
        tsb.append("expectedEngineErrors", getExpectedEngineErrors());
    }
    return tsb.append("runAsync", runAsync);
}
#end_block

#method_before
protected void proceedProxyReturnValue() {
    EngineError returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().message);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().message);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().message);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().message);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
        case V2V_JOB_DOESNT_EXIST:
        case V2V_NO_SUCH_OVF:
        case V2V_JOB_NOT_DONE:
        case V2V_JOB_ALREADY_EXIST:
        case UnsupportedGlusterVolumeReplicaCountError:
            if (this instanceof IrsBrokerCommand || this instanceof StorageDomainMetadataCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().message);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().message));
            }
            break;
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().message);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().message);
    outEx.setVdsError(tempVar);
    logToAudit();
    throw outEx;
}
#method_after
protected void proceedProxyReturnValue() {
    EngineError returnStatus = getReturnValueFromStatus(getReturnStatus());
    VDSExceptionBase outEx;
    switch(returnStatus) {
        case Done:
            return;
        case recovery:
            outEx = new VDSRecoveringException(returnStatus, getReturnStatus().message);
            break;
        case SpmStatusError:
            outEx = new IRSNonOperationalException(getReturnStatus().message);
            break;
        case StoragePoolMasterNotFound:
        case StoragePoolTooManyMasters:
        case StoragePoolWrongMaster:
        case StoragePoolHasPotentialMaster:
        case StorageDomainMasterError:
            outEx = new IRSNoMasterDomainException(getReturnStatus().message);
            break;
        case UnicodeArgumentException:
            outEx = new IRSUnicodeArgumentException(getReturnStatus().message);
            break;
        case TooManyDomainsInStoragePoolError:
        case StorageDomainAlreadyAttached:
        case StorageDomainDescriptionTooLongError:
        case TooManyPVsInVG:
        case createIllegalVolumeSnapshotError:
        case prepareIllegalVolumeError:
        case createVolumeRollbackError:
        case InvalidParameterException:
        case InvalidDefaultExceptionException:
        case NotImplementedException:
        case OperationInProgress:
        case MiscDirCleanupFailure:
        case createVolumeSizeError:
        case IncorrectFormat:
        case VolumeIsBusy:
        case VolumeImageHasChildren:
        case VolumeUnlinkError:
        case OrphanVolumeError:
        case VolumeAlreadyExists:
        case VolumeNonWritable:
        case VolumeNonShareable:
        case VolumeCannotGetParent:
        case SharedVolumeNonWritable:
        case InternalVolumeNonWritable:
        case CannotDeleteSharedVolume:
        case NonLeafVolumeNotWritable:
        case ImagesActionError:
        case ImageValidationError:
        case ImageDeleteError:
        case ImageIsNotEmpty:
        case ImageIsNotLegalChain:
        case OverwriteImageError:
        case MoveTemplateImageError:
        case StoragePoolDisconnectionError:
        case StoragePoolAlreadyExists:
        case IsoCannotBeMasterDomain:
        case CannotConnectMultiplePools:
        case BackupCannotBeMasterDomain:
        case StoragePoolConnected:
        case StoragePoolDescriptionTooLongError:
        case StorageDomainNotInPool:
        case StorageDomainNotEmpty:
        case StorageDomainMetadataCreationError:
        case StorageDomainMetadataFileMissing:
        case StorageDomainMetadataNotFound:
        case StorageDomainAlreadyExists:
        case StorageDomainMasterUnmountError:
        case BlockStorageDomainMasterFSCKError:
        case StorageDomainLayoutError:
        case StorageDomainTypeError:
        case StorageDomainNotMemberOfPool:
        case StorageDomainStatusError:
        case StorageDomainCheckError:
        case StorageDomainTypeNotBackup:
        case StorageDomainStateTransitionIllegal:
        case StorageDomainActive:
        case CannotDetachMasterStorageDomain:
        case StorageDomainInsufficientPermissions:
        case StorageDomainClassError:
        case StorageDomainIsMadeFromTooManyPVs:
        case InvalidTask:
        case UnknownTask:
        case TaskClearError:
        case TaskNotFinished:
        case InvalidTaskType:
        case AddTaskError:
        case TaskInProgress:
        case TaskStateError:
        case TaskAborted:
        case TaskPersistError:
        case InvalidJob:
        case InvalidRecovery:
        case InvalidTaskMng:
        case TaskStateTransitionError:
        case TaskHasRefs:
        case VolumeGroupSizeError:
        case VolumeGroupAlreadyExistsError:
        case VolumeGroupUninitialized:
        case VolumeGroupHasDomainTag:
        case CannotRemoveLogicalVolume:
        case CannotDeactivateLogicalVolume:
        case CannotActivateLogicalVolume:
        case LogicalVolumePermissionsError:
        case LogicalVolumeAlreadyExists:
        case PartitionedPhysDev:
        case DomainAlreadyLocked:
        case DomainLockDoesNotExist:
        case MetaDataKeyError:
        case MetaDataSealIsBroken:
        case MetaDataValidationError:
        case MetaDataMappingError:
        case MetaDataParamError:
        case MetadataOverflowError:
        case ImportUnknownType:
        case ExportError:
        case MergeVolumeRollbackError:
        case ActionStopped:
        case FAILED_CHANGE_CD_IS_MOUNTED:
        case UnsupportedDomainVersion:
        case CurrentVersionTooAdvancedError:
        case iSCSILogoutError:
        case iSCSIDiscoveryError:
        case ISCSI_LOGIN_AUTH_ERROR:
        case PoolUpgradeInProgress:
        case MixedSDVersionError:
        case NoSpaceLeftOnDomain:
        case ImageDoesNotExistInDomainError:
        case NO_IMPLEMENTATION:
        case VOLUME_WAS_NOT_PREPARED_BEFORE_TEARDOWN:
        case IMAGES_NOT_SUPPORTED_ERROR:
        case GET_FILE_LIST_ERROR:
        case STORAGE_DOMAIN_REFRESH_ERROR:
        case VOLUME_GROUP_BLOCK_SIZE_ERROR:
        case MIGRATION_DEST_INVALID_HOSTNAME:
        case ResourceTimeout:
        case HOT_PLUG_UNPLUG_CPU_ERROR:
        case DEVICE_BLOCK_SIZE_NOT_SUPPORTED:
        case V2V_JOB_DOESNT_EXIST:
        case V2V_NO_SUCH_OVF:
        case V2V_JOB_NOT_DONE:
        case V2V_JOB_ALREADY_EXIST:
        case UnsupportedGlusterVolumeReplicaCountError:
            if (this instanceof IrsBrokerCommand || this instanceof StorageDomainMetadataCommand) {
                outEx = new IrsOperationFailedNoFailoverException(getReturnStatus().message);
            } else {
                outEx = new VDSErrorException(String.format("Failed in vdscommand to %1$s, error = %2$s", getCommandName(), getReturnStatus().message));
            }
            break;
        case VDS_NETWORK_ERROR:
        case ERR_BAD_ADDR:
            outEx = new VDSNetworkException(getReturnStatus().message);
            break;
        default:
            log.error("Failed in '{}' method", getCommandName());
            outEx = createException();
            break;
    }
    VDSError tempVar = new VDSError();
    tempVar.setCode(returnStatus);
    tempVar.setMessage(getReturnStatus().message);
    outEx.setVdsError(tempVar);
    logToAuditIfNeeded();
    throw outEx;
}
#end_block

#method_before
protected void logToAudit() {
    // if error is in expected errors list, don't audit log it
    if (getParameters().getExpectedEngineErrors().contains(getReturnValueFromStatus(getReturnStatus()))) {
        return;
    }
}
#method_after
protected void logToAudit() {
}
#end_block

#method_before
public static String getRedirectUriServerName(String name) {
    try {
        if (InetAddress.getByName(name) instanceof Inet6Address) {
            name = String.format("[%s]", name);
        }
    } catch (UnknownHostException ex) {
        log.error("Error getting redirect uri server name, unknown hostname : %s", name);
        log.debug("Exception", ex);
    }
    return name;
}
#method_after
public static String getRedirectUriServerName(String name) {
    return InetAddressUtils.isIPv6Address(name) ? String.format("[%s]", name) : name;
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase result;
    // If non-monitored command is invoked with JobId or ActionId as parameters, reject this command on can do action.
    if (!actionType.isActionMonitored() && !isActionExternal(actionType) && (parameters.getJobId() != null || parameters.getStepId() != null)) {
        result = new VdcReturnValueBase();
        result.getValidationMessages().add(EngineMessage.ACTION_TYPE_NON_MONITORED.toString());
        result.setValid(false);
        result.setSucceeded(false);
    } else {
        if (!runAsInternal) {
            logExecution(parameters.getSessionId(), String.format("command %s", actionType), parameters.toString());
        }
        CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, context);
        result = runAction(command, runAsInternal);
    }
    return result;
}
#method_after
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase result;
    // If non-monitored command is invoked with JobId or ActionId as parameters, reject this command on can do action.
    if (!actionType.isActionMonitored() && !isActionExternal(actionType) && (parameters.getJobId() != null || parameters.getStepId() != null)) {
        result = new VdcReturnValueBase();
        result.getValidationMessages().add(EngineMessage.ACTION_TYPE_NON_MONITORED.toString());
        result.setValid(false);
        result.setSucceeded(false);
    } else {
        if (!runAsInternal) {
            logExecution(parameters.getSessionId(), String.format("command %s", actionType));
        }
        CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, context);
        result = runAction(command, runAsInternal);
    }
    return result;
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            log.debug("Unable to execute query {} as no user session was found", actionType);
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
        logExecution(sessionId, String.format("query %s", actionType), parameters.toString());
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = dbFacade.getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck, EngineContext engineContext) {
    if (isPerformUserCheck) {
        String sessionId = parameters.getSessionId();
        if (StringUtils.isEmpty(sessionId) || sessionDataContainer.getUser(sessionId, parameters.getRefresh()) == null) {
            log.debug("Unable to execute query {} as no user session was found", actionType);
            return getErrorQueryReturnValue(EngineMessage.USER_IS_NOT_LOGGED_IN);
        }
        logExecution(sessionId, String.format("query %s with isFiltered : %s", actionType, parameters.isFiltered()));
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = dbFacade.getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion).getOptionValue();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(EngineMessage.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters, engineContext);
    command.setInternalExecution(!isPerformUserCheck);
    command.execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
private void logExecution(String sessionId, String queryOrAction, String parameters) {
    DbUser user = sessionDataContainer.getUser(sessionId, false);
    log.debug("Executing {} with parameters {}{}", queryOrAction, parameters, user == null ? "." : String.format(" for user %s@%s.", user.getLoginName(), user.getDomain()));
}
#method_after
private void logExecution(String sessionId, String details) {
    DbUser user = sessionDataContainer.getUser(sessionId, false);
    log.debug("Executing {}{}", details, user == null ? "." : String.format(" for user %s@%s.", user.getLoginName(), user.getDomain()));
}
#end_block

#method_before
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = DbFacade.getInstance().getAsyncTaskDao().getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled() && x.getCommandStatus() == CommandStatus.ACTIVE && !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
}
#method_after
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
}
#end_block

#method_before
private static MetaData loadMetaData() throws IOException {
    // Load the metadata file:
    InputStream stream = RsdlManager.class.getResourceAsStream(METADATA_FILE_NAME);
    if (stream == null) {
        throw new IOException("Can't find metadata resource \"" + METADATA_FILE_NAME + "\"");
    }
    MetaData metaData;
    try {
        Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
        metaData = (MetaData) new Yaml(constructor).load(stream);
        if (metaData == null) {
            throw new IOException("Can't load metadata file \"" + METADATA_FILE_NAME + "\"");
        }
    } finally {
        stream.close();
    }
    // Make sure that the loaded metadata contains default values:
    assignDefaults(metaData);
    // Remove leading slashes from all the action names:
    for (Action action : metaData.getActions()) {
        String name = action.getName();
        name = name.replaceAll("^/?", "");
        action.setName(name);
    }
    return metaData;
}
#method_after
private static MetaData loadMetaData() throws IOException {
    try (InputStream in = RsdlManager.class.getResourceAsStream(METADATA_FILE_NAME)) {
        if (in == null) {
            throw new IOException("Can't find metadata from resource \"" + METADATA_FILE_NAME + "\"");
        }
        return loadMetaData(in);
    }
}
#end_block

#method_before
private static MetaData loadMetaData() throws IOException {
    // Load the metadata file:
    InputStream stream = RsdlManager.class.getResourceAsStream(METADATA_FILE_NAME);
    if (stream == null) {
        throw new IOException("Can't find metadata resource \"" + METADATA_FILE_NAME + "\"");
    }
    MetaData metaData;
    try {
        Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
        metaData = (MetaData) new Yaml(constructor).load(stream);
        if (metaData == null) {
            throw new IOException("Can't load metadata file \"" + METADATA_FILE_NAME + "\"");
        }
    } finally {
        stream.close();
    }
    // Make sure that the loaded metadata contains default values:
    assignDefaults(metaData);
    // Remove leading slashes from all the action names:
    for (Action action : metaData.getActions()) {
        String name = action.getName();
        name = name.replaceAll("^/?", "");
        action.setName(name);
    }
    return metaData;
}
#method_after
private static MetaData loadMetaData(InputStream in) throws IOException {
    Constructor constructor = new CustomClassLoaderConstructor(Thread.currentThread().getContextClassLoader());
    MetaData metaData = (MetaData) new Yaml(constructor).load(in);
    if (metaData == null) {
        throw new IOException("Can't load metadata from input stream");
    }
    // Make sure that the loaded metadata contains default values:
    assignDefaults(metaData);
    // Remove leading slashes from all the action names:
    for (Action action : metaData.getActions()) {
        String name = action.getName();
        name = name.replaceAll("^/?", "");
        action.setName(name);
    }
    return metaData;
}
#end_block

#method_before
private static List<ExtMap> queryDirectoryGroups(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    List<ExtMap> directoryGroups = new ArrayList<>();
    for (ExtMap group : queryGroupRecords(extension, namespace, filter, groupsResolving, groupsResolvingRecursive)) {
        directoryGroups.add(group);
    }
    return directoryGroups;
}
#method_after
private static List<ExtMap> queryDirectoryGroups(final ExtensionProxy extension, final String namespace, final ExtMap filter, boolean groupsResolving, boolean groupsResolvingRecursive) {
    return queryGroupRecords(extension, namespace, filter, groupsResolving, groupsResolvingRecursive).stream().collect(Collectors.toList());
}
#end_block

#method_before
private static Collection<ExtMap> populateRecords(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final Collection<ExtMap> records = new ArrayList<>();
    queryImpl(extension, namespace, input, new QueryResultHandler() {

        @Override
        public boolean handle(Collection<ExtMap> queryResults) {
            boolean result = true;
            for (ExtMap queryResult : queryResults) {
                if (records.size() < QUERIES_RESULTS_LIMIT) {
                    records.add(queryResult);
                } else {
                    result = false;
                    break;
                }
            }
            return result;
        }
    });
    return records;
}
#method_after
private static Collection<ExtMap> populateRecords(final ExtensionProxy extension, final String namespace, final ExtMap input) {
    final List<ExtMap> records = new ArrayList<>();
    queryImpl(extension, namespace, input, (queryResults) -> {
        boolean result = true;
        for (ExtMap queryResult : queryResults) {
            if (records.size() < QUERIES_RESULTS_LIMIT) {
                records.add(queryResult);
            } else {
                result = false;
                break;
            }
        }
        return result;
    });
    return records;
}
#end_block

#method_before
public static ExtMap generateQueryMap(Collection<String> ids, ExtUUID queryEntity) {
    ExtMap result = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, queryEntity);
    ExtKey key = queryEntity.equals(Authz.QueryEntity.GROUP) ? Authz.GroupRecord.ID : Authz.PrincipalRecord.ID;
    List<ExtMap> filter = new ArrayList<>();
    for (String id : ids) {
        filter.add(createMapForKeyAndValue(key, id));
    }
    result.mput(QueryFilterRecord.OPERATOR, QueryFilterOperator.OR).mput(QueryFilterRecord.FILTER, filter);
    return result;
}
#method_after
public static ExtMap generateQueryMap(Collection<String> ids, ExtUUID queryEntity) {
    ExtMap result = new ExtMap().mput(Authz.InvokeKeys.QUERY_ENTITY, queryEntity);
    ExtKey key = queryEntity.equals(Authz.QueryEntity.GROUP) ? Authz.GroupRecord.ID : Authz.PrincipalRecord.ID;
    List<ExtMap> filter = ids.stream().map((id) -> createMapForKeyAndValue(key, id)).collect(Collectors.toList());
    result.mput(QueryFilterRecord.OPERATOR, QueryFilterOperator.OR).mput(QueryFilterRecord.FILTER, filter);
    return result;
}
#end_block

#method_before
public static ExtMap generateQueryForName(String name, ExtUUID queryEntity) {
    StringBuilder query = new StringBuilder(getQueryPrefixByEntity(queryEntity)).append("|");
    for (String key : attributesToKeys.keySet()) {
        query.append(String.format("(%1$s=%2$s)", key, name));
    }
    return generateQueryMap(query.append(")").toString(), queryEntity);
}
#method_after
public static ExtMap generateQueryForName(String name, ExtUUID queryEntity) {
    StringBuilder query = new StringBuilder(getQueryPrefixByEntity(queryEntity)).append("|");
    attributesToKeys.keySet().forEach((key) -> query.append(String.format("(%1$s=%2$s)", key, name)));
    return generateQueryMap(query.append(")").toString(), queryEntity);
}
#end_block

#method_before
public static void redirectToModule(HttpServletRequest request, HttpServletResponse response) throws IOException {
    log.debug("Entered redirectToModule");
    try {
        SSOSession ssoSession = getSsoSession(request);
        URLBuilder redirectUrl = new URLBuilder(getRedirectUrl(request).toString()).addParameter("code", ssoSession.getAuthorizationCode());
        String state = ssoSession.getState();
        if (StringUtils.isNotEmpty(state)) {
            redirectUrl.addParameter("state", state);
        }
        response.sendRedirect(redirectUrl.build());
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception ex) {
        log.error("Error redirecting back to module: {}", ex.getMessage());
        log.debug("Error redirecting back to module", ex);
        throw new RuntimeException(ex);
    } finally {
        SSOUtils.getSsoSession(request).cleanup();
    }
}
#method_after
public static void redirectToModule(HttpServletRequest request, HttpServletResponse response) throws IOException {
    log.debug("Entered redirectToModule");
    try {
        SSOSession ssoSession = getSsoSession(request);
        URLBuilder redirectUrl = new URLBuilder(getRedirectUrl(request).toString()).addParameter("code", ssoSession.getAuthorizationCode());
        String state = ssoSession.getState();
        if (StringUtils.isNotEmpty(state)) {
            redirectUrl.addParameter("state", state);
        }
        response.sendRedirect(redirectUrl.build());
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception ex) {
        log.error("Error redirecting back to module: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new RuntimeException(ex);
    } finally {
        SSOUtils.getSsoSession(request).cleanup();
    }
}
#end_block

#method_before
public static void redirectToErrorPage(HttpServletRequest request, HttpServletResponse response, Exception ex) {
    log.error(ex.getMessage());
    log.debug("Exception in OAuthAuthorizeServlet:", ex);
    redirectToErrorPageImpl(request, response, new OAuthException(SSOConstants.ERR_CODE_SERVER_ERROR, ex.getMessage(), ex));
}
#method_after
public static void redirectToErrorPage(HttpServletRequest request, HttpServletResponse response, Exception ex) {
    log.error(ex.getMessage());
    log.debug("Exception", ex);
    redirectToErrorPageImpl(request, response, new OAuthException(SSOConstants.ERR_CODE_SERVER_ERROR, ex.getMessage(), ex));
}
#end_block

#method_before
public static void redirectToErrorPage(HttpServletRequest request, HttpServletResponse response, OAuthException ex) {
    log.error("OAuthException {}: {}", ex.getCode(), ex.getMessage());
    log.debug("OAuthException:", ex);
    redirectToErrorPageImpl(request, response, ex);
}
#method_after
public static void redirectToErrorPage(HttpServletRequest request, HttpServletResponse response, OAuthException ex) {
    log.error("OAuthException {}: {}", ex.getCode(), ex.getMessage());
    log.debug("Exception", ex);
    redirectToErrorPageImpl(request, response, ex);
}
#end_block

#method_before
private static void redirectToErrorPageImpl(HttpServletRequest request, HttpServletResponse response, OAuthException ex) {
    log.debug("Entered redirectToErrorPage");
    SSOSession ssoSession = null;
    try {
        ssoSession = SSOUtils.getSsoSession(request, true);
        if (ssoSession.getStatus() != SSOSession.Status.authenticated) {
            ssoSession.setStatus(SSOSession.Status.unauthenticated);
        }
        String redirectUrl = new URLBuilder(getRedirectUrl(request)).addParameter("error_code", ex.getCode()).addParameter("error", ex.getMessage()).build();
        response.sendRedirect(redirectUrl);
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception e) {
        log.error("Error redirecting to error page: {}", e.getMessage());
        log.debug("Error redirecting to error page", e);
        throw new RuntimeException(ex);
    } finally {
        if (ssoSession != null) {
            ssoSession.cleanup();
        }
    }
}
#method_after
private static void redirectToErrorPageImpl(HttpServletRequest request, HttpServletResponse response, OAuthException ex) {
    log.debug("Entered redirectToErrorPage");
    SSOSession ssoSession = null;
    try {
        ssoSession = SSOUtils.getSsoSession(request, true);
        if (ssoSession.getStatus() != SSOSession.Status.authenticated) {
            ssoSession.setStatus(SSOSession.Status.unauthenticated);
        }
        String redirectUrl = new URLBuilder(getRedirectUrl(request)).addParameter("error_code", ex.getCode()).addParameter("error", ex.getMessage()).build();
        response.sendRedirect(redirectUrl);
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception e) {
        log.error("Error redirecting to error page: {}", e.getMessage());
        log.debug("Exception", e);
        throw new RuntimeException(ex);
    } finally {
        if (ssoSession != null) {
            ssoSession.cleanup();
        }
    }
}
#end_block

#method_before
public static String getParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : URLDecoder.decode(new String(value.getBytes("iso-8859-1")), StandardCharsets.UTF_8.name());
}
#method_after
public static String getParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : decode(new String(value.getBytes("iso-8859-1")));
}
#end_block

#method_before
public static String getRequestParameter(HttpServletRequest request, String paramName) throws Exception {
    String value = getParameter(request, paramName);
    if (value == null) {
        throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(SSOConstants.ERR_CODE_INVALID_REQUEST_MSG, paramName));
    }
    return URLDecoder.decode(value, StandardCharsets.UTF_8.name());
}
#method_after
public static String getRequestParameter(HttpServletRequest request, String paramName) throws Exception {
    String value = getParameter(request, paramName);
    if (value == null) {
        throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(SSOConstants.ERR_CODE_INVALID_REQUEST_MSG, paramName));
    }
    return value;
}
#end_block

#method_before
public static void persistUserPassword(HttpServletRequest request, SSOSession ssoSession, String password) {
    try {
        if (ssoSession.getScopeAsList().contains("ovirt-ext=token:password-access") && password != null && StringUtils.isNotEmpty(ssoSession.getClientId())) {
            ssoSession.setPassword(encrypt(request.getServletContext(), ssoSession.getClientId(), password));
        }
    } catch (Exception ex) {
        log.error("Unable to encrypt password: {}", ex.getMessage());
        log.debug("Unable to encrypt password", ex);
    }
}
#method_after
public static void persistUserPassword(HttpServletRequest request, SSOSession ssoSession, String password) {
    try {
        if (ssoSession.getScopeAsList().contains("ovirt-ext=token:password-access") && password != null && StringUtils.isNotEmpty(ssoSession.getClientId())) {
            ssoSession.setPassword(encrypt(request.getServletContext(), ssoSession.getClientId(), password));
        }
    } catch (Exception ex) {
        log.error("Unable to encrypt password: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
}
#end_block

#method_before
public static SSOSession persistAuthInfoInContextWithToken(HttpServletRequest request, String password, String profileName, ExtMap authRecord, ExtMap principalRecord) throws Exception {
    String validTo = authRecord.get(Authn.AuthRecord.VALID_TO);
    String authCode = generateAuthorizationToken();
    String accessToken = generateAuthorizationToken();
    SSOSession ssoSession = getSsoSession(request, true);
    ssoSession.setAccessToken(accessToken);
    ssoSession.setAuthorizationCode(authCode);
    request.setAttribute(SSOConstants.HTTP_REQ_ATTR_ACCESS_TOKEN, accessToken);
    ssoSession.setActive(true);
    ssoSession.setAuthRecord(authRecord);
    ssoSession.setAutheticatedCredentials(ssoSession.getTempCredentials());
    getSsoContext(request).registerSsoSession(ssoSession);
    ssoSession.setPrincipalRecord(principalRecord);
    ssoSession.setProfile(profileName);
    ssoSession.setStatus(SSOSession.Status.authenticated);
    ssoSession.setTempCredentials(null);
    ssoSession.setUserId(getUserId(principalRecord));
    try {
        ssoSession.setValidTo(validTo == null ? Integer.MAX_VALUE : (int) new SimpleDateFormat("yyyyMMddHHmmssZ").parse(validTo).getTime());
    } catch (Exception ex) {
        log.error("Unable to parse Auth Record valid_to value: {}", ex.getMessage());
        log.debug("Unable to parse Auth Record valid_to value", ex);
    }
    persistUserPassword(request, ssoSession, password);
    ssoSession.touch();
    return ssoSession;
}
#method_after
public static SSOSession persistAuthInfoInContextWithToken(HttpServletRequest request, String password, String profileName, ExtMap authRecord, ExtMap principalRecord) throws Exception {
    String validTo = authRecord.get(Authn.AuthRecord.VALID_TO);
    String authCode = generateAuthorizationToken();
    String accessToken = generateAuthorizationToken();
    SSOSession ssoSession = getSsoSession(request, true);
    ssoSession.setAccessToken(accessToken);
    ssoSession.setAuthorizationCode(authCode);
    request.setAttribute(SSOConstants.HTTP_REQ_ATTR_ACCESS_TOKEN, accessToken);
    ssoSession.setActive(true);
    ssoSession.setAuthRecord(authRecord);
    ssoSession.setAutheticatedCredentials(ssoSession.getTempCredentials());
    getSsoContext(request).registerSsoSession(ssoSession);
    ssoSession.setPrincipalRecord(principalRecord);
    ssoSession.setProfile(profileName);
    ssoSession.setStatus(SSOSession.Status.authenticated);
    ssoSession.setTempCredentials(null);
    ssoSession.setUserId(getUserId(principalRecord));
    try {
        ssoSession.setValidTo(validTo == null ? Integer.MAX_VALUE : (int) new SimpleDateFormat("yyyyMMddHHmmssZ").parse(validTo).getTime());
    } catch (Exception ex) {
        log.error("Unable to parse Auth Record valid_to value: {}", ex.getMessage());
        log.debug("Exception", ex);
    }
    persistUserPassword(request, ssoSession, password);
    ssoSession.touch();
    return ssoSession;
}
#end_block

#method_before
public static void validateClientRequest(HttpServletRequest request, String clientId, String clientSecret, String scope, String redirectUri) {
    try {
        SSOContext ssoContext = getSsoContext(request);
        ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
        if (clientInfo == null) {
            throw new OAuthException(SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT, SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT_MSG);
        }
        if (!clientInfo.isTrusted()) {
            throw new OAuthException(SSOConstants.ERR_CODE_ACCESS_DENIED, SSOConstants.ERR_CODE_ACCESS_DENIED_MSG);
        }
        if (StringUtils.isNotEmpty(clientSecret) && !EnvelopePBE.check(clientInfo.getClientSecret(), clientSecret)) {
            throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(SSOConstants.ERR_CODE_INVALID_REQUEST_MSG, SSOConstants.HTTP_PARAM_CLIENT_SECRET));
        }
        if (StringUtils.isNotEmpty(scope)) {
            validateScope(clientInfo.getScope(), scope);
        }
        if (StringUtils.isNotEmpty(redirectUri) && ssoContext.getSsoLocalConfig().getBoolean("SSO_CALLBACK_PREFIX_CHECK")) {
            List<String> allowedPrefixes = scopeAsList(clientInfo.getCallbackPrefix());
            boolean isValidUri = false;
            for (String allowedPrefix : allowedPrefixes) {
                if (redirectUri.startsWith(allowedPrefix)) {
                    isValidUri = true;
                    break;
                }
            }
            if (!isValidUri) {
                throw new OAuthException(SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT, SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT_MSG);
            }
        }
    } catch (OAuthException ex) {
        throw ex;
    } catch (Exception ex) {
        log.error("Internal Server Error: {}", ex.getMessage());
        log.debug("Internal Server Error", ex);
        throw new OAuthException(SSOConstants.ERR_CODE_SERVER_ERROR, ex.getMessage());
    }
}
#method_after
public static void validateClientRequest(HttpServletRequest request, String clientId, String clientSecret, String scope, String redirectUri) {
    try {
        SSOContext ssoContext = getSsoContext(request);
        ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
        if (clientInfo == null) {
            throw new OAuthException(SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT, SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT_MSG);
        }
        if (!clientInfo.isTrusted()) {
            throw new OAuthException(SSOConstants.ERR_CODE_ACCESS_DENIED, SSOConstants.ERR_CODE_ACCESS_DENIED_MSG);
        }
        if (StringUtils.isNotEmpty(clientSecret) && !EnvelopePBE.check(clientInfo.getClientSecret(), clientSecret)) {
            throw new OAuthException(SSOConstants.ERR_CODE_INVALID_REQUEST, String.format(SSOConstants.ERR_CODE_INVALID_REQUEST_MSG, SSOConstants.HTTP_PARAM_CLIENT_SECRET));
        }
        if (StringUtils.isNotEmpty(scope)) {
            validateScope(clientInfo.getScope(), scope);
        }
        if (StringUtils.isNotEmpty(redirectUri) && ssoContext.getSsoLocalConfig().getBoolean("SSO_CALLBACK_PREFIX_CHECK")) {
            List<String> allowedPrefixes = scopeAsList(clientInfo.getCallbackPrefix());
            boolean isValidUri = false;
            for (String allowedPrefix : allowedPrefixes) {
                if (redirectUri.startsWith(allowedPrefix)) {
                    isValidUri = true;
                    break;
                }
            }
            if (!isValidUri) {
                throw new OAuthException(SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT, SSOConstants.ERR_CODE_UNAUTHORIZED_CLIENT_MSG);
            }
        }
    } catch (OAuthException ex) {
        throw ex;
    } catch (Exception ex) {
        log.error("Internal Server Error: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new OAuthException(SSOConstants.ERR_CODE_SERVER_ERROR, ex.getMessage());
    }
}
#end_block

#method_before
public static void sendJsonDataWithMessage(HttpServletResponse response, OAuthException ex, boolean isValidateRequest) throws IOException {
    if (isValidateRequest) {
        log.debug("OAuthException {}: {}", ex.getCode(), ex.getMessage());
    } else {
        log.error("OAuthException {}: {}", ex.getCode(), ex.getMessage());
    }
    log.debug("OAuthException:", ex);
    Map<String, Object> errorData = new HashMap<>();
    errorData.put(SSOConstants.ERROR_CODE, ex.getCode());
    errorData.put(SSOConstants.ERROR, ex.getMessage());
    sendJsonData(response, errorData);
}
#method_after
public static void sendJsonDataWithMessage(HttpServletResponse response, OAuthException ex, boolean isValidateRequest) throws IOException {
    if (isValidateRequest) {
        log.debug("OAuthException {}: {}", ex.getCode(), ex.getMessage());
    } else {
        log.error("OAuthException {}: {}", ex.getCode(), ex.getMessage());
    }
    log.debug("Exception", ex);
    Map<String, Object> errorData = new HashMap<>();
    errorData.put(SSOConstants.ERROR_CODE, ex.getCode());
    errorData.put(SSOConstants.ERROR, ex.getMessage());
    sendJsonData(response, errorData);
}
#end_block

#method_before
public static Map<String, Object> searchUsers(String token, QueryData queryData) {
    return searchImpl(token, queryData, "users");
}
#method_after
public static Map<String, Object> searchUsers(String token, Map<String, Object> params) {
    return search(token, params, "users", authzSearchScope);
}
#end_block

#method_before
public static Map<String, Object> searchGroups(String token, QueryData queryData) {
    return searchImpl(token, queryData, "groups");
}
#method_after
public static Map<String, Object> searchGroups(String token, Map<String, Object> params) {
    return search(token, params, "groups", authzSearchScope);
}
#end_block

#method_before
private static Map getData(HttpURLConnection connection) throws Exception {
    try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        try (InputStream input = connection.getInputStream()) {
            FiltersHelper.copy(input, os);
        }
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(SSOOAuthServiceUtils.class.getClassLoader());
        try {
            log.info(new String(os.toByteArray(), StandardCharsets.UTF_8.name()));
            return new JsonObjectDeserializer().deserialize(new String(os.toByteArray(), StandardCharsets.UTF_8.name()), HashMap.class);
        } finally {
            Thread.currentThread().setContextClassLoader(loader);
        }
    }
}
#method_after
private static Map getData(HttpURLConnection connection) throws Exception {
    try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        try (InputStream input = connection.getInputStream()) {
            FiltersHelper.copy(input, os);
        }
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(SSOOAuthServiceUtils.class.getClassLoader());
        try {
            return new JsonObjectDeserializer().deserialize(new String(os.toByteArray(), StandardCharsets.UTF_8.name()), HashMap.class);
        } finally {
            Thread.currentThread().setContextClassLoader(loader);
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            {
                returnValue = searchVmsFromDb();
                break;
            }
        case DirectoryGroup:
            {
                returnValue = searchDirectoryGroups();
                break;
            }
        case DirectoryUser:
            {
                returnValue = searchDirectoryUsers();
                break;
            }
        case AuditLog:
            {
                returnValue = searchAuditLogEvents();
                break;
            }
        case DBUser:
            {
                returnValue = searchDbUsers();
                break;
            }
        case DBGroup:
            {
                returnValue = searchDbGroups();
                break;
            }
        case VDS:
            {
                returnValue = searchVDSsByDb();
                break;
            }
        case VmTemplate:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case VmPools:
            {
                returnValue = searchVmPools();
                break;
            }
        case Cluster:
            {
                returnValue = searchClusters();
                break;
            }
        case StoragePool:
            {
                returnValue = searchStoragePool();
                break;
            }
        case StorageDomain:
            {
                returnValue = searchStorageDomain();
                break;
            }
        case Quota:
            {
                returnValue = searchQuota();
                break;
            }
        case Disk:
            {
                returnValue = searchDisk();
                break;
            }
        case GlusterVolume:
            {
                returnValue = searchGlusterVolumes();
                break;
            }
        case Network:
            {
                returnValue = searchNetworks();
                break;
            }
        case Provider:
            {
                returnValue = searchProviders();
                break;
            }
        case InstanceType:
            {
                returnValue = searchInstanceTypes();
                break;
            }
        case ImageType:
            {
                returnValue = searchVMTemplates();
                break;
            }
        case Session:
            returnValue = searchSessions();
            break;
        default:
            {
                log.error("Search object type not handled: {}", getParameters().getSearchTypeValue());
                break;
            }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<? extends IVdcQueryable> returnValue = new ArrayList<>();
    switch(getParameters().getSearchTypeValue()) {
        case VM:
            returnValue = searchVmsFromDb();
            break;
        case DirectoryGroup:
            returnValue = searchDirectoryGroups();
            break;
        case DirectoryUser:
            returnValue = searchDirectoryUsers();
            break;
        case AuditLog:
            returnValue = searchAuditLogEvents();
            break;
        case DBUser:
            returnValue = searchDbUsers();
            break;
        case DBGroup:
            returnValue = searchDbGroups();
            break;
        case VDS:
            returnValue = searchVDSsByDb();
            break;
        case VmTemplate:
            returnValue = searchVMTemplates();
            break;
        case VmPools:
            returnValue = searchVmPools();
            break;
        case Cluster:
            returnValue = searchClusters();
            break;
        case StoragePool:
            returnValue = searchStoragePool();
            break;
        case StorageDomain:
            returnValue = searchStorageDomain();
            break;
        case Quota:
            returnValue = searchQuota();
            break;
        case Disk:
            returnValue = searchDisk();
            break;
        case GlusterVolume:
            returnValue = searchGlusterVolumes();
            break;
        case Network:
            returnValue = searchNetworks();
            break;
        case Provider:
            returnValue = searchProviders();
            break;
        case InstanceType:
            returnValue = searchInstanceTypes();
            break;
        case ImageType:
            returnValue = searchVMTemplates();
            break;
        case Session:
            returnValue = searchSessions();
            break;
        default:
            log.error("Search object type not handled: {}", getParameters().getSearchTypeValue());
            break;
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
private List<VDS> searchVDSsByDb() {
    List<VDS> data = genericSearch(getDbFacade().getVdsDao(), true);
    for (VDS vds : data) {
        vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), vds.getVdsGroupCompatibilityVersion()));
    }
    return data;
}
#method_after
private List<VDS> searchVDSsByDb() {
    List<VDS> data = genericSearch(getDbFacade().getVdsDao(), true);
    for (VDS vds : data) {
        vds.setCpuName(getCpuFlagsManagerHandler().findMaxServerCpuByFlags(vds.getCpuFlags(), vds.getClusterCompatibilityVersion()));
    }
    return data;
}
#end_block

#method_before
private List<DirectoryUser> searchDirectoryUsers() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    List<DirectoryUser> results = new ArrayList<>();
    Map<String, Object> response = SSOOAuthServiceUtils.searchUsers(sessionDataContainer.getSsoAccessToken(getParameters().getSessionId()), data);
    if (response.containsKey("result")) {
        List<ExtMap> users = (List<ExtMap>) response.get("result");
        results = users.stream().map((ExtMap u) -> DirectoryUtils.mapPrincipalRecordToDirectoryUser(data.getAuthz(), u)).collect(Collectors.toList());
    }
    return results;
}
#method_after
private List<DirectoryUser> searchDirectoryUsers() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    List<DirectoryUser> results = new ArrayList<>();
    Map<String, Object> response = SSOOAuthServiceUtils.searchUsers(sessionDataContainer.getSsoAccessToken(getParameters().getSessionId()), getParamsMap(data));
    if (response.containsKey("result")) {
        List<ExtMap> users = (List<ExtMap>) response.get("result");
        results = users.stream().map((ExtMap u) -> DirectoryUtils.mapPrincipalRecordToDirectoryUser(data.getAuthz(), u)).collect(Collectors.toList());
    }
    return results;
}
#end_block

#method_before
private List<DirectoryGroup> searchDirectoryGroups() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    List<DirectoryGroup> results = new ArrayList<>();
    Map<String, Object> response = SSOOAuthServiceUtils.searchGroups(sessionDataContainer.getSsoAccessToken(getParameters().getSessionId()), data);
    if (response.containsKey("result")) {
        List<ExtMap> groups = (List<ExtMap>) response.get("result");
        results = groups.stream().map((ExtMap g) -> DirectoryUtils.mapGroupRecordToDirectoryGroup(data.getAuthz(), g)).collect(Collectors.toList());
    }
    return results;
}
#method_after
private List<DirectoryGroup> searchDirectoryGroups() {
    // Parse the query:
    QueryData data = initQueryData(true);
    if (data == null) {
        return Collections.emptyList();
    }
    List<DirectoryGroup> results = new ArrayList<>();
    Map<String, Object> response = SSOOAuthServiceUtils.searchGroups(sessionDataContainer.getSsoAccessToken(getParameters().getSessionId()), getParamsMap(data));
    if (response.containsKey("result")) {
        List<ExtMap> groups = (List<ExtMap>) response.get("result");
        results = groups.stream().map((ExtMap g) -> DirectoryUtils.mapGroupRecordToDirectoryGroup(data.getAuthz(), g)).collect(Collectors.toList());
    }
    return results;
}
#end_block

#method_before
private List<VDSGroup> searchClusters() {
    return genericSearch(getDbFacade().getVdsGroupDao(), true);
}
#method_after
private List<Cluster> searchClusters() {
    return genericSearch(getDbFacade().getClusterDao(), true);
}
#end_block

#method_before
private QueryData initQueryData(boolean useCache) {
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = queriesCache.get(searchKey);
            isExistsValue = (data != null);
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debug("ResourceManager::searchBusinessObjects(''{}'') - entered", searchText);
            final char AT = '@';
            String queryAuthz = null;
            String queryNamespace = null;
            ISyntaxChecker curSyntaxChecker;
            Matcher m = adSearchPattern.matcher(searchText);
            // checks if this is a AD query, if it is, verify given profile and namespace and pass the query
            if (m.matches()) {
                final String COLON = ":";
                String prefix = m.group("prefix");
                searchText = m.group("content");
                // get profile
                List<String> profiles = getBackend().runInternalQuery(VdcQueryType.GetDomainList, new VdcQueryParametersBase()).getReturnValue();
                for (String profile : profiles) {
                    if (searchText.startsWith(profile + COLON)) {
                        queryAuthz = profile;
                        searchText = searchText.replace(profile + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                if (queryAuthz == null) {
                    queryAuthz = getDefaultAuthz();
                }
                // get namespace
                HashMap<String, List<String>> namespacesMap = getBackend().runInternalQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase()).getReturnValue();
                List<String> namespaces = namespacesMap.get(queryAuthz);
                for (String namespace : namespaces) {
                    if (searchText.startsWith(namespace + COLON)) {
                        queryNamespace = namespace;
                        searchText = searchText.replace(namespace + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                // ADUSER/ADGROUP<profile>::<query>
                if (searchText.startsWith(COLON)) {
                    searchText = prefix + searchText;
                } else {
                    searchText = prefix + COLON + searchText;
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(LDAP);
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(LDAP);
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : Math.min(Integer.MAX_VALUE, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.info("ResourceManager::searchBusinessObjects - erroneous search text - ''{}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (!searchObj.getvalid()) {
                log.warn("ResourceManager::searchBusinessObjects - Invalid search text - ''{}''", searchText);
                return null;
            }
            // find if this is a trivial search expression (like 'Vms:' etc).
            isSafe = SearchObjects.isSafeExpression(searchText);
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryAuthz, queryNamespace);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery()))
                queriesCache.put(searchKey, data);
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character: {}", getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: {}", getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: {}: {}", getParameters().getSearchPattern(), ex.getMessage());
        log.debug("Exception", ex);
        data = null;
    }
    return data;
}
#method_after
private QueryData initQueryData(boolean useCache) {
    final String ASTR = "*";
    QueryData data = null;
    boolean isExistsValue = false;
    boolean IsFromYesterday = false;
    boolean isSafe = false;
    String searchKey = "";
    try {
        String searchText = getParameters().getSearchPattern();
        // do not cache expressions with '*' since it is translated to specific IDs that might be changed
        useCache = useCache && !searchText.contains(ASTR);
        if (useCache) {
            // first lets check the cache of queries.
            searchKey = String.format("%1$s,%2$s,%3$s", searchText, getParameters().getMaxCount(), getParameters().getCaseSensitive());
            data = queriesCache.get(searchKey);
            isExistsValue = data != null;
            if (isExistsValue) {
                TimeSpan span = DateTime.getNow().subtract(new Date(data.getDate()));
                if (span.Days >= 1) {
                    IsFromYesterday = true;
                }
            }
        }
        // search text.
        if (!isExistsValue || IsFromYesterday) {
            log.debug("ResourceManager::searchBusinessObjects(''{}'') - entered", searchText);
            final char AT = '@';
            String queryAuthz = null;
            String queryNamespace = null;
            ISyntaxChecker curSyntaxChecker;
            Matcher m = adSearchPattern.matcher(searchText);
            // checks if this is a AD query, if it is, verify given profile and namespace and pass the query
            if (m.matches()) {
                final String COLON = ":";
                String prefix = m.group("prefix");
                searchText = m.group("content");
                // get profile
                List<String> profiles = getBackend().runInternalQuery(VdcQueryType.GetDomainList, new VdcQueryParametersBase(getParameters().getSessionId())).getReturnValue();
                for (String profile : profiles) {
                    if (searchText.startsWith(profile + COLON)) {
                        queryAuthz = profile;
                        searchText = searchText.replace(profile + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                if (queryAuthz == null) {
                    queryAuthz = getDefaultAuthz();
                }
                // get namespace
                HashMap<String, List<String>> namespacesMap = getBackend().runInternalQuery(VdcQueryType.GetAvailableNamespaces, new VdcQueryParametersBase(getParameters().getSessionId())).getReturnValue();
                List<String> namespaces = namespacesMap.get(queryAuthz);
                for (String namespace : namespaces) {
                    if (searchText.startsWith(namespace + COLON)) {
                        queryNamespace = namespace;
                        searchText = searchText.replace(namespace + COLON, StringUtils.EMPTY);
                        break;
                    }
                }
                // ADUSER/ADGROUP<profile>::<query>
                if (searchText.startsWith(COLON)) {
                    searchText = prefix + searchText;
                } else {
                    searchText = prefix + COLON + searchText;
                }
                curSyntaxChecker = SyntaxCheckerFactory.createADSyntaxChecker(LDAP);
            } else {
                curSyntaxChecker = SyntaxCheckerFactory.createBackendSyntaxChecker(LDAP);
            }
            SyntaxContainer searchObj = curSyntaxChecker.analyzeSyntaxState(searchText, true);
            // set the case-sensitive flag
            searchObj.setCaseSensitive(getParameters().getCaseSensitive());
            // If a number > maxValue is given then maxValue will be used
            searchObj.setMaxCount(getParameters().getMaxCount() == -1 ? Integer.MAX_VALUE : Math.min(Integer.MAX_VALUE, getParameters().getMaxCount()));
            // setting FromSearch value
            searchObj.setSearchFrom(getParameters().getSearchFrom());
            if (searchObj.getError() != SyntaxError.NO_ERROR) {
                log.info("ResourceManager::searchBusinessObjects - erroneous search text - ''{}''", searchText);
                int startPos = searchObj.getErrorStartPos();
                int endPos = searchObj.getErrorEndPos();
                int length = endPos - startPos;
                String error = (length > 0 && ((startPos + 1 + length) < searchText.length()) && (endPos + 1 < searchText.length())) ? searchText.substring(0, startPos) + "$" + searchText.substring(startPos + 1, startPos + 1 + length) + "$" + searchText.substring(endPos + 1) : searchObj.getError().toString();
                getQueryReturnValue().setExceptionString(error);
                return null;
            }
            if (!searchObj.getvalid()) {
                log.warn("ResourceManager::searchBusinessObjects - Invalid search text - ''{}''", searchText);
                return null;
            }
            // find if this is a trivial search expression (like 'Vms:' etc).
            isSafe = SearchObjects.isSafeExpression(searchText);
            // An expression is considered safe if matches a trivial search.
            data = new QueryData(curSyntaxChecker.generateQueryFromSyntaxContainer(searchObj, isSafe), DateTime.getNow().getTime(), queryAuthz, queryNamespace);
            // query from scratch.
            if (!containsStaticInValues(data.getQuery())) {
                queriesCache.put(searchKey, data);
            }
        }
    } catch (SearchEngineIllegalCharacterException e) {
        log.error("Search expression can not end with ESCAPE character: {}", getParameters().getSearchPattern());
        data = null;
    } catch (SqlInjectionException e) {
        log.error("Sql Injection in search: {}", getParameters().getSearchPattern());
        data = null;
    } catch (RuntimeException ex) {
        log.warn("Illegal search: {}: {}", getParameters().getSearchPattern(), ex.getMessage());
        log.debug("Exception", ex);
        data = null;
    }
    return data;
}
#end_block

#method_before
public static DirectoryUser mapPrincipalRecordToDirectoryUser(final String authzName, final ExtMap principalRecord) {
    DirectoryUser directoryUser = null;
    if (principalRecord != null) {
        directoryUser = new DirectoryUser(authzName, principalRecord.<String>get(Authz.PrincipalRecord.NAMESPACE), principalRecord.<String>get(Authz.PrincipalRecord.ID), principalRecord.<String>get(Authz.PrincipalRecord.NAME), principalRecord.<String>get(Authz.PrincipalRecord.PRINCIPAL));
        directoryUser.setDepartment(principalRecord.<String>get(Authz.PrincipalRecord.DEPARTMENT));
        directoryUser.setFirstName(principalRecord.<String>get(Authz.PrincipalRecord.FIRST_NAME));
        directoryUser.setLastName(principalRecord.<String>get(Authz.PrincipalRecord.LAST_NAME));
        directoryUser.setEmail(principalRecord.<String>get(Authz.PrincipalRecord.EMAIL));
        directoryUser.setTitle(principalRecord.<String>get(Authz.PrincipalRecord.TITLE));
        directoryUser.setPrincipal(principalRecord.<String>get(Authz.PrincipalRecord.PRINCIPAL));
        List<DirectoryGroup> directoryGroups = new ArrayList<>();
        List<ExtMap> groups = principalRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS);
        if (groups != null) {
            for (ExtMap group : groups) {
                directoryGroups.add(mapGroupRecordToDirectoryGroup(authzName, group));
            }
        }
        directoryUser.setGroups(directoryGroups);
    }
    return directoryUser;
}
#method_after
public static DirectoryUser mapPrincipalRecordToDirectoryUser(final String authzName, final ExtMap principalRecord) {
    DirectoryUser directoryUser = null;
    if (principalRecord != null) {
        directoryUser = new DirectoryUser(authzName, principalRecord.<String>get(Authz.PrincipalRecord.NAMESPACE), principalRecord.<String>get(Authz.PrincipalRecord.ID), principalRecord.<String>get(Authz.PrincipalRecord.NAME), principalRecord.<String>get(Authz.PrincipalRecord.PRINCIPAL), principalRecord.<String>get(Authz.PrincipalRecord.DISPLAY_NAME));
        directoryUser.setDepartment(principalRecord.<String>get(Authz.PrincipalRecord.DEPARTMENT));
        directoryUser.setFirstName(principalRecord.<String>get(Authz.PrincipalRecord.FIRST_NAME));
        directoryUser.setLastName(principalRecord.<String>get(Authz.PrincipalRecord.LAST_NAME));
        directoryUser.setEmail(principalRecord.<String>get(Authz.PrincipalRecord.EMAIL));
        directoryUser.setTitle(principalRecord.<String>get(Authz.PrincipalRecord.TITLE));
        directoryUser.setPrincipal(principalRecord.<String>get(Authz.PrincipalRecord.PRINCIPAL));
        List<DirectoryGroup> directoryGroups = new ArrayList<>();
        List<ExtMap> groups = principalRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS);
        if (groups != null) {
            for (ExtMap group : groups) {
                directoryGroups.add(mapGroupRecordToDirectoryGroup(authzName, group));
            }
        }
        directoryUser.setGroups(directoryGroups);
    }
    return directoryUser;
}
#end_block

#method_before
public static DirectoryGroup mapGroupRecordToDirectoryGroup(final String authzName, final ExtMap group) {
    DirectoryGroup directoryGroup = null;
    if (group != null) {
        directoryGroup = new DirectoryGroup(authzName, group.<String>get(Authz.GroupRecord.NAMESPACE), group.<String>get(Authz.GroupRecord.ID), group.<String>get(Authz.GroupRecord.NAME));
        for (ExtMap memberOf : group.<List<ExtMap>>get(Authz.GroupRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            directoryGroup.getGroups().add(mapGroupRecordToDirectoryGroup(authzName, memberOf));
        }
    }
    return directoryGroup;
}
#method_after
public static DirectoryGroup mapGroupRecordToDirectoryGroup(final String authzName, final ExtMap group) {
    DirectoryGroup directoryGroup = null;
    if (group != null) {
        directoryGroup = new DirectoryGroup(authzName, group.<String>get(Authz.GroupRecord.NAMESPACE), group.<String>get(Authz.GroupRecord.ID), group.<String>get(Authz.GroupRecord.NAME), group.<String>get(Authz.GroupRecord.DISPLAY_NAME));
        for (ExtMap memberOf : group.<List<ExtMap>>get(Authz.GroupRecord.GROUPS, Collections.<ExtMap>emptyList())) {
            directoryGroup.getGroups().add(mapGroupRecordToDirectoryGroup(authzName, memberOf));
        }
    }
    return directoryGroup;
}
#end_block

#method_before
public static void changePassword(SSOContext context, HttpServletRequest request, Credentials credentials) throws AuthenticationException {
    ExtensionProfile profile = getExtensionProfile(context, credentials.getProfile());
    String user = mapUser(profile, credentials);
    log.debug("AuthenticationUtils.changePassword invoking CREDENTIALS_CHANGE on authn");
    ExtMap outputMap = profile.authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.CREDENTIALS_CHANGE).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getCredentials()).mput(Authn.InvokeKeys.CREDENTIALS_NEW, credentials.getCredentialsNew()));
    if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
        SSOUtils.getSsoSession(request).setChangePasswdCredentials(credentials);
        log.debug("AuthenticationUtils.changePassword CREDENTIALS_CHANGE on authn failed");
        throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(request, credentials.getProfile(), outputMap));
    }
    log.debug("AuthenticationUtils.changePassword CREDENTIALS_CHANGE on authn succeeded");
}
#method_after
public static void changePassword(SSOContext context, HttpServletRequest request, Credentials credentials) throws AuthenticationException {
    ExtensionProfile profile = getExtensionProfile(context, credentials.getProfile());
    String user = mapUser(profile, credentials);
    log.debug("AuthenticationUtils.changePassword invoking CREDENTIALS_CHANGE on authn");
    ExtMap outputMap = profile.authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.CREDENTIALS_CHANGE).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getCredentials()).mput(Authn.InvokeKeys.CREDENTIALS_NEW, credentials.getNewCredentials()));
    if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
        SSOUtils.getSsoSession(request).setChangePasswdCredentials(credentials);
        log.debug("AuthenticationUtils.changePassword CREDENTIALS_CHANGE on authn failed");
        throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(request, credentials.getProfile(), outputMap));
    }
    log.debug("AuthenticationUtils.changePassword CREDENTIALS_CHANGE on authn succeeded");
}
#end_block

#method_before
public static Map<String, List<String>> getAvailableNamesSpaces(SSOExtensionsManager extensionsManager) {
    Map<String, List<String>> namespacesMap = new HashMap<>();
    for (ExtensionProxy authz : extensionsManager.getExtensionsByService(Authz.class.getName())) {
        String authzName = authz.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME);
        for (String namespace : authz.getContext().<Collection<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES, Collections.<String>emptyList())) {
            if (!namespacesMap.containsKey(authzName)) {
                namespacesMap.put(authzName, new ArrayList<>());
            }
            namespacesMap.get(authzName).add(namespace);
        }
    }
    for (List<String> entry : namespacesMap.values()) {
        Collections.sort(entry);
    }
    return namespacesMap;
}
#method_after
public static Map<String, List<String>> getAvailableNamesSpaces(SSOExtensionsManager extensionsManager) {
    Map<String, List<String>> namespacesMap = new HashMap<>();
    extensionsManager.getExtensionsByService(Authz.class.getName()).forEach(authz -> {
        String authzName = authz.getContext().<String>get(Base.ContextKeys.INSTANCE_NAME);
        authz.getContext().<Collection<String>>get(Authz.ContextKeys.AVAILABLE_NAMESPACES, Collections.<String>emptyList()).forEach(namespace -> {
            if (!namespacesMap.containsKey(authzName)) {
                namespacesMap.put(authzName, new ArrayList<>());
            }
            namespacesMap.get(authzName).add(namespace);
        });
    });
    namespacesMap.values().forEach(Collections::sort);
    return namespacesMap;
}
#end_block

#method_before
public static List<String> getAvailableProfiles(SSOExtensionsManager extensionsManager) {
    List<String> profiles = new ArrayList<>();
    for (ExtensionProxy authnExtension : extensionsManager.getExtensionsByService(Authn.class.getName())) {
        Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
        profiles.add(config.getProperty(Authn.ConfigKeys.PROFILE_NAME));
    }
    return profiles;
}
#method_after
public static List<String> getAvailableProfiles(SSOExtensionsManager extensionsManager) {
    return extensionsManager.getExtensionsByService(Authn.class.getName()).stream().map(AuthenticationUtils::getProfileName).collect(Collectors.toList());
}
#end_block

#method_before
public static List<String> getAvailableProfilesSupportingPasswd(SSOExtensionsManager extensionsManager) {
    List<String> profiles = new ArrayList<>();
    for (ExtensionProxy authnExtension : extensionsManager.getExtensionsByService(Authn.class.getName())) {
        if ((authnExtension.getContext().<Long>get(Authn.ContextKeys.CAPABILITIES, 0L) & Authn.Capabilities.AUTHENTICATE_PASSWORD) != 0) {
            Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
            profiles.add(config.getProperty(Authn.ConfigKeys.PROFILE_NAME));
        }
    }
    return profiles;
}
#method_after
public static List<String> getAvailableProfilesSupportingPasswd(SSOExtensionsManager extensionsManager) {
    return getAvailableProfilesImpl(extensionsManager, Authn.Capabilities.AUTHENTICATE_PASSWORD);
}
#end_block

#method_before
public static List<String> getAvailableProfilesSupportingPasswdChange(SSOExtensionsManager extensionsManager) {
    List<String> profiles = new ArrayList<>();
    for (ExtensionProxy authnExtension : extensionsManager.getExtensionsByService(Authn.class.getName())) {
        if ((authnExtension.getContext().<Long>get(Authn.ContextKeys.CAPABILITIES, 0L) & Authn.Capabilities.CREDENTIALS_CHANGE) != 0) {
            Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
            profiles.add(config.getProperty(Authn.ConfigKeys.PROFILE_NAME));
        }
    }
    return profiles;
}
#method_after
public static List<String> getAvailableProfilesSupportingPasswdChange(SSOExtensionsManager extensionsManager) {
    return getAvailableProfilesImpl(extensionsManager, Authn.Capabilities.CREDENTIALS_CHANGE);
}
#end_block

#method_before
public static ExtensionProfile getExtensionProfile(SSOContext ssoContext, String profileName) {
    ExtensionProfile profile = getExtensionProfileImpl(ssoContext, profileName, null);
    if (profile.authn == null || profile.authz == null) {
        log.debug("AuthenticationUtils.getExtensionProfile authn and authz NOT found for profile {}", profileName);
        throw new RuntimeException(String.format("Error in obtaining profile %s", profileName));
    }
    log.debug("AuthenticationUtils.getExtensionProfile authn and authz found for profile %s", profileName);
    return profile;
}
#method_after
public static ExtensionProfile getExtensionProfile(SSOContext ssoContext, String profileName) {
    Optional<ExtensionProfile> profile = getExtensionProfileImpl(ssoContext, profileName, null);
    if (!profile.isPresent()) {
        log.debug("AuthenticationUtils.getExtensionProfile authn and authz NOT found for profile {}", profileName);
        throw new RuntimeException(String.format("Error in obtaining profile %s", profileName));
    }
    log.debug("AuthenticationUtils.getExtensionProfile authn and authz found for profile %s", profileName);
    return profile.get();
}
#end_block

#method_before
public static ExtensionProfile getExtensionProfileByAuthzName(SSOContext ssoContext, String authzName) {
    ExtensionProfile profile = getExtensionProfileImpl(ssoContext, null, authzName);
    if (profile.authn == null || profile.authz == null) {
        log.debug("AuthenticationUtils.getExtensionProfile authn and authz NOT found for authz {}", authzName);
        throw new RuntimeException(String.format("Error in obtaining profile for authz %s", authzName));
    }
    log.debug("AuthenticationUtils.getExtensionProfile authn and authz found for authz %s", authzName);
    return profile;
}
#method_after
public static ExtensionProfile getExtensionProfileByAuthzName(SSOContext ssoContext, String authzName) {
    Optional<ExtensionProfile> profile = getExtensionProfileImpl(ssoContext, null, authzName);
    if (!profile.isPresent()) {
        log.debug("AuthenticationUtils.getExtensionProfile authn and authz NOT found for authz {}", authzName);
        throw new RuntimeException(String.format("Error in obtaining profile for authz %s", authzName));
    }
    log.debug("AuthenticationUtils.getExtensionProfile authn and authz found for authz %s", authzName);
    return profile.get();
}
#end_block

#method_before
public static ExtensionProfile getExtensionProfileImpl(SSOContext ssoContext, String searchProfileName, String searchAuthzName) {
    ExtensionProfile profile = new ExtensionProfile();
    for (ExtensionProxy authn : ssoContext.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName())) {
        Properties config = authn.getContext().get(Base.ContextKeys.CONFIGURATION);
        String profileName = config.getProperty(Authn.ConfigKeys.PROFILE_NAME);
        String authzName = authn.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.AUTHZ_PLUGIN);
        if ((StringUtils.isNotEmpty(searchProfileName) && searchProfileName.equals(profileName)) || (StringUtils.isNotEmpty(searchAuthzName) && searchAuthzName.equals(authzName))) {
            String mapperName = authn.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.MAPPING_PLUGIN);
            profile.mapper = mapperName != null ? ssoContext.getSsoExtensionsManager().getExtensionByName(mapperName) : null;
            profile.authn = authn;
            profile.authz = ssoContext.getSsoExtensionsManager().getExtensionByName(authzName);
            break;
        }
    }
    return profile;
}
#method_after
private static Optional<ExtensionProfile> getExtensionProfileImpl(SSOContext ssoContext, final String searchProfileName, final String searchAuthzName) {
    return ssoContext.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName()).stream().filter(a -> matchesSearchName(a, searchProfileName, searchAuthzName)).map(a -> mapToExtensionProfile(ssoContext, a)).findFirst();
}
#end_block

#method_before
public static final String mapMessageErrorCode(ExtMap outputMap) {
    String msg = USER_FAILED_TO_AUTHENTICATE;
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
        msg = USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED;
    }
    return msg;
}
#method_after
public static final String mapMessageErrorCode(HttpServletRequest request, String profile, ExtMap outputMap) {
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    String msg = messagesMap.containsKey(authResult) ? messagesMap.get(authResult) : USER_FAILED_TO_AUTHENTICATE;
    if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
        if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null || SSOUtils.getSsoContext(request).getSsoProfilesSupportingPasswdChange().contains(profile)) {
            msg = String.format(USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED, request.getContextPath() + SSOConstants.INTERACTIVE_CHANGE_PASSWD_FORM_URI);
        } else {
            msg = USER_PASSWORD_EXPIRED;
        }
    }
    return msg;
}
#end_block

#method_before
public static void handleCredentials(HttpSession session, String user, String password, String profile) throws IOException, ServletException, AuthenticationException, SQLException {
    if (StringUtils.isEmpty(user) || StringUtils.isEmpty(password) || StringUtils.isEmpty(profile)) {
        throw new AuthenticationException("Please provide username, password and profile.");
    }
    ExtensionProxy authn = null;
    ExtensionProxy authz = null;
    ExtensionProxy mapper = null;
    SSOConfig ssoConfig = (SSOConfig) session.getServletContext().getAttribute(SSOUtils.SSO_CONFIG);
    for (ExtensionProxy authnExtension : ssoConfig.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName())) {
        Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
        if (profile.equals(config.getProperty(Authn.ConfigKeys.PROFILE_NAME))) {
            String mapperName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.MAPPING_PLUGIN);
            String authzName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.AUTHZ_PLUGIN);
            mapper = mapperName != null ? ssoConfig.getSsoExtensionsManager().getExtensionByName(mapperName) : null;
            authn = authnExtension;
            authz = ssoConfig.getSsoExtensionsManager().getExtensionByName(authzName);
            break;
        }
    }
    if (authn == null || authz == null) {
        throw new RuntimeException(String.format("Error in obtaining profile %s", profile));
    }
    if (mapper != null) {
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).get(Mapping.InvokeKeys.USER, user);
    }
    ExtMap outputMap = authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
        int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            Credentials userCredentials = (Credentials) session.getAttribute(SSOUtils.USER_CREDENTIALS);
            session.setAttribute(SSOUtils.LOGIN_PASSWD_CHANGE_URI_MSG, session.getServletContext().getContextPath() + SSOUtils.PASSWORD_CHANGE_FORM_URI);
            session.setAttribute(SSOUtils.PASSWD_EXPIRED_USER_NAME, userCredentials.getUsername());
            session.setAttribute(SSOUtils.PASSWD_EXPIRED_USER_PROFILE, userCredentials.getProfile());
        }
        throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(outputMap));
    }
    ExtMap authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    if (mapper != null) {
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    ExtMap output = authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    Map<String, Object> sessionData = SSOUtils.getSessionData(session.getServletContext(), session.getId());
    sessionData.put(SSOUtils.SSO_PROFILE_ATTR_NAME, profile);
    sessionData.put(SSOUtils.SSO_AUTHZ_ATTR_NAME, authz.getContext().get(Base.ContextKeys.INSTANCE_NAME));
    sessionData.put(SSOUtils.SSO_AUTH_RECORD_ATTR_NAME, authRecord);
    sessionData.put(SSOUtils.SSO_PRINCIPAL_RECORD_ATTR_NAME, output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#method_after
public static void handleCredentials(SSOContext ssoContext, HttpServletRequest request, Credentials credentials) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException("Please provide username, password and profile.");
    }
    SSOSession ssoSession = login(ssoContext, request, credentials, null);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#end_block

#method_before
public static List<String> getAvailableProfiles(ServletContext ctx) {
    SSOConfig ssoConfig = (SSOConfig) ctx.getAttribute(SSOUtils.SSO_CONFIG);
    List<String> profiles = new ArrayList<>();
    for (ExtensionProxy authnExtension : ssoConfig.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName())) {
        Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
        profiles.add(config.getProperty(Authn.ConfigKeys.PROFILE_NAME));
    }
    return profiles;
}
#method_after
public static List<String> getAvailableProfiles(SSOExtensionsManager extensionsManager) {
    return extensionsManager.getExtensionsByService(Authn.class.getName()).stream().map(AuthenticationUtils::getProfileName).collect(Collectors.toList());
}
#end_block

#method_before
public static List<String> getAvailableProfilesSupportingPasswd(ServletContext ctx) {
    SSOConfig ssoConfig = (SSOConfig) ctx.getAttribute(SSOUtils.SSO_CONFIG);
    List<String> profiles = new ArrayList<>();
    for (ExtensionProxy authnExtension : ssoConfig.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName())) {
        if ((authnExtension.getContext().<Long>get(Authn.ContextKeys.CAPABILITIES, 0L) & Authn.Capabilities.AUTHENTICATE_PASSWORD) != 0) {
            Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
            profiles.add(config.getProperty(Authn.ConfigKeys.PROFILE_NAME));
        }
    }
    return profiles;
}
#method_after
public static List<String> getAvailableProfilesSupportingPasswd(SSOExtensionsManager extensionsManager) {
    return getAvailableProfilesImpl(extensionsManager, Authn.Capabilities.AUTHENTICATE_PASSWORD);
}
#end_block

#method_before
public static boolean isUserAuthenticated(HttpSession session) {
    Map<String, Object> sessionData = SSOUtils.getSessionData(session.getServletContext(), session.getId());
    return sessionData.get(SSO_PRINCIPAL_RECORD_ATTR_NAME) != null;
}
#method_after
public static boolean isUserAuthenticated(HttpServletRequest request) {
    return getSsoSession(request).getStatus() == SSOSession.Status.authenticated;
}
#end_block

#method_before
public static void redirectToModule(HttpSession session, HttpServletRequest request, HttpServletResponse response) throws IOException {
    try {
        if (StringUtils.isEmpty(SSOUtils.getParameter(request, POST_ACTION_URL))) {
            response.sendRedirect(((SSOConfig) request.getServletContext().getAttribute(SSOUtils.SSO_CONFIG)).getWelcomeUrl());
        } else {
            StringBuilder redirectUrl = new StringBuilder(SSOUtils.getParameter(request, POST_ACTION_URL));
            if (StringUtils.isNotEmpty(SSOUtils.getParameter(request, OPAQUE))) {
                redirectUrl.append("&opaque=");
                redirectUrl.append(response.encodeURL(SSOUtils.getParameter(request, OPAQUE)));
            }
            redirectUrl.append("&sso_token=");
            redirectUrl.append(response.encodeURL(getSsoToken(session.getId())));
            Map<String, Object> sessionData = SSOUtils.getSessionData(request.getServletContext(), session.getId());
            response.addCookie(new Cookie("profile", (String) sessionData.get(SSOUtils.SSO_PROFILE_ATTR_NAME)));
            response.sendRedirect(redirectUrl.toString());
        }
    } catch (Exception ex) {
        throw new RuntimeException(ex);
    }
}
#method_after
public static void redirectToModule(HttpServletRequest request, HttpServletResponse response) throws IOException {
    log.debug("Entered redirectToModule");
    try {
        SSOSession ssoSession = getSsoSession(request);
        URLBuilder redirectUrl = new URLBuilder(getRedirectUrl(request).toString()).addParameter("code", ssoSession.getAuthorizationCode());
        String state = ssoSession.getState();
        if (StringUtils.isNotEmpty(state)) {
            redirectUrl.addParameter("state", state);
        }
        response.sendRedirect(redirectUrl.build());
        log.debug("Redirecting back to module: {}", redirectUrl);
    } catch (Exception ex) {
        log.error("Error redirecting back to module: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new RuntimeException(ex);
    } finally {
        SSOUtils.getSsoSession(request).cleanup();
    }
}
#end_block

#method_before
public static String getParameter(HttpServletRequest request, String paramName) {
    String value = null;
    Map<String, String[]> map = (Map<String, String[]>) request.getSession(true).getAttribute(PARAMS_MAP);
    if (map != null && map.containsKey(paramName)) {
        value = map.get(paramName)[0];
    }
    return value;
}
#method_after
public static String getParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : URLDecoder.decode(new String(value.getBytes("iso-8859-1")), StandardCharsets.UTF_8.name());
}
#end_block

#method_before
public static Credentials getUserCredentialsFromHeader(HttpServletRequest request) {
    String header = request.getHeader(SSOUtils.HEADER_AUTHORIZATION);
    Credentials credentials = null;
    if (StringUtils.isNotEmpty(header)) {
        String[] creds = new String(Base64.decodeBase64(header.substring("Basic".length())), Charset.forName("UTF-8")).split(":", 2);
        if (creds.length == 2) {
            credentials = translateUser(creds[0], creds[1], (SSOConfig) request.getServletContext().getAttribute(SSOUtils.SSO_CONFIG));
        }
    }
    return credentials;
}
#method_after
public static Credentials getUserCredentialsFromHeader(HttpServletRequest request) {
    String header = request.getHeader(SSOConstants.HEADER_AUTHORIZATION);
    Credentials credentials = null;
    if (StringUtils.isNotEmpty(header)) {
        String[] creds = new String(Base64.decodeBase64(header.substring("Basic".length())), StandardCharsets.UTF_8).split(":", 2);
        if (creds.length == 2) {
            credentials = translateUser(creds[0], creds[1], getSsoContext(request));
        }
    }
    return credentials;
}
#end_block

#method_before
private static Credentials translateUser(String user, String password, SSOConfig config) {
    Credentials credentials = null;
    int separator = user.lastIndexOf("@");
    if (separator != -1) {
        String profile = user.substring(separator + 1);
        if (StringUtils.isNotEmpty(profile) && config.getSsoProfiles().contains(profile)) {
            credentials = new Credentials();
            credentials.setPassword(password);
            credentials.setProfile(profile);
            credentials.setUsername(user.substring(0, separator));
        }
    }
    return credentials;
}
#method_after
public static Credentials translateUser(String user, String password, SSOContext ssoContext) {
    Credentials credentials = new Credentials();
    String username = user;
    int separator = user.lastIndexOf("@");
    if (separator != -1) {
        username = user.substring(0, separator);
        String profile = user.substring(separator + 1);
        if (StringUtils.isNotEmpty(profile)) {
            credentials.setProfile(profile);
            credentials.setProfileValid(ssoContext.getSsoProfiles().contains(profile));
        }
    }
    credentials.setUsername(username);
    credentials.setPassword(password);
    return credentials;
}
#end_block

#method_before
public static Version fromVersionString(String versionString) {
    if (StringUtils.isEmpty(versionString)) {
        return null;
    }
    String[] parts = versionString.split("\\.");
    Version version = new Version();
    if (parts.length < 1) {
        return null;
    }
    try {
        version.setMajor(Integer.parseInt(StringUtils.stripStart(parts[0], "0")));
    } catch (NumberFormatException e) {
        log.error("Failed to map version string major component", e);
        return null;
    }
    if (parts.length > 1) {
        try {
            version.setMinor(Integer.parseInt(StringUtils.stripStart(parts[1], "0")));
        } catch (NumberFormatException e) {
            log.error("Failed to map version string minor component", e);
            return version;
        }
    }
    if (parts.length > 2) {
        try {
            version.setBuild(Integer.parseInt(StringUtils.stripStart(parts[2], "0")));
        } catch (NumberFormatException e) {
            log.error("Failed to map version string build component", e);
            return version;
        }
    }
    if (parts.length > 3) {
        try {
            version.setRevision(Integer.parseInt(StringUtils.stripStart(parts[3], "0")));
        } catch (NumberFormatException e) {
            log.error("Failed to map version string revision component", e);
            return version;
        }
    }
    return version;
}
#method_after
public static Version fromVersionString(String versionString) {
    if (versionString == null) {
        return null;
    }
    Version version = new Version();
    version.setFullVersion(versionString);
    Matcher match = VERSION_PATTERN.matcher(versionString);
    if (match.matches()) {
        String major = match.group("major");
        String minor = match.group("minor");
        String build = match.group("build");
        String revision = match.group("revision");
        if (major != null) {
            version.setMajor(Integer.parseInt(major));
        }
        if (minor != null) {
            version.setMinor(Integer.parseInt(minor));
        }
        if (build != null) {
            version.setBuild(Integer.parseInt(build));
        }
        if (revision != null) {
            version.setRevision(Integer.parseInt(revision));
        }
    } else {
        log.warn("The version string \"{}\" doesn't match the expected pattern, only the full version will be reported.", versionString);
    }
    return version;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VmTemplate> returnValue = DbFacade.getInstance().getVmTemplateDao().getAllForStorageDomain(getParameters().getId(), getUserID(), getParameters().isFiltered());
    for (VmTemplate template : returnValue) {
        VmTemplateHandler.updateDisksFromDb(template);
        Collections.sort(template.getDiskList(), new DiskByDiskAliasComparator());
    }
    Collections.sort(returnValue, Collections.reverseOrder(new VmTemplateComparerByDiskSize()));
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VmTemplate> returnValue = DbFacade.getInstance().getVmTemplateDao().getAllForStorageDomain(getParameters().getId(), getUserID(), getParameters().isFiltered());
    if (getParameters().isWithDisks()) {
        for (VmTemplate template : returnValue) {
            VmTemplateHandler.updateDisksFromDb(template);
            Collections.sort(template.getDiskList(), new DiskByDiskAliasComparator());
        }
    }
    Collections.sort(returnValue, Collections.reverseOrder(new VmTemplateComparerByDiskSize()));
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
@Before
public void init() {
    vmDevicesMonitoring = new VmDevicesMonitoring();
    List<Pair<Guid, String>> initialHashes = new ArrayList<>();
    initialHashes.add(new Pair<>(VM_ID, INITIAL_HASH));
    doReturn(initialHashes).when(vmDynamicDao).getAllDevicesHashes();
    doReturn(Version.v4_0).when(vdsManager).getGroupCompatibilityVersion();
    doReturn(vdsManager).when(resourceManager).getVdsManager(VDS_ID);
    vmDevicesMonitoring.setVmDynamicDao(vmDynamicDao);
    vmDevicesMonitoring.setVmDeviceDao(vmDeviceDao);
    vmDevicesMonitoring.setResourceManager(resourceManager);
}
#method_after
@Before
public void init() {
    vmDevicesMonitoring = spy(new VmDevicesMonitoring());
    List<Pair<Guid, String>> initialHashes = new ArrayList<>();
    initialHashes.add(new Pair<>(VM_ID, INITIAL_HASH));
    doReturn(initialHashes).when(vmDynamicDao).getAllDevicesHashes();
    doReturn(Version.v4_0).when(vdsManager).getGroupCompatibilityVersion();
    doReturn(vdsManager).when(resourceManager).getVdsManager(VDS_ID);
    doReturn(vmDynamicDao).when(vmDevicesMonitoring).getVmDynamicDao();
    doReturn(vmDeviceDao).when(vmDevicesMonitoring).getVmDeviceDao();
    doReturn(resourceManager).when(vmDevicesMonitoring).getResourceManager();
}
#end_block

#method_before
private ResourceManager getResourceManager() {
    return resourceManager;
}
#method_after
ResourceManager getResourceManager() {
    return resourceManager;
}
#end_block

#method_before
public VmDeviceDao getVmDeviceDao() {
    return vmDeviceDao;
}
#method_after
VmDeviceDao getVmDeviceDao() {
    return vmDeviceDao;
}
#end_block

#method_before
public VmDynamicDao getVmDynamicDao() {
    return vmDynamicDao;
}
#method_after
VmDynamicDao getVmDynamicDao() {
    return vmDynamicDao;
}
#end_block

#method_before
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addDeviceToAdd(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#method_after
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        if (dbDevice == null) {
            dbDevice = getByDeviceType((String) vdsmDevice.get(VdsProperties.Device), dbDeviceMap);
            deviceId = dbDevice != null ? dbDevice.getDeviceId() : deviceId;
        }
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addDeviceToAdd(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#end_block

#method_before
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null && !VmDeviceUtils.hasWatchdog(getVmTemplateId())) {
        WatchdogParameters parameters = new WatchdogParameters();
        parameters.setId(getParameters().getVmId());
        parameters.setAction(vmWatchdog.getAction());
        parameters.setModel(vmWatchdog.getModel());
        runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
    }
}
#method_after
protected void addVmWatchdog() {
    VmWatchdog vmWatchdog = getParameters().getWatchdog();
    if (vmWatchdog != null) {
        VdcActionType actionType = VmDeviceUtils.hasWatchdog(getVmTemplateId()) ? VdcActionType.UpdateWatchdog : VdcActionType.AddWatchdog;
        runInternalAction(actionType, buildWatchdogParameters(vmWatchdog), cloneContextAndDetachFromParent());
    }
}
#end_block

#method_before
public void updateVm(Guid vmId, String vdsmHash) {
    if (!VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId)) && isVmDevicesChanged(vmId, vdsmHash, fetchTime)) {
        lockTouchedVm(vmId);
        addVmToProcess(vmId);
    }
}
#method_after
public void updateVm(Guid vmId, String vdsmHash) {
    if (VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId))) {
        return;
    }
    DevicesChange devicesChange = isVmDevicesChanged(vmId, vdsmHash, fetchTime);
    if (devicesChange == DevicesChange.CHANGED) {
        lockTouchedVm(vmId);
        addVmToSaveHash(vmId);
        addVmToProcess(vmId);
    } else if (devicesChange == DevicesChange.HASH_ONLY) {
        addVmToSaveHash(vmId);
    }
}
#end_block

#method_before
public void updateVmFromFullList(Map<String, Object> vmInfo) {
    if (!VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId)) && isVmDevicesChanged(getVmId(vmInfo), UPDATE_HASH, fetchTime)) {
        processFullList(vmInfo);
    }
}
#method_after
public void updateVmFromFullList(Map<String, Object> vmInfo) {
    if (VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId))) {
        return;
    }
    Guid vmId = getVmId(vmInfo);
    if (isVmDevicesChanged(vmId, UPDATE_HASH, fetchTime) == DevicesChange.CHANGED) {
        addVmToSaveHash(vmId);
        processFullList(vmInfo);
    }
}
#end_block

#method_before
private boolean isVmDevicesChanged(Guid vmId, String vdsmHash, long fetchTime) {
    if (vdsmHash == null) {
        return false;
    }
    // This operation is atomic
    synchronized (devicesStatusesLock) {
        DevicesStatus previousStatus = vmDevicesStatuses.get(vmId);
        boolean previousHashUpdate = previousStatus != null && UPDATE_HASH.equals(previousStatus.getHash());
        if (previousStatus == null || previousHashUpdate || fetchTimeBefore(previousStatus.getFetchTime(), fetchTime)) {
            vmDevicesStatuses.put(vmId, new DevicesStatus(vdsmHash, fetchTime));
            return previousStatus == null || !previousHashUpdate && !Objects.equals(previousStatus.getHash(), vdsmHash);
        } else {
            return false;
        }
    }
}
#method_after
private DevicesChange isVmDevicesChanged(Guid vmId, String vdsmHash, long fetchTime) {
    if (vdsmHash == null) {
        return DevicesChange.NOT_CHANGED;
    }
    // This operation is atomic
    synchronized (devicesStatusesLock) {
        DevicesStatus previousStatus = vmDevicesStatuses.get(vmId);
        boolean previousHashUpdate = previousStatus != null && UPDATE_HASH.equals(previousStatus.getHash());
        if (previousStatus == null || previousHashUpdate || fetchTimeBefore(previousStatus.getFetchTime(), fetchTime)) {
            vmDevicesStatuses.put(vmId, new DevicesStatus(vdsmHash, fetchTime));
            if (previousStatus == null || !Objects.equals(previousStatus.getHash(), vdsmHash)) {
                return previousHashUpdate ? DevicesChange.HASH_ONLY : DevicesChange.CHANGED;
            } else {
                return DevicesChange.NOT_CHANGED;
            }
        } else {
            return DevicesChange.NOT_CHANGED;
        }
    }
}
#end_block

#method_before
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        if (dbDevice == null) {
            dbDevice = getByDeviceType((String) vdsmDevice.get(VdsProperties.Device), dbDevices);
            deviceId = dbDevice != null ? dbDevice.getDeviceId() : deviceId;
        }
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addDeviceToAdd(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#method_after
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        if (dbDevice == null) {
            dbDevice = getByDeviceType((String) vdsmDevice.get(VdsProperties.Device), dbDeviceMap);
            deviceId = dbDevice != null ? dbDevice.getDeviceId() : deviceId;
        }
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addDeviceToAdd(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#end_block

#method_before
private VmDevice getByDeviceType(String deviceName, List<VmDevice> dbDevices) {
    VmDeviceType vmDeviceType = VmDeviceType.getByName(deviceName);
    if (vmDeviceType == null) {
        return null;
    }
    if (VmDeviceType.VIRTIOSERIAL == vmDeviceType) {
        return dbDevices.stream().filter(device -> device.getDevice().equals(deviceName)).findFirst().orElse(null);
    }
    return null;
}
#method_after
private VmDevice getByDeviceType(String deviceTypeName, Map<?, VmDevice> dbDevices) {
    if (VmDeviceType.VIRTIOSERIAL.getName().equals(deviceTypeName)) {
        return VmDeviceCommonUtils.findVmDeviceByType(dbDevices, deviceTypeName);
    }
    return null;
}
#end_block

#method_before
private void saveDevicesToDb(Change change) {
    getVmDeviceDao().updateAllInBatch(change.getDevicesToUpdate());
    if (!change.getDeviceIdsToRemove().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.getDeviceIdsToRemove());
            return null;
        });
    }
    if (!change.getDevicesToAdd().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.getDevicesToAdd());
            return null;
        });
    }
    if (!change.touchedVms.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.touchedVms.stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
    }
}
#method_after
private void saveDevicesToDb(Change change) {
    getVmDeviceDao().updateAllInBatch(change.getDevicesToUpdate());
    if (!change.getDeviceIdsToRemove().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.getDeviceIdsToRemove());
            return null;
        });
    }
    if (!change.getDevicesToAdd().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.getDevicesToAdd());
            return null;
        });
    }
    if (!change.getVmsToSaveHash().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.getVmsToSaveHash().stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
    }
}
#end_block

#method_before
private static Collection<CommandAssociatedEntity> buildCommandAssociatedEntities(Guid cmdId, Collection<SubjectEntity> subjectEntities) {
    if (subjectEntities.isEmpty()) {
        return Collections.emptyList();
    }
    return subjectEntities.stream().map(subjectEntity -> new CommandAssociatedEntity(cmdId, subjectEntity.getEntityType(), subjectEntity.getEntityId())).collect(Collectors.toSet());
}
#method_after
private static Collection<CommandAssociatedEntity> buildCommandAssociatedEntities(Guid cmdId, Collection<SubjectEntity> subjectEntities) {
    if (subjectEntities.isEmpty()) {
        return Collections.emptySet();
    }
    return subjectEntities.stream().map(subjectEntity -> new CommandAssociatedEntity(cmdId, subjectEntity.getEntityType(), subjectEntity.getEntityId())).collect(Collectors.toSet());
}
#end_block

#method_before
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getVdsGroupCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#method_after
private void setSupportedFeatures() {
    Version clusterCompatibilityVersion = host.getClusterCompatibilityVersion();
    networkCustomPropertiesSupported = FeatureSupported.networkCustomProperties(clusterCompatibilityVersion);
    hostNetworkQosSupported = FeatureSupported.hostNetworkQos(clusterCompatibilityVersion);
}
#end_block

#method_before
List<String> translateErrorMessages(List<String> messages) {
    return Backend.getInstance().getErrorsTranslator().TranslateErrorText(messages);
}
#method_after
List<String> translateErrorMessages(List<String> messages) {
    return Backend.getInstance().getErrorsTranslator().translateErrorText(messages);
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, createOrUpdateBondBusinessEntityMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, createOrUpdateBondBusinessEntityMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : unmanagedNetworkValidator.validate(params, existingInterfaces, networkBusinessEntityMap);
    return vr;
}
#end_block

#method_before
protected ValidationResult validateBondModeVsNetworksAttachedToIt(Collection<NetworkAttachment> attachmentsToConfigure) {
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(existingInterfaces);
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        if (!mustAttachementBeCheckedForBondMode(attachment, hostInterfacesByNetworkName)) {
            continue;
        }
        CreateOrUpdateBond bondToCheck = createOrUpdateBondBusinessEntityMap.get(attachment.getNicName());
        if (bondToCheck == null) {
            VdsNetworkInterface existingNetworkInterfaceForAttachement = existingInterfacesMap.get(attachment.getNicName());
            if (existingNetworkInterfaceForAttachement == null || !existingNetworkInterfaceForAttachement.isBond()) {
                continue;
            }
            bondToCheck = CreateOrUpdateBond.fromBond((Bond) existingNetworkInterfaceForAttachement);
        }
        String networkLabel = networkBusinessEntityMap.get(attachment.getNetworkName()).getLabel();
        ValidationResult validationResult = checkBondMode(bondToCheck, networkLabel, attachment.getNetworkName());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateBondModeVsNetworksAttachedToIt(Collection<NetworkAttachment> attachmentsToConfigure) {
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = NetworkUtils.hostInterfacesByNetworkName(existingInterfaces);
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        if (!mustAttachementBeCheckedForBondMode(attachment, hostInterfacesByNetworkName)) {
            continue;
        }
        CreateOrUpdateBond bondToCheck = createOrUpdateBondBusinessEntityMap.get(attachment.getNicName());
        if (bondToCheck == null) {
            VdsNetworkInterface existingNetworkInterfaceForAttachement = existingInterfacesMap.get(attachment.getNicName());
            if (existingNetworkInterfaceForAttachement == null || !existingNetworkInterfaceForAttachement.isBond()) {
                continue;
            }
            bondToCheck = CreateOrUpdateBond.fromBond((Bond) existingNetworkInterfaceForAttachement);
        }
        String networkLabel = networkBusinessEntityMap.get(attachment.getNetworkName()).getLabel();
        ValidationResult validationResult = checkBondMode(bondToCheck, networkLabel, attachment.getNetworkName());
        if (!validationResult.isValid()) {
            return validationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            return new ValidationResult(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult networksUniquelyConfiguredOnHost(Collection<NetworkAttachment> attachmentsToConfigure) {
    Set<Guid> usedNetworkIds = new HashSet<>(attachmentsToConfigure.size());
    for (NetworkAttachment attachment : attachmentsToConfigure) {
        boolean alreadyUsedNetworkId = usedNetworkIds.contains(attachment.getNetworkId());
        if (alreadyUsedNetworkId) {
            Network network = existingNetworkRelatedToAttachment(attachment);
            EngineMessage engineMessage = EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, network.getName()));
        } else {
            usedNetworkIds.add(attachment.getNetworkId());
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    if (vmNames.isEmpty()) {
        return ValidationResult.VALID;
    } else {
        final List<String> sortedRemovedNetworks = new ArrayList<>(removedNetworks);
        Collections.sort(sortedRemovedNetworks);
        EngineMessage engineMessage = EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS;
        return new ValidationResult(engineMessage, LinqUtils.concat(ReplacementUtils.replaceAllWith(VAR_NETWORK_NAMES, sortedRemovedNetworks), ReplacementUtils.getListVariableAssignmentStringUsingAllValues(engineMessage, vmNames)));
    }
}
#method_after
@SuppressWarnings("unchecked")
ValidationResult validateNotRemovingUsedNetworkByVms() {
    Collection<String> removedNetworks = new HashSet<>();
    for (NetworkAttachment removedAttachment : removedNetworkAttachments) {
        removedNetworks.add(existingNetworkRelatedToAttachment(removedAttachment).getName());
    }
    final List<String> vmsNames = getVmInterfaceManager().findActiveVmsUsingNetworks(host.getId(), removedNetworks);
    final List<String> removedNetworksList = new ArrayList<>(removedNetworks);
    DetachNetworkUsedByVmValidator detachNetworkUsedByVmValidator = new DetachNetworkUsedByVmValidator(vmsNames, removedNetworksList);
    return detachNetworkUsedByVmValidator.validate();
}
#end_block

#method_before
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.createSetVariableString(VAR_BOND_NAME, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements);
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validRemovedBonds(Collection<NetworkAttachment> attachmentsToConfigure) {
    List<Guid> invalidBondIds = Entities.idsNotReferencingExistingRecords(params.getRemovedBonds(), existingInterfacesMap.unmodifiableEntitiesByIdMap());
    if (!invalidBondIds.isEmpty()) {
        EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
        return new ValidationResult(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, invalidBondIds));
    }
    Map<String, List<Guid>> nicNameToAttachedNetworkAttachmentIds = getIdsOfNetworkAttachmentsRelatedToInterfaceNames(attachmentsToConfigure);
    for (VdsNetworkInterface removedBond : removedBondVdsNetworkInterface) {
        String bondName = removedBond.getName();
        VdsNetworkInterface existingBond = existingInterfacesMap.get(bondName);
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingBond).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        boolean cantRemoveRequiredInterface = nicNameToAttachedNetworkAttachmentIds.containsKey(bondName);
        if (cantRemoveRequiredInterface) {
            List<Guid> networkAttachmentsForNic = nicNameToAttachedNetworkAttachmentIds.get(bondName);
            EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
            List<String> replacements = new ArrayList<>();
            replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
            replacements.addAll(ReplacementUtils.replaceWith(VAR_ATTACHMENT_IDS, networkAttachmentsForNic));
            return new ValidationResult(engineMessage, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (CreateOrUpdateBond modifiedOrNewBond : params.getCreateOrUpdateBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond.toBond()).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (CreateOrUpdateBond modifiedOrNewBond : params.getCreateOrUpdateBonds()) {
        String bondName = modifiedOrNewBond.getName();
        Guid bondId = modifiedOrNewBond.getId();
        /*
             * bondId is provided, but bondName not. This means that user attempted update, but bond of such ID does not
             * exit, thus completors did not complete name.
             */
        if (bondId != null && bondName == null) {
            return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, bondId));
        }
        /*
             * user did not provide neither bondId nor bondName. That means he probably attempted new bond creation
             * but forgot to provide bondName.
             */
        if (bondId == null && bondName == null) {
            return new ValidationResult(EngineMessage.BOND_DOES_NOT_HAVE_NEITHER_ID_NOR_NAME_SPECIFIED);
        }
        /*
             * if (bondId == null && bondName != null) 
             * User provided only bondName, and completors failed to find existing bonds id for that name.
             * We cannot tell, what user wanted to do(create/update). We have to assume, it's new record creation, which
             * is valid scenario.
             */
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        boolean validBondName = bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            EngineMessage engineMessage = EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
ValidationResult validateModifiedBondSlaves(CreateOrUpdateBond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists();
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /* definition of currently processed bond references this slave, but this slave already 'slaves' for
                another bond. This is ok only when this bond will be removed as a part of this request
                or the slave will be removed from its former bond, as a part of this request. */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /* we're creating new bond, and it's definition contains reference to slave already assigned
                        to a different bond. */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && // but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && //  or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validateModifiedBondSlaves(CreateOrUpdateBond modifiedOrNewBond) {
    for (String slaveName : modifiedOrNewBond.getSlaves()) {
        VdsNetworkInterface potentialSlave = existingInterfacesMap.get(slaveName);
        HostInterfaceValidator slaveHostInterfaceValidator = createHostInterfaceValidator(potentialSlave);
        ValidationResult interfaceExists = slaveHostInterfaceValidator.interfaceExists(slaveName);
        if (!interfaceExists.isValid()) {
            return interfaceExists;
        }
        ValidationResult interfaceIsValidSlave = slaveHostInterfaceValidator.interfaceIsValidSlave();
        if (!interfaceIsValidSlave.isValid()) {
            return interfaceIsValidSlave;
        }
        /*
             * definition of currently processed bond references this slave, but this slave already 'slaves' for
             * another bond. This is ok only when this bond will be removed as a part of this request
             * or the slave will be removed from its former bond, as a part of this request.
             */
        String currentSlavesBondName = potentialSlave.getBondName();
        if (potentialSlave.isPartOfBond() && /*
                         * we're creating new bond, and it's definition contains reference to slave already assigned
                         * to a different bond.
                         */
        (!potentialSlave.isPartOfBond(modifiedOrNewBond.getName()) && //  but this bond is also removed in this request, so it's ok.
        !isBondRemoved(currentSlavesBondName) && //  or slave was removed from its former bond
        !bondIsUpdatedAndDoesNotContainCertainSlave(slaveName, currentSlavesBondName))) {
            EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
            return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName));
        }
        ValidationResult slaveHasAttachedNetworksValidationResult = validateSlaveHasNoNetworks(potentialSlave.getName());
        if (!slaveHasAttachedNetworksValidationResult.isValid()) {
            return slaveHasAttachedNetworksValidationResult;
        }
        if (slaveUsedMultipleTimesInDifferentBonds(slaveName)) {
            return new ValidationResult(EngineMessage.NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES, ReplacementUtils.createSetVariableString("NETWORK_INTERFACE_REFERENCED_AS_A_SLAVE_MULTIPLE_TIMES_ENTITY", slaveName));
        }
        ValidationResult slaveHasNoLabelsValidationResult = validateSlaveHasNoLabels(slaveName);
        if (!slaveHasNoLabelsValidationResult.isValid()) {
            return slaveHasNoLabelsValidationResult;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateSlaveHasNoNetworks(String slaveName) {
    for (NetworkAttachment attachment : getAttachmentsToConfigure()) {
        if (Objects.equals(attachment.getNicName(), slaveName)) {
            if (attachment.getId() == null) {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            } else {
                EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
                return new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveName), ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, attachment.getNetworkName()));
            }
        }
    }
    for (VdsNetworkInterface iface : existingInterfaces) {
        if (slaveName.equals(NetworkUtils.stripVlan(iface))) {
            if (iface.getNetworkImplementationDetails() != null && !iface.getNetworkImplementationDetails().isManaged()) {
                return new ValidationResult(EngineMessage.NETWORK_INTERFACE_WITH_UNMANAGED_NETWORK_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(VAR_NETWORK_NAME, iface.getNetworkName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, slaveName));
            }
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : networkIdIsSet(attachment);
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        vr = skipValidation(vr) ? vr : validator.nicNameIsSet();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        vr = skipValidation(vr) ? vr : networkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(params.getNetworkAttachments());
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS);
}
#method_after
private ValidationResult referencedNetworkAttachmentActuallyExists(Guid networkAttachmentId) {
    boolean doesNotReferenceExistingNetworkAttachment = networkAttachmentId == null;
    if (doesNotReferenceExistingNetworkAttachment) {
        return ValidationResult.VALID;
    }
    for (NetworkAttachment existingAttachment : existingAttachments) {
        if (existingAttachment.getId().equals(networkAttachmentId)) {
            return ValidationResult.VALID;
        }
    }
    EngineMessage engineMessage = EngineMessage.NETWORK_ATTACHMENT_NOT_EXISTS;
    String id = networkAttachmentId.toString();
    String replacement = ReplacementUtils.getVariableAssignmentString(engineMessage, id);
    return new ValidationResult(engineMessage, replacement);
}
#end_block

#method_before
private ValidationResult validateCoherentNicIdentification(CreateOrUpdateBond createOrUpdateBond) {
    Guid nicId = createOrUpdateBond.getId();
    String nicName = createOrUpdateBond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(createOrUpdateBond.getName(), nicId, nicName, message, existingInterfacesMap);
}
#method_after
private ValidationResult validateCoherentNicIdentification(CreateOrUpdateBond createOrUpdateBond) {
    Guid nicId = createOrUpdateBond.getId();
    String nicName = createOrUpdateBond.getName();
    EngineMessage message = EngineMessage.BOND_REFERENCES_NICS_INCOHERENTLY;
    return hostSetupNetworksValidatorHelper.validateCoherentIdentification(nicName, nicId, nicName, message, existingInterfacesMap);
}
#end_block

#method_before
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(attachment.getNicName(), attachment.getNicId());
    if (nicActuallyExistsOrReferencesNewBond) {
        return ValidationResult.VALID;
    }
    // Duplicate message / fix other code as well?
    return new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST);
}
#method_after
private ValidationResult nicActuallyExistsOrReferencesNewBond(NetworkAttachment attachment) {
    String nicName = attachment.getNicName();
    Guid nicId = attachment.getNicId();
    boolean nicActuallyExistsOrReferencesNewBond = isNicActuallyExistsOrReferencesNewBond(nicName, nicId);
    return ValidationResult.failWith(EngineMessage.HOST_NETWORK_INTERFACE_HAVING_ID_OR_NAME_DOES_NOT_EXIST, ReplacementUtils.createSetVariableString(VAR_NIC_ID, nicId), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, nicName)).when(!nicActuallyExistsOrReferencesNewBond);
}
#end_block

#method_before
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#method_after
ValidationResult notRemovingLabeledNetworks(NetworkAttachment attachment) {
    Network removedNetwork = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(removedNetwork)) {
        return ValidationResult.VALID;
    }
    boolean networkAttachedToNicByAnotherAttachment = networkAttachmentsByNetworkId.get(removedNetwork.getId()) != null;
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, removedNetwork.getName())).when(!networkAttachedToNicByAnotherAttachment && isNicToConfigureContainTheLabel(attachment.getNicName(), removedNetwork.getLabel()));
}
#end_block

#method_before
ValidationResult validateAttachmentAndNicReferenceSameLabelNotConflict(NetworkAttachment attachment) {
    Network network = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(network)) {
        return ValidationResult.VALID;
    }
    String label = network.getLabel();
    String nicThatShouldHaveTheLabel = nicLabelByLabel.containsKey(label) ? nicLabelByLabel.get(label).getNicName() : null;
    EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString(VAR_INTERFACE_NAME, attachment.getNicName()), ReplacementUtils.createSetVariableString(VAR_LABELED_INTERFACE_NAME, nicThatShouldHaveTheLabel)).unless(nicThatShouldHaveTheLabel == null || nicThatShouldHaveTheLabel.equals(attachment.getNicName()));
}
#method_after
ValidationResult validateAttachmentAndNicReferenceSameLabelNotConflict(NetworkAttachment attachment) {
    Network network = existingNetworkRelatedToAttachment(attachment);
    if (!NetworkUtils.isLabeled(network)) {
        return ValidationResult.VALID;
    }
    String label = network.getLabel();
    String nicThatShouldHaveTheLabel = nicLabelByLabel.containsKey(label) ? nicLabelByLabel.get(label).getNicName() : null;
    EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
    return ValidationResult.failWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString(VAR_NIC_NAME, attachment.getNicName()), ReplacementUtils.createSetVariableString(VAR_LABELED_NIC_NAME, nicThatShouldHaveTheLabel)).unless(nicThatShouldHaveTheLabel == null || nicThatShouldHaveTheLabel.equals(attachment.getNicName()));
}
#end_block

#method_before
private ValidationResult validateCustomProperties() {
    String version = host.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#method_after
private ValidationResult validateCustomProperties() {
    String version = host.getClusterCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validPropertiesForVmNetwork = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validPropertiesForVmNetwork.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesForNonVm = new HashMap<>(validPropertiesForVmNetwork);
    validPropertiesForNonVm.remove("bridge_opts");
    return validateCustomProperties(util, validPropertiesForVmNetwork, validPropertiesForNonVm);
}
#end_block

#method_before
@Test
public void labelBeingAttachedToNonVlanNonSlaveInterfaceAttachToNewSlave() {
    HostSetupNetworksParameters params = createHostSetupNetworksParams();
    VdsNetworkInterface slave = createNic();
    CreateOrUpdateBond createOrUpdateBond = new CreateOrUpdateBond();
    createOrUpdateBond.setName("bond");
    createOrUpdateBond.setSlaves(Collections.singleton(slave.getName()));
    params.setCreateOrUpdateBonds(Collections.singletonList((createOrUpdateBond)));
    assertLabelBeingAttachedToNonVlanNonSlaveInterfaceFailed(params, slave);
}
#method_after
@Test
public void labelBeingAttachedToNonVlanNonSlaveInterfaceAttachToNewSlave() {
    HostSetupNetworksParameters params = createHostSetupNetworksParams();
    VdsNetworkInterface slave = createNic();
    CreateOrUpdateBond createOrUpdateBond = new CreateOrUpdateBond();
    createOrUpdateBond.setName("bond");
    createOrUpdateBond.setSlaves(Collections.singleton(slave.getName()));
    params.setCreateOrUpdateBonds(Collections.singletonList(createOrUpdateBond));
    assertLabelBeingAttachedToNonVlanNonSlaveInterfaceFailed(params, slave);
}
#end_block

#method_before
@Test
public void labelBeingAttachedToNonVlanNonSlaveInterfaceAttachToRemovedSlave() {
    HostSetupNetworksParameters params = createHostSetupNetworksParams();
    VdsNetworkInterface slave = createNic();
    Bond bondWithSlave = new Bond("bond");
    bondWithSlave.setSlaves(Collections.singletonList(slave.getName()));
    CreateOrUpdateBond updatedBond = new CreateOrUpdateBond();
    updatedBond.setName(bondWithSlave.getName());
    updatedBond.setSlaves(new HashSet<>());
    params.setCreateOrUpdateBonds(Collections.singletonList((updatedBond)));
    NicLabel nicLabel = new NicLabel();
    nicLabel.setNicName(slave.getName());
    NicLabelValidator nicLabelValidator = createNicLabelValidator(params, Arrays.asList(bondWithSlave, slave));
    assertThat(nicLabelValidator.labelBeingAttachedToNonVlanNonSlaveInterface(nicLabel), isValid());
}
#method_after
@Test
public void labelBeingAttachedToNonVlanNonSlaveInterfaceAttachToRemovedSlave() {
    HostSetupNetworksParameters params = createHostSetupNetworksParams();
    VdsNetworkInterface slave = createNic();
    Bond bondWithSlave = new Bond("bond");
    bondWithSlave.setSlaves(Collections.singletonList(slave.getName()));
    CreateOrUpdateBond updatedBond = new CreateOrUpdateBond();
    updatedBond.setName(bondWithSlave.getName());
    updatedBond.setSlaves(new HashSet<>());
    params.setCreateOrUpdateBonds(Collections.singletonList(updatedBond));
    NicLabel nicLabel = new NicLabel();
    nicLabel.setNicName(slave.getName());
    NicLabelValidator nicLabelValidator = createNicLabelValidator(params, Arrays.asList(bondWithSlave, slave));
    assertThat(nicLabelValidator.labelBeingAttachedToNonVlanNonSlaveInterface(nicLabel), isValid());
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    return host;
}
#method_after
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getClusterId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    return host;
}
#end_block

#method_before
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    validateEnums(Action.class, action);
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    if (vds.isOvirtNode()) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
            return doAction(VdcActionType.UpgradeOvirtNode, params, action);
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#method_after
@Override
public Response install(Action action) {
    // REVISIT fencing options
    VDS vds = getEntity();
    validateEnums(Action.class, action);
    UpdateVdsActionParameters params = new UpdateVdsActionParameters(vds.getStaticData(), action.getRootPassword(), true);
    params = (UpdateVdsActionParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, params);
    if (vds.isOvirtNode()) {
        params.setReinstallOrUpgrade(true);
        if (action.isSetImage()) {
            params.setoVirtIsoFile(action.getImage());
            return doAction(VdcActionType.UpgradeOvirtNode, params, action);
        }
    }
    return doAction(VdcActionType.UpdateVds, params, action);
}
#end_block

#method_before
@Override
public Response approve(Action action) {
    if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
        update(setCluster(get(), action.getCluster()));
    }
    validateEnums(Action.class, action);
    ApproveVdsParameters params = new ApproveVdsParameters(guid);
    params = (ApproveVdsParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, (VdsOperationActionParameters) params);
    // Set pk authentication as default
    params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    if (action.isSetRootPassword()) {
        params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
        params.setRootPassword(action.getRootPassword());
    } else if (action.isSetSsh() && action.getSsh().isSetAuthenticationMethod()) {
        if (action.getSsh().getAuthenticationMethod().equals(AuthenticationMethod.PASSWORD.value())) {
            params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
            if (action.getSsh().isSetUser() && action.getSsh().getUser().isSetPassword()) {
                params.setPassword(action.getSsh().getUser().getPassword());
            }
        }
    }
    return doAction(VdcActionType.ApproveVds, params, action);
}
#method_after
@Override
public Response approve(Action action) {
    if (action.isSetCluster() && (action.getCluster().isSetId() || action.getCluster().isSetName())) {
        update(setCluster(get(), action.getCluster()));
    }
    validateEnums(Action.class, action);
    ApproveVdsParameters params = new ApproveVdsParameters(guid);
    params = (ApproveVdsParameters) getMapper(Action.class, VdsOperationActionParameters.class).map(action, params);
    // Set pk authentication as default
    params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.PublicKey);
    if (action.isSetRootPassword()) {
        params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
        params.setRootPassword(action.getRootPassword());
    } else if (action.isSetSsh() && action.getSsh().isSetAuthenticationMethod()) {
        if (action.getSsh().getAuthenticationMethod().equals(AuthenticationMethod.PASSWORD.value())) {
            params.setAuthMethod(VdsOperationActionParameters.AuthenticationMethod.Password);
            if (action.getSsh().isSetUser() && action.getSsh().getUser().isSetPassword()) {
                params.setPassword(action.getSsh().getUser().getPassword());
            }
        }
    }
    return doAction(VdcActionType.ApproveVds, params, action);
}
#end_block

#method_before
public BusinessEntityMap<Bond> getBackendHostBonds() {
    List<Bond> backendBonds = getBackendCollection(Bond.class, VdcQueryType.GetHostBondsByHostId, new IdQueryParameters(guid));
    return new BusinessEntityMap<Bond>(backendBonds);
}
#method_after
public BusinessEntityMap<Bond> getBackendHostBonds() {
    List<Bond> backendBonds = getBackendCollection(Bond.class, VdcQueryType.GetHostBondsByHostId, new IdQueryParameters(guid));
    return new BusinessEntityMap<>(backendBonds);
}
#end_block

#method_before
public BusinessEntityMap<VdsNetworkInterface> getBackendNics() {
    List<VdsNetworkInterface> backendNics = getBackendCollection(VdsNetworkInterface.class, VdcQueryType.GetVdsInterfacesByVdsId, new IdQueryParameters(guid));
    return new BusinessEntityMap<VdsNetworkInterface>(backendNics);
}
#method_after
public BusinessEntityMap<VdsNetworkInterface> getBackendNics() {
    List<VdsNetworkInterface> backendNics = getBackendCollection(VdsNetworkInterface.class, VdcQueryType.GetVdsInterfacesByVdsId, new IdQueryParameters(guid));
    return new BusinessEntityMap<>(backendNics);
}
#end_block

#method_before
private Host setCluster(Host host, Cluster cluster) {
    if (cluster.isSetId()) {
        host.setCluster(cluster);
    } else {
        host.setCluster(new Cluster());
        host.getCluster().setId(lookupClusterByName(cluster.getName()).getId().toString());
    }
    return host;
}
#method_after
private Host setCluster(Host host, org.ovirt.engine.api.model.Cluster cluster) {
    if (cluster.isSetId()) {
        host.setCluster(cluster);
    } else {
        host.setCluster(new org.ovirt.engine.api.model.Cluster());
        host.getCluster().setId(lookupClusterByName(cluster.getName()).getId().toString());
    }
    return host;
}
#end_block

#method_before
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name);
}
#method_after
protected Cluster lookupClusterByName(String name) {
    return getEntity(Cluster.class, VdcQueryType.GetClusterByName, new NameQueryParameters(name), "Cluster: name=" + name);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    return doAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(asList(guid), false, action.isSetReason() ? action.getReason() : null), action);
}
#method_after
@Override
public Response deactivate(Action action) {
    boolean stopGlusterService = QueryHelper.getBooleanMatrixParameter(uriInfo, STOP_GLUSTER_SERVICE, true, false);
    return doAction(VdcActionType.MaintenanceNumberOfVdss, new MaintenanceNumberOfVdssParameters(asList(guid), false, action.isSetReason() ? action.getReason() : null, stopGlusterService), action);
}
#end_block

#method_before
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#method_after
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setConnection(iscsiDetails.getAddress());
    cnx.setIqn(iscsiDetails.getTarget());
    cnx.setStorageType(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setPort(iscsiDetails.getPort().toString());
    } else {
        cnx.setPort(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setUserName(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setPassword(iscsiDetails.getPassword());
    }
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#end_block

#method_before
@Override
public Response unregisteredStorageDomainsDiscover(Action action) {
    StorageType storageType = ((action.getIscsi() != null) && (action.getIscsi().getAddress() != null)) ? StorageType.ISCSI : StorageType.FCP;
    // Validate if the Host exists.
    getEntity();
    List<StorageServerConnections> storageServerConnections = new ArrayList<>();
    if (storageType == StorageType.ISCSI) {
        for (String iscsiTarget : action.getIscsiTargets()) {
            StorageServerConnections connectionDetails = getInitializedConnectionIscsiDetails(action);
            connectionDetails.setiqn(iscsiTarget);
            storageServerConnections.add(connectionDetails);
        }
    } else {
    // For FC we don't need to do anything.
    }
    GetUnregisteredBlockStorageDomainsParameters unregisteredBlockStorageDomainsParameters = new GetUnregisteredBlockStorageDomainsParameters(guid, storageType, storageServerConnections);
    try {
        Pair<List<StorageDomain>, List<StorageServerConnections>> pair = getEntity(Pair.class, VdcQueryType.GetUnregisteredBlockStorageDomains, unregisteredBlockStorageDomainsParameters, "GetUnregisteredBlockStorageDomains", true);
        List<StorageDomain> storageDomains = pair.getFirst();
        return actionSuccess(mapToStorageDomains(action, storageDomains));
    } catch (Exception e) {
        return handleError(e, false);
    }
}
#method_after
@Override
public Response unregisteredStorageDomainsDiscover(Action action) {
    StorageType storageType = ((action.getIscsi() != null) && (action.getIscsi().getAddress() != null)) ? StorageType.ISCSI : StorageType.FCP;
    // Validate if the Host exists.
    getEntity();
    List<StorageServerConnections> storageServerConnections = new ArrayList<>();
    if (storageType == StorageType.ISCSI) {
        Action.IscsiTargetsList iscsiTargets = action.getIscsiTargets();
        if (iscsiTargets != null) {
            for (String iscsiTarget : iscsiTargets.getIscsiTargets()) {
                StorageServerConnections connectionDetails = getInitializedConnectionIscsiDetails(action);
                connectionDetails.setIqn(iscsiTarget);
                storageServerConnections.add(connectionDetails);
            }
        }
    } else {
    // For FC we don't need to do anything.
    }
    GetUnregisteredBlockStorageDomainsParameters unregisteredBlockStorageDomainsParameters = new GetUnregisteredBlockStorageDomainsParameters(guid, storageType, storageServerConnections);
    try {
        Pair<List<StorageDomain>, List<StorageServerConnections>> pair = getEntity(Pair.class, VdcQueryType.GetUnregisteredBlockStorageDomains, unregisteredBlockStorageDomainsParameters, "GetUnregisteredBlockStorageDomains", true);
        List<StorageDomain> storageDomains = pair.getFirst();
        return actionSuccess(mapToStorageDomains(action, storageDomains));
    } catch (Exception e) {
        return handleError(e, false);
    }
}
#end_block

#method_before
private Action mapTargets(Action action, List<StorageServerConnections> targets) {
    if (targets != null) {
        for (StorageServerConnections cnx : targets) {
            action.getIscsiTargets().add(map(cnx).getTarget());
        }
    }
    return action;
}
#method_after
private Action mapTargets(Action action, List<StorageServerConnections> targets) {
    if (targets != null) {
        Action.IscsiTargetsList iscsiTargets = new Action.IscsiTargetsList();
        for (StorageServerConnections cnx : targets) {
            iscsiTargets.getIscsiTargets().add(map(cnx).getTarget());
        }
        action.setIscsiTargets(iscsiTargets);
    }
    return action;
}
#end_block

#method_before
private StorageServerConnections getInitializedConnectionIscsiDetails(Action action) {
    StorageServerConnections connectionDetails = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setconnection(iscsiDetails.getAddress());
    connectionDetails.setstorage_type(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setport(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setpassword(iscsiDetails.getPassword());
    }
    return connectionDetails;
}
#method_after
private StorageServerConnections getInitializedConnectionIscsiDetails(Action action) {
    StorageServerConnections connectionDetails = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setConnection(iscsiDetails.getAddress());
    connectionDetails.setStorageType(StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setPort(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setPort(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setUserName(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setPassword(iscsiDetails.getPassword());
    }
    return connectionDetails;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    HostStatisticalQuery query = new HostStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Host, VDS>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    HostStatisticalQuery query = new HostStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<>(entityType, guid, query));
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
    VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming, entity.getStaticData());
    UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, incoming.getRootPassword(), false);
    // Updating Fence-agents is deprecated from this context, so the original, unchanged, list of agents is
    // passed to the engine.
    updateParams.setFenceAgents(entity.getFenceAgents());
    if (incoming.isSetOverrideIptables()) {
        updateParams.setOverrideFirewall(incoming.isOverrideIptables());
    }
    updateParams = (UpdateVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(incoming, (VdsOperationActionParameters) updateParams);
    return updateParams;
}
#method_after
@Override
public VdcActionParametersBase getParameters(Host incoming, VDS entity) {
    VdsStatic updated = getMapper(modelType, VdsStatic.class).map(incoming, entity.getStaticData());
    UpdateVdsActionParameters updateParams = new UpdateVdsActionParameters(updated, incoming.getRootPassword(), false);
    // Updating Fence-agents is deprecated from this context, so the original, unchanged, list of agents is
    // passed to the engine.
    updateParams.setFenceAgents(entity.getFenceAgents());
    if (incoming.isSetOverrideIptables()) {
        updateParams.setOverrideFirewall(incoming.isOverrideIptables());
    }
    updateParams = (UpdateVdsActionParameters) getMapper(Host.class, VdsOperationActionParameters.class).map(incoming, updateParams);
    return updateParams;
}
#end_block

#method_before
private String[] createIncoherentIdentificationErrorReplacements(String violatingEntityId, Guid referringId, String referringName) {
    return new String[] { String.format("$referrerId %s", violatingEntityId), String.format("$referringId %s", referringId), String.format("$referringName %s", referringName) };
}
#method_after
private String[] createIncoherentIdentificationErrorReplacements(String violatingEntityId, Guid referringId, String referringName) {
    return new String[] { ReplacementUtils.createSetVariableString("referrerId", violatingEntityId), ReplacementUtils.createSetVariableString("referringId", referringId), ReplacementUtils.createSetVariableString("referringName", referringName) };
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setVdsGroupCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
}
#method_after
@Before
public void setUp() throws Exception {
    host = new VDS();
    host.setId(Guid.newGuid());
    host.setClusterCompatibilityVersion(Version.v3_5);
    final VdsDynamic vdsDynamic = new VdsDynamic();
    vdsDynamic.setSupportedClusterLevels(TEST_VERSION);
    host.setDynamicData(vdsDynamic);
    bond = new Bond();
    bond.setId(Guid.newGuid());
    when(mockNetworkExclusivenessValidatorResolver.resolveNetworkExclusivenessValidator(TEST_SUPPORTED_VERSIONS)).thenReturn(mockNetworkExclusivenessValidator);
    when(mockNetworkAttachmentIpConfigurationValidator.validateNetworkAttachmentIpConfiguration(any())).thenReturn(ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, labeledNetwork.getName())));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, labeledNetwork.getName())));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    replacements.add(ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
    replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(engineMessage, replacements));
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network network, Guid id) {
    NetworkAttachment networkAttachment = new NetworkAttachment();
    networkAttachment.setId(id);
    networkAttachment.setNetworkId(network.getId());
    networkAttachment.setNetworkName(network.getName());
    return networkAttachment;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic, Guid guid) {
    NetworkAttachment attachment = createNetworkAttachment(networkA, guid);
    if (nic != null) {
        attachment.setNicId(nic.getId());
        attachment.setNicName(nic.getName());
    }
    return attachment;
}
#end_block

#method_before
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic) {
    NetworkAttachment attachment = createNetworkAttachment(networkA, Guid.newGuid());
    attachment.setNicId(nic.getId());
    attachment.setNicName(nic.getName());
    return attachment;
}
#method_after
private NetworkAttachment createNetworkAttachment(Network networkA, VdsNetworkInterface nic) {
    return createNetworkAttachment(networkA, nic, Guid.newGuid());
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBondWithNameAndId();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, createOrUpdateBond.getName()));
    doTestValidModifiedBonds(createOrUpdateBond, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBondWithNameAndId();
    doTestValidModifiedBonds(createOrUpdateBond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, createOrUpdateBond.getName())), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBondWithNameAndId();
    createOrUpdateBond.setSlaves(Stream.of("slaveA", "slaveB").collect(toSet()));
    doTestValidModifiedBonds(createOrUpdateBond, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(null, "bond1", "slaveA", "slaveB");
    doTestValidModifiedBonds(createOrUpdateBond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#method_after
private void doTestValidModifiedBonds(CreateOrUpdateBond createOrUpdateBond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(CreateOrUpdateBond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).build();
    _doTestValidateModifiedBondSlaves(spy(validator), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveInterfaceDoesNotExist() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(Guid.newGuid(), "bond1", "slaveA", "slaveB");
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), new ValidationResult(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST), ValidationResult.VALID, failsWith(EngineMessage.HOST_NETWORK_INTERFACE_NOT_EXIST));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_INTERFACE_NAME, bond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).build();
    _doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(Guid.newGuid(), "bond1", "slaveA", "slaveB");
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_NIC_NAME, createOrUpdateBond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(createOrUpdateBond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces(bond, differentBond, slaveA, slaveB).build();
    _doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveB.getName())));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBond() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ALREADY_IN_BOND;
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces(bond, differentBond, slaveA, slaveB).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveB.getName())));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(differentBond.getId())).addExistingInterfaces(bond, differentBond, slaveA, slaveB).build();
    _doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondWhichGetsRemoved() throws Exception {
    Bond bond = createBond("bondName");
    Bond differentBond = createBond("differentBond");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(differentBond.getId())).addExistingInterfaces(bond, differentBond, slaveA, slaveB).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondButItsDetachedFromItAsAPartOfRequest() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    VdsNetworkInterface slaveC = createBondSlave(differentBond, "slaveC");
    VdsNetworkInterface slaveD = createBondSlave(differentBond, "slaveD");
    setBondSlaves(bond, slaveA, slaveB);
    setBondSlaves(differentBond, slaveC, slaveD);
    HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond), CreateOrUpdateBond.fromBond(differentBond))).addExistingInterfaces(bond, differentBond, slaveA, slaveB, slaveC, slaveD).build();
    _doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveAlreadySlavesForDifferentBondButItsDetachedFromItAsAPartOfRequest() throws Exception {
    Bond bond = createBond("bond1");
    Bond differentBond = createBond("bond2");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    VdsNetworkInterface slaveB = createBondSlave(differentBond, "slaveB");
    VdsNetworkInterface slaveC = createBondSlave(differentBond, "slaveC");
    VdsNetworkInterface slaveD = createBondSlave(differentBond, "slaveD");
    setBondSlaves(bond, slaveA, slaveB);
    setBondSlaves(differentBond, slaveC, slaveD);
    HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond), CreateOrUpdateBond.fromBond(differentBond))).addExistingInterfaces(bond, differentBond, slaveA, slaveB, slaveC, slaveD).build();
    doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    NetworkAttachment attachmentOfNetworkToSlaveA = createNetworkAttachment(networkBeingRemoved, slaveA);
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    final HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces(bond, slaveA, slaveB).addExistingAttachments(attachmentOfNetworkToSlaveA).addNetworks(networkBeingRemoved).build();
    _doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkBeingRemoved.getName())));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsNotRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName("assignedNetwork");
    NetworkAttachment attachmentOfNetworkToSlaveA = createNetworkAttachment(networkBeingRemoved, slaveA);
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    setBondSlaves(bond, slaveA, slaveB);
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    final HostSetupNetworksValidator build = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(CreateOrUpdateBond.fromBond(bond))).addExistingInterfaces(bond, slaveA, slaveB).addExistingAttachments(attachmentOfNetworkToSlaveA).addNetworks(networkBeingRemoved).build();
    doTestValidateModifiedBondSlaves(spy(build), ValidationResult.VALID, ValidationResult.VALID, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, slaveA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkBeingRemoved.getName())));
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setId(Guid.newGuid());
    removedNetworkAttachment.setNicName(slaveA.getName());
    setBondSlaves(bond, slaveA, slaveB);
    final HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedNetworkAttachments(removedNetworkAttachment)).addExistingInterfaces(bond, slaveA, slaveB).addExistingAttachments(removedNetworkAttachment).addNetworks(networkBeingRemoved).build();
    _doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveHasNetworkAssignedWhichIsRemovedAsAPartOfRequest() throws Exception {
    Bond bond = createBond();
    Network networkBeingRemoved = new Network();
    networkBeingRemoved.setName("assignedNetwork");
    VdsNetworkInterface slaveA = createBondSlave(bond, "slaveA");
    slaveA.setNetworkName(networkBeingRemoved.getName());
    VdsNetworkInterface slaveB = createBondSlave(bond, "slaveB");
    NetworkAttachment removedNetworkAttachment = new NetworkAttachment();
    removedNetworkAttachment.setId(Guid.newGuid());
    removedNetworkAttachment.setNicName(slaveA.getName());
    setBondSlaves(bond, slaveA, slaveB);
    final HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedNetworkAttachments(removedNetworkAttachment)).addExistingInterfaces(bond, slaveA, slaveB).addExistingAttachments(removedNetworkAttachment).addNetworks(networkBeingRemoved).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, ValidationResult.VALID, isValid());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    host.setVdsGroupCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(params).addNetworks(networkA).build());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED;
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, networkA.getName())));
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testValidateCustomPropertiesWhenCustomPropertiesFeatureIsNotSupported() throws Exception {
    Network networkA = createNetworkWithName("networkA");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    Map<String, String> customProperties = new HashMap<>();
    customProperties.put("a", "b");
    networkAttachment.setProperties(customProperties);
    host.setClusterCompatibilityVersion(Version.v3_4);
    HostSetupNetworksParameters params = new HostSetupNetworksParameters(host.getId());
    params.setNetworkAttachments(Collections.singletonList(networkAttachment));
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(params).addNetworks(networkA).build());
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED;
    assertThat(validator.validateCustomProperties(null, Collections.<String, String>emptyMap(), Collections.<String, String>emptyMap()), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, networkA.getName())));
}
#end_block

#method_before
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    Bond bond = new Bond();
    bond.setName("bond1");
    setBondSlaves(bond, nicA, nicB);
    when(networkDaoMock.get(eq(networkA.getId()))).thenReturn(networkA);
    when(networkClusterDaoMock.get(new NetworkClusterId(host.getVdsGroupId(), networkA.getId()))).thenReturn(mock(NetworkCluster.class));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(CreateOrUpdateBond.fromBond(bond)).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#method_after
@Test
public void testAddNetworkToNicAlongWithAddingItIntoBond() {
    Network networkA = createNetworkWithName("networkA");
    VdsNetworkInterface nicA = createNic("nicA");
    VdsNetworkInterface nicB = createNic("nicB");
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA, (Guid) null);
    networkAttachment.setNicId(nicA.getId());
    networkAttachment.setNicName(nicA.getName());
    networkAttachment.setNetworkId(networkA.getId());
    networkAttachment.setNetworkName(networkA.getName());
    CreateOrUpdateBond createOrUpdateBond = createNewCreateOrUpdateBond(Guid.newGuid(), "bond1", nicA.getName(), nicB.getName());
    addNetworkIdToNetworkDaoMock(networkA);
    addNetworkToClusterDaoMock(networkA.getId());
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addNetworkAttachments(networkAttachment).addBonds(createOrUpdateBond).build()).addExistingInterfaces(nicA, nicB).addNetworks(networkA).build();
    ValidationResult validate = validator.validate();
    assertThat(validate, not(isValid()));
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ADDED_TO_BOND_AND_NETWORK_IS_ATTACHED_TO_IT_AT_THE_SAME_TIME;
    assertThat(validate, failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, nicA.getName()), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, networkA.getName())));
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    host.setVdsGroupCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesNotPresent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    host.setVdsGroupCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#method_after
@Test
public void testValidateQosOverriddenInterfacesWhenAttachmentHasQosOverriddenAndRequiredValuesPresentButInconsistent() {
    EngineMessage hostNetworkQosValidatorFailure = EngineMessage.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_INCONSISTENT_VALUES;
    host.setClusterCompatibilityVersion(Version.v3_6);
    Network network = createNetworkWithName("network");
    HostSetupNetworksValidator validator = createValidatorForTestingValidateQosOverridden(network);
    HostSetupNetworksValidator validatorSpy = spy(validator);
    HostNetworkQosValidator hostNetworkQosValidatorMock = mock(HostNetworkQosValidator.class);
    when(hostNetworkQosValidatorMock.requiredQosValuesPresentForOverriding(eq(network.getName()))).thenReturn(ValidationResult.VALID);
    when(hostNetworkQosValidatorMock.valuesConsistent(eq(network.getName()))).thenReturn(new ValidationResult(hostNetworkQosValidatorFailure));
    doReturn(hostNetworkQosValidatorMock).when(validatorSpy).createHostNetworkQosValidator(any(HostNetworkQos.class));
    assertThat(validatorSpy.validateQosOverriddenInterfaces(), ValidationResultMatchers.failsWith(hostNetworkQosValidatorFailure));
    verify(hostNetworkQosValidatorMock).requiredQosValuesPresentForOverriding(eq(network.getName()));
    verify(hostNetworkQosValidatorMock).valuesConsistent(eq(network.getName()));
    verifyNoMoreInteractions(hostNetworkQosValidatorMock);
}
#end_block

#method_before
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC_ENTITY", network.getName()), ReplacementUtils.createSetVariableString("interfaceName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledInterfaceName", nicLabel.getNicName())));
    }
}
#method_after
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString("nicName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledNicName", nicLabel.getNicName())));
    }
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator, new UnmanagedNetworkValidator());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().setupNetworks(generateNetworks(), generateBonds(), generateOptions());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    httpTask = getBroker().setupNetworks(generateNetworks(), generateBonds(), generateOptions(), getParameters().isManagementNetworkChanged());
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    for (HostNetwork hostNetwork : getParameters().getNetworks()) {
        Map<String, Object> attributes = new HashMap<>();
        if (hostNetwork.isBonding()) {
            attributes.put("bonding", hostNetwork.getNicName());
        } else {
            attributes.put("nic", hostNetwork.getNicName());
        }
        if (hostNetwork.isVlan()) {
            attributes.put("vlan", hostNetwork.getVlan().toString());
        }
        if (hostNetwork.getMtu() == 0) {
            attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu().toString());
        } else {
            attributes.put(VdsProperties.MTU, String.valueOf(hostNetwork.getMtu()));
        }
        attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
        if (hostNetwork.isVmNetwork()) {
            attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
        }
        if (hostNetwork.getBootProtocol() != null) {
            addBootProtocol(attributes, hostNetwork);
        }
        if (hostNetwork.isDefaultRoute()) {
            attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (hostNetwork.hasProperties()) {
            attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
        }
        if (getParameters().getHostNetworkQosSupported() && hostNetwork.isQosConfiguredOnInterface()) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
            qosMapper.serialize(hostNetwork.getQos());
        }
        networks.put(hostNetwork.getNetworkName(), attributes);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<>();
    for (HostNetwork hostNetwork : getParameters().getNetworks()) {
        Map<String, Object> attributes = new HashMap<>();
        if (hostNetwork.isBonding()) {
            attributes.put("bonding", hostNetwork.getNicName());
        } else {
            attributes.put("nic", hostNetwork.getNicName());
        }
        if (hostNetwork.isVlan()) {
            attributes.put("vlan", hostNetwork.getVlan().toString());
        }
        if (hostNetwork.getMtu() == 0) {
            attributes.put(VdsProperties.MTU, NetworkUtils.getDefaultMtu());
        } else {
            attributes.put(VdsProperties.MTU, hostNetwork.getMtu());
        }
        attributes.put("bridged", Boolean.toString(hostNetwork.isVmNetwork()));
        if (hostNetwork.isVmNetwork()) {
            attributes.put(VdsProperties.STP, hostNetwork.isStp() ? "yes" : "no");
        }
        if (hostNetwork.getBootProtocol() != null) {
            addBootProtocol(attributes, hostNetwork);
        }
        if (hostNetwork.isDefaultRoute()) {
            attributes.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (hostNetwork.hasProperties()) {
            attributes.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, hostNetwork.getProperties());
        }
        if (getParameters().getHostNetworkQosSupported() && hostNetwork.isQosConfiguredOnInterface()) {
            HostNetworkQosMapper qosMapper = new HostNetworkQosMapper(attributes);
            qosMapper.serialize(hostNetwork.getQos());
        }
        networks.put(hostNetwork.getNetworkName(), attributes);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private Map<String, Object> generateOptions() {
    Map<String, Object> options = new HashMap<>();
    options.put(VdsProperties.CONNECTIVITY_CHECK, Boolean.toString(getParameters().isRollbackOnFailure()));
    // VDSM uses the connectivity timeout only if 'connectivityCheck' is set to true
    if (getParameters().isRollbackOnFailure()) {
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, getParameters().getConectivityTimeout());
    }
    return options;
}
#method_after
private Map<String, Object> generateOptions() {
    Map<String, Object> options = new HashMap<>();
    options.put(VdsProperties.CONNECTIVITY_CHECK, Boolean.toString(getParameters().isRollbackOnFailure()));
    // VDSM uses the connectivity timeout only if 'connectivityCheck' is set to true
    if (getParameters().isRollbackOnFailure()) {
        options.put(VdsProperties.CONNECTIVITY_TIMEOUT, getParameters().getConnectivityTimeout());
    }
    return options;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__SETUP);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__NETWORKS);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__SETUP);
    addValidationMessage(EngineMessage.VAR__TYPE__NETWORKS);
}
#end_block

#method_before
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getCreateOrUpdateBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
}
#method_after
private void completeMissingDataInParameters() {
    NicNameNicIdCompleter nicNameNicIdCompleter = new NicNameNicIdCompleter(getExistingNics());
    nicNameNicIdCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments());
    nicNameNicIdCompleter.completeBonds(getParameters().getCreateOrUpdateBonds());
    nicNameNicIdCompleter.completeNetworkAttachments(getExistingAttachments());
    nicNameNicIdCompleter.completeLabels(getParameters().getLabels());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getParameters().getNetworkAttachments(), getNetworkBusinessEntityMap());
    networkIdNetworkNameCompleter.completeNetworkAttachments(getExistingAttachments(), getNetworkBusinessEntityMap());
    NicLabelsCompleter labelsCompleter = new NicLabelsCompleter(getParameters(), getExistingAttachments(), getClusterNetworks(), getExistingNicsBusinessEntityMap());
    labelsCompleter.completeNetworkAttachments();
    fillInUnsetIpConfigs();
}
#end_block

#method_before
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver);
    return validator.validate();
}
#method_after
private ValidationResult validateWithHostSetupNetworksValidator(VDS host) {
    HostSetupNetworksValidator validator = new HostSetupNetworksValidator(host, getParameters(), getExistingNics(), getExistingAttachments(), getNetworkBusinessEntityMap(), managementNetworkUtil, networkClusterDao, networkDao, vdsDao, hostSetupNetworksValidatorHelper, vmDao, networkExclusivenessValidatorResolver, networkAttachmentIpConfigurationValidator, unmanagedNetworkValidator);
    return validator.validate();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock()) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                logMonitorLockReleased("Host setup networks");
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (noChangesDetected()) {
        log.info("No changes were detected in setup networks for host '{}' (ID: '{}')", getVdsName(), getVdsId());
        setSucceeded(true);
        return;
    }
    int timeout = getSetupNetworksTimeout();
    FutureVDSCall<VDSReturnValue> setupNetworksTask = invokeSetupNetworksCommand(timeout);
    try {
        VDSReturnValue retVal = setupNetworksTask.get(timeout, TimeUnit.SECONDS);
        if (retVal != null) {
            if (!retVal.getSucceeded() && retVal.getVdsError() == null && getParameters().rollbackOnFailure()) {
                throw new EngineException(EngineError.SETUP_NETWORKS_ROLLBACK, retVal.getExceptionString());
            }
            VdsHandler.handleVdsResult(retVal);
            if (retVal.getSucceeded()) {
                try (EngineLock monitoringLock = acquireMonitorLock("Host setup networks")) {
                    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
                    VDS updatedHost = (VDS) returnValue.getReturnValue();
                    persistNetworkChanges(updatedHost);
                }
                setSucceeded(true);
            }
        }
    } catch (TimeoutException e) {
        log.debug("Host Setup networks command timed out for {} seconds", timeout);
    }
}
#end_block

#method_before
private void removeUnchangedBonds(List<VdsNetworkInterface> existingNics) {
    Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(existingNics);
    List<CreateOrUpdateBond> createOrUpdateBonds = getParameters().getCreateOrUpdateBonds();
    for (Iterator<CreateOrUpdateBond> iterator = createOrUpdateBonds.iterator(); iterator.hasNext(); ) {
        CreateOrUpdateBond bondFromRequest = iterator.next();
        Guid idOfBondFromRequest = bondFromRequest.getId();
        boolean bondFromRequestIsNewBond = idOfBondFromRequest == null;
        if (!bondFromRequestIsNewBond) {
            if (bondFromRequest.equalToBond((Bond) nicsById.get(idOfBondFromRequest))) {
                iterator.remove();
                break;
            }
        }
    }
}
#method_after
private void removeUnchangedBonds(List<VdsNetworkInterface> existingNics) {
    Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(existingNics);
    List<CreateOrUpdateBond> createOrUpdateBonds = getParameters().getCreateOrUpdateBonds();
    for (Iterator<CreateOrUpdateBond> iterator = createOrUpdateBonds.iterator(); iterator.hasNext(); ) {
        CreateOrUpdateBond bondFromRequest = iterator.next();
        Guid idOfBondFromRequest = bondFromRequest.getId();
        boolean bondFromRequestIsNewBond = idOfBondFromRequest == null;
        if (!bondFromRequestIsNewBond) {
            if (bondFromRequest.equalToBond((Bond) nicsById.get(idOfBondFromRequest))) {
                iterator.remove();
            }
        }
    }
}
#end_block

#method_before
public boolean attachmentFromRequestIsEqualToAlreadyExistingOne(NetworkAttachment networkAttachmentFromRequest, NetworkAttachment existingNetworkAttachment) {
    return existingNetworkAttachment != null && // when flag 'isOverrideConfiguration' is set, NetworkAttachment from request cannot be ignored.
    !networkAttachmentFromRequest.isOverrideConfiguration() && Objects.equals(networkAttachmentFromRequest.getId(), existingNetworkAttachment.getId()) && Objects.equals(networkAttachmentFromRequest.getNetworkId(), existingNetworkAttachment.getNetworkId()) && Objects.equals(networkAttachmentFromRequest.getNetworkName(), existingNetworkAttachment.getNetworkName()) && Objects.equals(networkAttachmentFromRequest.getNicId(), existingNetworkAttachment.getNicId()) && Objects.equals(networkAttachmentFromRequest.getHostNetworkQos(), existingNetworkAttachment.getHostNetworkQos()) && Objects.equals(networkAttachmentFromRequest.getNicName(), existingNetworkAttachment.getNicName()) && Objects.equals(networkAttachmentFromRequest.getIpConfiguration(), existingNetworkAttachment.getIpConfiguration()) && Objects.equals(networkAttachmentFromRequest.getProperties(), existingNetworkAttachment.getProperties());
}
#method_after
public boolean attachmentFromRequestIsEqualToAlreadyExistingOne(NetworkAttachment networkAttachmentFromRequest, NetworkAttachment existingNetworkAttachment) {
    return existingNetworkAttachment != null && Objects.equals(networkAttachmentFromRequest.getId(), existingNetworkAttachment.getId()) && Objects.equals(networkAttachmentFromRequest.getNetworkId(), existingNetworkAttachment.getNetworkId()) && Objects.equals(networkAttachmentFromRequest.getNetworkName(), existingNetworkAttachment.getNetworkName()) && Objects.equals(networkAttachmentFromRequest.getNicId(), existingNetworkAttachment.getNicId()) && Objects.equals(networkAttachmentFromRequest.getHostNetworkQos(), existingNetworkAttachment.getHostNetworkQos()) && Objects.equals(networkAttachmentFromRequest.getNicName(), existingNetworkAttachment.getNicName()) && Objects.equals(networkAttachmentFromRequest.getIpConfiguration(), existingNetworkAttachment.getIpConfiguration()) && Objects.equals(networkAttachmentFromRequest.getProperties(), existingNetworkAttachment.getProperties());
}
#end_block

#method_before
private void removeUnchangedAttachments(List<NetworkAttachment> existingAttachments) {
    Map<Guid, NetworkAttachment> existingAttachmentsById = Entities.businessEntitiesById(existingAttachments);
    for (Iterator<NetworkAttachment> iterator = getParameters().getNetworkAttachments().iterator(); iterator.hasNext(); ) {
        NetworkAttachment attachmentFromRequest = iterator.next();
        Guid idOfAttachmentFromRequest = attachmentFromRequest.getId();
        boolean attachmentFromRequestIsNewAttachment = idOfAttachmentFromRequest == null;
        if (!attachmentFromRequestIsNewAttachment) {
            NetworkAttachment existingAttachment = existingAttachmentsById.get(idOfAttachmentFromRequest);
            if (attachmentFromRequestIsEqualToAlreadyExistingOne(attachmentFromRequest, existingAttachment)) {
                iterator.remove();
                break;
            }
        }
    }
}
#method_after
private void removeUnchangedAttachments(List<NetworkAttachment> existingAttachments) {
    Map<Guid, NetworkAttachment> existingAttachmentsById = Entities.businessEntitiesById(existingAttachments);
    for (Iterator<NetworkAttachment> iterator = getParameters().getNetworkAttachments().iterator(); iterator.hasNext(); ) {
        NetworkAttachment attachmentFromRequest = iterator.next();
        Guid idOfAttachmentFromRequest = attachmentFromRequest.getId();
        boolean attachmentFromRequestIsNewAttachment = idOfAttachmentFromRequest == null;
        // when flag 'isOverrideConfiguration' is set, NetworkAttachment from request cannot be ignored.
        boolean overridingConfiguration = attachmentFromRequest.isOverrideConfiguration();
        if (!attachmentFromRequestIsNewAttachment && !overridingConfiguration) {
            NetworkAttachment existingAttachment = existingAttachmentsById.get(idOfAttachmentFromRequest);
            if (attachmentFromRequestIsEqualToAlreadyExistingOne(attachmentFromRequest, existingAttachment)) {
                iterator.remove();
            }
        }
    }
}
#end_block

#method_before
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface nic = Entities.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = nic.getNetworkImplementationDetails();
        boolean networkIsNotInSync = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkIsNotInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", existingNetworkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult checkForOutOfSyncNetworks() {
    for (NetworkAttachment networkAttachment : getParameters().getNetworkAttachments()) {
        boolean newNetworkAttachment = networkAttachment.getId() == null;
        if (newNetworkAttachment) {
            // attachment to be yet created cannot be out of sync.
            continue;
        }
        boolean doNotCheckForOutOfSync = networkAttachment.isOverrideConfiguration();
        if (doNotCheckForOutOfSync) {
            continue;
        }
        Map<Guid, NetworkAttachment> existingNetworkAttachmentMap = Entities.businessEntitiesById(getExistingAttachments());
        NetworkAttachment existingNetworkAttachment = existingNetworkAttachmentMap.get(networkAttachment.getId());
        VdsNetworkInterface nic = NetworkUtils.hostInterfacesByNetworkName(getExistingNics()).get(existingNetworkAttachment.getNetworkName());
        NetworkImplementationDetails networkImplementationDetails = nic.getNetworkImplementationDetails();
        boolean networkIsNotInSync = networkImplementationDetails != null && !networkImplementationDetails.isInSync();
        if (networkIsNotInSync) {
            return new ValidationResult(EngineMessage.NETWORKS_NOT_IN_SYNC, ReplacementUtils.createSetVariableString("NETWORK_NOT_IN_SYNC", existingNetworkAttachment.getNetworkName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private FutureVDSCall<VDSReturnValue> invokeSetupNetworksCommand(int timeout) {
    final HostSetupNetworksVdsCommandParameters parameters = createSetupNetworksParameters(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = getBackend().getResourceManager().runFutureVdsCommand(FutureVDSCommandType.HostSetupNetworks, parameters);
    if (parameters.isRollbackOnFailure()) {
        HostSetupNetworkPoller poller = new HostSetupNetworkPoller();
        while (!setupNetworksTask.isDone()) {
            poller.poll(getVdsId());
        }
    }
    return setupNetworksTask;
}
#method_after
private FutureVDSCall<VDSReturnValue> invokeSetupNetworksCommand(int timeout) {
    final HostSetupNetworksVdsCommandParameters parameters = createSetupNetworksParameters(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = getVdsBroker().runFutureVdsCommand(FutureVDSCommandType.HostSetupNetworks, parameters);
    if (parameters.isRollbackOnFailure()) {
        HostSetupNetworkPoller poller = new HostSetupNetworkPoller();
        while (!setupNetworksTask.isDone()) {
            poller.poll(getVdsId());
        }
    }
    return setupNetworksTask;
}
#end_block

#method_before
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getCreateOrUpdateBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getVdsGroupCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    return hostCmdParams;
}
#method_after
private HostSetupNetworksVdsCommandParameters createSetupNetworksParameters(int timeout) {
    final HostSetupNetworksVdsCommandParameters hostCmdParams = new HostSetupNetworksVdsCommandParameters(getVds(), getNetworksToConfigure(), getAllNetworksToRemove(), getParameters().getCreateOrUpdateBonds(), getRemovedBondNames());
    hostCmdParams.setRollbackOnFailure(getParameters().rollbackOnFailure());
    hostCmdParams.setConnectivityTimeout(timeout);
    boolean hostNetworkQosSupported = FeatureSupported.hostNetworkQos(getVds().getClusterCompatibilityVersion());
    hostCmdParams.setHostNetworkQosSupported(hostNetworkQosSupported);
    hostCmdParams.setManagementNetworkChanged(isManagementNetworkChanged());
    return hostCmdParams;
}
#end_block

#method_before
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getVdsGroupId()) && ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && (ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#method_after
private boolean defaultRouteRequired(Network network, IpConfiguration ipConfiguration) {
    return managementNetworkUtil.isManagementNetwork(network.getId(), getVds().getClusterId()) && ipConfiguration != null && ipConfiguration.hasPrimaryAddressSet() && (ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.DHCP || ipConfiguration.getPrimaryAddress().getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(ipConfiguration.getPrimaryAddress().getGateway()));
}
#end_block

#method_before
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
            // save the new network topology to DB
            hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
            getVdsDynamicDao().updateNetConfigDirty(getVds().getId(), getVds().getNetConfigDirty());
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getModifiedNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return null;
        }
    });
}
#method_after
private void persistNetworkChanges(final VDS updatedHost) {
    TransactionSupport.executeInNewTransaction(() -> {
        UserConfiguredNetworkData userConfiguredNetworkData = new UserConfiguredNetworkData(getParameters().getNetworkAttachments(), applyUserConfiguredNics());
        // save the new network topology to DB
        hostNetworkTopologyPersister.persistAndEnforceNetworkCompliance(updatedHost, false, userConfiguredNetworkData);
        getVdsDynamicDao().updateNetConfigDirty(updatedHost.getId(), updatedHost.getNetConfigDirty());
        // Update cluster networks (i.e. check if need to activate each new network)
        for (Network net : getModifiedNetworks()) {
            NetworkClusterHelper.setStatus(getClusterId(), net);
        }
        return null;
    });
}
#end_block

#method_before
private List<Network> getClusterNetworks() {
    if (clusterNetworks == null) {
        clusterNetworks = getNetworkDao().getAllForCluster(getVdsGroupId());
    }
    return clusterNetworks;
}
#method_after
private List<Network> getClusterNetworks() {
    if (clusterNetworks == null) {
        clusterNetworks = getNetworkDao().getAllForCluster(getClusterId());
    }
    return clusterNetworks;
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("rollbackOnFailure", isRollbackOnFailure()).append("conectivityTimeout", getConectivityTimeout()).append("hostNetworkQosSupported", getHostNetworkQosSupported()).append("networks", Entities.collectionToString(getNetworks(), "\t\t")).append("removedNetworks", getRemovedNetworks()).append("bonds", Entities.collectionToString(getCreateOrUpdateBonds(), "\t\t")).append("removedBonds", getRemovedBonds());
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("rollbackOnFailure", isRollbackOnFailure()).append("connectivityTimeout", getConnectivityTimeout()).append("hostNetworkQosSupported", getHostNetworkQosSupported()).append("networks", Entities.collectionToString(getNetworks(), "\t\t")).append("removedNetworks", getRemovedNetworks()).append("bonds", Entities.collectionToString(getCreateOrUpdateBonds(), "\t\t")).append("removedBonds", getRemovedBonds());
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getClusterCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
private void commitNetworkChanges(VdsNetworkInterface iface, List<LogicalNetworkModel> networks) {
    NetworkInterfaceModel bondModel = nicMap.get(iface.getName());
    NetworkOperation.attachNetworks(bondModel, new ArrayList<LogicalNetworkModel>(networks), hostSetupNetworksParametersData);
}
#method_after
private void commitNetworkChanges(VdsNetworkInterface iface, List<LogicalNetworkModel> networks) {
    NetworkInterfaceModel bondModel = nicMap.get(iface.getName());
    NetworkOperation.attachNetworks(bondModel, new ArrayList<>(networks), hostSetupNetworksParametersData);
}
#end_block

#method_before
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#method_after
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getClusterId());
}
#end_block

#method_before
public void updateVm(Guid vmId, String vdsmHash) {
    if (!VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId)) && isVmDevicesChanged(vmId, vdsmHash, fetchTime)) {
        lockTouchedVm(vmId);
        addVmToUpdate(vmId);
    }
}
#method_after
public void updateVm(Guid vmId, String vdsmHash) {
    if (!VmDeviceCommonUtils.isOldClusterVersion(getGroupCompatibilityVersion(vdsId)) && isVmDevicesChanged(vmId, vdsmHash, fetchTime)) {
        lockTouchedVm(vmId);
        addVmToProcess(vmId);
    }
}
#end_block

#method_before
public void updateDevice(VmDevice device) {
    if (isVmDeviceChanged(device.getId(), fetchTime)) {
        lockTouchedVm(device.getVmId());
        addDeviceToUpdate(device);
    }
}
#method_after
public void updateDevice(VmDevice device) {
    if (isVmDeviceChanged(device.getId(), fetchTime)) {
        lockTouchedVm(device.getVmId());
        addDeviceToProcess(device);
    }
}
#end_block

#method_before
public void removeDevice(VmDeviceId deviceId) {
    if (isVmDeviceChanged(deviceId, fetchTime)) {
        lockTouchedVm(deviceId.getVmId());
        addRemovedDeviceId(deviceId);
    }
}
#method_after
public void removeDevice(VmDeviceId deviceId) {
    if (isVmDeviceChanged(deviceId, fetchTime)) {
        lockTouchedVm(deviceId.getVmId());
        addDeviceIdToRemove(deviceId);
    }
}
#end_block

#method_before
public void flush() {
    Map<String, Object>[] vmInfos = getVmInfo(vdsId, getVmsToUpdate());
    if (vmInfos != null) {
        for (Map<String, Object> vmInfo : vmInfos) {
            processFullList(vmInfo);
        }
    }
    for (VmDevice deviceToUpdate : getDevicesToUpdate()) {
        processDeviceUpdate(this, deviceToUpdate);
    }
    saveDevicesToDb(this);
    unlockTouchedVms();
}
#method_after
public void flush() {
    Map<String, Object>[] vmInfos = getVmInfo(vdsId, getVmsToProcess());
    if (vmInfos != null) {
        for (Map<String, Object> vmInfo : vmInfos) {
            processFullList(vmInfo);
        }
    }
    for (VmDevice deviceToProcess : getDevicesToProcess()) {
        processDevice(this, deviceToProcess);
    }
    saveDevicesToDb(this);
    unlockTouchedVms();
}
#end_block

#method_before
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addAddedDevice(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addUpdatedDevice(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#method_after
private void processVmDevices(Change change, Map<String, Object> vmInfo) {
    Guid vmId = getVmId(vmInfo);
    Set<Guid> processedDeviceIds = new HashSet<>();
    List<VmDevice> dbDevices = getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> dbDeviceMap = Entities.businessEntitiesById(dbDevices);
    for (Object o : (Object[]) vmInfo.get(VdsProperties.Devices)) {
        Map<String, Object> vdsmDevice = (Map<String, Object>) o;
        if (vdsmDevice.get(VdsProperties.Address) == null) {
            logDeviceInformation(vmId, vdsmDevice);
            continue;
        }
        Guid deviceId = getDeviceId(vdsmDevice);
        VmDevice dbDevice = dbDeviceMap.get(new VmDeviceId(deviceId, vmId));
        String logicalName = getDeviceLogicalName(change.getVdsId(), vmInfo, vdsmDevice);
        if (deviceId == null || dbDevice == null) {
            VmDevice newDevice = buildNewVmDevice(vmId, vdsmDevice, logicalName);
            change.addDeviceToAdd(newDevice);
            deviceId = newDevice.getDeviceId();
        } else {
            dbDevice.setIsPlugged(Boolean.TRUE);
            dbDevice.setAddress(vdsmDevice.get(VdsProperties.Address).toString());
            dbDevice.setAlias(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.Alias)));
            dbDevice.setLogicalName(logicalName);
            dbDevice.setHostDevice(StringUtils.defaultString((String) vdsmDevice.get(VdsProperties.HostDev)));
            change.addDeviceToUpdate(dbDevice);
        }
        processedDeviceIds.add(deviceId);
    }
    handleRemovedDevices(change, vmId, processedDeviceIds, dbDevices);
}
#end_block

#method_before
private void handleRemovedDevices(Change change, Guid vmId, Set<Guid> libvirtDevices, List<VmDevice> dbDevices) {
    for (VmDevice device : dbDevices) {
        if (libvirtDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (deviceWithoutAddress(device)) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setIsPlugged(Boolean.FALSE);
                device.setAddress("");
                change.addUpdatedDevice(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            change.addRemovedDeviceId(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#method_after
private void handleRemovedDevices(Change change, Guid vmId, Set<Guid> libvirtDevices, List<VmDevice> dbDevices) {
    for (VmDevice device : dbDevices) {
        if (libvirtDevices.contains(device.getDeviceId())) {
            continue;
        }
        if (deviceWithoutAddress(device)) {
            continue;
        }
        if (device.getIsManaged()) {
            if (device.getIsPlugged()) {
                device.setIsPlugged(Boolean.FALSE);
                device.setAddress("");
                change.addDeviceToUpdate(device);
                log.debug("VM '{}' managed pluggable device was unplugged : '{}'", vmId, device);
            } else if (!devicePluggable(device)) {
                log.error("VM '{}' managed non pluggable device was removed unexpectedly from libvirt: '{}'", vmId, device);
            }
        } else {
            change.addDeviceIdToRemove(device.getId());
            log.debug("VM '{}' unmanaged device was marked for remove : {1}", vmId, device);
        }
    }
}
#end_block

#method_before
private void saveDevicesToDb(Change change) {
    getVmDeviceDao().updateAllInBatch(change.getUpdatedDevices());
    if (!change.getRemovedDeviceIds().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.getRemovedDeviceIds());
            return null;
        });
    }
    if (!change.getAddedDevices().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.getAddedDevices());
            return null;
        });
    }
    if (!change.touchedVms.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.touchedVms.stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
    }
}
#method_after
private void saveDevicesToDb(Change change) {
    getVmDeviceDao().updateAllInBatch(change.getDevicesToUpdate());
    if (!change.getDeviceIdsToRemove().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().removeAll(change.getDeviceIdsToRemove());
            return null;
        });
    }
    if (!change.getDevicesToAdd().isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDeviceDao().saveAll(change.getDevicesToAdd());
            return null;
        });
    }
    if (!change.touchedVms.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, () -> {
            getVmDynamicDao().updateDevicesHashes(change.touchedVms.stream().map(vmId -> new Pair<>(vmId, vmDevicesStatuses.get(vmId).getHash())).collect(Collectors.toList()));
            return null;
        });
    }
}
#end_block

#method_before
protected boolean tryBackAllCinderDisks(List<CinderDisk> cinderDisks, Guid newSnapshotId) {
    boolean isSucceeded = true;
    for (CinderDisk disk : cinderDisks) {
        ImagesContainterParametersBase params = buildCinderChildCommandParameters(disk, newSnapshotId);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.TryBackToCinderSnapshot, params, cloneContextAndDetachFromParent());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk for preview. '{}': {}", disk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            isSucceeded = false;
            break;
        }
    }
    return isSucceeded;
}
#method_after
protected boolean tryBackAllCinderDisks(List<CinderDisk> cinderDisks, Guid newSnapshotId) {
    for (CinderDisk disk : cinderDisks) {
        ImagesContainterParametersBase params = buildCinderChildCommandParameters(disk, newSnapshotId);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.TryBackToCinderSnapshot, params, cloneContextAndDetachFromParent());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk for preview. '{}': {}", disk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private CreateCinderSnapshotParameters buildCinderChildCommandParameters(CinderDisk cinderDisk, Guid newSnapshotId) {
    CreateCinderSnapshotParameters createParams = new CreateCinderSnapshotParameters(cinderDisk.getImageId());
    createParams.setContainerId(cinderDisk.getId());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setEntityInfo(getParameters().getEntityInfo());
    createParams.setDestinationImageId(cinderDisk.getImageId());
    createParams.setVmSnapshotId(newSnapshotId);
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    return createParams;
}
#method_after
private CreateCinderSnapshotParameters buildCinderChildCommandParameters(CinderDisk cinderDisk, Guid newSnapshotId) {
    CreateCinderSnapshotParameters createParams = new CreateCinderSnapshotParameters(cinderDisk.getImageId());
    createParams.setContainerId(cinderDisk.getId());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDestinationImageId(cinderDisk.getImageId());
    createParams.setVmSnapshotId(newSnapshotId);
    createParams.setParentCommand(getActionType());
    createParams.setParentParameters(getParameters());
    return createParams;
}
#end_block

#method_before
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    boolean isSucceeded = true;
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            isSucceeded = false;
            break;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    if (isSucceeded) {
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    }
}
#method_after
protected void addVmCinderDisks(Collection<DiskImage> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    if (cinderDisks.isEmpty()) {
        return;
    }
    Map<Guid, Guid> diskImageMap = new HashMap<>();
    for (CinderDisk cinderDisk : cinderDisks) {
        ImagesContainterParametersBase params = buildCloneCinderDiskCommandParameters(cinderDisk);
        VdcReturnValueBase vdcReturnValueBase = runInternalAction(VdcActionType.CloneSingleCinderDisk, params, cloneContext().withoutExecutionContext().withoutLock());
        if (!vdcReturnValueBase.getSucceeded()) {
            log.error("Error cloning Cinder disk '{}': {}", cinderDisk.getDiskAlias());
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            return;
        }
        Guid imageId = vdcReturnValueBase.getActionReturnValue();
        diskImageMap.put(cinderDisk.getId(), imageId);
    }
    srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "rawtypes" })
@Override
public String toString() {
    Class<Map<String, String>> clazz = (Class) Map.class;
    Map<String, String> params = MAPPER.convertValue(this.getParams(), clazz);
    if (params.containsKey("password")) {
        params.put("password", "XXX");
    }
    return "<JsonRpcRequest id: " + this.getId() + ", method: " + this.getMethod() + ", params: " + params + ">";
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
@Override
public String toString() {
    Class<Map<String, String>> clazz = (Class) Map.class;
    Map<String, String> params = MAPPER.convertValue(this.getParams(), clazz);
    if (params.containsKey("password")) {
        params.put("password", "*****");
    }
    return "<JsonRpcRequest id: " + this.getId() + ", method: " + this.getMethod() + ", params: " + params + ">";
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(this.command + "\n");
    for (String key : this.headers.keySet()) {
        builder.append(key + ":" + this.headers.get(key) + "\n");
    }
    builder.append("\n");
    if (Command.SEND.toString().equals(this.command)) {
        JsonRpcRequest request = JsonRpcRequest.fromByteArray(this.content);
        builder.append(request.toString());
    } else if (Command.MESSAGE.toString().equals(this.command)) {
        JsonRpcResponse response = JsonRpcResponse.fromByteArray(this.content);
        builder.append(response.toString());
    }
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(this.command).append("\n");
    for (String key : this.headers.keySet()) {
        builder.append(key).append(":").append(this.headers.get(key)).append("\n");
    }
    builder.append("\n");
    if (Command.SEND.toString().equals(this.command)) {
        JsonRpcRequest request = JsonRpcRequest.fromByteArray(this.content);
        builder.append(request.toString());
    } else if (Command.MESSAGE.toString().equals(this.command)) {
        JsonRpcResponse response = JsonRpcResponse.fromByteArray(this.content);
        builder.append(response.toString());
    }
    return builder.toString();
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "rawtypes" })
@Override
public String toString() {
    Map<String, String> result = null;
    if (this.getResult() != null) {
        Class<Map<String, String>> clazz = (Class) Map.class;
        result = MAPPER.convertValue(this.getResult(), clazz);
        if (result.containsKey("password")) {
            result.put("password", "XXX");
        }
    }
    String response = this.getResult() != null ? " result: " + result : " error: " + this.getError().toString();
    return "<JsonRpcResponse id: " + this.getId() + response + ">";
}
#method_after
@SuppressWarnings({ "unchecked", "rawtypes" })
@Override
public String toString() {
    Map<String, String> result = null;
    if (this.getResult() != null) {
        Class<Map<String, String>> clazz = (Class) Map.class;
        result = MAPPER.convertValue(this.getResult(), clazz);
        if (result.containsKey("password")) {
            result.put("password", "*****");
        }
    }
    String response = this.getResult() != null ? " result: " + result : " error: " + this.getError().toString();
    return "<JsonRpcResponse id: " + this.getId() + response + ">";
}
#end_block

#method_before
protected static boolean methodAllowsConcurrent(Object instance, String methodId) {
    OnTimerMethodAnnotation methodToRunAnnotation = null;
    Method[] methods = instance.getClass().getMethods();
    for (Method method : methods) {
        OnTimerMethodAnnotation annotation = method.getAnnotation(OnTimerMethodAnnotation.class);
        if (annotation != null && methodId.equals(annotation.value())) {
            methodToRunAnnotation = annotation;
            break;
        }
    }
    return methodToRunAnnotation == null || methodToRunAnnotation.allowsConcurrent();
}
#method_after
protected static boolean methodAllowsConcurrent(Object instance, String methodId) {
    Method method = getMethodToRun(instance, methodId);
    OnTimerMethodAnnotation methodToRunAnnotation = method.getAnnotation(OnTimerMethodAnnotation.class);
    return methodToRunAnnotation == null || methodToRunAnnotation.allowsConcurrent();
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    getSysprepAdminPassword().setIsValid(true);
    getSysprepAdminPasswordVerification().setIsValid(true);
    getCloudInitRootPassword().setIsValid(true);
    getCloudInitRootPasswordVerification().setIsValid(true);
    if (this.isWindowsOS) {
        if (getSysprepPasswordEnabled()) {
            getSysprepAdminPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getSysprepAdminPassword().getEntity(), getSysprepAdminPasswordVerification().getEntity()) });
        }
    } else {
        if (getRootPasswordEnabled()) {
            getCloudInitRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getCloudInitRootPassword().getEntity(), getCloudInitRootPasswordVerification().getEntity()) });
        }
    }
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation(), new LengthValidation(15) });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation(), new LengthValidation(64) });
        }
    }
    getSysprepDomain().setIsValid(true);
    if (getDomainEnabled()) {
        getSysprepDomain().setIsValid(new HostAddressValidation().validate(getSysprepDomain().getSelectedItem()).getSuccess());
    }
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new VmInitNetworkNameValidation(), new NotEmptyValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getSysprepDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getCloudInitRootPassword().getIsValid() && getSysprepAdminPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    getSysprepAdminPassword().setIsValid(true);
    getSysprepAdminPasswordVerification().setIsValid(true);
    getCloudInitRootPassword().setIsValid(true);
    getCloudInitRootPasswordVerification().setIsValid(true);
    if (this.isWindowsOS) {
        if (getSysprepPasswordEnabled()) {
            getSysprepAdminPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getSysprepAdminPassword().getEntity(), getSysprepAdminPasswordVerification().getEntity()) });
        }
    } else {
        if (getRootPasswordEnabled()) {
            getCloudInitRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation(), new MatchFieldsValidator(getCloudInitRootPassword().getEntity(), getCloudInitRootPasswordVerification().getEntity()) });
        }
    }
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation(), new LengthValidation(AsyncDataProvider.getInstance().getMaxVmNameLengthSysprep()) });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation(), new LengthValidation(AsyncDataProvider.getInstance().getMaxVmNameLength()) });
        }
    }
    getSysprepDomain().setIsValid(true);
    if (getDomainEnabled()) {
        getSysprepDomain().setIsValid(new HostAddressValidation().validate(getSysprepDomain().getSelectedItem()).getSuccess());
    }
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() == NetworkBootProtocol.STATIC_IP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new VmInitNetworkNameValidation(), new NotEmptyValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getSysprepDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getCloudInitRootPassword().getIsValid() && getSysprepAdminPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    if (vm.getVmInit() != null && !StringUtils.isEmpty(vm.getVmInit().getCustomScript())) {
        sysPrepContent = vm.getVmInit().getCustomScript();
    } else {
        sysPrepContent = loadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    }
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (hostName != null && hostName.length() > 15) {
        hostName = hostName.substring(0, 15);
    }
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String activeDirectoryOU = "";
        String adminPassword = "";
        String orgName = Config.<String>getValue(ConfigValues.OrganizationName);
        if (vm.getVmInit() != null) {
            if (!StringUtils.isEmpty(vm.getVmInit().getInputLocale())) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUiLanguage())) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getSystemLocale())) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUserLocale())) {
                userLocale = vm.getVmInit().getUserLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getActiveDirectoryOU())) {
                activeDirectoryOU = vm.getVmInit().getActiveDirectoryOU();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getRootPassword())) {
                adminPassword = vm.getVmInit().getRootPassword();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getOrgName())) {
                orgName = vm.getVmInit().getOrgName();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UILanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
        sysPrepContent = replace(sysPrepContent, "$MachineObjectOU$", activeDirectoryOU);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", orgName);
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", adminPassword);
    }
    return sysPrepContent;
}
#method_after
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    if (vm.getVmInit() != null && !StringUtils.isEmpty(vm.getVmInit().getCustomScript())) {
        sysPrepContent = vm.getVmInit().getCustomScript();
    } else {
        sysPrepContent = loadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    }
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    Integer nameLength = Config.<Integer>getValue(ConfigValues.MaxVmNameLengthSysprep);
    if (hostName != null && hostName.length() > nameLength) {
        hostName = hostName.substring(0, nameLength);
    }
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String activeDirectoryOU = "";
        String adminPassword = "";
        String orgName = Config.<String>getValue(ConfigValues.OrganizationName);
        if (vm.getVmInit() != null) {
            if (!StringUtils.isEmpty(vm.getVmInit().getInputLocale())) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUiLanguage())) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getSystemLocale())) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUserLocale())) {
                userLocale = vm.getVmInit().getUserLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getActiveDirectoryOU())) {
                activeDirectoryOU = vm.getVmInit().getActiveDirectoryOU();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getRootPassword())) {
                adminPassword = vm.getVmInit().getRootPassword();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getOrgName())) {
                orgName = vm.getVmInit().getOrgName();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UILanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
        sysPrepContent = replace(sysPrepContent, "$MachineObjectOU$", activeDirectoryOU);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", orgName);
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", adminPassword);
    }
    return sysPrepContent;
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(VdcActionType.UpdateVm).when(command).getActionType();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#end_block

#method_before
private void mockVmValidator() {
    VmValidator vmValidator = spy(new VmValidator(vm));
    doReturn(vmValidator).when(command).createVmValidator(vm);
    doReturn(dbFacade).when(vmValidator).getDbFacade();
    doReturn(diskDao).when(vmValidator).getDiskDao();
}
#method_after
private void mockVmValidator() {
    mockVmValidator(vm);
}
#end_block

#method_before
private void mockVmValidator() {
    VmValidator vmValidator = spy(new VmValidator(vm));
    doReturn(vmValidator).when(command).createVmValidator(vm);
    doReturn(dbFacade).when(vmValidator).getDbFacade();
    doReturn(diskDao).when(vmValidator).getDiskDao();
}
#method_after
private void mockVmValidator(VM paramVm) {
    VmValidator vmValidator = spy(new VmValidator(paramVm));
    doReturn(vmValidator).when(command).createVmValidator(paramVm);
    doReturn(dbFacade).when(vmValidator).getDbFacade();
    doReturn(diskDao).when(vmValidator).getDiskDao();
}
#end_block

#method_before
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        Cluster cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForCluster, new IdQueryParameters(cluster.getId()), new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                ArrayList<Quota> quotaList = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (quotaList != null && !quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (quotaList != null && defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    for (Quota quota : quotaList) {
                        if (quota.getId().equals(defaultQuota)) {
                            vmModel.getQuota().setSelectedItem(quota);
                            hasQuotaInList = true;
                            break;
                        }
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }));
    }
}
#method_after
protected void updateQuotaByCluster(final Guid defaultQuota, final String quotaName) {
    if (getModel().getQuota().getIsAvailable()) {
        Cluster cluster = getModel().getSelectedCluster();
        if (cluster == null) {
            return;
        }
        AsyncDataProvider.getInstance().getAllRelevantQuotasForClusterSorted(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                UnitVmModel vmModel = (UnitVmModel) model;
                List<Quota> quotaList = (List<Quota>) returnValue;
                if (quotaList == null) {
                    return;
                }
                if (!quotaList.isEmpty()) {
                    vmModel.getQuota().setItems(quotaList);
                }
                if (defaultQuota != null && !Guid.Empty.equals(defaultQuota)) {
                    boolean hasQuotaInList = false;
                    if (!quotaList.isEmpty()) {
                        hasQuotaInList = defaultQuota.equals(quotaList.get(0).getId());
                    }
                    // Add the quota to the list only in edit mode
                    if (!hasQuotaInList && !getModel().getIsNew()) {
                        Quota quota = new Quota();
                        quota.setId(defaultQuota);
                        quota.setQuotaName(quotaName);
                        quotaList.add(0, quota);
                        vmModel.getQuota().setItems(quotaList);
                        vmModel.getQuota().setSelectedItem(quota);
                    }
                }
            }
        }), cluster.getId(), defaultQuota);
    }
}
#end_block

#method_before
public Integer getMaxVmNameLength() {
    Integer maxVmNameLengthNonWindows = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLength);
    if (maxVmNameLengthNonWindows == null) {
        return 64;
    }
    return maxVmNameLengthNonWindows;
}
#method_after
public Integer getMaxVmNameLength() {
    Integer maxVmNameLength = (Integer) getConfigValuePreConverted(ConfigurationValues.MaxVmNameLength);
    if (maxVmNameLength == null) {
        return 64;
    }
    return maxVmNameLength;
}
#end_block

#method_before
private boolean validateName(final ImportVmData data) {
    final int maxNameLength = getMaxNameLength(data.getVm());
    EntityModel<String> tmp = new EntityModel<>(data.getVm().getName());
    tmp.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(maxNameLength), new I18NNameValidation(), new UniqueNameValidator(data), new IValidation() {

        @Override
        public ValidationResult validate(Object value) {
            return data.isNameExistsInTheSystem() && data.getName().equals(data.getVm().getName()) ? ValidationResult.fail(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason()) : ValidationResult.ok();
        }
    } });
    data.setError(tmp.getIsValid() ? null : ConstantsManager.getInstance().getConstants().invalidName());
    return tmp.getIsValid();
}
#method_after
private boolean validateName(final ImportVmData data) {
    final int maxNameLength = getMaxNameLength();
    EntityModel<String> tmp = new EntityModel<>(data.getVm().getName());
    tmp.validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(maxNameLength), new I18NNameValidation(), new UniqueNameValidator(data), new IValidation() {

        @Override
        public ValidationResult validate(Object value) {
            return data.isNameExistsInTheSystem() && data.getName().equals(data.getVm().getName()) ? ValidationResult.fail(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason()) : ValidationResult.ok();
        }
    } });
    data.setError(tmp.getIsValid() ? null : ConstantsManager.getInstance().getConstants().invalidName());
    return tmp.getIsValid();
}
#end_block

#method_before
protected int getMaxNameLength(VM vm) {
    return AsyncDataProvider.getInstance().getMaxVmNameLength();
}
#method_after
protected int getMaxNameLength() {
    return AsyncDataProvider.getInstance().getMaxVmNameLength();
}
#end_block

#method_before
protected void updateDiskImageDynamic(final DiskImage imageFromIRS, final DiskImage targetImage) {
    // Update image's actual size in DB
    if (imageFromIRS != null) {
        completeImageData(imageFromIRS);
    } else {
        log.warn("Could not update DiskImage's size with ID '{}'", targetImage.getImageId());
    }
}
#method_after
protected void updateDiskImageDynamic(final DiskImage imageFromVdsm, final DiskImage targetImage) {
    // Update image's actual size in DB
    if (imageFromVdsm != null) {
        completeImageData(imageFromVdsm);
    } else {
        log.warn("Could not update DiskImage's size with ID '{}'", targetImage.getImageId());
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    // original state (before the merge-attempt).
    if (getDestinationDiskImage() != null) {
        DiskImage curr = getDestinationDiskImage();
        while (!curr.getParentId().equals(getDiskImage().getParentId())) {
            curr = getDiskImageDao().getSnapshotById(curr.getParentId());
            getImageDao().remove(curr.getImageId());
        }
        getDestinationDiskImage().setvolumeFormat(curr.getVolumeFormat());
        getDestinationDiskImage().setVolumeType(curr.getVolumeType());
        getDestinationDiskImage().setParentId(getDiskImage().getParentId());
        getBaseDiskDao().update(curr);
        getImageDao().update(getDestinationDiskImage().getImage());
        DiskImage imageFromIRS = getImageInfoFromIRS(getDestinationDiskImage().getStoragePoolId(), getDestinationDiskImage().getStorageIds().get(0), getDestinationDiskImage().getId(), getDestinationDiskImage().getImageId());
        if (imageFromIRS != null) {
            completeImageData(imageFromIRS);
        } else {
            log.warn("Could not update DiskImage's size with ID '{}'", getDestinationDiskImage().getImageId());
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    // original state (before the merge-attempt).
    if (getDestinationDiskImage() != null) {
        DiskImage curr = getDestinationDiskImage();
        while (!curr.getParentId().equals(getDiskImage().getParentId())) {
            curr = getDiskImageDao().getSnapshotById(curr.getParentId());
            getImageDao().remove(curr.getImageId());
        }
        getDestinationDiskImage().setvolumeFormat(curr.getVolumeFormat());
        getDestinationDiskImage().setVolumeType(curr.getVolumeType());
        getDestinationDiskImage().setParentId(getDiskImage().getParentId());
        getBaseDiskDao().update(curr);
        getImageDao().update(getDestinationDiskImage().getImage());
        updateDiskImageDynamic(getImageInfoFromVdsm(getDestinationDiskImage()), getDestinationDiskImage());
    }
    setSucceeded(true);
}
#end_block

#method_before
public void onSucceeded() {
    DiskImage imageFromIRS = getImageInfoFromIRS(getDiskImage().getStoragePoolId(), getDiskImage().getStorageIds().get(0), getDiskImage().getId(), getDiskImage().getImageId());
    TransactionSupport.executeInNewTransaction(() -> {
        syncDbRecords(imageFromIRS, true);
        return null;
    });
    log.info("Successfully merged snapshot '{}' images '{}'..'{}'", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
}
#method_after
public void onSucceeded() {
    syncDbRecords(getTargetImageInfoFromVdsm(), true);
    log.info("Successfully merged snapshot '{}' images '{}'..'{}'", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
}
#end_block

#method_before
private void syncDbRecords(DiskImage imageFromIRS, boolean removeImages) {
    // If deletion failed after a backwards merge, the snapshots' images need to be swapped
    // as they would upon success.  Instead of removing them, mark them illegal.
    DiskImage baseImage = getDiskImage();
    DiskImage topImage = getDestinationDiskImage();
    // The vdsm merge verb may decide to perform a forward or backward merge.
    if (topImage == null) {
        log.info("No merge destination image, not updating image/snapshot association");
    } else if (getParameters().getMergeStatusReturnValue().getBlockJobType() == VmBlockJobType.PULL) {
        // For forward merge, the volume format and type may change.
        topImage.setvolumeFormat(baseImage.getVolumeFormat());
        topImage.setVolumeType(baseImage.getVolumeType());
        topImage.setParentId(baseImage.getParentId());
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        if (imageFromIRS != null) {
            completeImageData(imageFromIRS);
        } else {
            log.warn("Could not update DiskImage's size with ID '{}'", baseImage.getImageId());
        }
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), baseImage.getImageId());
    } else {
        // For backwards merge, the prior base image now has the data associated with the newer
        // snapshot we want to keep.  Re-associate this older image with the newer snapshot.
        // The base snapshot is deleted if everything went well.  In case it's not deleted, we
        // hijack it to preserve a link to the broken image.  This makes the image discoverable
        // so that we can retry the deletion later, yet doesn't corrupt the VM image chain.
        List<DiskImage> children = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(topImage.getImageId());
        if (!children.isEmpty()) {
            DiskImage childImage = children.get(0);
            childImage.setParentId(baseImage.getImageId());
            getImageDao().update(childImage.getImage());
        }
        Image oldTopImage = topImage.getImage();
        topImage.setImage(baseImage.getImage());
        baseImage.setImage(oldTopImage);
        Guid oldTopSnapshotId = topImage.getImage().getSnapshotId();
        topImage.getImage().setSnapshotId(baseImage.getImage().getSnapshotId());
        baseImage.getImage().setSnapshotId(oldTopSnapshotId);
        boolean oldTopIsActive = topImage.getImage().isActive();
        topImage.getImage().setActive(baseImage.getImage().isActive());
        VolumeClassification baseImageVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(baseImage.getImage().isActive());
        topImage.getImage().setVolumeClassification(baseImageVolumeClassification);
        baseImage.getImage().setActive(oldTopIsActive);
        VolumeClassification oldTopVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(oldTopIsActive);
        topImage.getImage().setVolumeClassification(oldTopVolumeClassification);
        topImage.setSize(baseImage.getSize());
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        if (imageFromIRS != null) {
            completeImageData(imageFromIRS);
        } else {
            log.warn("Could not update DiskImage's size with ID '{}'", baseImage.getImageId());
        }
        getBaseDiskDao().update(baseImage);
        getImageDao().update(baseImage.getImage());
        updateVmConfigurationForImageChange(topImage.getImage().getSnapshotId(), baseImage.getImageId(), topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), topImage.getImageId());
    }
    Set<Guid> imagesToUpdate = getParameters().getMergeStatusReturnValue().getImagesToRemove();
    if (imagesToUpdate == null) {
        log.error("Failed to update orphaned images in db: image list could not be retrieved");
        return;
    }
    for (Guid imageId : imagesToUpdate) {
        if (removeImages) {
            getImageDao().remove(imageId);
        } else {
            // The (illegal && no-parent && no-children) status indicates an orphaned image.
            Image image = getImageDao().get(imageId);
            image.setStatus(ImageStatus.ILLEGAL);
            image.setParentId(Guid.Empty);
            getImageDao().update(image);
        }
    }
}
#method_after
private void syncDbRecords(DiskImage imageFromVdsm, boolean removeImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        // If deletion failed after a backwards merge, the snapshots' images need to be swapped
        // as they would upon success.  Instead of removing them, mark them illegal.
        DiskImage baseImage = getDiskImage();
        DiskImage topImage = getDestinationDiskImage();
        // The vdsm merge verb may decide to perform a forward or backward merge.
        if (topImage == null) {
            log.info("No merge destination image, not updating image/snapshot association");
        } else if (getParameters().getMergeStatusReturnValue().getBlockJobType() == VmBlockJobType.PULL) {
            handleForwardLiveMerge(topImage, baseImage, imageFromVdsm);
        } else {
            handleBackwardLiveMerge(topImage, baseImage, imageFromVdsm);
        }
        Set<Guid> imagesToUpdate = getParameters().getMergeStatusReturnValue().getImagesToRemove();
        if (imagesToUpdate == null) {
            log.error("Failed to update orphaned images in db: image list could not be retrieved");
            return null;
        }
        for (Guid imageId : imagesToUpdate) {
            if (removeImages) {
                getImageDao().remove(imageId);
            } else {
                // The (illegal && no-parent && no-children) status indicates an orphaned image.
                Image image = getImageDao().get(imageId);
                image.setStatus(ImageStatus.ILLEGAL);
                image.setParentId(Guid.Empty);
                getImageDao().update(image);
            }
        }
        return null;
    });
}
#end_block

#method_before
public void onFailed() {
    if (!completedMerge()) {
        TransactionSupport.executeInNewTransaction(() -> {
            syncDbRecordsMergeFailure();
            return null;
        });
        log.error("Merging of snapshot '{}' images '{}'..'{}' failed. Images have been" + " marked illegal and can no longer be previewed or reverted to." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
    } else {
        DiskImage imageFromIRS = getImageInfoFromIRS(getDiskImage().getStoragePoolId(), getDiskImage().getStorageIds().get(0), getDiskImage().getId(), getDiskImage().getImageId());
        TransactionSupport.executeInNewTransaction(() -> {
            syncDbRecords(imageFromIRS, false);
            return null;
        });
        log.error("Snapshot '{}' images '{}'..'{}' merged, but volume removal failed." + " Some or all of the following volumes may be orphaned: {}." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)", getParameters().getMergeStatusReturnValue().getImagesToRemove());
    }
}
#method_after
public void onFailed() {
    if (!completedMerge()) {
        TransactionSupport.executeInNewTransaction(() -> {
            syncDbRecordsMergeFailure();
            return null;
        });
        log.error("Merging of snapshot '{}' images '{}'..'{}' failed. Images have been" + " marked illegal and can no longer be previewed or reverted to." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
    } else {
        syncDbRecords(getTargetImageInfoFromVdsm(), false);
        log.error("Snapshot '{}' images '{}'..'{}' merged, but volume removal failed." + " Some or all of the following volumes may be orphaned: {}." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)", getParameters().getMergeStatusReturnValue().getImagesToRemove());
    }
}
#end_block

#method_before
public void onSucceeded() {
    TransactionSupport.executeInNewTransaction(() -> {
        syncDbRecords(true);
        return null;
    });
    log.info("Successfully merged snapshot '{}' images '{}'..'{}'", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
}
#method_after
public void onSucceeded() {
    syncDbRecords(true);
    log.info("Successfully merged snapshot '{}' images '{}'..'{}'", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
}
#end_block

#method_before
private void syncDbRecords(boolean removeImages) {
    // If deletion failed after a backwards merge, the snapshots' images need to be swapped
    // as they would upon success.  Instead of removing them, mark them illegal.
    DiskImage baseImage = getDiskImage();
    DiskImage topImage = getDestinationDiskImage();
    // The vdsm merge verb may decide to perform a forward or backward merge.
    if (topImage == null) {
        log.info("No merge destination image, not updating image/snapshot association");
    } else if (getParameters().getMergeStatusReturnValue().getBlockJobType() == VmBlockJobType.PULL) {
        // For forward merge, the volume format and type may change.
        topImage.setvolumeFormat(baseImage.getVolumeFormat());
        topImage.setVolumeType(baseImage.getVolumeType());
        topImage.setParentId(baseImage.getParentId());
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        updateDiskImageDynamic(topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), baseImage.getImageId());
    } else {
        // For backwards merge, the prior base image now has the data associated with the newer
        // snapshot we want to keep.  Re-associate this older image with the newer snapshot.
        // The base snapshot is deleted if everything went well.  In case it's not deleted, we
        // hijack it to preserve a link to the broken image.  This makes the image discoverable
        // so that we can retry the deletion later, yet doesn't corrupt the VM image chain.
        List<DiskImage> children = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForParent(topImage.getImageId());
        if (!children.isEmpty()) {
            DiskImage childImage = children.get(0);
            childImage.setParentId(baseImage.getImageId());
            getImageDao().update(childImage.getImage());
        }
        Image oldTopImage = topImage.getImage();
        topImage.setImage(baseImage.getImage());
        baseImage.setImage(oldTopImage);
        Guid oldTopSnapshotId = topImage.getImage().getSnapshotId();
        topImage.getImage().setSnapshotId(baseImage.getImage().getSnapshotId());
        baseImage.getImage().setSnapshotId(oldTopSnapshotId);
        boolean oldTopIsActive = topImage.getImage().isActive();
        topImage.getImage().setActive(baseImage.getImage().isActive());
        VolumeClassification baseImageVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(baseImage.getImage().isActive());
        topImage.getImage().setVolumeClassification(baseImageVolumeClassification);
        baseImage.getImage().setActive(oldTopIsActive);
        VolumeClassification oldTopVolumeClassification = VolumeClassification.getVolumeClassificationByActiveFlag(oldTopIsActive);
        topImage.getImage().setVolumeClassification(oldTopVolumeClassification);
        topImage.setSize(baseImage.getSize());
        topImage.setImageStatus(ImageStatus.OK);
        getBaseDiskDao().update(topImage);
        getImageDao().update(topImage.getImage());
        updateDiskImageDynamic(topImage);
        getBaseDiskDao().update(baseImage);
        getImageDao().update(baseImage.getImage());
        updateVmConfigurationForImageChange(topImage.getImage().getSnapshotId(), baseImage.getImageId(), topImage);
        updateVmConfigurationForImageRemoval(baseImage.getImage().getSnapshotId(), topImage.getImageId());
    }
    Set<Guid> imagesToUpdate = getParameters().getMergeStatusReturnValue().getImagesToRemove();
    if (imagesToUpdate == null) {
        log.error("Failed to update orphaned images in db: image list could not be retrieved");
        return;
    }
    for (Guid imageId : imagesToUpdate) {
        if (removeImages) {
            getImageDao().remove(imageId);
        } else {
            // The (illegal && no-parent && no-children) status indicates an orphaned image.
            Image image = getImageDao().get(imageId);
            image.setStatus(ImageStatus.ILLEGAL);
            image.setParentId(Guid.Empty);
            getImageDao().update(image);
        }
    }
}
#method_after
private void syncDbRecords(boolean removeImages) {
    TransactionSupport.executeInNewTransaction(() -> {
        // If deletion failed after a backwards merge, the snapshots' images need to be swapped
        // as they would upon success.  Instead of removing them, mark them illegal.
        DiskImage baseImage = getDiskImage();
        DiskImage topImage = getDestinationDiskImage();
        // The vdsm merge verb may decide to perform a forward or backward merge.
        if (topImage == null) {
            log.info("No merge destination image, not updating image/snapshot association");
        } else if (getParameters().getMergeStatusReturnValue().getBlockJobType() == VmBlockJobType.PULL) {
            handleForwardLiveMerge(topImage, baseImage);
        } else {
            handleBackwardLiveMerge(topImage, baseImage);
        }
        Set<Guid> imagesToUpdate = getParameters().getMergeStatusReturnValue().getImagesToRemove();
        if (imagesToUpdate == null) {
            log.error("Failed to update orphaned images in db: image list could not be retrieved");
            return null;
        }
        for (Guid imageId : imagesToUpdate) {
            if (removeImages) {
                getImageDao().remove(imageId);
            } else {
                // The (illegal && no-parent && no-children) status indicates an orphaned image.
                Image image = getImageDao().get(imageId);
                image.setStatus(ImageStatus.ILLEGAL);
                image.setParentId(Guid.Empty);
                getImageDao().update(image);
            }
        }
        return null;
    });
}
#end_block

#method_before
public void onFailed() {
    if (!completedMerge()) {
        TransactionSupport.executeInNewTransaction(() -> {
            syncDbRecordsMergeFailure();
            return null;
        });
        log.error("Merging of snapshot '{}' images '{}'..'{}' failed. Images have been" + " marked illegal and can no longer be previewed or reverted to." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
    } else {
        TransactionSupport.executeInNewTransaction(() -> {
            syncDbRecords(false);
            return null;
        });
        log.error("Snapshot '{}' images '{}'..'{}' merged, but volume removal failed." + " Some or all of the following volumes may be orphaned: {}." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)", getParameters().getMergeStatusReturnValue().getImagesToRemove());
    }
}
#method_after
public void onFailed() {
    if (!completedMerge()) {
        TransactionSupport.executeInNewTransaction(() -> {
            syncDbRecordsMergeFailure();
            return null;
        });
        log.error("Merging of snapshot '{}' images '{}'..'{}' failed. Images have been" + " marked illegal and can no longer be previewed or reverted to." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)");
    } else {
        syncDbRecords(false);
        log.error("Snapshot '{}' images '{}'..'{}' merged, but volume removal failed." + " Some or all of the following volumes may be orphaned: {}." + " Please retry Live Merge on the snapshot to complete the operation.", getDiskImage().getImage().getSnapshotId(), getDiskImage().getImageId(), getDestinationDiskImage() != null ? getDestinationDiskImage().getImageId() : "(n/a)", getParameters().getMergeStatusReturnValue().getImagesToRemove());
    }
}
#end_block

#method_before
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<>();
            switch(getDiskStorageType().getEntity()) {
                case IMAGE:
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageDomainType(storageDomains, StorageDomainType.Master));
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageDomainType(storageDomains, StorageDomainType.Data));
                    break;
                case CINDER:
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER));
                    break;
            }
            filteredStorageDomains = (ArrayList<StorageDomain>) Linq.filterStorageDomainsByStorageStatus(filteredStorageDomains, StorageDomainStatus.Active);
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrNull(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains, storage);
            if (storage == null) {
                switch(getDiskStorageType().getEntity()) {
                    case IMAGE:
                        diskModel.setMessage(constants.noActiveStorageDomainsInDC());
                        break;
                    case CINDER:
                        diskModel.setMessage(constants.noCinderStorageDomainsInDC());
                        break;
                }
            }
        }
    }), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
protected void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<>();
            switch(getDiskStorageType().getEntity()) {
                case IMAGE:
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageDomainType(storageDomains, StorageDomainType.Master));
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageDomainType(storageDomains, StorageDomainType.Data));
                    break;
                case CINDER:
                    filteredStorageDomains.addAll(Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER));
                    break;
            }
            filteredStorageDomains = (ArrayList<StorageDomain>) Linq.filterStorageDomainsByStorageStatus(filteredStorageDomains, StorageDomainStatus.Active);
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrNull(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains, storage);
            if (storage == null) {
                switch(getDiskStorageType().getEntity()) {
                    case IMAGE:
                        diskModel.setMessage(constants.noActiveStorageDomainsInDC());
                        diskModel.getIsModelDisabled().setEntity(true);
                        break;
                    case CINDER:
                        diskModel.setMessage(constants.noCinderStorageDomainsInDC());
                        diskModel.getIsModelDisabled().setEntity(true);
                        break;
                }
            }
        }
    }), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateHosts(StoragePool datacenter) {
    AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            ArrayList<VDS> filteredHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (isHostAvailable(host)) {
                    filteredHosts.add(host);
                }
            }
            diskModel.getHost().setItems(filteredHosts);
        }
    }), datacenter.getId());
}
#method_after
private void updateHosts(StoragePool datacenter) {
    AsyncDataProvider.getInstance().getHostListByDataCenter(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            Iterable<VDS> hosts = (Iterable<VDS>) returnValue;
            ArrayList<VDS> filteredHosts = new ArrayList<>();
            for (VDS host : hosts) {
                if (isHostAvailable(host)) {
                    filteredHosts.add(host);
                }
            }
            diskModel.getHost().setItems(filteredHosts);
        }
    }), datacenter.getId());
}
#end_block

#method_before
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById((new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(constants.relevantDCnotActive());
                }
            }
        })), getVm().getStoragePoolId());
        updateBootableDiskAvailable();
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<StoragePool>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(constants.noActiveDataCenters());
                }
            }
        }));
    }
}
#method_after
private void updateDatacenters() {
    boolean isInVm = getVm() != null;
    getDataCenter().setIsAvailable(!isInVm);
    // $NON-NLS-1$
    setMessage("");
    getIsModelDisabled().setEntity(false);
    if (isInVm) {
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                StoragePool dataCenter = (StoragePool) returnValue;
                ArrayList<StoragePool> dataCenters = new ArrayList<>();
                if (isDatacenterAvailable(dataCenter)) {
                    dataCenters.add(dataCenter);
                }
                diskModel.getDataCenter().setItems(dataCenters, Linq.firstOrNull(dataCenters));
                if (dataCenters.isEmpty()) {
                    diskModel.setMessage(constants.relevantDCnotActive());
                    diskModel.getIsModelDisabled().setEntity(true);
                }
            }
        }), getVm().getStoragePoolId());
        updateBootableDiskAvailable();
    } else {
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                AbstractDiskModel diskModel = (AbstractDiskModel) target;
                ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                ArrayList<StoragePool> filteredDataCenters = new ArrayList<>();
                for (StoragePool dataCenter : dataCenters) {
                    if (isDatacenterAvailable(dataCenter)) {
                        filteredDataCenters.add(dataCenter);
                    }
                }
                diskModel.getDataCenter().setItems(filteredDataCenters);
                if (filteredDataCenters.isEmpty()) {
                    diskModel.setMessage(constants.noActiveDataCenters());
                    diskModel.getIsModelDisabled().setEntity(true);
                }
            }
        }));
    }
}
#end_block

#method_before
private void updateDirectLunDiskEnabled(StoragePool datacenter) {
    if (getDiskStorageType().getEntity() != DiskStorageType.LUN) {
        return;
    }
    boolean isDirectLUNDiskkEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DirectLUNDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsDirectLunDiskAvaialable().setEntity(isDirectLUNDiskkEnabled);
    // $NON-NLS-1$
    setMessage(!isDirectLUNDiskkEnabled ? constants.directLUNDiskNotSupported() : "");
}
#method_after
private void updateDirectLunDiskEnabled(StoragePool datacenter) {
    if (getDiskStorageType().getEntity() != DiskStorageType.LUN) {
        return;
    }
    boolean isDirectLUNDiskkEnabled = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.DirectLUNDiskEnabled, datacenter.getCompatibilityVersion().getValue());
    getIsDirectLunDiskAvaialable().setEntity(isDirectLUNDiskkEnabled);
    // $NON-NLS-1$
    setMessage(!isDirectLUNDiskkEnabled ? constants.directLUNDiskNotSupported() : "");
    getIsModelDisabled().setEntity(!isDirectLUNDiskkEnabled);
}
#end_block

#method_before
private void updateQuota(StoragePool datacenter) {
    if (datacenter.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED) || !getDiskStorageType().getEntity().isInternal()) {
        getQuota().setIsAvailable(false);
        return;
    }
    getQuota().setIsAvailable(true);
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    IdQueryParameters parameters = new IdQueryParameters(storageDomain.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllRelevantQuotasForStorage, parameters, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object innerModel, Object innerReturnValue) {
            ArrayList<Quota> quotaList = ((VdcQueryReturnValue) innerReturnValue).getReturnValue();
            if (quotaList != null && !quotaList.isEmpty()) {
                getQuota().setItems(quotaList);
            }
            Guid diskQuota = getDisk() != null ? ((DiskImage) getDisk()).getQuotaId() : null;
            Guid vmQuota = getVm() != null ? getVm().getQuotaId() : null;
            Guid defaultQuota = diskQuota != null ? diskQuota : vmQuota;
            if (defaultQuota == null) {
                return;
            }
            for (Quota quota : quotaList) {
                if (quota.getId().equals(defaultQuota)) {
                    getQuota().setSelectedItem(quota);
                    return;
                }
            }
            if (diskQuota != null) {
                Quota quota = new Quota();
                quota.setId(diskQuota);
                quota.setQuotaName(getDiskImage().getQuotaName());
                quotaList.add(quota);
                getQuota().setItems(quotaList);
                getQuota().setSelectedItem(quota);
            }
        }
    }));
}
#method_after
private void updateQuota(StoragePool datacenter) {
    if (datacenter.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED) || !getDiskStorageType().getEntity().isInternal()) {
        getQuota().setIsAvailable(false);
        return;
    }
    getQuota().setIsAvailable(true);
    StorageDomain storageDomain = getStorageDomain().getSelectedItem();
    if (storageDomain == null) {
        return;
    }
    final Guid diskQuota = getDisk() != null ? ((DiskImage) getDisk()).getQuotaId() : null;
    final Guid vmQuota = getVm() != null ? getVm().getQuotaId() : null;
    final Guid defaultQuota = diskQuota != null ? diskQuota : vmQuota;
    AsyncDataProvider.getInstance().getAllRelevantQuotasForStorageSorted(new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<Quota> quotaList = (List<Quota>) returnValue;
            if (quotaList != null && !quotaList.isEmpty()) {
                getQuota().setItems(quotaList);
                // If list contains default quota, return
                if (quotaList.get(0).getId().equals(defaultQuota)) {
                    return;
                }
            }
            if (diskQuota != null) {
                Quota quota = new Quota();
                quota.setId(diskQuota);
                quota.setQuotaName(getDiskImage().getQuotaName());
                if (quotaList == null) {
                    quotaList = new ArrayList<>();
                }
                quotaList.add(quota);
                getQuota().setItems(quotaList);
                getQuota().setSelectedItem(quota);
            }
        }
    }), storageDomain.getId(), defaultQuota);
}
#end_block

#method_before
protected void datacenter_SelectedItemChanged() {
    StoragePool datacenter = getDataCenter().getSelectedItem();
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    setMessage(null);
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    updateInterface(isInVm ? getVm().getVdsGroupCompatibilityVersion() : null);
    switch(getDiskStorageType().getEntity()) {
        case IMAGE:
        case CINDER:
            updateStorageDomains(datacenter);
            break;
        default:
            updateHosts(datacenter);
            break;
    }
}
#method_after
protected void datacenter_SelectedItemChanged() {
    StoragePool datacenter = getDataCenter().getSelectedItem();
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    setMessage(null);
    getIsModelDisabled().setEntity(false);
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    updateInterface(isInVm ? getVm().getCompatibilityVersion() : null);
    switch(getDiskStorageType().getEntity()) {
        case IMAGE:
        case CINDER:
            updateStorageDomains(datacenter);
            break;
        default:
            updateHosts(datacenter);
            break;
    }
}
#end_block

#method_before
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    if (getVm() == null) {
        getAlias().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    } else {
        getAlias().validateEntity(new IValidation[] { new I18NNameValidation() });
    }
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getCinderVolumeType().getIsAvailable()) {
        getCinderVolumeType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid() && getCinderVolumeType().getIsValid();
}
#method_after
public boolean validate() {
    getDescription().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.DISK_DESCRIPTION_MAX_SIZE) });
    getAlias().validateEntity(getDiskAliasValidations());
    StoragePool dataCenter = getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getCinderVolumeType().getIsAvailable()) {
        getCinderVolumeType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    return getAlias().getIsValid() && getDescription().getIsValid() && getQuota().getIsValid() && getDiskInterface().getIsValid() && getCinderVolumeType().getIsValid();
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(vm.getVmInit() != null);
    getModel().getVmInitModel().init(vm.getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsVolumeFormatAvailable(true);
    disksAllocationModel.setIsAliasChangable(true);
    disksAllocationModel.setContainer(getModel());
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<VDSGroup> clusters = (List<VDSGroup>) returnValue;
                        List<VDSGroup> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getVdsGroupId());
                        initTemplate();
                    }
                }), true, false);
                AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }), vm.getId());
            }
        }
    }), vm.getStoragePoolId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmInitEnabled().setEntity(vm.getVmInit() != null);
    getModel().getVmInitModel().init(vm.getStaticData());
    getModel().getVmType().setIsChangeable(true);
    getModel().getCopyPermissions().setIsAvailable(true);
    DisksAllocationModel disksAllocationModel = getModel().getDisksAllocationModel();
    disksAllocationModel.setIsVolumeFormatAvailable(true);
    disksAllocationModel.setIsAliasChangable(true);
    disksAllocationModel.setContainer(getModel());
    AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final StoragePool dataCenter = (StoragePool) returnValue;
            if (dataCenter == null) {
                disableNewTemplateModel(ConstantsManager.getInstance().getConstants().dataCenterIsNotAccessibleMsg());
            } else {
                AsyncDataProvider.getInstance().getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        List<Cluster> clusters = (List<Cluster>) returnValue;
                        List<Cluster> filteredClusters = AsyncDataProvider.getInstance().filterByArchitecture(clusters, vm.getClusterArch());
                        model.setDataCentersAndClusters(model, Arrays.asList(dataCenter), filteredClusters, vm.getClusterId());
                        initTemplate();
                    }
                }), true, false);
                AsyncDataProvider.getInstance().isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                    }
                }), vm.getId());
            }
        }
    }), vm.getStoragePoolId());
}
#end_block

#method_before
protected void updateTemplate() {
    final DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        final StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                NewTemplateVmModelBehavior behavior1 = NewTemplateVmModelBehavior.this;
                AsyncDataProvider.getInstance().getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewTemplateVmModelBehavior behavior2 = (NewTemplateVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrNull(templatesByDataCenter, new Linq.IdPredicate<>(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        ArrayList<VmTemplate> templateList = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesByStorage, dataCenterWithCluster.getCluster().getArchitecture());
                        behavior2.postInitTemplate(templateList);
                    }
                }), storage.getId());
            }
        }), dataCenter.getId());
    } else {
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
                ArrayList<VmTemplate> templates = (ArrayList<VmTemplate>) returnValue;
                behavior.postInitTemplate(AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templates, dataCenterWithCluster.getCluster().getArchitecture()));
            }
        }), dataCenter.getId());
    }
}
#method_after
protected void updateTemplate() {
    final DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter == null) {
        return;
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        final StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target1, Object returnValue1) {
                NewTemplateVmModelBehavior behavior1 = NewTemplateVmModelBehavior.this;
                AsyncDataProvider.getInstance().getTemplateListByStorage(new AsyncQuery(new Object[] { behavior1, returnValue1 }, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target2, Object returnValue2) {
                        Object[] array2 = (Object[]) target2;
                        NewTemplateVmModelBehavior behavior2 = (NewTemplateVmModelBehavior) array2[0];
                        ArrayList<VmTemplate> templatesByDataCenter = (ArrayList<VmTemplate>) array2[1];
                        ArrayList<VmTemplate> templatesByStorage = (ArrayList<VmTemplate>) returnValue2;
                        VmTemplate blankTemplate = Linq.firstOrNull(templatesByDataCenter, new Linq.IdPredicate<>(Guid.Empty));
                        if (blankTemplate != null) {
                            templatesByStorage.add(0, blankTemplate);
                        }
                        ArrayList<VmTemplate> templateList = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesByStorage, dataCenterWithCluster.getCluster().getArchitecture());
                        behavior2.postInitTemplate(templateList);
                    }
                }), storage.getId());
            }
        }), dataCenter.getId());
    } else {
        AsyncDataProvider.getInstance().getTemplateListByDataCenter(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
                ArrayList<VmTemplate> templates = (ArrayList<VmTemplate>) returnValue;
                behavior.postInitTemplate(AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templates, dataCenterWithCluster.getCluster().getArchitecture()));
            }
        }), dataCenter.getId());
    }
}
#end_block

#method_before
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    // If a VM has at least one disk, present its storage domain.
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
            ArrayList<Disk> imageDisks = new ArrayList<Disk>();
            ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            for (Disk disk : vmDisks) {
                if (disk.isShareable() || disk.isDiskSnapshot()) {
                    continue;
                }
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
                    imageDisks.add(disk);
                }
            }
            behavior.initStorageDomains();
            initDisks(imageDisks);
            VmModelHelper.sendWarningForNonExportableDisks(getModel(), vmDisks, VmModelHelper.WarningType.VM_TEMPLATE);
        }
    }), vm.getId(), true);
}
#method_after
@Override
public void dataCenterWithClusterSelectedItemChanged() {
    super.dataCenterWithClusterSelectedItemChanged();
    // If a VM has at least one disk, present its storage domain.
    AsyncDataProvider.getInstance().getVmDiskList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
            ArrayList<Disk> imageDisks = new ArrayList<>();
            ArrayList<Disk> vmDisks = (ArrayList<Disk>) returnValue;
            for (Disk disk : vmDisks) {
                if (disk.isShareable() || disk.isDiskSnapshot()) {
                    continue;
                }
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
                    imageDisks.add(disk);
                }
            }
            behavior.initStorageDomains();
            initDisks(imageDisks);
            VmModelHelper.sendWarningForNonExportableDisks(getModel(), vmDisks, VmModelHelper.WarningType.VM_TEMPLATE);
        }
    }), vm.getId(), true);
}
#end_block

#method_before
private void initDisks(ArrayList<Disk> disks) {
    Collections.sort(disks, new Linq.DiskByAliasComparer());
    ArrayList<DiskModel> list = new ArrayList<DiskModel>();
    for (Disk disk : disks) {
        DiskModel diskModel = new DiskModel();
        switch(disk.getDiskStorageType()) {
            case IMAGE:
                DiskImage diskImage = (DiskImage) disk;
                diskModel.setSize(new EntityModel<>((int) diskImage.getSizeInGigabytes()));
                ListModel volumes = new ListModel();
                volumes.setItems((diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.getInstance().getVolumeTypeList()), diskImage.getVolumeType());
                diskModel.setVolumeType(volumes);
                diskModel.getAlias().setEntity(diskImage.getDiskAlias());
                break;
            case CINDER:
                CinderDisk cinderDisk = (CinderDisk) disk;
                diskModel.setSize(new EntityModel<>((int) cinderDisk.getSizeInGigabytes()));
                ListModel volumeTypes = new ListModel();
                volumeTypes.setItems(new ArrayList<>(Arrays.asList(cinderDisk.getVolumeType())), cinderDisk.getVolumeType());
                diskModel.setVolumeType(volumeTypes);
                diskModel.getAlias().setEntity(cinderDisk.getDiskAlias());
                diskModel.getVolumeFormat().setIsChangeable(false);
                break;
        }
        diskModel.setDisk(disk);
        list.add(diskModel);
        diskModel.getVolumeFormat().setIsAvailable(true);
    }
    getModel().setDisks(list);
}
#method_after
private void initDisks(ArrayList<Disk> disks) {
    Collections.sort(disks, new DiskByDiskAliasComparator());
    ArrayList<DiskModel> list = new ArrayList<>();
    for (Disk disk : disks) {
        DiskModel diskModel = new DiskModel();
        switch(disk.getDiskStorageType()) {
            case IMAGE:
                DiskImage diskImage = (DiskImage) disk;
                diskModel.setSize(new EntityModel<>((int) diskImage.getSizeInGigabytes()));
                ListModel volumes = new ListModel();
                volumes.setItems(diskImage.getVolumeType() == VolumeType.Preallocated ? new ArrayList<>(Arrays.asList(new VolumeType[] { VolumeType.Preallocated })) : AsyncDataProvider.getInstance().getVolumeTypeList(), diskImage.getVolumeType());
                diskModel.setVolumeType(volumes);
                diskModel.getAlias().setEntity(diskImage.getDiskAlias());
                break;
            case CINDER:
                CinderDisk cinderDisk = (CinderDisk) disk;
                diskModel.setSize(new EntityModel<>((int) cinderDisk.getSizeInGigabytes()));
                ListModel volumeTypes = new ListModel();
                volumeTypes.setItems(new ArrayList<>(Arrays.asList(cinderDisk.getVolumeType())), cinderDisk.getVolumeType());
                diskModel.setVolumeType(volumeTypes);
                diskModel.getAlias().setEntity(cinderDisk.getDiskAlias());
                diskModel.getVolumeFormat().setIsChangeable(false);
                break;
        }
        diskModel.setDisk(disk);
        list.add(diskModel);
        diskModel.getVolumeFormat().setIsAvailable(true);
    }
    getModel().setDisks(list);
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(vm.getQuotaId(), vm.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getModel().getSelectedCluster().getCompatibilityVersion(), vm.getCpuProfileId());
    }
    updateCustomPropertySheet();
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(vm.getQuotaId(), vm.getQuotaName());
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
    if (getModel().getSelectedCluster() != null) {
        updateCpuProfile(getModel().getSelectedCluster().getId(), getCompatibilityVersion(), vm.getCpuProfileId());
    }
    updateCustomPropertySheet();
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
}
#end_block

#method_before
@Override
public void initStorageDomains() {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomainList = new ArrayList<StorageDomain>();
            for (StorageDomain storageDomain : storageDomains) {
                if (storageDomain.getStatus() == StorageDomainStatus.Active && storageDomain.getStorageDomainType().isDataDomain()) {
                    activeStorageDomainList.add(storageDomain);
                }
            }
            for (DiskModel diskModel : getModel().getDisks()) {
                if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) diskModel.getDisk();
                    ArrayList<StorageDomain> activeDiskStorages = Linq.getStorageDomainsByIds(diskImage.getStorageIds(), activeStorageDomainList);
                    if (activeDiskStorages.isEmpty()) {
                        behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().vmStorageDomainIsNotAccessible());
                        return;
                    }
                }
            }
            if (activeStorageDomainList.size() > 0) {
                if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
                    StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
                    StorageDomain s = Linq.firstOrNull(activeStorageDomainList, new Linq.IdPredicate<>(selectStorage.getId()));
                    activeStorageDomainList = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { s }));
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(false);
                    behavior.getModel().getStorageDomain().setSelectedItem(s);
                } else {
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(true);
                }
            } else {
                behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().noActiveStorageDomain());
            }
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisksAllocationModel().getDisks();
            Collections.sort(activeStorageDomainList, new NameableComparator());
            if (disks != null) {
                ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
                for (DiskModel diskModel : diskImages) {
                    diskModel.getStorageDomain().setItems(activeStorageDomainList);
                    diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                }
                ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
                if (!cinderDisks.isEmpty()) {
                    Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
                    initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
                }
            }
        }
    }), vm.getStoragePoolId(), ActionGroup.CREATE_TEMPLATE);
}
#method_after
@Override
public void initStorageDomains() {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomainList = new ArrayList<>();
            for (StorageDomain storageDomain : storageDomains) {
                if (storageDomain.getStatus() == StorageDomainStatus.Active && storageDomain.getStorageDomainType().isDataDomain()) {
                    activeStorageDomainList.add(storageDomain);
                }
            }
            for (DiskModel diskModel : getModel().getDisks()) {
                if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) diskModel.getDisk();
                    ArrayList<StorageDomain> activeDiskStorages = Linq.getStorageDomainsByIds(diskImage.getStorageIds(), activeStorageDomainList);
                    if (activeDiskStorages.isEmpty()) {
                        behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().vmStorageDomainIsNotAccessible());
                        return;
                    }
                }
            }
            if (activeStorageDomainList.size() > 0) {
                if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
                    StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
                    StorageDomain s = Linq.firstOrNull(activeStorageDomainList, new Linq.IdPredicate<>(selectStorage.getId()));
                    activeStorageDomainList = new ArrayList<>(Arrays.asList(new StorageDomain[] { s }));
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(false);
                    behavior.getModel().getStorageDomain().setSelectedItem(s);
                } else {
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(true);
                }
            } else {
                behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().noActiveStorageDomain());
            }
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisksAllocationModel().getDisks();
            Collections.sort(activeStorageDomainList, new NameableComparator());
            if (disks != null) {
                ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
                for (DiskModel diskModel : diskImages) {
                    diskModel.getStorageDomain().setItems(activeStorageDomainList);
                }
                ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
                if (!cinderDisks.isEmpty()) {
                    Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
                    initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
                }
            }
        }
    }), vm.getStoragePoolId(), ActionGroup.CREATE_TEMPLATE);
}
#end_block

#method_before
public void attachDisk() {
    InstanceImagesAttachDiskModel model = new InstanceImagesAttachDiskModel() {

        @Override
        public void onSave() {
            if (validate()) {
                flush();
                List<EntityModel<DiskModel>> selectedDisks = getSelectedDisks();
                if (selectedDisks.size() == 1) {
                    // only 0 or 1 is allowed
                    setDisk(selectedDisks.iterator().next().getEntity().getDisk());
                }
                getDiskModel().setEntity(this);
                parentModel.getParentListModel().setWindow(null);
                parentModel.getParentListModel().setWindow(parentModel.getUnitVmModel());
                // from now on only editing is possible
                attachCommand.setIsAvailable(false);
                fillData();
            }
        }

        @Override
        public void updateInterface(Version clusterVersion) {
            InstanceImageLineModel.this.updateInterface(clusterVersion, this);
        }

        @Override
        protected void updateBootableDiskAvailable() {
            updateBootableFrom(parentModel.getAllCurrentDisks());
        }

        @Override
        protected List<Disk> getAttachedNotSubmittedDisks() {
            return parentModel.getNotYetAttachedNotAttachableDisks();
        }
    };
    VM realOrFakeVm = vm;
    Version compatibilityVersion = parentModel.getUnitVmModel().getSelectedCluster().getCompatibilityVersion();
    if (realOrFakeVm == null) {
        realOrFakeVm = new VM();
        realOrFakeVm.setId(null);
        realOrFakeVm.setVdsGroupId(parentModel.getUnitVmModel().getSelectedCluster().getId());
        realOrFakeVm.setStoragePoolId(parentModel.getUnitVmModel().getSelectedDataCenter().getId());
        realOrFakeVm.setVdsGroupCompatibilityVersion(compatibilityVersion);
    }
    model.setVm(realOrFakeVm);
    setupModelAsDialog(model, ConstantsManager.getInstance().getConstants().attachVirtualDiskTitle(), HelpTag.attach_virtual_disk, // $NON-NLS-1$
    "attach_virtual_disk");
    showDialog(model);
    model.initialize(parentModel.getAllCurrentDisks());
    maybeLoadAttachableDisks(model);
}
#method_after
public void attachDisk() {
    InstanceImagesAttachDiskModel model = new InstanceImagesAttachDiskModel() {

        @Override
        public void onSave() {
            if (validate()) {
                flush();
                List<EntityModel<DiskModel>> selectedDisks = getSelectedDisks();
                if (selectedDisks.size() == 1) {
                    // only 0 or 1 is allowed
                    setDisk(selectedDisks.iterator().next().getEntity().getDisk());
                }
                getDiskModel().setEntity(this);
                parentModel.getParentListModel().setWindow(null);
                parentModel.getParentListModel().setWindow(parentModel.getUnitVmModel());
                // from now on only editing is possible
                attachCommand.setIsAvailable(false);
                fillData();
            }
        }

        @Override
        public void updateInterface(Version clusterVersion) {
            InstanceImageLineModel.this.updateInterface(clusterVersion, this);
        }

        @Override
        protected void updateBootableDiskAvailable() {
            updateBootableFrom(parentModel.getAllCurrentDisks());
        }

        @Override
        protected List<Disk> getAttachedNotSubmittedDisks() {
            return parentModel.getNotYetAttachedNotAttachableDisks();
        }
    };
    VM realOrFakeVm = vm;
    Version compatibilityVersion = parentModel.getUnitVmModel().getSelectedCluster().getCompatibilityVersion();
    if (realOrFakeVm == null) {
        realOrFakeVm = new VM();
        realOrFakeVm.setId(null);
        realOrFakeVm.setClusterId(parentModel.getUnitVmModel().getSelectedCluster().getId());
        realOrFakeVm.setStoragePoolId(parentModel.getUnitVmModel().getSelectedDataCenter().getId());
        realOrFakeVm.setClusterCompatibilityVersion(compatibilityVersion);
    }
    model.setVm(realOrFakeVm);
    setupModelAsDialog(model, ConstantsManager.getInstance().getConstants().attachVirtualDiskTitle(), HelpTag.attach_virtual_disk, // $NON-NLS-1$
    "attach_virtual_disk");
    showDialog(model);
    model.initialize(parentModel.getAllCurrentDisks());
    maybeLoadAttachableDisks(model);
}
#end_block

#method_before
private void showNewDialog() {
    final AbstractDiskModel model = new NewDiskModel() {

        @Override
        public void onSave() {
            if (validate()) {
                flush();
                getDiskModel().setEntity(this);
                parentModel.getParentListModel().setWindow(null);
                parentModel.getParentListModel().setWindow(parentModel.getUnitVmModel());
                // the "new" turns into "edit" - no need for attach anymore
                attachCommand.setIsAvailable(false);
                fillData();
                Disk disk = super.getDisk();
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
                    ((DiskImage) disk).setActive(true);
                }
            }
        }

        @Override
        public void updateInterface(Version clusterVersion) {
            InstanceImageLineModel.this.updateInterface(clusterVersion, this);
        }

        @Override
        protected void updateBootableDiskAvailable() {
            updateBootableFrom(parentModel.getAllCurrentDisks());
        }
    };
    VM vm = new VM();
    vm.setVdsGroupId(parentModel.getUnitVmModel().getSelectedCluster().getId());
    vm.setStoragePoolId(parentModel.getUnitVmModel().getSelectedDataCenter().getId());
    vm.setVdsGroupCompatibilityVersion(parentModel.getUnitVmModel().getSelectedCluster().getCompatibilityVersion());
    vm.setQuotaId(parentModel.getUnitVmModel().getQuota().getSelectedItem().getId());
    model.setVm(vm);
    model.getSizeExtend().setIsAvailable(false);
    setupModelAsDialog(model, ConstantsManager.getInstance().getConstants().newVirtualDiskTitle(), HelpTag.new_virtual_disk, // $NON-NLS-1$
    "new_virtual_disk");
    showDialog(model);
    model.initialize(parentModel.getAllCurrentDisks());
    if (getVm() != null) {
        model.setVm(getVm());
        ((NewDiskModel) model).updateSuggestedDiskAliasFromServer();
    } else {
        String currentVmName = parentModel.getUnitVmModel().getName().getEntity();
        if (!StringUtils.isEmpty(currentVmName)) {
            // if already set the VM name on the new VM dialog, suggest the name according to the name
            model.getAlias().setEntity(suggestAliasForNewVm(currentVmName));
        }
    }
}
#method_after
private void showNewDialog() {
    final AbstractDiskModel model = new NewDiskModel() {

        @Override
        public void onSave() {
            if (validate()) {
                flush();
                getDiskModel().setEntity(this);
                parentModel.getParentListModel().setWindow(null);
                parentModel.getParentListModel().setWindow(parentModel.getUnitVmModel());
                // the "new" turns into "edit" - no need for attach anymore
                attachCommand.setIsAvailable(false);
                fillData();
                Disk disk = super.getDisk();
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
                    ((DiskImage) disk).setActive(true);
                }
            }
        }

        @Override
        public void updateInterface(Version clusterVersion) {
            InstanceImageLineModel.this.updateInterface(clusterVersion, this);
        }

        @Override
        protected void updateBootableDiskAvailable() {
            updateBootableFrom(parentModel.getAllCurrentDisks());
        }
    };
    VM vm = new VM();
    vm.setClusterId(parentModel.getUnitVmModel().getSelectedCluster().getId());
    vm.setStoragePoolId(parentModel.getUnitVmModel().getSelectedDataCenter().getId());
    vm.setClusterCompatibilityVersion(parentModel.getUnitVmModel().getSelectedCluster().getCompatibilityVersion());
    Quota selectedQuota = parentModel.getUnitVmModel().getQuota().getSelectedItem();
    vm.setQuotaId(selectedQuota == null ? null : selectedQuota.getId());
    model.setVm(vm);
    model.getSizeExtend().setIsAvailable(false);
    setupModelAsDialog(model, ConstantsManager.getInstance().getConstants().newVirtualDiskTitle(), HelpTag.new_virtual_disk, // $NON-NLS-1$
    "new_virtual_disk");
    showDialog(model);
    model.initialize(parentModel.getAllCurrentDisks());
    if (getVm() != null) {
        model.setVm(getVm());
        ((NewDiskModel) model).updateSuggestedDiskAliasFromServer();
    } else {
        String currentVmName = parentModel.getUnitVmModel().getName().getEntity();
        if (!StringUtils.isEmpty(currentVmName)) {
            // if already set the VM name on the new VM dialog, suggest the name according to the name
            model.getAlias().setEntity(suggestAliasForNewVm(currentVmName));
        }
    }
}
#end_block

#method_before
public Map deleteImage(String sdUUID, String spUUID, String imgGUID, String postZero, String force) {
    return getOKStatusNotImplemented();
}
#method_after
public Map deleteImage(String imgGUID, String spUUID, String sdUUID, boolean postZero, boolean force) {
    return storageService.deleteImage(imgGUID, spUUID, sdUUID, postZero, force);
}
#end_block

#method_before
public List getClusterLevelsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    return resultList;
}
#method_after
public List getClusterLevelsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    return resultList;
}
#end_block

#method_before
public List getSupportedENGINEsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    return resultList;
}
#method_after
public List getSupportedENGINEsList() {
    List resultList = lst();
    resultList.add("3.0");
    resultList.add("3.1");
    resultList.add("3.2");
    resultList.add("3.3");
    resultList.add("3.4");
    resultList.add("3.5");
    resultList.add("3.6");
    resultList.add("4.0");
    return resultList;
}
#end_block

#method_before
public List getEmulatedMachinesList() {
    List resultList = lst();
    resultList.add("pc-0.10");
    resultList.add("pc-0.11");
    resultList.add("pc-0.12");
    resultList.add("pc-0.13");
    resultList.add("pc-0.14");
    resultList.add("pc-0.15");
    resultList.add("pc-1.0");
    resultList.add("pc-1.0");
    resultList.add("pc-i440fx-2.1");
    resultList.add("rhel6.4.0");
    resultList.add("rhel6.5.0");
    resultList.add("rhel6.6.0");
    resultList.add("rhel6.7.0");
    resultList.add("rhel6.8.0");
    resultList.add("rhel6.9.0");
    resultList.add("rhel7.0.0");
    resultList.add("rhel7.5.0");
    resultList.add("pc");
    resultList.add("isapc");
    return resultList;
}
#method_after
public List getEmulatedMachinesList() {
    List resultList = lst();
    resultList.add("pc-0.10");
    resultList.add("pc-0.11");
    resultList.add("pc-0.12");
    resultList.add("pc-0.13");
    resultList.add("pc-0.14");
    resultList.add("pc-0.15");
    resultList.add("pc-1.0");
    resultList.add("pc-1.0");
    resultList.add("pc-i440fx-2.1");
    resultList.add("pseries-rhel7.2.0");
    resultList.add("pc-i440fx-rhel7.2.0");
    resultList.add("rhel6.4.0");
    resultList.add("rhel6.5.0");
    resultList.add("rhel6.6.0");
    resultList.add("rhel6.7.0");
    resultList.add("rhel6.8.0");
    resultList.add("rhel6.9.0");
    resultList.add("rhel7.0.0");
    resultList.add("rhel7.2.0");
    resultList.add("rhel7.5.0");
    resultList.add("pc");
    resultList.add("isapc");
    return resultList;
}
#end_block

#method_before
public Map hostdevListByCaps() {
    // TODO: still not filly supported - in progress
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("computer", getCapability());
        infoMap.put("pci_0000_00_1b_0", getHardware(0));
        infoMap.put("pci_0000_00_1b_1", getHardware(1));
        infoMap.put("pci_0000_00_1b_2", getHardware(2));
        infoMap.put("pci_0000_00_1b_3", getHardware(3));
        infoMap.put("pci_0000_00_1b_4", getHardware(4));
        infoMap.put("pci_0000_00_1b_5", getHardware(5));
        infoMap.put("pci_0000_00_1b_6", getHardware(6));
        infoMap.put("pci_0000_00_1b_7", getHardware(7));
        infoMap.put("pci_0000_00_1b_8", getHardware(8));
        infoMap.put("pci_0000_00_1b_9", getHardware(9));
        infoMap.put("pci_0000_00_1b_10", getHardware(10));
        infoMap.put("pci_0000_00_1b_11", getHardware(11));
        infoMap.put("pci_0000_00_1f_12", getHardware(12));
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map hostdevListByCaps() {
    // TODO: still not fully supported - in progress
    final Host host = getActiveHost();
    try {
        Map resultMap = getDoneStatus();
        Map infoMap = map();
        infoMap.put("computer", getCapability());
        infoMap.put("pci_0000_00_1b_0", getHardware(0));
        infoMap.put("pci_0000_00_1b_1", getHardware(1));
        infoMap.put("pci_0000_00_1b_2", getHardware(2));
        infoMap.put("pci_0000_00_1b_3", getHardware(3));
        infoMap.put("pci_0000_00_1b_4", getHardware(4));
        infoMap.put("pci_0000_00_1b_5", getHardware(5));
        infoMap.put("pci_0000_00_1b_6", getHardware(6));
        infoMap.put("pci_0000_00_1b_7", getHardware(7));
        infoMap.put("pci_0000_00_1b_8", getHardware(8));
        infoMap.put("pci_0000_00_1b_9", getHardware(9));
        infoMap.put("pci_0000_00_1b_10", getHardware(10));
        infoMap.put("pci_0000_00_1b_11", getHardware(11));
        infoMap.put("pci_0000_00_1f_12", getHardware(12));
        resultMap.put("info", infoMap);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "Host.HostDevListByCaps":
            return new HostDevListByCaps();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        // Unsupported command
        default:
            // TODO: Support Host.setMOMPolicyParameters
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#method_after
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "Host.HostDevListByCaps":
            return new HostDevListByCaps();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        default:
            // TODO: Support Host.setMOMPolicyParameters
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#end_block

#method_before
public static JsonCommand createCommand(String methodName) {
    if (methodName.contains("delete") || methodName.contains("Volume.")) {
        log.error("method is {}", methodName);
    }
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        default:
            // TODO: Support Host.setMOMPolicyParameters
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#method_after
public static JsonCommand createCommand(String methodName) {
    switch(methodName) {
        case "Host.getCapabilities":
            return new GetCapabilitiesCommand();
        case "Host.getVMList":
            return new GetVmListCommand();
        case "Host.getStats":
            return new GetStatsCommand();
        case "Host.getAllVmStats":
            return new GetAllVmStatsCommand();
        case "Host.getHardwareInfo":
            return new GetHardwareInfoCommmand();
        case "Host.getAllTasksStatuses":
            return new GetAllTasksStatusesCommand();
        case "Host.getAllTasksInfo":
            return new GetAllTasksInfoCommand();
        case "Host.getStorageDomains":
            return new HostGetStorageDomainsCommand();
        case "Host.getVMFullList":
            return new GetFullVmListCommand();
        case "VM.create":
            return new VmCreateCommand();
        case "VM.destroy":
            return new VmDestroyCommand();
        case "VM.shutdown":
            return new VmShutdownCommand();
        case "VM.getStats":
            return new VmGetStatsCommand();
        case "VM.migrate":
            return new VmMigrateCommand();
        case "VM.setTicket":
            return new VmSetTicketCommand();
        case "StoragePool.spmStart":
            return new SpmStartCommand();
        case "StoragePool.spmStop":
            return new SpmStopCommand();
        case "StoragePool.getSpmStatus":
            return new SpmGetStatusCommand();
        case "StoragePool.connect":
            return new StoragePoolConnectCommand();
        case "StoragePool.disconnect":
            return new StoragePoolDisconnectCommand();
        case "StoragePool.connectStorageServer":
            return new StorageServerConnectCommand();
        case "StoragePool.disconnectStorageServer":
            return new StorageServerDisconnectCommand();
        case "StoragePool.getInfo":
            return new StoragePoolGetInfo();
        case "StoragePool.refresh":
            return new StoragePoolRefreshCommand();
        case "StoragePool.getIsoList":
            return new StoragePoolGetIsoListCommand();
        case "StoragePool.create":
            return new StoragePoolCreateCommand();
        case "StorageDomain.activate":
            return new StorageDomainActivateCommand();
        case "StorageDomain.getInfo":
            return new StorageDomainGetInfoCommand();
        case "StorageDomain.getStats":
            return new StorageDomainGetStatsCommand();
        case "StorageDomain.create":
            return new StorageDomainCreateCommand();
        case "Volume.create":
            return new VolumeCreateCommand();
        case "Task.getStatus":
            return new TaskGetStatusCommand();
        case "Task.stop":
            return new TaskStopCommand();
        case "Task.clear":
            return new TaskClearCommand();
        case "Task.revert":
            return new TaskRevertCommand();
        case "Image.delete":
            return new ImageDelete();
        default:
            // TODO: Support Host.setMOMPolicyParameters
            Exception e = new Exception();
            log.error("Unsupported method " + methodName, e);
            return new UnsupportedCommand();
    }
}
#end_block

#method_before
public Map list(boolean isFull, List<String> vmIds) {
    return vmService.list(isFull, vmIds);
}
#method_after
public Map list(String isFull, List<String> vmIds) {
    return vmService.list(Boolean.parseBoolean(isFull), vmIds);
}
#end_block

#method_before
public Map deleteImage(String imgGUID, String spUUID, String sdUUID, boolean postZero, boolean force) {
    return storageService.deleteVolume(imgGUID, spUUID, sdUUID, postZero, force);
}
#method_after
public Map deleteImage(String imgGUID, String spUUID, String sdUUID, boolean postZero, boolean force) {
    return storageService.deleteImage(imgGUID, spUUID, sdUUID, postZero, force);
}
#end_block

#method_before
public Map getStoragePoolInfo(String spUUID) {
    try {
        final DataCenter dataCenter = getDataCenterById(spUUID);
        final Host host = getActiveHost();
        Map resultMap = getOKStatus();
        Map infoMap = map();
        infoMap.put("spm_id", host.getSpmId());
        // 553c2cb4-54d1-4c30-b2c2-6cb41a03518d
        infoMap.put("master_uuid", dataCenter.getMasterStorageDomainId());
        infoMap.put("name", dataCenter.getName());
        infoMap.put("version", "3");
        String isoDomainId = null;
        // StorageDomain masterStorageDomain = null;
        int i = 0;
        StringBuilder b = new StringBuilder();
        for (StorageDomain storageDomain : dataCenter.getStorageDomainMap().values()) {
            b.append(storageDomain.getId()).append(":").append(storageDomain.getDomainStatus().getName());
            if (i != dataCenter.getStorageDomainMap().values().size() - 1) {
                b.append(",");
            }
            if (storageDomain.getDomainClass() == StorageDomain.DomainClass.ISO) {
                isoDomainId = storageDomain.getId();
            }
        // if (dataCenter.getMasterStorageDomainId().equals(storageDomain.getId())) {
        // masterStorageDomain = storageDomain;
        // }
        }
        infoMap.put("domains", b.toString());
        // 67070f56-027f-4ece-958d-e226639b622b:Active,4a6a6ed3-13f9-4481-8c03-8d217f6baef6:Active,553c2cb4-54d1-4c30-b2c2-6cb41a03518d:Active
        // connected
        infoMap.put("pool_status", dataCenter.getPoolStatus());
        infoMap.put("isoprefix", isoDomainId == null ? "" : "/rhev/data-center/" + spUUID + "/" + isoDomainId + "/images/11111111-1111-1111-1111-111111111111");
        // NFS
        infoMap.put("type", dataCenter.getStorageType().toString());
        infoMap.put("master_ver", dataCenter.getMasterVersion());
        // Integer.valueOf(2)
        infoMap.put("lver", host.getSpmLver());
        Map dominfo = map();
        for (StorageDomain storageDomain : dataCenter.getStorageDomainMap().values()) {
            Map dominfoChild = map();
            // 67070f56-027f-4ece-958d-e226639b622b
            dominfo.put(storageDomain.getId(), dominfoChild);
            dominfoChild.put("status", storageDomain.getDomainStatus().getName());
            dominfoChild.put("diskfree", "59586904064");
            // empty list
            dominfoChild.put("alerts", lst());
            dominfoChild.put("disktotal", "274792972288");
        }
        resultMap.put("info", infoMap);
        resultMap.put("dominfo", dominfo);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map getStoragePoolInfo(String spUUID) {
    try {
        final DataCenter dataCenter = getDataCenterById(spUUID);
        final Host host = getActiveHost();
        Map resultMap = map();
        Map infoMap = map();
        infoMap.put("spm_id", host.getSpmId());
        // 553c2cb4-54d1-4c30-b2c2-6cb41a03518d
        infoMap.put("master_uuid", dataCenter.getMasterStorageDomainId());
        infoMap.put("name", dataCenter.getName());
        infoMap.put("version", "3");
        String isoDomainId = null;
        // StorageDomain masterStorageDomain = null;
        int i = 0;
        StringBuilder b = new StringBuilder();
        for (StorageDomain storageDomain : dataCenter.getStorageDomainMap().values()) {
            // force ACTIVE Status for storage domain.
            if (!storageDomain.getDomainStatus().equals(StorageDomain.DomainStatus.ACTIVE)) {
                storageDomain.setDomainStatus(StorageDomain.DomainStatus.ACTIVE);
                updateStorageDomain(storageDomain);
            }
            // TODO: name of storage domain not sent, API talk with id no naming relations, might be problematic. storageDomain.setName("sd_fake")
            b.append(storageDomain.getId()).append(":").append(storageDomain.getDomainStatus().getName());
            if (i != dataCenter.getStorageDomainMap().values().size() - 1) {
                b.append(",");
            }
            if (storageDomain.getDomainClass() == StorageDomain.DomainClass.ISO) {
                isoDomainId = storageDomain.getId();
            }
        // if (dataCenter.getMasterStorageDomainId().equals(storageDomain.getId())) {
        // masterStorageDomain = storageDomain;
        // }
        }
        infoMap.put("domains", b.toString());
        // 67070f56-027f-4ece-958d-e226639b622b:Active,4a6a6ed3-13f9-4481-8c03-8d217f6baef6:Active,553c2cb4-54d1-4c30-b2c2-6cb41a03518d:Active
        // connected
        infoMap.put("pool_status", dataCenter.getPoolStatus());
        infoMap.put("isoprefix", isoDomainId == null ? "" : "/rhev/data-center/" + spUUID + "/" + isoDomainId + "/images/11111111-1111-1111-1111-111111111111");
        // NFS
        infoMap.put("type", dataCenter.getStorageType().toString());
        infoMap.put("master_ver", dataCenter.getMasterVersion());
        // Integer.valueOf(2)
        infoMap.put("lver", host.getSpmLver());
        Map dominfo = map();
        for (StorageDomain storageDomain : dataCenter.getStorageDomainMap().values()) {
            Map dominfoChild = map();
            // 67070f56-027f-4ece-958d-e226639b622b
            dominfo.put(storageDomain.getId(), dominfoChild);
            dominfoChild.put("status", storageDomain.getDomainStatus().getName());
            dominfoChild.put("diskfree", "59586904064");
            // empty list
            dominfoChild.put("alerts", lst());
            dominfoChild.put("disktotal", "274792972288");
        }
        resultMap.put("info", infoMap);
        resultMap.put("dominfo", dominfo);
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
public Map spmStart(String spUUID, String prevID, String prevLVER, String recoveryMode, String scsiFencing) {
    final Host host = getActiveHost();
    Map resultMap = getOKStatus();
    Task task = new Task(getUuid());
    resultMap.put("uuid", task.getId());
    task.setTarget(host);
    getActiveHost().getRunningTasks().put(task.getId(), task);
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_START_SPM, 10000l, task));
    return resultMap;
}
#method_after
public Map spmStart(String spUUID, String prevID, String prevLVER, String recoveryMode, String scsiFencing) {
    final Host host = getActiveHost();
    Map resultMap = getOKStatus();
    Task task = new Task(getUuid());
    resultMap.put("uuid", task.getId());
    task.setTarget(host);
    getActiveHost().getRunningTasks().put(task.getId(), task);
    TaskProcessor.setTasksMap(host.getName(), task.getId());
    TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_START_SPM, 10000l, task));
    VdsmManager.getInstance().setSpmMap(spUUID, host);
    return resultMap;
}
#end_block

#method_before
public Map spmStop(String spUUID) {
    final Host host = getActiveHost();
    host.setSpmId(-1);
    host.setSpmStatus(Host.SpmStatus.FREE);
    host.setSpmLver(-1);
    updateHost(host);
    Map resultMap = getOKStatus();
    return resultMap;
}
#method_after
public Map spmStop(String spUUID) {
    final Host host = getActiveHost();
    host.setSpmId(-1);
    host.setSpmStatus(Host.SpmStatus.FREE);
    host.setSpmLver(-1);
    updateHost(host);
    Map resultMap = getOKStatus();
    VdsmManager.getInstance().removeSpmFromMap(spUUID);
    return resultMap;
}
#end_block

#method_before
public Map createVolume(String sdUUID, String spUUID, String imgUUID, String size, Integer volFormat, Integer preallocate, Integer diskType, String volUUID, String desc, String srcImgUUID, String srcVolUUID) {
    try {
        DataCenter dataCenter = getDataCenterById(spUUID);
        StorageDomain storageDomain = dataCenter.getStorageDomainMap().get(sdUUID);
        final Volume volume = new Volume();
        volume.setId(volUUID);
        volume.setSize(size);
        volume.setVolFormat(volFormat);
        volume.setPreallocate(preallocate);
        volume.setDiskType(diskType);
        volume.setImgUUID(imgUUID);
        volume.setDesc(desc);
        volume.setSrcImgUUID(srcImgUUID);
        volume.setSrcVolUUID(srcVolUUID);
        log.info("Adding volume: {} for sp: {}, sd: {}", new Object[] { volUUID, spUUID, sdUUID });
        storageDomain.getVolumes().put(volUUID, volume);
        updateDataCenter(dataCenter);
        final Map resultMap = getOKStatus();
        final Task task = new Task(getUuid());
        resultMap.put("uuid", task.getId());
        getActiveHost().getRunningTasks().put(task.getId(), task);
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_CREATE_VOLUME, 5000l, task));
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#method_after
public Map createVolume(String sdUUID, String spUUID, String imgUUID, String size, Integer volFormat, Integer preallocate, Integer diskType, String volUUID, String desc, String srcImgUUID, String srcVolUUID) {
    try {
        DataCenter dataCenter = getDataCenterById(spUUID);
        StorageDomain storageDomain = dataCenter.getStorageDomainMap().get(sdUUID);
        final Volume volume = new Volume();
        volume.setId(volUUID);
        volume.setSize(size);
        volume.setVolFormat(volFormat);
        volume.setPreallocate(preallocate);
        volume.setDiskType(diskType);
        volume.setImgUUID(imgUUID);
        volume.setDesc(desc);
        volume.setSrcImgUUID(srcImgUUID);
        volume.setSrcVolUUID(srcVolUUID);
        log.info("Adding volume: {} for sp: {}, sd: {}", new Object[] { volUUID, spUUID, sdUUID });
        storageDomain.getVolumes().put(volUUID, volume);
        updateDataCenter(dataCenter);
        final Map resultMap = getOKStatus();
        final Task task = new Task(getUuid());
        resultMap.put("uuid", task.getId());
        syncTask(VdsmManager.getInstance().getSpmHost(spUUID), task);
        TaskProcessor.getInstance().addTask(new TaskRequest(TaskType.FINISH_CREATE_VOLUME, 3000l, task));
        return resultMap;
    } catch (Exception e) {
        throw error(e);
    }
}
#end_block

#method_before
public void run() {
    JsonRpcRequest request = null;
    try {
        request = JsonRpcRequest.fromByteArray(message);
        ContextHolder.init();
        ContextHolder.setServerName(client.getHostname());
        ResponseBuilder builder = new ResponseBuilder(request.getId());
        String methodName = request.getMethod();
        builder = CommandFactory.createCommand(methodName).run(request.getParams(), builder);
        send(builder.build(), request.getMethod());
    } catch (Throwable e) {
        log.error("Failure in processing request", e);
        Map<String, Object> error = new HashMap<>();
        error.put("code", 100);
        error.put("message", e.getMessage());
        if (request != null) {
            send(new ResponseBuilder(request.getId()).withError(error).build(), request.getMethod());
        }
    }
}
#method_after
public void run() {
    JsonRpcRequest request = null;
    try {
        request = JsonRpcRequest.fromByteArray(message);
        ContextHolder.init();
        if (client.getRetryPolicy().getIdentifier() != null) {
            ContextHolder.setServerName(client.getRetryPolicy().getIdentifier());
            log.debug("client policy identifier {}", client.getRetryPolicy().getIdentifier());
        } else if (client.getHostname() != null) {
            ContextHolder.setServerName(client.getHostname());
        } else {
            ContextHolder.setServerName(Integer.toString(client.hashCode()));
            log.error("client identifier were not found, using hash");
        }
        ResponseBuilder builder = new ResponseBuilder(request.getId());
        String methodName = request.getMethod();
        builder = CommandFactory.createCommand(methodName).run(request.getParams(), builder);
        send(builder.build(), request.getMethod());
    } catch (Throwable e) {
        log.error("Failure in processing request", e);
        Map<String, Object> error = new HashMap<>();
        error.put("code", 100);
        error.put("message", e.getMessage());
        if (request != null) {
            send(new ResponseBuilder(request.getId()).withError(error).build(), request.getMethod());
        }
    }
}
#end_block

#method_before
public void init(Map<String, String> paramMap) {
    constantDelay = getLong(paramMap.get("constantDelay"));
    randomDelay = getLong(paramMap.get("randomDelay"));
    networkBridgeName = paramMap.get("networkBridgeName");
    cacheDir = paramMap.get("cacheDir");
    // Each run will store its logs separately
    logDir = paramMap.get("logDir") + "/" + System.currentTimeMillis();
    forwardVdsmServer = paramMap.get("forwardVdsmServer");
    vdsmPort = paramMap.get("vdsmPort");
    vmConfAndStatsConstants = paramMap.get("vmConfAndStatsConstants");
    vmConfAndStatsUpdateIntervals = paramMap.get("vmConfAndStatsUpdateIntervals");
    threadpoolSize = Integer.valueOf(paramMap.get("threadPoolSize"));
    final String notLoggedMethods = paramMap.get("notLoggedMethods");
    if (notLoggedMethods != null && notLoggedMethods.trim().length() > 0) {
        final String[] methodNames = notLoggedMethods.split(",");
        for (String methodName : methodNames) {
            notLoggedMethodSet.add(methodName.trim());
        }
    }
    makeDir(cacheDir);
    makeDir(logDir);
    if (isProxyActive()) {
        targetServerUrl = getForwardVdsmServer() + ":" + getVdsmPort() + "/";
    }
}
#method_after
public void init(Map<String, String> paramMap) {
    constantDelay = Utils.getLong(paramMap.get("constantDelay"));
    randomDelay = Utils.getLong(paramMap.get("randomDelay"));
    networkLoad = Utils.splitString(paramMap.get("networkLoad"));
    cpuLoadList = Utils.splitString(paramMap.get("cpuLoad"));
    memLoad = Utils.splitString(paramMap.get("memLoad"));
    storageDelay = Utils.splitString(paramMap.get("storageDelay"));
    networkBridgeName = paramMap.get("networkBridgeName");
    cacheDir = paramMap.get("cacheDir");
    // Each run will store its logs separately
    logDir = paramMap.get("logDir") + "/" + System.currentTimeMillis();
    forwardVdsmServer = paramMap.get("forwardVdsmServer");
    vdsmPort = paramMap.get("vdsmPort");
    vmConfAndStatsConstants = paramMap.get("vmConfAndStatsConstants");
    vmConfAndStatsUpdateIntervals = paramMap.get("vmConfAndStatsUpdateIntervals");
    jsonHandlersThreadsPool = Integer.valueOf(paramMap.get("jsonHandlersThreadsPool"));
    final String notLoggedMethods = paramMap.get("notLoggedMethods");
    if (notLoggedMethods != null && notLoggedMethods.trim().length() > 0) {
        final String[] methodNames = notLoggedMethods.split(",");
        for (String methodName : methodNames) {
            notLoggedMethodSet.add(methodName.trim());
        }
    }
    makeDir(cacheDir);
    makeDir(logDir);
    if (isProxyActive()) {
        targetServerUrl = getForwardVdsmServer() + ":" + getVdsmPort() + "/";
    }
}
#end_block

#method_before
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependecyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setVdsGroupId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setVdsGroupId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#method_after
@Before
public void setUp() {
    final int osId = 0;
    final Version version = Version.v3_0;
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
    injectorRule.bind(DbFacade.class, dbFacade);
    when(cpuFlagsManagerHandler.getCpuId(anyString(), any(Version.class))).thenReturn(CPU_ID);
    when(osRepository.getMinimumRam(osId, version)).thenReturn(0);
    when(osRepository.getMinimumRam(osId, null)).thenReturn(0);
    when(osRepository.getMaximumRam(osId, version)).thenReturn(256);
    when(osRepository.getMaximumRam(osId, null)).thenReturn(256);
    when(osRepository.isWindows(osId)).thenReturn(false);
    when(osRepository.getArchitectureFromOS(osId)).thenReturn(ArchitectureType.x86_64);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<>());
    displayTypeMap.get(osId).put(version, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
    VmHandler.init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new Cluster();
    group.setCpuName("Intel Conroe Family");
    group.setId(Guid.newGuid());
    group.setCompatibilityVersion(version);
    group.setArchitecture(ArchitectureType.x86_64);
    vm.setClusterId(group.getId());
    vm.setClusterArch(ArchitectureType.x86_64);
    vmStatic.setClusterId(group.getId());
    vmStatic.setName("my_vm");
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        public Cluster getCluster() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(false).when(command).isVirtioScsiEnabledForVm(any(Guid.class));
    doReturn(true).when(command).isBalloonEnabled();
    doReturn(true).when(osRepository).isBalloonEnabled(vm.getVmOsId(), group.getCompatibilityVersion());
}
#end_block

#method_before
@Test
public void testLongName() {
    vmStatic.setName("this_should_be_very_long_vm_name_so_it will_fail_can_do_action_validation");
    assertFalse("canDoAction should fail for too long vm name.", command.canDoAction());
    assertCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
}
#method_after
@Test
public void testLongName() {
    vmStatic.setName("this_should_be_very_long_vm_name_so_it will_fail_can_do_action_validation");
    assertFalse("validate should fail for too long vm name.", command.validate());
    assertValidateMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
}
#end_block

#method_before
@Test
public void testValidName() {
    prepareVmToPassCanDoAction();
    mockVmValidator();
    boolean c = command.canDoAction();
    assertTrue("canDoAction should have passed.", c);
}
#method_after
@Test
public void testValidName() {
    prepareVmToPassValidate();
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    boolean c = command.validate();
    assertTrue("validate should have passed.", c);
}
#end_block

#method_before
@Test
public void testChangeToExistingName() {
    prepareVmToPassCanDoAction();
    mockSameNameQuery(true);
    assertFalse("canDoAction should have failed with vm name already in use.", command.canDoAction());
    assertCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
}
#method_after
@Test
public void testChangeToExistingName() {
    prepareVmToPassValidate();
    mockSameNameQuery(true);
    assertFalse("validate should have failed with vm name already in use.", command.validate());
    assertValidateMessage(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
}
#end_block

#method_before
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setName("vm1");
    mockSameNameQuery(true);
    mockVmValidator();
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#method_after
@Test
public void testNameNotChanged() {
    prepareVmToPassValidate();
    vm.setName("vm1");
    mockSameNameQuery(true);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    assertTrue("validate should have passed.", command.validate());
}
#end_block

#method_before
@Test
public void testDedicatedHostNotExistOrNotSameCluster() {
    prepareVmToPassCanDoAction();
    // this will cause null to return when getting vds from vdsDao
    doReturn(vdsDao).when(command).getVdsDao();
    doReturn(false).when(command).isDedicatedVdsExistOnSameCluster(any(VmBase.class), any(ArrayList.class));
    vmStatic.setDedicatedVmForVdsList(Guid.newGuid());
    assertFalse("canDoAction should have failed with invalid dedicated host.", command.canDoAction());
}
#method_after
@Test
public void testDedicatedHostNotExistOrNotSameCluster() {
    prepareVmToPassValidate();
    // this will cause null to return when getting vds from vdsDao
    doReturn(vdsDao).when(command).getVdsDao();
    doReturn(false).when(command).isDedicatedVdsExistOnSameCluster(any(VmBase.class), any(ArrayList.class));
    vmStatic.setDedicatedVmForVdsList(Guid.newGuid());
    assertFalse("validate should have failed with invalid dedicated host.", command.validate());
}
#end_block

#method_before
@Test
public void testValidDedicatedHost() {
    prepareVmToPassCanDoAction();
    mockVmValidator();
    VDS vds = new VDS();
    vds.setVdsGroupId(group.getId());
    doReturn(vdsDao).when(command).getVdsDao();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(true).when(command).isDedicatedVdsExistOnSameCluster(any(VmBase.class), any(ArrayList.class));
    vmStatic.setDedicatedVmForVdsList(Guid.newGuid());
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#method_after
@Test
public void testValidDedicatedHost() {
    prepareVmToPassValidate();
    mockVmValidator();
    VDS vds = new VDS();
    vds.setClusterId(group.getId());
    doReturn(vdsDao).when(command).getVdsDao();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(true).when(command).isDedicatedVdsExistOnSameCluster(any(VmBase.class), any(ArrayList.class));
    vmStatic.setDedicatedVmForVdsList(Guid.newGuid());
    command.initEffectiveCompatibilityVersion();
    assertTrue("validate should have passed.", command.validate());
}
#end_block

#method_before
@Test
public void testInvalidNumberOfMonitors() {
    prepareVmToPassCanDoAction();
    vmStatic.setNumOfMonitors(99);
    assertFalse("canDoAction should have failed with invalid number of monitors.", command.canDoAction());
    assertCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
}
#method_after
@Test
public void testInvalidNumberOfMonitors() {
    prepareVmToPassValidate();
    vmStatic.setNumOfMonitors(99);
    assertFalse("validate should have failed with invalid number of monitors.", command.validate());
    assertValidateMessage(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
}
#end_block

#method_before
private void mockVmDevice(VmDevice vmDevice) {
    when(vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), vmDevice.getType())).thenReturn(Arrays.asList(vmDevice));
    doReturn(vmDeviceDao).when(dbFacade).getVmDeviceDao();
}
#method_after
private void mockVmDevice(VmDevice vmDevice) {
    when(vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), vmDevice.getType())).thenReturn(Arrays.asList(vmDevice));
    doReturn(vmDeviceDao).when(dbFacade).getVmDeviceDao();
    VmDeviceUtils.init();
}
#end_block

#method_before
@Test
public void testChangeClusterForbidden() {
    prepareVmToPassCanDoAction();
    vmStatic.setVdsGroupId(Guid.newGuid());
    assertFalse("canDoAction should have failed with can't change cluster.", command.canDoAction());
    assertCanDoActionMessage(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
}
#method_after
@Test
public void testChangeClusterForbidden() {
    prepareVmToPassValidate();
    Cluster newGroup = new Cluster();
    newGroup.setId(Guid.newGuid());
    newGroup.setCompatibilityVersion(Version.v3_0);
    vmStatic.setClusterId(newGroup.getId());
    doReturn(clusterDao).when(command).getClusterDao();
    assertFalse("validate should have failed with can't change cluster.", command.validate());
    assertValidateMessage(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
}
#end_block

#method_before
@Test
public void testCannotDisableVirtioScsi() {
    prepareVmToPassCanDoAction();
    command.getParameters().setVirtioScsiEnabled(false);
    Disk disk = new DiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setPlugged(true);
    mockDiskDaoGetAllForVm(Collections.singletonList(disk), true);
    mockVmValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
}
#method_after
@Test
public void testCannotDisableVirtioScsi() {
    prepareVmToPassValidate();
    command.getParameters().setVirtioScsiEnabled(false);
    Disk disk = new DiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setPlugged(true);
    mockDiskDaoGetAllForVm(Collections.singletonList(disk), true);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
}
#end_block

#method_before
@Test
public void testCanEditARunningVM() {
    prepareVmToPassCanDoAction();
    vm.setStatus(VMStatus.Up);
    mockDiskDaoGetAllForVm(Collections.<Disk>emptyList(), true);
    mockVmValidator();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(true).when(command).areUpdatedFieldsLegal();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testCanEditARunningVM() {
    prepareVmToPassValidate();
    vm.setStatus(VMStatus.Up);
    mockDiskDaoGetAllForVm(Collections.<Disk>emptyList(), true);
    mockVmValidator();
    doReturn(vmDeviceDao).when(command).getVmDeviceDao();
    doReturn(true).when(command).areUpdatedFieldsLegal();
    command.initEffectiveCompatibilityVersion();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
@Test
public void testUnsupportedCpus() {
    prepareVmToPassCanDoAction();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(0, Version.v3_0), value);
    when(osRepository.isCpuSupported(0, Version.v3_0, CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#method_after
@Test
public void testUnsupportedCpus() {
    prepareVmToPassValidate();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(0, Version.v3_0), value);
    when(osRepository.isCpuSupported(0, Version.v3_0, CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    command.initEffectiveCompatibilityVersion();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#end_block

#method_before
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassCanDoAction();
    group.setCompatibilityVersion(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
public void testCannotUpdateOSNotSupportVirtioScsi() {
    prepareVmToPassValidate();
    group.setCompatibilityVersion(Version.v3_3);
    when(command.isVirtioScsiEnabledForVm(any(Guid.class))).thenReturn(true);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void testMigratoinCanBeSetWhenVMUsesScsiReservation() {
    prepareVmToPassCanDoAction();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    VmDevice device = createVmDevice();
    device.setUsingScsiReservation(false);
    mockVmDevice(device);
    mockVmValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void testMigratoinCanBeSetWhenVMUsesScsiReservation() {
    prepareVmToPassValidate();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    VmDevice device = createVmDevice();
    device.setUsingScsiReservation(false);
    mockVmDevice(device);
    mockVmValidator();
    command.initEffectiveCompatibilityVersion();
    ValidateTestUtils.runAndAssertValidateSuccess(command);
}
#end_block

#method_before
private VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(Guid.Empty, vm.getId()), VmDeviceGeneralType.DISK, "device", "address", 1, new HashMap<String, Object>(), true, true, true, "alias", new HashMap<String, String>(), Guid.newGuid(), "logical", true);
}
#method_after
private VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(Guid.Empty, vm.getId()), VmDeviceGeneralType.DISK, "device", "address", 1, new HashMap<>(), true, true, true, "alias", new HashMap<>(), Guid.newGuid(), "logical", true);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    int threadsPerCpu = newVmStatic.getThreadsPerCpu();
    int memSizeMb = newVmStatic.getMemSizeMb();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets, threadsPerCpu);
        hotSetMemory(memSizeMb);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDao().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    // try hotplug only if topology (cpuPerSocket) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        auditLogHotSetCpusCandos(params);
    }
}
#method_after
private void hotSetCpus(int cpuPerSocket, int newNumOfSockets, int newThreadsPerCpu) {
    int currentSockets = getVm().getNumOfSockets();
    int currentCpuPerSocket = getVm().getCpuPerSocket();
    int currentThreadsPerCpu = getVm().getThreadsPerCpu();
    // try hotplug only if topology (cpuPerSocket, threadsPerCpu) hasn't changed
    if (getVm().getStatus() == VMStatus.Up && currentSockets != newNumOfSockets && currentCpuPerSocket == cpuPerSocket && currentThreadsPerCpu == newThreadsPerCpu) {
        HotSetNumberOfCpusParameters params = new HotSetNumberOfCpusParameters(newVmStatic, currentSockets < newNumOfSockets ? PlugAction.PLUG : PlugAction.UNPLUG);
        setNumberOfCpusResult = runInternalAction(VdcActionType.HotSetNumberOfCpus, params, cloneContextAndDetachFromParent());
        newVmStatic.setNumOfSockets(setNumberOfCpusResult.getSucceeded() ? newNumOfSockets : currentSockets);
        hotSetCpusLog(params);
    }
}
#end_block

#method_before
private void hotSetMemory(int newAmountOfMemory) {
    int currentMemory = getVm().getMemSizeMb();
    if (getVm().getStatus() == VMStatus.Up && currentMemory != newAmountOfMemory) {
        HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
        0);
        VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
        auditLogHotSetMemCandos(params, setAmountOfMemoryResult);
    }
}
#method_after
private void hotSetMemory(int newAmountOfMemory) {
    int currentMemory = getVm().getMemSizeMb();
    if (getVm().getStatus() == VMStatus.Up && currentMemory != newAmountOfMemory) {
        HotSetAmountOfMemoryParameters params = new HotSetAmountOfMemoryParameters(newVmStatic, currentMemory < newAmountOfMemory ? PlugAction.PLUG : PlugAction.UNPLUG, // We always use node 0, auto-numa should handle the allocation
        0);
        VdcReturnValueBase setAmountOfMemoryResult = runInternalAction(VdcActionType.HotSetAmountOfMemory, params, cloneContextAndDetachFromParent());
        newVmStatic.setMemSizeMb(setAmountOfMemoryResult.getSucceeded() ? newAmountOfMemory : currentMemory);
        hotSetMemlog(params, setAmountOfMemoryResult);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getCluster().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
private GraphicsDevice getGraphicsDevOfType(GraphicsType type) {
    List<GraphicsDevice> graphicsDevices = getGraphicsDevices();
    for (GraphicsDevice dev : graphicsDevices) {
        if (dev.getGraphicsType() == type) {
            return dev;
        }
    }
    return null;
}
#method_after
private GraphicsDevice getGraphicsDevOfType(GraphicsType type) {
    return getGraphicsDevices().stream().filter(dev -> dev.getGraphicsType() == type).findFirst().orElse(null);
}
#end_block

#method_before
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    VmNumaNodeDao dao = DbFacade.getInstance().getVmNumaNodeDao();
    List<VmNumaNode> addList = new ArrayList<>();
    List<VmNumaNode> oldList = dao.getAllVmNumaNodeByVmId(getVmId());
    Map<Guid, VmNumaNode> removeMap = new HashMap<>();
    for (VmNumaNode node : oldList) {
        removeMap.put(node.getId(), node);
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    List<VmNumaNode> updateList = new ArrayList<>();
    if (newList != null) {
        for (VmNumaNode node : newList) {
            // no id means new entity
            if (node.getId() == null) {
                addList.add(node);
            } else {
                updateList.add(node);
            }
        }
    }
    for (VmNumaNode vmNumaNode : updateList) {
        removeMap.remove(vmNumaNode.getId());
    }
    VmNumaNodeOperationParameters params;
    if (!removeMap.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), new ArrayList<>(removeMap.values()));
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.RemoveVmNumaNodes, params));
    }
    if (!updateList.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), updateList);
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.UpdateVmNumaNodes, params));
    }
    if (!addList.isEmpty()) {
        params = new VmNumaNodeOperationParameters(getVmId(), addList);
        addAddtionalParams(params);
        addLogMessages(getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params));
    }
}
#method_after
private void updateVmNumaNodes() {
    if (!getParameters().isUpdateNuma()) {
        return;
    }
    List<VmNumaNode> newList = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getParameters().getVm(), new ArrayList<>(newList));
    addLogMessages(getBackend().runInternalAction(VdcActionType.SetVmNumaNodes, params));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(EngineMessage.VAR__ACTION__UPDATE);
    addCanDoActionMessage(EngineMessage.VAR__TYPE__VM);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__UPDATE);
    addValidationMessage(EngineMessage.VAR__TYPE__VM);
}
#end_block

#method_before
protected boolean isDedicatedVdsExistOnSameCluster(VmBase vm, ArrayList<String> canDoActionMessages) {
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vm, canDoActionMessages);
}
#method_after
protected boolean isDedicatedVdsExistOnSameCluster(VmBase vm, ArrayList<String> validationMessages) {
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vm, validationMessages);
}
#end_block

#method_before
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean isValidPciAndIdeLimit(VM vmFromParams) {
    List<Disk> allDisks = getDbFacade().getDiskDao().getAllForVm(getVmId());
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    return checkPciAndIdeLimit(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), vmFromParams.getNumOfMonitors(), interfaces, allDisks, isVirtioScsiEnabled(), hasWatchdog(), isBalloonEnabled(), isSoundDeviceEnabled(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
        quotaSanityOnly = true;
    } else {
        if (getParameters().getVmStaticData().getQuotaId() == null || getParameters().getVmStaticData().getQuotaId().equals(Guid.Empty) || !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getVmtCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getVdsGroupId(), getParameters().getVmStaticData().getCpuPerSocket() * getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    // The cases must be persistent with the create_functions_sp
    if (!getQuotaManager().isVmStatusQuotaCountable(getVm().getStatus())) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
        quotaSanityOnly = true;
    } else {
        if (getParameters().getVmStaticData().getQuotaId() == null || getParameters().getVmStaticData().getQuotaId().equals(Guid.Empty) || !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaClusterConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getClusterId(), getVm().getNumOfCpus(), getVm().getMemSizeMb()));
            list.add(new QuotaClusterConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getClusterId(), getParameters().getVmStaticData().getNumOfCpus(), getParameters().getVmStaticData().getMemSizeMb()));
        }
    }
    return list;
}
#end_block

#method_before
public ValidationResult vmHostCanLiveMerge() {
    for (VM vm : vms) {
        if (!vm.isDown() && ((vm.getRunOnVds() == null || !DbFacade.getInstance().getVdsDao().get(vm.getRunOnVds()).getLiveMergeSupport()))) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HOST_CANNOT_LIVE_MERGE, String.format("$VmName %s", vm.getName()));
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmHostCanLiveMerge() {
    for (VM vm : vms) {
        if (!vm.isDown() && (vm.getRunOnVds() == null || !DbFacade.getInstance().getVdsDao().get(vm.getRunOnVds()).getLiveMergeSupport())) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_VM_HOST_CANNOT_LIVE_MERGE, String.format("$VmName %s", vm.getName()));
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult vmNotHavingDeviceSnapshotsAttachedToOtherVms(boolean onlyPlugged) {
    for (VM vm : vms) {
        List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vm.getId());
        ValidationResult result = (new DiskImagesValidator(ImagesHandler.filterImageDisks(vmDisks, true, false, true))).diskImagesSnapshotsNotAttachedToOtherVms(onlyPlugged);
        if (result != ValidationResult.VALID) {
            return result;
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmNotHavingDeviceSnapshotsAttachedToOtherVms(boolean onlyPlugged) {
    for (VM vm : vms) {
        List<Disk> vmDisks = getDbFacade().getDiskDao().getAllForVm(vm.getId());
        ValidationResult result = new DiskImagesValidator(ImagesHandler.filterImageDisks(vmDisks, true, false, true)).diskImagesSnapshotsNotAttachedToOtherVms(onlyPlugged);
        if (result != ValidationResult.VALID) {
            return result;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult canDisableVirtioScsi(Collection<? extends Disk> vmDisks) {
    if (vmDisks == null) {
        vmDisks = getDiskDao().getAllForVm(vms.iterator().next().getId(), true);
    }
    boolean isVirtioScsiDiskExist = CollectionUtils.exists(vmDisks, new Predicate() {

        @Override
        public boolean evaluate(Object disk) {
            return ((Disk) disk).getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    });
    if (isVirtioScsiDiskExist) {
        return new ValidationResult(EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult canDisableVirtioScsi(Collection<? extends Disk> vmDisks) {
    if (vmDisks == null) {
        vmDisks = getDiskDao().getAllForVm(vms.iterator().next().getId(), true);
    }
    boolean isVirtioScsiDiskExist = vmDisks.stream().anyMatch(d -> d.getDiskInterface() == DiskInterface.VirtIO_SCSI);
    if (isVirtioScsiDiskExist) {
        return new ValidationResult(EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult vmNotHavingPassthroughVnics() {
    for (VM vm : vms) {
        List<VmNetworkInterface> vnics = getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        List<VmNetworkInterface> passthroughVnics = LinqUtils.filter(vnics, new org.ovirt.engine.core.utils.linq.Predicate<VmNetworkInterface>() {

            public boolean eval(VmNetworkInterface vnic) {
                return vnic.isPassthrough();
            }
        });
        Collection<String> replacements = ReplacementUtils.replaceWithNameable("interfaces", passthroughVnics);
        replacements.add(String.format("$vmName %s", vm.getName()));
        if (!passthroughVnics.isEmpty()) {
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_OF_PASSTHROUGH_VNICS_IS_NOT_SUPPORTED, replacements);
        }
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult vmNotHavingPassthroughVnics() {
    for (VM vm : vms) {
        List<VmNetworkInterface> vnics = getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vm.getId());
        List<String> passthroughVnicNames = vnics.stream().filter(VmNic::isPassthrough).map(VmNic::getName).collect(Collectors.toList());
        if (!passthroughVnicNames.isEmpty()) {
            Collection<String> replacements = ReplacementUtils.replaceWith("interfaces", passthroughVnicNames);
            replacements.add(String.format("$vmName %s", vm.getName()));
            return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_OF_PASSTHROUGH_VNICS_IS_NOT_SUPPORTED, replacements);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult isPinnedVmRunningOnDedicatedHost(VM recentVm, VmStatic paramVm) {
    if (!VmHandler.isVmPinned(paramVm)) {
        // VM is not pinned
        return ValidationResult.VALID;
    }
    if (recentVm.getStatus() == VMStatus.Up || recentVm.getStatus() == VMStatus.Paused) {
        // VM is up or paused, therefore vm.getRunOnVds() != null
        if (paramVm.getDedicatedVmForVdsList().contains(recentVm.getRunOnVds())) {
            // VM is running on a dedicated host
            return ValidationResult.VALID;
        }
        // reached here, VM is NOT running on a dedicated host
        // fail with error message
        String hostName = String.format("$hostName %1$s", recentVm.getRunOnVdsName());
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PINNED_VM_NOT_RUNNING_ON_DEDICATED_HOST, hostName, hostName);
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isPinnedVmRunningOnDedicatedHost(VM recentVm, VmStatic paramVm) {
    boolean isPinned = paramVm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST;
    Guid vdsId = recentVm.getRunOnVds();
    List<Guid> hostList = paramVm.getDedicatedVmForVdsList();
    // If hostList is empty -> all hosts are allowed
    if (isPinned && vdsId != null && !hostList.isEmpty() && !hostList.contains(vdsId)) {
        // VM is NOT running on a dedicated host
        // fail with error message
        String hostName = String.format("$hostName %1$s", recentVm.getRunOnVdsName());
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_PINNED_VM_NOT_RUNNING_ON_DEDICATED_HOST, hostName, hostName);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@OnTimerMethodAnnotation("checkCertificationValidity")
public void checkCertificationValidity() {
    try {
        if (!checkCertificate(EngineEncryptionUtils.getCertificate(EngineLocalConfig.getInstance().getPKICACert()), AuditLogType.ENGINE_CA_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null) ^ !checkCertificate((X509Certificate) EngineEncryptionUtils.getCertificate(), AuditLogType.ENGINE_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null)) {
            return;
        }
        if (!Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)) {
            return;
        }
        hostDao.getAll().stream().filter(host -> host.getStatus() == VDSStatus.Up || host.getStatus() == VDSStatus.NonOperational).forEach(host -> checkHostCertificateValidity(host));
    } catch (Exception e) {
        log.error("Failed to check certification validity: {}", e.getMessage());
        log.error("Exception", e);
    }
}
#method_after
@OnTimerMethodAnnotation("checkCertificationValidity")
public void checkCertificationValidity() {
    try {
        if (!checkCertificate(EngineEncryptionUtils.getCertificate(EngineLocalConfig.getInstance().getPKICACert()), AuditLogType.ENGINE_CA_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CA_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null) ^ !checkCertificate((X509Certificate) EngineEncryptionUtils.getCertificate(), AuditLogType.ENGINE_CERTIFICATION_HAS_EXPIRED, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE_ALERT, AuditLogType.ENGINE_CERTIFICATION_IS_ABOUT_TO_EXPIRE, null)) {
            return;
        }
        if (!Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication)) {
            return;
        }
        hostDao.getAll().stream().filter(host -> host.getStatus() == VDSStatus.Up || host.getStatus() == VDSStatus.NonOperational).forEach(this::checkHostCertificateValidity);
    } catch (Exception e) {
        log.error("Failed to check certification validity: {}", e.getMessage());
        log.error("Exception", e);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    // We can share only ISO or Export domain , or a data domain
    // which is not attached.
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    boolean returnValue = checkStoragePool() && initializeVds() && validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool());
    if (returnValue && getStoragePool().getStatus() == StoragePoolStatus.Uninitialized && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        returnValue = false;
        addValidationMessage(EngineMessage.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    if (returnValue && getStoragePool().getStatus() != StoragePoolStatus.Uninitialized) {
        returnValue = checkMasterDomainIsUp();
    }
    return returnValue;
}
#method_after
@Override
protected boolean validate() {
    // We can share only ISO or Export domain , or a data domain
    // which is not attached.
    StorageDomainToPoolRelationValidator storageDomainToPoolRelationValidator = new StorageDomainToPoolRelationValidator(getStorageDomain().getStorageStaticData(), getStoragePool());
    boolean returnValue = checkStoragePool() && initializeVds() && checkStorageDomain() && validate(storageDomainToPoolRelationValidator.validateDomainCanBeAttachedToPool());
    if (returnValue && getStoragePool().getStatus() == StoragePoolStatus.Uninitialized && getStorageDomain().getStorageDomainType() != StorageDomainType.Data) {
        returnValue = false;
        addValidationMessage(EngineMessage.ERROR_CANNOT_ADD_STORAGE_POOL_WITHOUT_DATA_DOMAIN);
    }
    if (returnValue && getStoragePool().getStatus() != StoragePoolStatus.Uninitialized) {
        returnValue = checkMasterDomainIsUp();
    }
    return returnValue;
}
#end_block

#method_before
public ValidationResult passthroughProfileIsSupported() {
    StoragePool dataCenter = dcDao.get(getNetwork().getDataCenterId());
    Version dcCompVer = dataCenter.getCompatibilityVersion();
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_PASSTHROUGH_PROFILE_NOT_SUPPORTED).when(vnicProfile.isPassthrough() && !FeatureSupported.sriov(dcCompVer));
}
#method_after
public ValidationResult passthroughProfileIsSupported() {
    StoragePool dataCenter = dcDao.get(getNetwork().getDataCenterId());
    Version dcCompatibilityVersion = dataCenter.getCompatibilityVersion();
    return ValidationResult.failWith(EngineMessage.ACTION_TYPE_FAILED_PASSTHROUGH_PROFILE_NOT_SUPPORTED).when(vnicProfile.isPassthrough() && !FeatureSupported.sriov(dcCompatibilityVersion));
}
#end_block

#method_before
private void addMissingHostNicVfsConfigsToDb() {
    final List<HostNicVfsConfig> hostNicVfsConfigsToAdd = new ArrayList<>();
    for (HostDevice device : fetchedMap.values()) {
        if (networkDeviceHelper.isSriovDevice(device)) {
            addToListIfNotNull(getHostNicVfsConfigToAddIfNotExist(device), hostNicVfsConfigsToAdd);
        }
    }
    if (!hostNicVfsConfigsToAdd.isEmpty()) {
        hostNicVfsConfigDao.saveAllInBatch(hostNicVfsConfigsToAdd);
    }
}
#method_after
private void addMissingHostNicVfsConfigsToDb() {
    final List<HostNicVfsConfig> hostNicVfsConfigsToAdd = new ArrayList<>();
    for (HostDevice device : fetchedMap.values()) {
        if (networkDeviceHelper.isSriovDevice(device)) {
            addToListIfNotNull(createHostNicVfsConfigToAddIfNotExist(device), hostNicVfsConfigsToAdd);
        }
    }
    if (!hostNicVfsConfigsToAdd.isEmpty()) {
        hostNicVfsConfigDao.saveAllInBatch(hostNicVfsConfigsToAdd);
    }
}
#end_block

#method_before
public AlertPanel showAlert(final Type type, final SafeHtml message) {
    final AlertPanel alertPanel = createAlert(type, message);
    ScheduledCommand command = new ScheduledCommand() {

        @Override
        public void execute() {
            attachAlert(alertPanel);
        }
    };
    if (canShowAlerts) {
        command.execute();
    } else {
        deferredAlertCommands.add(command);
    }
    return alertPanel;
}
#method_after
public void showAlert(final Type type, final SafeHtml message) {
    showAlert(type, message, 0);
}
#end_block

#method_before
public AlertPanel showAlert(final Type type, final SafeHtml message) {
    final AlertPanel alertPanel = createAlert(type, message);
    ScheduledCommand command = new ScheduledCommand() {

        @Override
        public void execute() {
            attachAlert(alertPanel);
        }
    };
    if (canShowAlerts) {
        command.execute();
    } else {
        deferredAlertCommands.add(command);
    }
    return alertPanel;
}
#method_after
public void showAlert(final Type type, final SafeHtml message, final int autoHideMs) {
    ScheduledCommand command = new ScheduledCommand() {

        @Override
        public void execute() {
            final AlertPanel alert = createAlert(type, message);
            attachAlert(alert);
            if (autoHideMs > 0) {
                final Timer timer = new Timer() {

                    @Override
                    public void run() {
                        detachAlert(alert);
                    }
                };
                alert.getWidget().addCloseHandler(new AlertCloseHandler() {

                    @Override
                    public void onClose(AlertCloseEvent evt) {
                        timer.cancel();
                    }
                });
                timer.schedule(autoHideMs);
            }
        }
    };
    if (canShowAlerts) {
        command.execute();
    } else {
        deferredAlertCommands.add(command);
    }
}
#end_block

#method_before
public void detachAlert(AlertPanel alertPanel) {
    RootPanel.get().remove(alertPanel);
}
#method_after
void detachAlert(AlertPanel alertPanel) {
    RootPanel.get().remove(alertPanel);
}
#end_block

#method_before
private void displayBrowserCompatibilityWarning() {
    if (!internalConfiguration.isCurrentBrowserSupported() && DisplayBrowserCompatibilityWarning.getValue()) {
        final AlertPanel alert = getAlertManager().showAlert(Type.WARNING, SafeHtmlUtils.fromSafeConstant(messages.browserNotSupported(dynamicMessages.compatibleBrowserDocsUrl())));
        final Timer timer = new Timer() {

            @Override
            public void run() {
                getAlertManager().detachAlert(alert);
            }
        };
        alert.getWidget().addCloseHandler(new AlertCloseHandler() {

            @Override
            public void onClose(AlertCloseEvent evt) {
                timer.cancel();
            }
        });
        timer.schedule(5000);
    }
}
#method_after
private void displayBrowserCompatibilityWarning() {
    if (!internalConfiguration.isCurrentBrowserSupported() && DisplayBrowserCompatibilityWarning.getValue()) {
        getAlertManager().showAlert(Type.WARNING, SafeHtmlUtils.fromSafeConstant(messages.browserNotSupported(dynamicMessages.compatibleBrowserDocsUrl())), 5000);
    }
}
#end_block

#method_before
void initUncaughtExceptionHandler(final Logger rootLogger, final Logger remoteLogger) {
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            // $NON-NLS-1$
            remoteLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            alertManager.showUncaughtExceptionAlert(t);
        }
    });
}
#method_after
void initUncaughtExceptionHandler(final Logger rootLogger, final Logger remoteLogger) {
    // Prevent uncaught exceptions from escaping application code
    GWT.setUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void onUncaughtException(Throwable t) {
            // $NON-NLS-1$
            rootLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            // $NON-NLS-1$
            remoteLogger.log(Level.SEVERE, "Uncaught exception: ", t);
            if (DisplayUncaughtUIExceptions.getValue()) {
                alertManager.showUncaughtExceptionAlert(t);
            }
        }
    });
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(// $NON-NLS-1$
    StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), ",")));
    // Set attributes for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        String ssoToken = (String) request.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (ssoToken != null) {
            request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(ssoToken));
        }
    }
    // Set attributes for engineSessionTimeout object
    request.setAttribute(MD5Attributes.ATTR_ENGINE_SESSION_TIMEOUT.getKey(), getEngineSessionTimeoutObject(getUserSessionTimeout(), getUserSessionHardTimeout()));
    // Set attribute for engineRpmVersion object
    String engineRpmVersion = getEngineRpmVersion(getEngineSessionId(request));
    request.setAttribute(MD5Attributes.ATTR_ENGINE_RPM_VERSION.getKey(), getValueObject(engineRpmVersion));
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getApplicationTypeFromRequest(request), getLocaleFromRequest(request)));
    request.setAttribute(MD5Attributes.ATTR_BASE_CONTEXT_PATH.getKey(), getValueObject(ServletUtils.getBaseContextPath(request)));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_LOCALES.getKey(), getValueObject(// $NON-NLS-1$
    StringUtils.join(UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()), ",")));
    request.setAttribute(MD5Attributes.ATTR_DISPLAY_UNCAUGHT_UI_EXCEPTIONS.getKey(), getDisplayUncaughtUIExceptions() ? BooleanNode.TRUE : BooleanNode.FALSE);
    // Set attributes for userInfo object
    DbUser loggedInUser = getLoggedInUser(getEngineSessionId(request));
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
        String ssoToken = (String) request.getSession().getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (ssoToken != null) {
            request.setAttribute(MD5Attributes.ATTR_SSO_TOKEN.getKey(), getValueObject(ssoToken));
        }
    }
    // Set attributes for engineSessionTimeout object
    request.setAttribute(MD5Attributes.ATTR_ENGINE_SESSION_TIMEOUT.getKey(), getEngineSessionTimeoutObject(getUserSessionTimeout(), getUserSessionHardTimeout()));
    // Set attribute for engineRpmVersion object
    String engineRpmVersion = getEngineRpmVersion(getEngineSessionId(request));
    request.setAttribute(MD5Attributes.ATTR_ENGINE_RPM_VERSION.getKey(), getValueObject(engineRpmVersion));
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
protected ObjectNode getUserInfoObject(DbUser loggedInUser) {
    ObjectNode obj = createObjectNode();
    // $NON-NLS-1$
    obj.put("id", loggedInUser.getId().toString());
    // $NON-NLS-1$
    obj.put("userName", loggedInUser.getLoginName());
    // $NON-NLS-1$
    obj.put("domain", loggedInUser.getDomain());
    return obj;
}
#method_after
protected ObjectNode getUserInfoObject(DbUser loggedInUser) {
    ObjectNode obj = createObjectNode();
    // $NON-NLS-1$
    obj.put("id", loggedInUser.getId().toString());
    // $NON-NLS-1$
    obj.put("userName", loggedInUser.getLoginName());
    // $NON-NLS-1$
    obj.put("domain", loggedInUser.getDomain());
    // $NON-NLS-1$
    obj.put("isAdmin", loggedInUser.isAdmin());
    return obj;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(getEngineSessionId(request));
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineReportsUrl object
    request.setAttribute(ATTR_ENGINE_REPORTS_BASE_URL, getReportInit(reportRedirectUrl.substring(reportBaseUrl.length()), reportRightClickRedirectUrl.substring(reportBaseUrl.length())));
    request.setAttribute(ATTR_DISPLAY_SUPPORTED_BROWSER_WARNING, getValueObject(String.valueOf(getDisplaySupportedBrowserWarning())));
    super.doGet(request, response);
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for applicationMode object
    Integer applicationMode = getApplicationMode(getEngineSessionId(request));
    request.setAttribute(ATTR_APPLICATION_MODE, getApplicationModeObject(applicationMode));
    // Set attribute for pluginDefinitions array
    List<PluginData> pluginData = getPluginData();
    request.setAttribute(ATTR_PLUGIN_DEFS, getPluginDefinitionsArray(pluginData));
    // Set attribute for engineReportsUrl object
    request.setAttribute(ATTR_ENGINE_REPORTS_BASE_URL, getReportInit(reportRedirectUrl.substring(reportBaseUrl.length()), reportRightClickRedirectUrl.substring(reportBaseUrl.length())));
    request.setAttribute(ATTR_DISPLAY_SUPPORTED_BROWSER_WARNING, getDisplaySupportedBrowserWarning() ? BooleanNode.TRUE : BooleanNode.FALSE);
    super.doGet(request, response);
}
#end_block

#method_before
private void evaluateMaintenanceHostCommandProgress(MaintenanceVdsCommand<MaintenanceVdsParameters> maintenanceCommand) {
    MaintenanceVdsParameters parameters = (MaintenanceVdsParameters) maintenanceCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Invoke the upgrade action
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Stoping all gluster services.", getHostName(parameters.getVdsId()));
            stopGlusterServices(parameters.getVdsId());
            maintenanceCommand.setCommandStatus(CommandStatus.SUCCEEDED);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with the upgrade
        default:
            if (isMaintenanceCommandExecuted(maintenanceCommand)) {
                log.info("Host '{}' failed to move to maintenance mode. Could not stop Gluster services.", getHostName(parameters.getVdsId()));
                maintenanceCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#method_after
private void evaluateMaintenanceHostCommandProgress(MaintenanceVdsCommand<MaintenanceVdsParameters> maintenanceCommand) {
    MaintenanceVdsParameters parameters = (MaintenanceVdsParameters) maintenanceCommand.getParameters();
    VdsDynamic host = DbFacade.getInstance().getVdsDynamicDao().get(parameters.getVdsId());
    switch(host.getStatus()) {
        // Wait till moving to maintenance ends
        case PreparingForMaintenance:
            break;
        // Stop Gluster processes
        case Maintenance:
            log.info("Host '{}' is on maintenance mode. Stoping all gluster services.", getHostName(parameters.getVdsId()));
            stopGlusterServices(parameters.getVdsId());
            maintenanceCommand.setCommandStatus(CommandStatus.SUCCEEDED);
            break;
        // Any other status implies maintenance action failed, and the callback cannot proceed with stopping gluster's services
        default:
            if (isMaintenanceCommandExecuted(maintenanceCommand)) {
                log.info("Host '{}' failed to move to maintenance mode. Could not stop Gluster services.", getHostName(parameters.getVdsId()));
                maintenanceCommand.setCommandStatus(CommandStatus.FAILED);
            }
            break;
    }
}
#end_block

#method_before
private void stopGlusterServices(Guid vdsId) {
    ResourceManager resourceManager = ResourceManager.getInstance();
    GlusterBrickDao glusterBrickDao = DbFacade.getInstance().getGlusterBrickDao();
    // Stop glusterd service first
    boolean succeeded = resourceManager.runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vdsId, Arrays.asList("glusterd"), "stop")).getSucceeded();
    if (succeeded) {
        // Stop other gluster related processes on the node
        succeeded = resourceManager.runVdsCommand(VDSCommandType.StopGlusterProcesses, new VdsIdVDSCommandParametersBase(vdsId)).getSucceeded();
        // Mark the bricks as DOWN on this node
        if (succeeded) {
            List<GlusterBrickEntity> bricks = glusterBrickDao.getGlusterVolumeBricksByServerId(vdsId);
            for (GlusterBrickEntity brick : bricks) {
                brick.setStatus(GlusterStatus.DOWN);
            }
            glusterBrickDao.updateBrickStatuses(bricks);
        }
    }
    if (!succeeded) {
        log.error("Failed to stop gluster services while moving the host '{}' to maintenance", getHostName(vdsId));
    }
}
#method_after
private void stopGlusterServices(Guid vdsId) {
    ResourceManager resourceManager = ResourceManager.getInstance();
    GlusterBrickDao glusterBrickDao = DbFacade.getInstance().getGlusterBrickDao();
    // Stop glusterd service first
    boolean succeeded = resourceManager.runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vdsId, Arrays.asList("glusterd"), "stop")).getSucceeded();
    if (succeeded) {
        // Stop other gluster related processes on the node
        succeeded = resourceManager.runVdsCommand(VDSCommandType.StopGlusterProcesses, new VdsIdVDSCommandParametersBase(vdsId)).getSucceeded();
        // Mark the bricks as DOWN on this node
        if (succeeded) {
            List<GlusterBrickEntity> bricks = glusterBrickDao.getGlusterVolumeBricksByServerId(vdsId);
            bricks.stream().forEach(brick -> brick.setStatus(GlusterStatus.DOWN));
            glusterBrickDao.updateBrickStatuses(bricks);
        }
    }
    if (!succeeded) {
        log.error("Failed to stop gluster services while moving the host '{}' to maintenance", getHostName(vdsId));
    }
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(VdsProtocol.fromValue(model.getProtocol().getEntity() ? VdsProtocol.STOMP.toString() : VdsProtocol.XML.toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity().trim());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setProtocol(model.getProtocol().getEntity() ? VdsProtocol.STOMP : VdsProtocol.XML);
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getClusterId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setClusterId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setFenceProxySources(FenceProxySourceTypeHelper.parseFromString(model.getPmProxyPreferences()));
    // Save other PM parameters.
    host.setPmEnabled(model.getIsPm().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider<?> networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setNetworkProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        if (model.getProviders().getSelectedItem() != null) {
            parameters.getVdsStaticData().setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (Boolean.TRUE.equals(model.getIsDiscoveredHosts().getEntity())) {
            Provider<?> provider = model.getProviders().getSelectedItem();
            ExternalHostGroup hostGroup = (ExternalHostGroup) model.getExternalHostGroups().getSelectedItem();
            ExternalComputeResource computeResource = (ExternalComputeResource) model.getExternalComputeResource().getSelectedItem();
            ExternalDiscoveredHost discoveredHost = (ExternalDiscoveredHost) model.getExternalDiscoveredHosts().getSelectedItem();
            parameters.initVdsActionParametersForProvision(provider.getId(), hostGroup, computeResource, discoveredHost.getMac(), discoveredHost.getName(), discoveredHost.getIp());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else {
        // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallHost(false);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        parameters.setFenceAgents(model.getFenceAgentListModel().getFenceAgents());
        if (model.getExternalHostProviderEnabled().getEntity() && model.getProviders().getSelectedItem() != null) {
            host.setHostProviderId(model.getProviders().getSelectedItem().getId());
        }
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel<Void> localModel = (HostListModel<Void>) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService());
                }
            }
        }), clusterId);
    }
}
#method_after
public void maintenance() {
    Guid clusterId = getClusterIdOfSelectedHosts();
    if (clusterId == null) {
        maintenance(false, false);
    } else {
        AsyncDataProvider.getInstance().getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                Cluster cluster = (Cluster) returnValue;
                if (cluster != null) {
                    maintenance(cluster.isMaintenanceReasonRequired(), cluster.supportsGlusterService() && GlusterFeaturesUtil.isStopGlusterProcessesSupported(cluster.getCompatibilityVersion()));
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void maintenance(boolean isMaintenanceReasonVisible, boolean isGlusterSupported) {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (isGlusterSupported) {
        model.getForce().setIsAvailable(true);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().stopGlusterServices());
        model.getForce().setEntity(false);
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    ArrayList<String> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getName());
    }
    model.setItems(vdss);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void maintenance(boolean isMaintenanceReasonVisible, boolean isStopGlusterServiceRequired) {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (isStopGlusterServiceRequired) {
        model.getForce().setIsAvailable(true);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().stopGlusterServices());
        model.getForce().setEntity(false);
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    ArrayList<String> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getName());
    }
    model.setItems(vdss);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void migrateAllVdss() {
    for (Guid vdsId : vdssToMaintenance.keySet()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal(), getParameters().getIsStopGlusterProcesses());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
        if (!result.isValid()) {
            getReturnValue().getValidationMessages().addAll(result.getValidationMessages());
            getReturnValue().setValid(false);
        }
    }
}
#method_after
private void migrateAllVdss() {
    for (Guid vdsId : vdssToMaintenance.keySet()) {
        // ParametersCurrentUser = CurrentUser
        MaintenanceVdsParameters tempVar = new MaintenanceVdsParameters(vdsId, getParameters().getIsInternal(), getParameters().isStopGlusterService());
        tempVar.setSessionId(getParameters().getSessionId());
        tempVar.setCorrelationId(getParameters().getCorrelationId());
        VdcReturnValueBase result = runInternalAction(VdcActionType.MaintenanceVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
        if (!result.isValid()) {
            getReturnValue().getValidationMessages().addAll(result.getValidationMessages());
            getReturnValue().setValid(false);
        }
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            addValidationMessage(EngineMessage.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDao().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = false;
                    addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    } else {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            addValidationMessage(EngineMessage.VDS_INVALID_SERVER_ID);
            result = false;
            continue;
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && (!vds.getClusterSupportsGlusterService() || !GlusterFeatureSupported.isGlusterStopServicesSupported(vds.getClusterCompatibilityVersion()))) {
            result = false;
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                List<VM> vms = getVmDao().getAllRunningForVds(vdsId);
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = false;
                    addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    if (vms.size() > 0) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new VmValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                        result = false;
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = false;
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        addValidationMessage(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                        result = false;
                    } else {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = DbFacade.getInstance().getVdsDao().getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
    }
    return result;
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    VDS vds = getVds();
    if (vds.getClusterSupportsGlusterService() && getParameters().getIsStopGlusterProcesses()) {
        return new HostMaintenanceCallback();
    } else {
        return super.getCallback();
    }
}
#method_after
@Override
public CommandCallback getCallback() {
    if (getVds().getClusterSupportsGlusterService() && getParameters().isStopGlusterService()) {
        return new HostMaintenanceCallback();
    } else {
        return super.getCallback();
    }
}
#end_block

#method_before
protected void analyze() {
    if (vdsmVm == null) {
        removeVmFromCache();
        return;
    }
    if (isExternalOrUnmanagedHostedEngineVm()) {
        processUnmanagedVm();
        return;
    }
    proceedDownVms();
    proceedWatchdogEvents();
    proceedBalloonCheck();
    proceedGuaranteedMemoryCheck();
    updateRepository();
    prepareGuestAgentNetworkDevicesForUpdate();
    updateLunDisks();
    updateVmJobs();
}
#method_after
protected void analyze() {
    if (vdsmVm == null) {
        removeVmFromCache();
        return;
    }
    if (isExternalOrUnmanagedHostedEngineVm()) {
        processUnmanagedVm();
        return;
    }
    proceedDownVms();
    proceedWatchdogEvents();
    proceedBalloonCheck();
    proceedGuaranteedMemoryCheck();
    updateRepository();
    prepareGuestAgentNetworkDevicesForUpdate();
    updateLunDisks();
}
#end_block

#method_before
private void updateVmStatistics() {
    // check if time for vm statistics refresh - update cache and DB
    if (updateStatistics) {
        dbVm.updateRunTimeStatisticsData(vdsmVm.getVmStatistics(), dbVm);
        saveStatistics();
        saveVmInterfaces();
        updateInterfaceStatistics();
        updateVmNumaNodeRuntimeInfo();
        updateDiskImageDynamics();
    }
}
#method_after
private void updateVmStatistics() {
    // check if time for vm statistics refresh - update cache and DB
    if (updateStatistics) {
        dbVm.updateRunTimeStatisticsData(vdsmVm.getVmStatistics(), dbVm);
        saveStatistics();
        saveVmInterfaces();
        updateInterfaceStatistics();
        updateVmNumaNodeRuntimeInfo();
        updateDiskImageDynamics();
        updateVmJobs();
    }
}
#end_block

#method_before
private void updateVmNumaNodeRuntimeInfo() {
    VmStatistics statistics = vdsmVm.getVmStatistics();
    if (!dbVm.getStatus().isRunning()) {
        dbVm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the dbVm is running on with node index as the key
    Map<Integer, VdsNumaNode> vdsNumaNodes = vdsNumaNodesSupplier.get();
    // Build numa nodes map of the dbVm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = vmNumaNodeDao.getAllVmNumaNodeByVmId(dbVm.getId()).stream().collect(Collectors.toMap(VmNumaNode::getIndex, Function.identity()));
    // Initialize the unpinned dbVm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if (!pinnedNodes.contains(pair.getSecond().getSecond()) && vdsNumaNodes.containsKey(pair.getSecond().getSecond())) {
                    pair.setFirst(vdsNumaNodes.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    dbVm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#method_after
private void updateVmNumaNodeRuntimeInfo() {
    VmStatistics statistics = vdsmVm.getVmStatistics();
    if (!dbVm.getStatus().isRunning()) {
        dbVm.getStatisticsData().getvNumaNodeStatisticsList().clear();
        return;
    }
    // Build numa nodes map of the host which the dbVm is running on with node index as the key
    Map<Integer, VdsNumaNode> vdsNumaNodes = vdsNumaNodesProvider.get();
    // Build numa nodes map of the dbVm with node index as the key
    Map<Integer, VmNumaNode> vmAllNumaNodesMap = vmNumaNodeDao.getAllVmNumaNodeByVmId(dbVm.getId()).stream().collect(Collectors.toMap(VmNumaNode::getIndex, Function.identity()));
    // Initialize the unpinned dbVm numa nodes list with the runtime pinning information
    List<VmNumaNode> vmNumaNodesNeedUpdate = new ArrayList<>();
    for (VmNumaNode vNode : statistics.getvNumaNodeStatisticsList()) {
        VmNumaNode dbVmNumaNode = vmAllNumaNodesMap.get(vNode.getIndex());
        if (dbVmNumaNode != null) {
            vNode.setId(dbVmNumaNode.getId());
            List<Integer> pinnedNodes = NumaUtils.getPinnedNodeIndexList(dbVmNumaNode.getVdsNumaNodeList());
            List<Pair<Guid, Pair<Boolean, Integer>>> runTimePinList = new ArrayList<>();
            for (Pair<Guid, Pair<Boolean, Integer>> pair : vNode.getVdsNumaNodeList()) {
                if (!pinnedNodes.contains(pair.getSecond().getSecond()) && vdsNumaNodes.containsKey(pair.getSecond().getSecond())) {
                    pair.setFirst(vdsNumaNodes.get(pair.getSecond().getSecond()).getId());
                    pair.getSecond().setFirst(false);
                    runTimePinList.add(pair);
                }
            }
            if (!runTimePinList.isEmpty()) {
                vNode.setVdsNumaNodeList(runTimePinList);
                vmNumaNodesNeedUpdate.add(vNode);
            }
        }
    }
    dbVm.getStatisticsData().getvNumaNodeStatisticsList().addAll(vmNumaNodesNeedUpdate);
}
#end_block

#method_before
protected VmAnalyzer getVmAnalyzer(Pair<VM, VmInternalData> monitoredVm) {
    return new VmAnalyzer(monitoredVm.getFirst(), monitoredVm.getSecond(), updateStatistics, vdsManager, auditLogDirector, resourceManager, vmStaticDao, vmDynamicDao, vmDao, vmNetworkInterfaceDao, vdsDao, diskDao, vmJobDao, vmNumaNodeDao, vdsNumaNodesSupplier);
}
#method_after
protected VmAnalyzer getVmAnalyzer(Pair<VM, VmInternalData> monitoredVm) {
    return new VmAnalyzer(monitoredVm.getFirst(), monitoredVm.getSecond(), updateStatistics, vdsManager, auditLogDirector, resourceManager, vmStaticDao, vmDynamicDao, vmDao, vmNetworkInterfaceDao, vdsDao, diskDao, vmJobDao, vdsNumaNodesProvider, vmNumaNodeDao);
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, labeledNetwork.getName())));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, labeledNetwork.getName())));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    replacements.add(ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
    replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(engineMessage, replacements));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_INTERFACE_NAME, bond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_NIC_NAME, bond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#end_block

#method_before
private void doTestValidateModifiedBondSlaves(HostSetupNetworksValidator validator, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, Matcher<ValidationResult> matcher) {
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validNewOrModifiedBonds(), matcher);
}
#method_after
private void doTestValidateModifiedBondSlaves(HostSetupNetworksValidator validator, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, Matcher<ValidationResult> matcher) {
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists(anyString())).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceHasNameSet()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validNewOrModifiedBonds(), matcher);
}
#end_block

#method_before
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC_ENTITY", network.getName()), ReplacementUtils.createSetVariableString("interfaceName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledInterfaceName", nicLabel.getNicName())));
    }
}
#method_after
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString("nicName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledNicName", nicLabel.getNicName())));
    }
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator, new UnmanagedNetworkValidator());
}
#end_block

#method_before
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, labeledNetwork.getName())));
}
#method_after
@Test
public void testNotRemovingLabeledNetworksWhenRemovingLabeledNetworkUnrelatedToRemovedBond() throws Exception {
    String nicName = "nicName";
    String label = "label";
    Network labeledNetwork = new Network();
    labeledNetwork.setName("networkName");
    labeledNetwork.setId(Guid.newGuid());
    labeledNetwork.setLabel(label);
    NetworkAttachment networkAttachment = createNetworkAttachment(labeledNetwork);
    networkAttachment.setNicName(nicName);
    VdsNetworkInterface existingNic = new VdsNetworkInterface();
    existingNic.setLabels(Collections.singleton(label));
    existingNic.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addExistingInterfaces(Collections.singletonList(existingNic)).addNetworks(Collections.singletonList(labeledNetwork)).build();
    EngineMessage engineMessage = EngineMessage.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC;
    assertThat(validator.notRemovingLabeledNetworks(networkAttachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(engineMessage, labeledNetwork.getName())));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORD_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#method_after
@Test
public void testValidRemovedBondsWhenReferencedInterfaceBondViaInexistingId() throws Exception {
    Guid idOfInexistingInterface = Guid.newGuid();
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(idOfInexistingInterface)).build();
    EngineMessage engineMessage = EngineMessage.NETWORK_BOND_RECORDS_DOES_NOT_EXISTS;
    assertThat(validator.validRemovedBonds(Collections.<NetworkAttachment>emptyList()), failsWith(engineMessage, ReplacementUtils.getListVariableAssignmentString(engineMessage, Collections.singletonList(idOfInexistingInterface))));
}
#end_block

#method_before
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    replacements.add(ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_BOND_NAME, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS, replacements));
}
#method_after
@Test
public void testValidRemovedBondsWhenBondIsRequired() throws Exception {
    String nicName = "nicName";
    bond.setName(nicName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addRemovedBonds(bond.getId())).addExistingInterfaces(Collections.<VdsNetworkInterface>singletonList(bond)).build();
    NetworkAttachment requiredNetworkAttachment = new NetworkAttachment();
    requiredNetworkAttachment.setNicName(nicName);
    List<String> replacements = new ArrayList<>();
    EngineMessage engineMessage = EngineMessage.BOND_USED_BY_NETWORK_ATTACHMENTS;
    replacements.add(ReplacementUtils.getVariableAssignmentString(engineMessage, nicName));
    // null -- new network attachment with null id.
    replacements.addAll(replaceWith(HostSetupNetworksValidator.VAR_ATTACHMENT_IDS, Collections.<Guid>singletonList(null)));
    assertThat(validator.validRemovedBonds(Collections.singletonList(requiredNetworkAttachment)), failsWith(engineMessage, replacements));
}
#end_block

#method_before
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#method_after
@Test
public void testNetworksUniquelyConfiguredOnHostWhenNotUniquelyConfigured() throws Exception {
    Guid id = Guid.newGuid();
    String networkName = "networkName";
    Network networkA = new Network();
    networkA.setName(networkName);
    networkA.setId(id);
    NetworkAttachment networkAttachment = createNetworkAttachment(networkA);
    NetworkAttachment networkAttachmentReferencingSameNetwork = createNetworkAttachment(networkA);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().addNetworks(Collections.singletonList(networkA)).build();
    assertThat(validator.networksUniquelyConfiguredOnHost(Arrays.asList(networkAttachment, networkAttachmentReferencingSameNetwork)), failsWith(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, ReplacementUtils.getVariableAssignmentStringWithMultipleValues(EngineMessage.NETWORKS_ALREADY_ATTACHED_TO_IFACES, networkName)));
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenReferencingExistingNonBondInterface() throws Exception {
    Bond bond = createBond();
    final EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_IS_NOT_BOND;
    ValidationResult notABondValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, bond.getName()));
    doTestValidModifiedBonds(bond, notABondValidationResult, notABondValidationResult, ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenInsufficientNumberOfSlaves() throws Exception {
    Bond bond = createBond();
    doTestValidModifiedBonds(bond, ValidationResult.VALID, new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bond.getName())), ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#method_after
@Test
public void testValidModifiedBondsFailsWhenSlavesValidationFails() throws Exception {
    EngineMessage engineMessage = EngineMessage.NETWORK_INTERFACE_ATTACHED_TO_NETWORK_CANNOT_BE_SLAVE;
    ValidationResult slavesValidationResult = new ValidationResult(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, "slaveA"), ReplacementUtils.createSetVariableString(HostSetupNetworksValidator.VAR_NETWORK_NAME, "networkName"));
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, /*this mocks validateModifiedBondSlaves to just verify, that caller method will behave ok, when
            validateModifiedBondSlaves return invalid result*/
    slavesValidationResult, slavesValidationResult);
}
#end_block

#method_before
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#method_after
@Test
public void testValidModifiedBondsWhenAllOk() throws Exception {
    Bond bond = new Bond("bond1");
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    doTestValidModifiedBonds(bond, ValidationResult.VALID, ValidationResult.VALID, ValidationResult.VALID);
}
#end_block

#method_before
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceByNameExistValidationResult, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceByNameExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
    verify(hostInterfaceValidatorMock).interfaceByNameExists();
    // assert only if previous call was successful, otherwise this method was not called.
    if (interfaceByNameExistValidationResult.isValid()) {
        verify(hostInterfaceValidatorMock).interfaceIsBondOrNull();
    }
}
#method_after
private void doTestValidModifiedBonds(Bond bond, ValidationResult interfaceIsBondValidationResult, ValidationResult expectedValidationResult, ValidationResult slavesValidationValidationResult) {
    HostSetupNetworksValidator validator = spy(new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).addExistingInterfaces((List<VdsNetworkInterface>) null).addExistingAttachments((List<NetworkAttachment>) null).addNetworks((Collection<Network>) null).build());
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(interfaceIsBondValidationResult);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    doReturn(slavesValidationValidationResult).when(validator).validateModifiedBondSlaves(any(Bond.class));
    if (expectedValidationResult.isValid()) {
        assertThat(validator.validNewOrModifiedBonds(), isValid());
    } else {
        assertThat(validator.validNewOrModifiedBonds(), failsWith(expectedValidationResult.getMessage(), expectedValidationResult.getVariableReplacements()));
    }
}
#end_block

#method_before
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_INTERFACE_NAME, bond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#method_after
@Test
public void testValidateModifiedBondSlavesWhenSlaveIsNotValid() throws Exception {
    Bond bond = createBond();
    bond.setSlaves(Arrays.asList("slaveA", "slaveB"));
    ValidationResult cannotBeSlaveValidationResult = new ValidationResult(EngineMessage.NETWORK_INTERFACE_BOND_OR_VLAN_CANNOT_BE_SLAVE, ReplacementUtils.createSetVariableString(HostInterfaceValidator.VAR_NIC_NAME, bond.getName()));
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addBonds(bond)).build();
    doTestValidateModifiedBondSlaves(spy(validator), ValidationResult.VALID, cannotBeSlaveValidationResult, failsWith(cannotBeSlaveValidationResult));
}
#end_block

#method_before
private void doTestValidateModifiedBondSlaves(HostSetupNetworksValidator validator, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, Matcher<ValidationResult> matcher) {
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceByNameExists()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validNewOrModifiedBonds(), matcher);
}
#method_after
private void doTestValidateModifiedBondSlaves(HostSetupNetworksValidator validator, ValidationResult interfaceExistValidationResult, ValidationResult interfaceIsValidSlaveValidationResult, Matcher<ValidationResult> matcher) {
    HostInterfaceValidator hostInterfaceValidatorMock = mock(HostInterfaceValidator.class);
    when(hostInterfaceValidatorMock.interfaceExists(anyString())).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceHasNameSet()).thenReturn(interfaceExistValidationResult);
    when(hostInterfaceValidatorMock.interfaceIsValidSlave()).thenReturn(interfaceIsValidSlaveValidationResult);
    // TODO MM: test for this.
    when(hostInterfaceValidatorMock.interfaceIsBondOrNull()).thenReturn(ValidationResult.VALID);
    doReturn(hostInterfaceValidatorMock).when(validator).createHostInterfaceValidator(any(VdsNetworkInterface.class));
    assertThat(validator.validNewOrModifiedBonds(), matcher);
}
#end_block

#method_before
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC, ReplacementUtils.createSetVariableString("NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC_ENTITY", network.getName()), ReplacementUtils.createSetVariableString("interfaceName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledInterfaceName", nicLabel.getNicName())));
    }
}
#method_after
private void attachmentAndNicLabelReferenceSameLabelCommonTest(boolean referenceSameNic, boolean valid) {
    VdsNetworkInterface nic = createNic("nic");
    final String labelName = "lbl1";
    Network network = createNetworkWithNameAndLabel("net", labelName);
    NetworkAttachment attachment = createNetworkAttachment(network, nic);
    NicLabel nicLabel = referenceSameNic ? new NicLabel(nic.getId(), nic.getName(), labelName) : new NicLabel(Guid.newGuid(), nic.getName() + "not", labelName);
    HostSetupNetworksValidator validator = new HostSetupNetworksValidatorBuilder().setParams(new ParametersBuilder().addLabels(nicLabel)).addNetworks(network).addExistingInterfaces(nic).build();
    if (valid) {
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), isValid());
    } else {
        EngineMessage engineMessage = EngineMessage.NETWORK_SHOULD_BE_ATTACHED_VIA_LABEL_TO_ANOTHER_NIC;
        assertThat(validator.validateAttachmentAndNicReferenceSameLabelNotConflict(attachment), failsWith(engineMessage, ReplacementUtils.getVariableAssignmentString(engineMessage, network.getName()), ReplacementUtils.createSetVariableString("nicName", attachment.getNicName()), ReplacementUtils.createSetVariableString("labeledNicName", nicLabel.getNicName())));
    }
}
#end_block

#method_before
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator);
}
#method_after
public HostSetupNetworksValidator build() {
    return new HostSetupNetworksValidator(host, params, existingInterfaces, existingAttachments, new BusinessEntityMap<>(networks), managementNetworkUtil, networkClusterDaoMock, networkDaoMock, vdsDaoMock, new HostSetupNetworksValidatorHelper(), vmDao, mockNetworkExclusivenessValidatorResolver, mockNetworkAttachmentIpConfigurationValidator, new UnmanagedNetworkValidator());
}
#end_block

#method_before
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(getSnapshotActionType());
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setShouldBeEndedByParent(getVm().isQualifiedForLiveSnapshotMerge() ? false : true);
    return parameters;
}
#method_after
private RemoveSnapshotSingleDiskParameters buildRemoveSnapshotSingleDiskParameters(final DiskImage source, DiskImage dest) {
    RemoveSnapshotSingleDiskParameters parameters = new RemoveSnapshotSingleDiskParameters(source.getImageId(), getVmId());
    parameters.setDestinationImageId(dest != null ? dest.getImageId() : null);
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setParentParameters(getParameters());
    parameters.setParentCommand(getActionType());
    parameters.setCommandType(getSnapshotActionType());
    parameters.setVdsId(getVm().getRunOnVds());
    parameters.setShouldBeEndedByParent(!getVm().isQualifiedForLiveSnapshotMerge());
    return parameters;
}
#end_block

#method_before
public static Collection<VdsNetworkInterface> findAllInterfaceBondNameIsEmpty(List<VdsNetworkInterface> items) {
    return where(items, new IPredicate<VdsNetworkInterface>() {

        @Override
        public boolean match(VdsNetworkInterface i) {
            return !StringHelper.isNullOrEmpty(i.getBondName());
        }
    });
}
#method_after
public static Collection<VdsNetworkInterface> findAllInterfaceBondNameIsEmpty(List<VdsNetworkInterface> items) {
    return where(items, new IPredicate<VdsNetworkInterface>() {

        @Override
        public boolean match(VdsNetworkInterface i) {
            return StringHelper.isNullOrEmpty(i.getBondName());
        }
    });
}
#end_block

#method_before
private void updateReportedNetworkAttachmentsNotMentionedInRequest(List<NetworkAttachment> networkAttachments) {
    for (VdsNetworkInterface nic : nicsByName.values()) {
        String networkName = nic.getNetworkName();
        if (networkName != null && clusterNetworks.containsKey(networkName)) {
            NetworkAttachment networkAttachmentRelatedToNetwork = getNetworkAttachmentRelatedToNetwork(networkAttachments, clusterNetworks.get(networkName));
            boolean networkAttachmentRelatedToNetworkExist = networkAttachmentRelatedToNetwork != null;
            if (networkAttachmentRelatedToNetworkExist) {
                VdsNetworkInterface baseInterfaceNicOrThis = getBaseInterfaceNicOrThis(nic);
                IpConfiguration nicIpConfiguration = NetworkUtils.createIpConfigurationFromVdsNetworkInterface(nic);
                boolean vlanChanged = !baseInterfaceNicOrThis.getId().equals(networkAttachmentRelatedToNetwork.getNicId());
                boolean propertiesChanged = customPropertiesForVdsNetworkInterface != null && !Objects.equals(customPropertiesForVdsNetworkInterface.getCustomPropertiesFor(nic), networkAttachmentRelatedToNetwork.getProperties());
                boolean ipConfigurationChanged = !Objects.equals(nicIpConfiguration, networkAttachmentRelatedToNetwork.getIpConfiguration());
                boolean shouldUpdateExistingAttachment = vlanChanged || propertiesChanged || ipConfigurationChanged;
                if (shouldUpdateExistingAttachment) {
                    networkAttachmentRelatedToNetwork.setNicId(baseInterfaceNicOrThis.getId());
                    networkAttachmentRelatedToNetwork.setNicName(baseInterfaceNicOrThis.getName());
                    Map<String, String> customPropertiesFor = customPropertiesForVdsNetworkInterface.getCustomPropertiesFor(nic);
                    if (customPropertiesFor != null && customPropertiesFor.isEmpty()) {
                        customPropertiesFor = null;
                    }
                    networkAttachmentRelatedToNetwork.setProperties(customPropertiesFor);
                    networkAttachmentRelatedToNetwork.setIpConfiguration(nicIpConfiguration);
                    networkAttachmentDao.update(networkAttachmentRelatedToNetwork);
                }
            } else {
                if (!nic.isPartOfBond()) {
                    createNetworkAttachmentForReportedNetworksNotHavingOne(nic, networkName);
                }
            }
        }
    }
}
#method_after
private void updateReportedNetworkAttachmentsNotMentionedInRequest(List<NetworkAttachment> networkAttachments) {
    for (VdsNetworkInterface nic : nicsByName.values()) {
        String networkName = nic.getNetworkName();
        if (networkName != null && clusterNetworks.containsKey(networkName)) {
            NetworkAttachment networkAttachmentRelatedToNetwork = getNetworkAttachmentRelatedToNetwork(networkAttachments, clusterNetworks.get(networkName));
            boolean networkAttachmentRelatedToNetworkExist = networkAttachmentRelatedToNetwork != null;
            if (networkAttachmentRelatedToNetworkExist) {
                VdsNetworkInterface baseInterfaceNicOrThis = getBaseInterfaceNicOrThis(nic);
                IpConfiguration nicIpConfiguration = NetworkUtils.createIpConfigurationFromVdsNetworkInterface(nic);
                boolean vlanChanged = !baseInterfaceNicOrThis.getId().equals(networkAttachmentRelatedToNetwork.getNicId());
                boolean propertiesChanged = customPropertiesForNics != null && !Objects.equals(customPropertiesForNics.getCustomPropertiesFor(nic), networkAttachmentRelatedToNetwork.getProperties());
                boolean ipConfigurationChanged = !Objects.equals(nicIpConfiguration, networkAttachmentRelatedToNetwork.getIpConfiguration());
                boolean shouldUpdateExistingAttachment = vlanChanged || propertiesChanged || ipConfigurationChanged;
                if (shouldUpdateExistingAttachment) {
                    networkAttachmentRelatedToNetwork.setNicId(baseInterfaceNicOrThis.getId());
                    networkAttachmentRelatedToNetwork.setNicName(baseInterfaceNicOrThis.getName());
                    Map<String, String> customPropertiesFor = customPropertiesForNics == null ? null : customPropertiesForNics.getCustomPropertiesFor(nic);
                    if (customPropertiesFor != null && customPropertiesFor.isEmpty()) {
                        customPropertiesFor = null;
                    }
                    networkAttachmentRelatedToNetwork.setProperties(customPropertiesFor);
                    networkAttachmentRelatedToNetwork.setIpConfiguration(nicIpConfiguration);
                    networkAttachmentDao.update(networkAttachmentRelatedToNetwork);
                }
            } else {
                if (!nic.isPartOfBond()) {
                    createNetworkAttachmentForReportedNetworksNotHavingOne(nic, networkName);
                }
            }
        }
    }
}
#end_block

#method_before
private void createNetworkAttachmentForReportedNetworksNotHavingOne(VdsNetworkInterface nic, String networkName) {
    NetworkAttachment networkAttachment = new NetworkAttachment(getBaseInterfaceNicOrThis(nic), clusterNetworks.get(networkName), NetworkUtils.createIpConfigurationFromVdsNetworkInterface(nic));
    networkAttachment.setId(Guid.newGuid());
    if (customPropertiesForVdsNetworkInterface != null) {
        networkAttachment.setProperties(customPropertiesForVdsNetworkInterface.getCustomPropertiesFor(nic));
    }
    networkAttachmentDao.save(networkAttachment);
}
#method_after
private void createNetworkAttachmentForReportedNetworksNotHavingOne(VdsNetworkInterface nic, String networkName) {
    NetworkAttachment networkAttachment = new NetworkAttachment(getBaseInterfaceNicOrThis(nic), clusterNetworks.get(networkName), NetworkUtils.createIpConfigurationFromVdsNetworkInterface(nic));
    networkAttachment.setId(Guid.newGuid());
    if (customPropertiesForNics != null) {
        networkAttachment.setProperties(customPropertiesForNics.getCustomPropertiesFor(nic));
    }
    networkAttachmentDao.save(networkAttachment);
}
#end_block

