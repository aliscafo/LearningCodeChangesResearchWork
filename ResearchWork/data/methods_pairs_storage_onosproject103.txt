276
#method_before
private void replyArp(Ethernet eth, ConnectPoint inPort) {
    ARP arp = (ARP) eth.getPayload();
    checkArgument(arp.getOpCode() == ARP.OP_REQUEST, NOT_ARP_REQUEST);
    checkNotNull(inPort);
    Ip4Address targetAddress = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(targetAddress)) {
                    Ethernet arpReply = buildArpReply(targetAddress, addresses.mac(), eth);
                    sendTo(arpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip4Address source = Ip4Address.valueOf(arp.getSenderProtocolAddress());
        Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source) && pa.vlan().equals(vlan)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(HostId.hostId(eth.getSourceMAC(), VlanId.vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        flood(eth, inPort);
        return;
    } else {
        Ethernet arpReply = buildArpReply(targetAddress, dst.mac(), eth);
        sendTo(arpReply, inPort);
    }
}
#method_after
private void replyArp(Ethernet eth, ConnectPoint inPort) {
    ARP arp = (ARP) eth.getPayload();
    checkArgument(arp.getOpCode() == ARP.OP_REQUEST, NOT_ARP_REQUEST);
    checkNotNull(inPort);
    Ip4Address targetAddress = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(targetAddress)) {
                    Ethernet arpReply = buildArpReply(targetAddress, addresses.mac(), eth);
                    sendTo(arpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip4Address source = Ip4Address.valueOf(arp.getSenderProtocolAddress());
        Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source) && pa.vlan().equals(vlan)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(HostId.hostId(eth.getSourceMAC(), VlanId.vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        // 
        // The request couldn't be resolved.
        // Flood the request on all ports except the incoming ports.
        // 
        flood(eth, inPort);
        return;
    }
    // 
    // Reply on the port the request was received on
    // 
    Ethernet arpReply = buildArpReply(targetAddress, dst.mac(), eth);
    sendTo(arpReply, inPort);
}
#end_block

#method_before
private void replyNdp(Ethernet eth, ConnectPoint inPort) {
    IPv6 ipv6 = (IPv6) eth.getPayload();
    ICMP6 icmpv6 = (ICMP6) ipv6.getPayload();
    NeighborSolicitation nsol = (NeighborSolicitation) icmpv6.getPayload();
    Ip6Address targetAddress = Ip6Address.valueOf(nsol.getTargetAddress());
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(targetAddress)) {
                    Ethernet ndpReply = buildNdpReply(targetAddress, addresses.mac(), eth);
                    sendTo(ndpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip6Address source = Ip6Address.valueOf(nsol.getTargetAddress());
        Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source) && pa.vlan().equals(vlan)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(HostId.hostId(eth.getSourceMAC(), VlanId.vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        flood(eth, inPort);
        return;
    } else {
        Ethernet ndpReply = buildNdpReply(targetAddress, dst.mac(), eth);
        sendTo(ndpReply, inPort);
    }
}
#method_after
private void replyNdp(Ethernet eth, ConnectPoint inPort) {
    IPv6 ipv6 = (IPv6) eth.getPayload();
    ICMP6 icmpv6 = (ICMP6) ipv6.getPayload();
    NeighborSolicitation nsol = (NeighborSolicitation) icmpv6.getPayload();
    Ip6Address targetAddress = Ip6Address.valueOf(nsol.getTargetAddress());
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(targetAddress)) {
                    Ethernet ndpReply = buildNdpReply(targetAddress, addresses.mac(), eth);
                    sendTo(ndpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip6Address source = Ip6Address.valueOf(nsol.getTargetAddress());
        Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source) && pa.vlan().equals(vlan)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    Set<Host> hosts = hostService.getHostsByIp(targetAddress);
    Host dst = null;
    Host src = hostService.getHost(HostId.hostId(eth.getSourceMAC(), VlanId.vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        // 
        // The request couldn't be resolved.
        // Flood the request on all ports except the incoming ports.
        // 
        flood(eth, inPort);
        return;
    }
    // 
    // Reply on the port the request was received on
    // 
    Ethernet ndpReply = buildNdpReply(targetAddress, dst.mac(), eth);
    sendTo(ndpReply, inPort);
}
#end_block

#method_before
private Ethernet buildNdpReply(Ip6Address srcIp, MacAddress srcMac, Ethernet request) {
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(request.getSourceMAC());
    eth.setSourceMACAddress(srcMac);
    eth.setEtherType(Ethernet.TYPE_IPV6);
    eth.setVlanID(request.getVlanID());
    IPv6 requestIp = (IPv6) request.getPayload();
    IPv6 ipv6 = new IPv6();
    ipv6.setSourceAddress(srcIp.toOctets());
    ipv6.setDestinationAddress(requestIp.getSourceAddress());
    ipv6.setHopLimit((byte) 255);
    eth.setPayload(ipv6);
    ICMP6 icmp6 = new ICMP6();
    icmp6.setIcmpType(ICMP6.NEIGHBOR_ADVERTISEMENT);
    icmp6.setIcmpCode((byte) 0);
    ipv6.setPayload(icmp6);
    NeighborAdvertisement nadv = new NeighborAdvertisement();
    nadv.setTargetAddress(srcIp.toOctets());
    nadv.setSolicitedFlag((byte) 1);
    nadv.setOverrideFlag((byte) 1);
    byte[] nadvData = new byte[8];
    ByteBuffer bbNadv = ByteBuffer.wrap(nadvData);
    byte nadvOptionType = 0x02;
    byte nadvOptionLength = 0x01;
    bbNadv.put(nadvOptionType);
    bbNadv.put(nadvOptionLength);
    bbNadv.put(srcMac.toBytes());
    Data nadvPayload = new Data();
    nadv.setPayload(nadvPayload.deserialize(nadvData, 0, 8));
    // IPacket nadvPacket = nadvPayload.deserialize(nadvData, 0, 8);
    // nadv.setPayload(nadvPacket);
    icmp6.setPayload(nadv);
    return eth;
}
#method_after
private Ethernet buildNdpReply(Ip6Address srcIp, MacAddress srcMac, Ethernet request) {
    Ethernet eth = new Ethernet();
    eth.setDestinationMACAddress(request.getSourceMAC());
    eth.setSourceMACAddress(srcMac);
    eth.setEtherType(Ethernet.TYPE_IPV6);
    eth.setVlanID(request.getVlanID());
    IPv6 requestIp = (IPv6) request.getPayload();
    IPv6 ipv6 = new IPv6();
    ipv6.setSourceAddress(srcIp.toOctets());
    ipv6.setDestinationAddress(requestIp.getSourceAddress());
    ipv6.setHopLimit((byte) 255);
    ICMP6 icmp6 = new ICMP6();
    icmp6.setIcmpType(ICMP6.NEIGHBOR_ADVERTISEMENT);
    icmp6.setIcmpCode((byte) 0);
    NeighborAdvertisement nadv = new NeighborAdvertisement();
    nadv.setTargetAddress(srcIp.toOctets());
    nadv.setSolicitedFlag((byte) 1);
    nadv.setOverrideFlag((byte) 1);
    byte[] nadvData = new byte[NeighborAdvertisement.OPTION_LENGTH_IEEE802_ADDRESS];
    ByteBuffer bbNadv = ByteBuffer.wrap(nadvData);
    byte nadvOptionType = NeighborAdvertisement.OPTION_TYPE_TARGET_LL_ADDRESS;
    // The Option length in 8-octets units
    byte nadvOptionLength = (NeighborAdvertisement.OPTION_LENGTH_IEEE802_ADDRESS + 7) / 8;
    bbNadv.put(nadvOptionType);
    bbNadv.put(nadvOptionLength);
    bbNadv.put(srcMac.toBytes());
    Data nadvPayload = new Data();
    nadv.setPayload(nadvPayload.deserialize(nadvData, 0, nadvData.length));
    icmp6.setPayload(nadv);
    ipv6.setPayload(icmp6);
    eth.setPayload(ipv6);
    return eth;
}
#end_block

#method_before
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/{key}")
public Response getIntentById(@PathParam("appId") Short appId, @PathParam("key") String key) {
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = nullIsNotFound(get(IntentService.class).getIntent(Key.of(key, app)), INTENT_NOT_FOUND);
    if (intent == null) {
        intent = nullIsNotFound(get(IntentService.class).getIntent(Key.of(Long.valueOf(key), app)), INTENT_NOT_FOUND);
    }
    final ObjectNode root;
    if (intent instanceof HostToHostIntent) {
        root = codec(HostToHostIntent.class).encode((HostToHostIntent) intent, this);
    } else if (intent instanceof PointToPointIntent) {
        root = codec(PointToPointIntent.class).encode((PointToPointIntent) intent, this);
    } else {
        root = codec(Intent.class).encode(intent, this);
    }
    return ok(root).build();
}
#method_after
@GET
@Produces(MediaType.APPLICATION_JSON)
@Path("{appId}/{key}")
public Response getIntentById(@PathParam("appId") Short appId, @PathParam("key") String key) {
    final ApplicationId app = get(CoreService.class).getAppId(appId);
    Intent intent = get(IntentService.class).getIntent(Key.of(key, app));
    if (intent == null) {
        intent = get(IntentService.class).getIntent(Key.of(Long.valueOf(key), app));
    }
    nullIsNotFound(intent, INTENT_NOT_FOUND);
    final ObjectNode root;
    if (intent instanceof HostToHostIntent) {
        root = codec(HostToHostIntent.class).encode((HostToHostIntent) intent, this);
    } else if (intent instanceof PointToPointIntent) {
        root = codec(PointToPointIntent.class).encode((PointToPointIntent) intent, this);
    } else {
        root = codec(Intent.class).encode(intent, this);
    }
    return ok(root).build();
}
#end_block

#method_before
@Override
public void write(IntentData newData) {
    synchronized (this) {
        // TODO this could be refactored/cleaned up
        IntentData currentData = current.get(newData.key());
        IntentData pendingData = pending.get(newData.key());
        if ((currentData == null || // Note: current and newData's versions will be equal for state updates
        currentData.version().compareTo(newData.version()) <= 0) && isValidStateTransition(currentData, pendingData)) {
            current.put(newData.key(), copyData(newData));
            if (pendingData != null && // Note: a new update for this key could be pending (it's version will be greater)
            pendingData.version().compareTo(newData.version()) <= 0) {
                pending.remove(newData.key());
            }
            try {
                notifyDelegate(IntentEvent.getEvent(newData));
            } catch (IllegalArgumentException e) {
                // no-op
                log.trace("ignore this exception: {}", e);
            }
        }
    }
}
#method_after
@Override
public void write(IntentData newData) {
    synchronized (this) {
        // TODO this could be refactored/cleaned up
        IntentData currentData = current.get(newData.key());
        IntentData pendingData = pending.get(newData.key());
        if (isUpdateAcceptable(currentData, newData)) {
            current.put(newData.key(), copyData(newData));
            if (pendingData != null && // Note: a new update for this key could be pending (it's version will be greater)
            pendingData.version().compareTo(newData.version()) <= 0) {
                pending.remove(newData.key());
            }
            try {
                notifyDelegate(IntentEvent.getEvent(newData));
            } catch (IllegalArgumentException e) {
                // no-op
                log.trace("ignore this exception: {}", e);
            }
        }
    }
}
#end_block

#method_before
@After
public void tearDown() {
    // verify that all intents are parked and the batch operation is unblocked
    Set<IntentState> parked = Sets.newHashSet(INSTALLED, WITHDRAWN, FAILED);
    for (Intent i : service.getIntents()) {
        IntentState state = service.getIntentState(i.key());
        assertTrue("Intent " + i.id() + " is in invalid state " + state, parked.contains(state));
    }
    // the batch has not yet been removed when we receive the last event
    // FIXME: this doesn't guarantee to avoid the race
    // FIXME
    // for (int tries = 0; tries < 10; tries++) {
    // if (manager.batchService.getPendingOperations().isEmpty()) {
    // break;
    // }
    // delay(10);
    // }
    // assertTrue("There are still pending batch operations.",
    // manager.batchService.getPendingOperations().isEmpty());
    extensionService.unregisterCompiler(MockIntent.class);
    extensionService.unregisterInstaller(MockInstallableIntent.class);
    service.removeListener(listener);
    manager.deactivate();
// TODO null the other refs?
}
#method_after
@After
public void tearDown() {
    extensionService.unregisterCompiler(MockIntent.class);
    extensionService.unregisterInstaller(MockInstallableIntent.class);
    service.removeListener(listener);
    manager.deactivate();
// TODO null the other refs?
}
#end_block

#method_before
@Test
public void submitIntent() {
    flowRuleService.setFuture(true);
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.INSTALLED);
    Intent intent = new MockIntent(MockIntent.nextId());
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALLED);
    assertEquals(1L, service.getIntentCount());
    assertEquals(1L, flowRuleService.getFlowRuleCount());
}
#method_after
@Test
public void submitIntent() {
    flowRuleService.setFuture(true);
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.INSTALLED);
    Intent intent = new MockIntent(MockIntent.nextId());
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALLED);
    assertEquals(1L, service.getIntentCount());
    assertEquals(1L, flowRuleService.getFlowRuleCount());
    verifyState();
}
#end_block

#method_before
@Test
public void withdrawIntent() {
    flowRuleService.setFuture(true);
    listener.setLatch(1, Type.INSTALLED);
    Intent intent = new MockIntent(MockIntent.nextId());
    service.submit(intent);
    listener.await(Type.INSTALLED);
    assertEquals(1L, service.getIntentCount());
    assertEquals(1L, flowRuleService.getFlowRuleCount());
    listener.setLatch(1, Type.WITHDRAWN);
    service.withdraw(intent);
    listener.await(Type.WITHDRAWN);
    assertEquals(0L, flowRuleService.getFlowRuleCount());
}
#method_after
@Test
public void withdrawIntent() {
    flowRuleService.setFuture(true);
    listener.setLatch(1, Type.INSTALLED);
    Intent intent = new MockIntent(MockIntent.nextId());
    service.submit(intent);
    listener.await(Type.INSTALLED);
    assertEquals(1L, service.getIntentCount());
    assertEquals(1L, flowRuleService.getFlowRuleCount());
    listener.setLatch(1, Type.WITHDRAWN);
    service.withdraw(intent);
    listener.await(Type.WITHDRAWN);
    assertEquals(0L, flowRuleService.getFlowRuleCount());
    verifyState();
}
#end_block

#method_before
@Test
public void errorIntentCompile() {
    final TestIntentCompilerError errorCompiler = new TestIntentCompilerError();
    extensionService.registerCompiler(MockIntent.class, errorCompiler);
    MockIntent intent = new MockIntent(MockIntent.nextId());
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
}
#method_after
@Test
public void errorIntentCompile() {
    final TestIntentCompilerError errorCompiler = new TestIntentCompilerError();
    extensionService.registerCompiler(MockIntent.class, errorCompiler);
    MockIntent intent = new MockIntent(MockIntent.nextId());
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
    verifyState();
}
#end_block

#method_before
@Ignore("Intent manager currently does not handle flow errors")
@Test
public void errorIntentInstallFromFlows() {
    final Long id = MockIntent.nextId();
    flowRuleService.setFuture(false);
    MockIntent intent = new MockIntent(id);
    listener.setLatch(1, Type.FAILED);
    listener.setLatch(1, Type.INSTALL_REQ);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    // need to make sure we have some failed futures returned first
    delay(10);
    flowRuleService.setFuture(true);
    listener.await(Type.FAILED);
}
#method_after
@Ignore("skipping until we fix update ordering problem")
@Test
public void errorIntentInstallFromFlows() {
    final Long id = MockIntent.nextId();
    flowRuleService.setFuture(false);
    MockIntent intent = new MockIntent(id);
    listener.setLatch(1, Type.FAILED);
    listener.setLatch(1, Type.INSTALL_REQ);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
    // FIXME the intent will be moved into INSTALLED immediately which overrides FAILED
    // ... the updates come out of order
    verifyState();
}
#end_block

#method_before
@Test
public void errorIntentInstallFromInstaller() {
    final TestIntentErrorInstaller errorInstaller = new TestIntentErrorInstaller();
    extensionService.registerInstaller(MockInstallableIntent.class, errorInstaller);
    MockIntent intent = new MockIntent(MockIntent.nextId());
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
}
#method_after
@Test
public void errorIntentInstallFromInstaller() {
    final TestIntentErrorInstaller errorInstaller = new TestIntentErrorInstaller();
    extensionService.registerInstaller(MockInstallableIntent.class, errorInstaller);
    MockIntent intent = new MockIntent(MockIntent.nextId());
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
    verifyState();
}
#end_block

#method_before
@Test
public void errorIntentInstallNeverTrue() {
    final Long id = MockIntent.nextId();
    flowRuleService.setFuture(false);
    MockIntent intent = new MockIntent(id);
    listener.setLatch(1, Type.FAILED);
    listener.setLatch(1, Type.INSTALL_REQ);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    // The delay here forces the retry loop in the intent manager to time out
    delay(100);
    flowRuleService.setFuture(false);
    service.withdraw(intent);
    listener.await(Type.FAILED);
}
#method_after
@Ignore("test needs to be rewritten, so that the intent is resubmitted")
@Test
public void errorIntentInstallNeverTrue() {
    final Long id = MockIntent.nextId();
    flowRuleService.setFuture(false);
    MockIntent intent = new MockIntent(id);
    listener.setLatch(1, Type.FAILED);
    listener.setLatch(1, Type.INSTALL_REQ);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    // The delay here forces the retry loop in the intent manager to time out
    delay(100);
    flowRuleService.setFuture(false);
    service.withdraw(intent);
    listener.await(Type.FAILED);
    verifyState();
}
#end_block

#method_before
@Test
public void intentSubclassCompile() {
    class MockIntentSubclass extends MockIntent {

        public MockIntentSubclass(Long number) {
            super(number);
        }
    }
    flowRuleService.setFuture(true);
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.INSTALLED);
    Intent intent = new MockIntentSubclass(MockIntent.nextId());
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALLED);
    assertEquals(1L, service.getIntentCount());
    assertEquals(1L, flowRuleService.getFlowRuleCount());
    final Map<Class<? extends Intent>, IntentCompiler<? extends Intent>> compilers = extensionService.getCompilers();
    assertEquals(2, compilers.size());
    assertNotNull(compilers.get(MockIntentSubclass.class));
    assertNotNull(compilers.get(MockIntent.class));
}
#method_after
@Test
public void intentSubclassCompile() {
    class MockIntentSubclass extends MockIntent {

        public MockIntentSubclass(Long number) {
            super(number);
        }
    }
    flowRuleService.setFuture(true);
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.INSTALLED);
    Intent intent = new MockIntentSubclass(MockIntent.nextId());
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALLED);
    assertEquals(1L, service.getIntentCount());
    assertEquals(1L, flowRuleService.getFlowRuleCount());
    final Map<Class<? extends Intent>, IntentCompiler<? extends Intent>> compilers = extensionService.getCompilers();
    assertEquals(2, compilers.size());
    assertNotNull(compilers.get(MockIntentSubclass.class));
    assertNotNull(compilers.get(MockIntent.class));
    verifyState();
}
#end_block

#method_before
@Test
public void intentWithoutCompiler() {
    class IntentNoCompiler extends Intent {

        IntentNoCompiler() {
            super(APPID, Collections.emptyList());
        }
    }
    Intent intent = new IntentNoCompiler();
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
}
#method_after
@Test
public void intentWithoutCompiler() {
    class IntentNoCompiler extends Intent {

        IntentNoCompiler() {
            super(APPID, Collections.emptyList());
        }
    }
    Intent intent = new IntentNoCompiler();
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
    verifyState();
}
#end_block

#method_before
@Test
public void intentWithoutInstaller() {
    extensionService.unregisterInstaller(MockInstallableIntent.class);
    MockIntent intent = new MockIntent(MockIntent.nextId());
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
}
#method_after
@Test
public void intentWithoutInstaller() {
    extensionService.unregisterInstaller(MockInstallableIntent.class);
    MockIntent intent = new MockIntent(MockIntent.nextId());
    listener.setLatch(1, Type.INSTALL_REQ);
    listener.setLatch(1, Type.FAILED);
    service.submit(intent);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.FAILED);
    verifyState();
}
#end_block

#method_before
@Test
public void testIntentFetching() {
    List<Intent> intents;
    flowRuleService.setFuture(true);
    intents = Lists.newArrayList(service.getIntents());
    assertThat(intents, hasSize(0));
    final MockIntent intent1 = new MockIntent(MockIntent.nextId());
    final MockIntent intent2 = new MockIntent(MockIntent.nextId());
    listener.setLatch(2, Type.INSTALL_REQ);
    listener.setLatch(2, Type.INSTALLED);
    service.submit(intent1);
    service.submit(intent2);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALLED);
    listener.await(Type.INSTALLED);
    intents = Lists.newArrayList(service.getIntents());
    assertThat(intents, hasSize(2));
    assertThat(intents, hasIntentWithId(intent1.id()));
    assertThat(intents, hasIntentWithId(intent2.id()));
}
#method_after
@Test
public void testIntentFetching() {
    List<Intent> intents;
    flowRuleService.setFuture(true);
    intents = Lists.newArrayList(service.getIntents());
    assertThat(intents, hasSize(0));
    final MockIntent intent1 = new MockIntent(MockIntent.nextId());
    final MockIntent intent2 = new MockIntent(MockIntent.nextId());
    listener.setLatch(2, Type.INSTALL_REQ);
    listener.setLatch(2, Type.INSTALLED);
    service.submit(intent1);
    service.submit(intent2);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALL_REQ);
    listener.await(Type.INSTALLED);
    listener.await(Type.INSTALLED);
    intents = Lists.newArrayList(service.getIntents());
    assertThat(intents, hasSize(2));
    assertThat(intents, hasIntentWithId(intent1.id()));
    assertThat(intents, hasIntentWithId(intent2.id()));
    verifyState();
}
#end_block

#method_before
@Test
public void groupModFailure() {
    TestOpenFlowGroupProviderService testProviderService = (TestOpenFlowGroupProviderService) providerService;
    GroupId groupId = new DefaultGroupId(1);
    List<GroupBucket> bucketList = Lists.newArrayList();
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    builder.setOutput(PortNumber.portNumber(1));
    GroupBucket bucket = DefaultGroupBucket.createSelectGroupBucket(builder.build());
    bucketList.add(bucket);
    GroupBuckets buckets = new GroupBuckets(bucketList);
    List<GroupOperation> operationList = Lists.newArrayList();
    GroupOperation operation = GroupOperation.createAddGroupOperation(groupId, GroupDescription.Type.SELECT, buckets);
    operationList.add(operation);
    GroupOperations operations = new GroupOperations(operationList);
    provider.performGroupOperation(deviceId, operations);
    OFGroupModFailedErrorMsg.Builder errorBuilder = OFFactories.getFactory(OFVersion.OF_13).errorMsgs().buildGroupModFailedErrorMsg();
    OFGroupMod.Builder groupBuilder = OFFactories.getFactory(OFVersion.OF_13).buildGroupModify();
    groupBuilder.setGroupType(OFGroupType.ALL);
    groupBuilder.setGroup(OFGroup.of(1));
    errorBuilder.setCode(OFGroupModFailedCode.GROUP_EXISTS);
    errorBuilder.setXid(1);
    controller.processPacket(dpid1, errorBuilder.build());
    assertNotNull("Operation failed should not be null", testProviderService.failedOperation);
}
#method_after
@Test
public void groupModFailure() {
    TestOpenFlowGroupProviderService testProviderService = (TestOpenFlowGroupProviderService) providerService;
    GroupId groupId = new DefaultGroupId(1);
    List<GroupBucket> bucketList = Lists.newArrayList();
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    builder.setOutput(PortNumber.portNumber(1));
    GroupBucket bucket = DefaultGroupBucket.createSelectGroupBucket(builder.build());
    bucketList.add(bucket);
    GroupBuckets buckets = new GroupBuckets(bucketList);
    List<GroupOperation> operationList = Lists.newArrayList();
    GroupOperation operation = GroupOperation.createAddGroupOperation(groupId, GroupDescription.Type.SELECT, buckets);
    operationList.add(operation);
    GroupOperations operations = new GroupOperations(operationList);
    provider.performGroupOperation(deviceId, operations);
    OFGroupModFailedErrorMsg.Builder errorBuilder = OFFactories.getFactory(OFVersion.OF_13).errorMsgs().buildGroupModFailedErrorMsg();
    OFGroupMod.Builder groupBuilder = OFFactories.getFactory(OFVersion.OF_13).buildGroupModify();
    groupBuilder.setGroupType(OFGroupType.ALL);
    groupBuilder.setGroup(OFGroup.of(1));
    errorBuilder.setCode(OFGroupModFailedCode.GROUP_EXISTS);
    errorBuilder.setXid(provider.getXidAndAdd(0) - 1);
    controller.processPacket(dpid1, errorBuilder.build());
    assertNotNull("Operation failed should not be null", testProviderService.failedOperation);
}
#end_block

#method_before
@Override
public void performGroupOperation(DeviceId deviceId, GroupOperations groupOps) {
    Map<OFGroupMod, OpenFlowSwitch> mods = Maps.newIdentityHashMap();
    final Dpid dpid = Dpid.dpid(deviceId.uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    for (GroupOperation groupOperation : groupOps.operations()) {
        if (sw == null) {
            log.error("SW {} is not found", sw.getStringId());
            return;
        }
        final Long groupModXid = xidCounter.getAndIncrement();
        GroupModBuilder builder = GroupModBuilder.builder(groupOperation.buckets(), groupOperation.groupId(), groupOperation.groupType(), sw.factory(), Optional.of(groupModXid));
        OFGroupMod groupMod = null;
        switch(groupOperation.opType()) {
            case ADD:
                groupMod = builder.buildGroupAdd();
                break;
            case MODIFY:
                groupMod = builder.buildGroupMod();
                break;
            case DELETE:
                groupMod = builder.buildGroupDel();
                break;
            default:
                log.error("Unsupported Group operation");
        }
        sw.sendMsg(groupMod);
        pendingGroupOperations.put(groupMod.getGroup().getGroupNumber(), groupOperation);
        pendingXidMaps.put(groupMod.getGroup().getGroupNumber(), groupModXid);
    }
}
#method_after
@Override
public void performGroupOperation(DeviceId deviceId, GroupOperations groupOps) {
    Map<OFGroupMod, OpenFlowSwitch> mods = Maps.newIdentityHashMap();
    final Dpid dpid = Dpid.dpid(deviceId.uri());
    OpenFlowSwitch sw = controller.getSwitch(dpid);
    for (GroupOperation groupOperation : groupOps.operations()) {
        if (sw == null) {
            log.error("SW {} is not found", dpid);
            return;
        }
        final Long groupModXid = XID_COUNTER.getAndIncrement();
        GroupModBuilder builder = GroupModBuilder.builder(groupOperation.buckets(), groupOperation.groupId(), groupOperation.groupType(), sw.factory(), Optional.of(groupModXid));
        OFGroupMod groupMod = null;
        switch(groupOperation.opType()) {
            case ADD:
                groupMod = builder.buildGroupAdd();
                break;
            case MODIFY:
                groupMod = builder.buildGroupMod();
                break;
            case DELETE:
                groupMod = builder.buildGroupDel();
                break;
            default:
                log.error("Unsupported Group operation");
        }
        sw.sendMsg(groupMod);
        pendingGroupOperations.put(groupMod.getGroup().getGroupNumber(), groupOperation);
        pendingXidMaps.put(groupMod.getGroup().getGroupNumber(), groupModXid);
    }
}
#end_block

#method_before
private void pushGroupMetrics(Dpid dpid, OFStatsReply statsReply) {
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    OFGroupStatsReply groupStatsReply = null;
    OFGroupDescStatsReply groupDescStatsReply = null;
    if (statsReply.getStatsType() == OFStatsType.GROUP) {
        OFStatsReply reply = groupStats.get(statsReply.getXid() + 1);
        if (reply != null) {
            groupStatsReply = (OFGroupStatsReply) statsReply;
            groupDescStatsReply = (OFGroupDescStatsReply) reply;
            groupStats.remove(statsReply.getXid() + 1);
        } else {
            groupStats.put(statsReply.getXid(), statsReply);
        }
    } else if (statsReply.getStatsType() == OFStatsType.GROUP_DESC) {
        OFStatsReply reply = groupStats.get(statsReply.getXid() - 1);
        if (reply != null) {
            groupStatsReply = (OFGroupStatsReply) reply;
            groupDescStatsReply = (OFGroupDescStatsReply) statsReply;
            groupStats.remove(statsReply.getXid() - 1);
        } else {
            groupStats.put(statsReply.getXid(), statsReply);
        }
    }
    if (groupStatsReply != null && groupDescStatsReply != null) {
        Collection<Group> groups = buildGroupMetrics(deviceId, groupStatsReply, groupDescStatsReply);
        providerService.pushGroupMetrics(deviceId, groups);
        for (Group group : groups) {
            pendingGroupOperations.remove(group.id());
            pendingXidMaps.remove(group.id());
        }
    }
}
#method_after
private void pushGroupMetrics(Dpid dpid, OFStatsReply statsReply) {
    DeviceId deviceId = DeviceId.deviceId(Dpid.uri(dpid));
    OFGroupStatsReply groupStatsReply = null;
    OFGroupDescStatsReply groupDescStatsReply = null;
    synchronized (groupStats) {
        if (statsReply.getStatsType() == OFStatsType.GROUP) {
            OFStatsReply reply = groupStats.get(statsReply.getXid() + 1);
            if (reply != null) {
                groupStatsReply = (OFGroupStatsReply) statsReply;
                groupDescStatsReply = (OFGroupDescStatsReply) reply;
                groupStats.remove(statsReply.getXid() + 1);
            } else {
                groupStats.put(statsReply.getXid(), statsReply);
            }
        } else if (statsReply.getStatsType() == OFStatsType.GROUP_DESC) {
            OFStatsReply reply = groupStats.get(statsReply.getXid() - 1);
            if (reply != null) {
                groupStatsReply = (OFGroupStatsReply) reply;
                groupDescStatsReply = (OFGroupDescStatsReply) statsReply;
                groupStats.remove(statsReply.getXid() - 1);
            } else {
                groupStats.put(statsReply.getXid(), statsReply);
            }
        }
    }
    if (groupStatsReply != null && groupDescStatsReply != null) {
        Collection<Group> groups = buildGroupMetrics(deviceId, groupStatsReply, groupDescStatsReply);
        providerService.pushGroupMetrics(deviceId, groups);
        for (Group group : groups) {
            pendingGroupOperations.remove(group.id());
            pendingXidMaps.remove(group.id());
        }
    }
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    switch(msg.getType()) {
        case STATS_REPLY:
            pushGroupMetrics(dpid, (OFStatsReply) msg);
            break;
        case ERROR:
            OFErrorMsg errorMsg = (OFErrorMsg) msg;
            if (errorMsg.getErrType() == OFErrorType.GROUP_MOD_FAILED) {
                int pendingGroupId = -1;
                for (Map.Entry<Integer, Long> entry : pendingXidMaps.entrySet()) {
                    if (entry.getValue() == errorMsg.getXid()) {
                        pendingGroupId = entry.getKey();
                    }
                }
                if (pendingGroupId == -1) {
                    log.warn("Error for unknown group operation: {}", errorMsg.getXid());
                } else {
                    GroupOperation operation = pendingGroupOperations.get(pendingGroupId);
                    if (operation != null) {
                        providerService.groupOperationFailed(operation);
                        pendingGroupOperations.remove(errorMsg.getXid());
                        pendingXidMaps.remove(pendingGroupId);
                        log.warn("Received an group mod error {}", msg);
                    } else {
                        log.error("Cannot find pending group operation with group ID: {}", pendingGroupId);
                    }
                }
                break;
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    switch(msg.getType()) {
        case STATS_REPLY:
            pushGroupMetrics(dpid, (OFStatsReply) msg);
            break;
        case ERROR:
            OFErrorMsg errorMsg = (OFErrorMsg) msg;
            if (errorMsg.getErrType() == OFErrorType.GROUP_MOD_FAILED) {
                int pendingGroupId = -1;
                for (Map.Entry<Integer, Long> entry : pendingXidMaps.entrySet()) {
                    if (entry.getValue() == errorMsg.getXid()) {
                        pendingGroupId = entry.getKey();
                        break;
                    }
                }
                if (pendingGroupId == -1) {
                    log.warn("Error for unknown group operation: {}", errorMsg.getXid());
                } else {
                    GroupOperation operation = pendingGroupOperations.get(pendingGroupId);
                    if (operation != null) {
                        providerService.groupOperationFailed(operation);
                        pendingGroupOperations.remove(pendingGroupId);
                        pendingXidMaps.remove(pendingGroupId);
                        log.warn("Received an group mod error {}", msg);
                    } else {
                        log.error("Cannot find pending group operation with group ID: {}", pendingGroupId);
                    }
                }
                break;
            }
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    // Creating ByteBuffer for calculating checksum
    final byte[] checksumData = new byte[IPv6.FIXED_HEADER_LENGTH + HEADER_LENGTH + payloadLength];
    final ByteBuffer cc = ByteBuffer.wrap(checksumData);
    // Creating IPv6 Pseudo Header for checksum calculation according to RFC443 and RFC2460
    cc.put(((IPv6) this.parent).getSourceAddress());
    cc.put(((IPv6) this.parent).getDestinationAddress());
    cc.putInt(HEADER_LENGTH + payloadLength);
    cc.put((byte) 0);
    cc.put((byte) 0);
    cc.put((byte) 0);
    cc.put(IPv6.PROTOCOL_ICMP6);
    cc.put(this.icmpType);
    cc.put(this.icmpCode);
    cc.put((byte) 0);
    cc.put((byte) 0);
    bb.put(this.icmpType);
    bb.put(this.icmpCode);
    bb.putShort(this.checksum);
    if (payloadData != null) {
        bb.put(payloadData);
        cc.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IPv6) {
        ((IPv6) this.parent).setNextHeader(IPv6.PROTOCOL_ICMP6);
    }
    // compute checksum if needed
    if (this.checksum == 0) {
        bb.rewind();
        cc.rewind();
        int accumulation = 0;
        for (int i = 0; i < checksumData.length / 2; ++i) {
            accumulation += 0xffff & cc.getShort();
        }
        // pad to an even number of shorts
        if (checksumData.length % 2 > 0) {
            accumulation += (cc.get() & 0xff) << 8;
        }
        accumulation = (accumulation >> 16 & 0xffff) + (accumulation & 0xffff);
        this.checksum = (short) (~accumulation & 0xffff);
        bb.putShort(2, this.checksum);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bbData = ByteBuffer.wrap(data);
    // Creating ByteBuffer for checksum calculation
    final byte[] checksumData = new byte[IPv6.FIXED_HEADER_LENGTH + HEADER_LENGTH + payloadLength];
    final ByteBuffer bbChecksum = ByteBuffer.wrap(checksumData);
    // 
    // Creating IPv6 Pseudo Header for checksum calculation according
    // to RFC 4443 and RFC 2460
    // 
    bbChecksum.put(((IPv6) this.parent).getSourceAddress());
    bbChecksum.put(((IPv6) this.parent).getDestinationAddress());
    bbChecksum.putInt(HEADER_LENGTH + payloadLength);
    bbChecksum.put((byte) 0);
    bbChecksum.put((byte) 0);
    bbChecksum.put((byte) 0);
    bbChecksum.put(IPv6.PROTOCOL_ICMP6);
    bbChecksum.put(this.icmpType);
    bbChecksum.put(this.icmpCode);
    bbChecksum.put((byte) 0);
    bbChecksum.put((byte) 0);
    bbData.put(this.icmpType);
    bbData.put(this.icmpCode);
    bbData.putShort(this.checksum);
    if (payloadData != null) {
        bbData.put(payloadData);
        bbChecksum.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IPv6) {
        ((IPv6) this.parent).setNextHeader(IPv6.PROTOCOL_ICMP6);
    }
    // compute checksum if needed
    if (this.checksum == 0) {
        bbData.rewind();
        bbChecksum.rewind();
        int accumulation = 0;
        for (int i = 0; i < checksumData.length / 2; ++i) {
            accumulation += 0xffff & bbChecksum.getShort();
        }
        // pad to an even number of shorts
        if (checksumData.length % 2 > 0) {
            accumulation += (bbChecksum.get() & 0xff) << 8;
        }
        accumulation = (accumulation >> 16 & 0xffff) + (accumulation & 0xffff);
        this.checksum = (short) (~accumulation & 0xffff);
        bbData.putShort(2, this.checksum);
    }
    return data;
}
#end_block

#method_before
@Override
public Database getPartition(String tableName, K key) {
    return partitionMap.get(sortedPartitionNames.get(Math.abs(tableName.hashCode()) % partitionMap.size()));
}
#method_after
@Override
public Database getPartition(String tableName, String key) {
    return sortedPartitions[hash(tableName) % sortedPartitions.length];
}
#end_block

#method_before
public Map<String, Set<DefaultControllerNode>> read() throws IOException {
    final Map<String, Set<DefaultControllerNode>> partitions = Maps.newHashMap();
    final ObjectMapper mapper = new ObjectMapper();
    final ObjectNode tabletNodes = (ObjectNode) mapper.readTree(definitionfile);
    final Iterator<Entry<String, JsonNode>> fields = tabletNodes.fields();
    while (fields.hasNext()) {
        final Entry<String, JsonNode> next = fields.next();
        final Set<DefaultControllerNode> nodes = new HashSet<>();
        final Iterator<JsonNode> elements = next.getValue().elements();
        while (elements.hasNext()) {
            ObjectNode nodeDef = (ObjectNode) elements.next();
            nodes.add(new DefaultControllerNode(new NodeId(nodeDef.get("id").asText()), IpAddress.valueOf(nodeDef.get("ip").asText()), nodeDef.get("tcpPort").asInt(7238)));
        }
        partitions.put(next.getKey(), nodes);
    }
    return partitions;
}
#method_after
public Map<String, Set<DefaultControllerNode>> read() throws IOException {
    final Map<String, Set<DefaultControllerNode>> partitions = Maps.newHashMap();
    final ObjectMapper mapper = new ObjectMapper();
    final ObjectNode tabletNodes = (ObjectNode) mapper.readTree(definitionfile);
    final Iterator<Entry<String, JsonNode>> fields = tabletNodes.fields();
    while (fields.hasNext()) {
        final Entry<String, JsonNode> next = fields.next();
        final Set<DefaultControllerNode> nodes = new HashSet<>();
        final Iterator<JsonNode> elements = next.getValue().elements();
        while (elements.hasNext()) {
            ObjectNode nodeDef = (ObjectNode) elements.next();
            nodes.add(new DefaultControllerNode(new NodeId(nodeDef.get("id").asText()), IpAddress.valueOf(nodeDef.get("ip").asText()), nodeDef.get("tcpPort").asInt(DatabaseManager.COPYCAT_TCP_PORT)));
        }
        partitions.put(next.getKey(), nodes);
    }
    return partitions;
}
#end_block

#method_before
public UpdateOperation<K, V> build() {
    return operation;
}
#method_after
public UpdateOperation<K, V> build() {
    validateInputs();
    return operation;
}
#end_block

#method_before
public Builder<K, V> withType(Type type) {
    operation.type = type;
    return this;
}
#method_after
public Builder<K, V> withType(Type type) {
    operation.type = checkNotNull(type, "type cannot be null");
    return this;
}
#end_block

#method_before
public Builder<K, V> withTableName(String tableName) {
    operation.tableName = tableName;
    return this;
}
#method_after
public Builder<K, V> withTableName(String tableName) {
    operation.tableName = checkNotNull(tableName, "tableName cannot be null");
    return this;
}
#end_block

#method_before
public Builder<K, V> withKey(K key) {
    operation.key = key;
    return this;
}
#method_after
public Builder<K, V> withKey(K key) {
    operation.key = checkNotNull(key, "key cannot be null");
    return this;
}
#end_block

#method_before
public Builder<K, V> withCurrentValue(V value) {
    operation.currentValue = value;
    return this;
}
#method_after
public Builder<K, V> withCurrentValue(V value) {
    operation.currentValue = checkNotNull(value, "currentValue cannot be null");
    return this;
}
#end_block

#method_before
public Builder<K, V> withValue(V value) {
    operation.value = value;
    return this;
}
#method_after
public Builder<K, V> withValue(V value) {
    operation.value = checkNotNull(value, "value cannot be null");
    return this;
}
#end_block

#method_before
public Builder<K, V> withCurrentVersion(long version) {
    operation.currentVersion = version;
    return this;
}
#method_after
public Builder<K, V> withCurrentVersion(long version) {
    checkArgument(version >= 0, "version cannot be negative");
    operation.currentVersion = version;
    return this;
}
#end_block

#method_before
protected K dK(String key) {
    return serializer.decode(key.getBytes());
}
#method_after
protected K dK(String key) {
    return serializer.decode(HexString.fromHexString(key));
}
#end_block

#method_before
@Override
public int size() {
    return get(proxy.size(name));
}
#method_after
@Override
public int size() {
    return complete(proxy.size(name));
}
#end_block

#method_before
@Override
public boolean isEmpty() {
    return get(proxy.isEmpty(name));
}
#method_after
@Override
public boolean isEmpty() {
    return complete(proxy.isEmpty(name));
}
#end_block

#method_before
@Override
public boolean containsKey(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    return get(proxy.containsKey(name, keyCache.getUnchecked(key)));
}
#method_after
@Override
public boolean containsKey(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    return complete(proxy.containsKey(name, keyCache.getUnchecked(key)));
}
#end_block

#method_before
@Override
public boolean containsValue(V value) {
    checkNotNull(value, ERROR_NULL_VALUE);
    return get(proxy.containsValue(name, serializer.encode(value)));
}
#method_after
@Override
public boolean containsValue(V value) {
    checkNotNull(value, ERROR_NULL_VALUE);
    return complete(proxy.containsValue(name, serializer.encode(value)));
}
#end_block

#method_before
@Override
public Versioned<V> get(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    Versioned<byte[]> value = get(proxy.get(name, keyCache.getUnchecked(key)));
    return new Versioned<>(serializer.decode(value.value()), value.version());
}
#method_after
@Override
public Versioned<V> get(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    Versioned<byte[]> value = complete(proxy.get(name, keyCache.getUnchecked(key)));
    return new Versioned<>(serializer.decode(value.value()), value.version());
}
#end_block

#method_before
@Override
public Versioned<V> put(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    Versioned<byte[]> previousValue = get(proxy.get(name, keyCache.getUnchecked(key)));
    return (previousValue != null) ? new Versioned<>(serializer.decode(previousValue.value()), previousValue.version()) : null;
}
#method_after
@Override
public Versioned<V> put(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    Versioned<byte[]> previousValue = complete(proxy.get(name, keyCache.getUnchecked(key)));
    return (previousValue != null) ? new Versioned<>(serializer.decode(previousValue.value()), previousValue.version()) : null;
}
#end_block

#method_before
@Override
public Versioned<V> remove(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    Versioned<byte[]> value = get(proxy.get(name, keyCache.getUnchecked(key)));
    return (value != null) ? new Versioned<>(serializer.decode(value.value()), value.version()) : null;
}
#method_after
@Override
public Versioned<V> remove(K key) {
    checkNotNull(key, ERROR_NULL_KEY);
    Versioned<byte[]> value = complete(proxy.get(name, keyCache.getUnchecked(key)));
    return (value != null) ? new Versioned<>(serializer.decode(value.value()), value.version()) : null;
}
#end_block

#method_before
@Override
public void clear() {
    get(proxy.clear(name));
}
#method_after
@Override
public void clear() {
    complete(proxy.clear(name));
}
#end_block

#method_before
@Override
public Set<K> keySet() {
    return get(proxy.keySet(name)).stream().map(this::dK).collect(Collectors.toSet());
}
#method_after
@Override
public Set<K> keySet() {
    return Collections.unmodifiableSet(complete(proxy.keySet(name)).stream().map(this::dK).collect(Collectors.toSet()));
}
#end_block

#method_before
@Override
public Collection<Versioned<V>> values() {
    return get(proxy.values(name)).stream().map(v -> new Versioned<V>(serializer.decode(v.value()), v.version())).collect(Collectors.toList());
}
#method_after
@Override
public Collection<Versioned<V>> values() {
    return Collections.unmodifiableList(complete(proxy.values(name)).stream().map(v -> new Versioned<V>(serializer.decode(v.value()), v.version())).collect(Collectors.toList()));
}
#end_block

#method_before
@Override
public Set<Entry<K, Versioned<V>>> entrySet() {
    return get(proxy.entrySet(name)).stream().map(this::fromRawEntry).collect(Collectors.toSet());
}
#method_after
@Override
public Set<Entry<K, Versioned<V>>> entrySet() {
    return Collections.unmodifiableSet(complete(proxy.entrySet(name)).stream().map(this::fromRawEntry).collect(Collectors.toSet()));
}
#end_block

#method_before
@Override
public Versioned<V> putIfAbsent(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    Versioned<byte[]> existingValue = get(proxy.putIfAbsent(name, keyCache.getUnchecked(key), serializer.encode(value)));
    return (existingValue != null) ? new Versioned<>(serializer.decode(existingValue.value()), existingValue.version()) : null;
}
#method_after
@Override
public Versioned<V> putIfAbsent(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    Versioned<byte[]> existingValue = complete(proxy.putIfAbsent(name, keyCache.getUnchecked(key), serializer.encode(value)));
    return (existingValue != null) ? new Versioned<>(serializer.decode(existingValue.value()), existingValue.version()) : null;
}
#end_block

#method_before
@Override
public boolean remove(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    return get(proxy.remove(name, keyCache.getUnchecked(key), serializer.encode(value)));
}
#method_after
@Override
public boolean remove(K key, V value) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(value, ERROR_NULL_VALUE);
    return complete(proxy.remove(name, keyCache.getUnchecked(key), serializer.encode(value)));
}
#end_block

#method_before
@Override
public boolean remove(K key, long version) {
    checkNotNull(key, ERROR_NULL_KEY);
    return get(proxy.remove(name, keyCache.getUnchecked(key), version));
}
#method_after
@Override
public boolean remove(K key, long version) {
    checkNotNull(key, ERROR_NULL_KEY);
    return complete(proxy.remove(name, keyCache.getUnchecked(key), version));
}
#end_block

#method_before
@Override
public boolean replace(K key, V oldValue, V newValue) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    byte[] existing = oldValue != null ? serializer.encode(oldValue) : null;
    return get(proxy.replace(name, keyCache.getUnchecked(key), existing, serializer.encode(newValue)));
}
#method_after
@Override
public boolean replace(K key, V oldValue, V newValue) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    byte[] existing = oldValue != null ? serializer.encode(oldValue) : null;
    return complete(proxy.replace(name, keyCache.getUnchecked(key), existing, serializer.encode(newValue)));
}
#end_block

#method_before
@Override
public boolean replace(K key, long oldVersion, V newValue) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    return get(proxy.replace(name, keyCache.getUnchecked(key), oldVersion, serializer.encode(newValue)));
}
#method_after
@Override
public boolean replace(K key, long oldVersion, V newValue) {
    checkNotNull(key, ERROR_NULL_KEY);
    checkNotNull(newValue, ERROR_NULL_VALUE);
    return complete(proxy.replace(name, keyCache.getUnchecked(key), oldVersion, serializer.encode(newValue)));
}
#end_block

#method_before
@Override
public boolean batchUpdate(List<UpdateOperation<K, V>> updates) {
    checkNotNull(updates, "updates cannot be null");
    return get(proxy.atomicBatchUpdate(updates.stream().map(this::toRawUpdateOperation).collect(Collectors.toList())));
}
#method_after
@Override
public boolean batchUpdate(List<UpdateOperation<K, V>> updates) {
    checkNotNull(updates, "updates cannot be null");
    return complete(proxy.atomicBatchUpdate(updates.stream().map(this::toRawUpdateOperation).collect(Collectors.toList())));
}
#end_block

#method_before
private UpdateOperation<String, byte[]> toRawUpdateOperation(UpdateOperation<K, V> update) {
    checkArgument(name.equals(update.tableName()), "Unexpected table name");
    UpdateOperation.Builder<String, byte[]> rawUpdate = UpdateOperation.<String, byte[]>newBuilder();
    rawUpdate = rawUpdate.withKey(keyCache.getUnchecked(checkNotNull(update.key(), ERROR_NULL_KEY))).withCurrentVersion(update.currentVersion()).withType(update.type());
    rawUpdate = rawUpdate.withTableName(update.tableName());
    if (update.value() != null) {
        rawUpdate = rawUpdate.withValue(serializer.encode(update.value()));
    } else {
        checkState(update.type() == UpdateOperation.Type.REMOVE || update.type() == UpdateOperation.Type.REMOVE_IF_VERSION_MATCH, ERROR_NULL_VALUE);
    }
    if (update.currentValue() != null) {
        rawUpdate = rawUpdate.withCurrentValue(serializer.encode(update.currentValue()));
    }
    return rawUpdate.build();
}
#method_after
private UpdateOperation<String, byte[]> toRawUpdateOperation(UpdateOperation<K, V> update) {
    checkArgument(name.equals(update.tableName()), "Unexpected table name");
    UpdateOperation.Builder<String, byte[]> rawUpdate = UpdateOperation.<String, byte[]>newBuilder();
    rawUpdate = rawUpdate.withKey(keyCache.getUnchecked(update.key())).withCurrentVersion(update.currentVersion()).withType(update.type());
    rawUpdate = rawUpdate.withTableName(update.tableName());
    if (update.value() != null) {
        rawUpdate = rawUpdate.withValue(serializer.encode(update.value()));
    } else {
        checkState(update.type() == UpdateOperation.Type.REMOVE || update.type() == UpdateOperation.Type.REMOVE_IF_VERSION_MATCH, ERROR_NULL_VALUE);
    }
    if (update.currentValue() != null) {
        rawUpdate = rawUpdate.withCurrentValue(serializer.encode(update.currentValue()));
    }
    return rawUpdate.build();
}
#end_block

#method_before
@Activate
public void activate() {
    final String logDir = System.getProperty("karaf.data", "./data");
    // load database configuration
    File file = new File(CONFIG_DIR, PARTITION_DEFNITION_FILE);
    log.info("Loading database definition: {}", file.getAbsolutePath());
    DatabaseDefinitionStore databaseDef = new DatabaseDefinitionStore(file);
    Map<String, Set<DefaultControllerNode>> partitionMap;
    try {
        partitionMap = databaseDef.read();
    } catch (IOException e) {
        log.error("Failed to load database config {}", file);
        throw new IllegalStateException("Failed to load database config", e);
    }
    String[] activeNodeUris = partitionMap.values().stream().reduce((s1, s2) -> Sets.union(s1, s2)).get().stream().map(this::nodeToUri).toArray(String[]::new);
    String localNodeUri = nodeToUri(clusterService.getLocalNode());
    ClusterConfig clusterConfig = new ClusterConfig().withProtocol(new NettyTcpProtocol()).withMembers(activeNodeUris).withLocalMember(localNodeUri);
    PartitionedDatabaseConfig databaseConfig = new PartitionedDatabaseConfig();
    partitionMap.forEach((name, nodes) -> {
        Set<String> replicas = nodes.stream().map(this::nodeToUri).collect(Collectors.toSet());
        DatabaseConfig partitionConfig = new DatabaseConfig().withConsistency(Consistency.STRONG).withLog(new FileLog(logDir)).withReplicas(replicas);
        databaseConfig.addPartition(name, partitionConfig);
    });
    partitionedDatabase = PartitionedDatabaseManager.create("onos-store", clusterConfig, databaseConfig);
    partitionedDatabase.open().whenComplete((db, error) -> {
        if (error != null) {
            log.warn("Failed to open database.", error);
        } else {
            log.info("Successfully opened database.");
        }
    });
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    final String logDir = System.getProperty("karaf.data", "./data");
    // load database configuration
    File file = new File(CONFIG_DIR, PARTITION_DEFINITION_FILE);
    log.info("Loading database definition: {}", file.getAbsolutePath());
    DatabaseDefinitionStore databaseDef = new DatabaseDefinitionStore(file);
    Map<String, Set<DefaultControllerNode>> partitionMap;
    try {
        partitionMap = databaseDef.read();
    } catch (IOException e) {
        log.error("Failed to load database config {}", file);
        throw new IllegalStateException("Failed to load database config", e);
    }
    String[] activeNodeUris = partitionMap.values().stream().reduce((s1, s2) -> Sets.union(s1, s2)).get().stream().map(this::nodeToUri).toArray(String[]::new);
    String localNodeUri = nodeToUri(clusterService.getLocalNode());
    ClusterConfig clusterConfig = new ClusterConfig().withProtocol(new NettyTcpProtocol()).withMembers(activeNodeUris).withLocalMember(localNodeUri);
    PartitionedDatabaseConfig databaseConfig = new PartitionedDatabaseConfig();
    partitionMap.forEach((name, nodes) -> {
        Set<String> replicas = nodes.stream().map(this::nodeToUri).collect(Collectors.toSet());
        DatabaseConfig partitionConfig = new DatabaseConfig().withConsistency(Consistency.STRONG).withLog(new FileLog(logDir)).withReplicas(replicas);
        databaseConfig.addPartition(name, partitionConfig);
    });
    partitionedDatabase = PartitionedDatabaseManager.create("onos-store", clusterConfig, databaseConfig);
    partitionedDatabase.open().whenComplete((db, error) -> {
        if (error != null) {
            log.warn("Failed to open database.", error);
        } else {
            log.info("Successfully opened database.");
        }
    });
    log.info("Started");
}
#end_block

#method_before
@Override
public Database getPartition(String tableName, K key) {
    return partitionMap.get(sortedPartitionNames.get(Math.abs(key.hashCode()) % partitionMap.size()));
}
#method_after
@Override
public Database getPartition(String tableName, String key) {
    return sortedPartitions[hash(key) % sortedPartitions.length];
}
#end_block

#method_before
public static PartitionedDatabase create(String name, ClusterConfig clusterConfig, PartitionedDatabaseConfig partitionedDatabaseConfig) {
    CopycatConfig copycatConfig = new CopycatConfig().withName(name).withClusterConfig(clusterConfig).withDefaultExecutor(Executors.newSingleThreadExecutor(new NamedThreadFactory("copycat-coordinator-%d")));
    ClusterCoordinator coordinator = new DefaultClusterCoordinator(copycatConfig.resolve());
    PartitionedDatabase partitionedDatabase = new PartitionedDatabase(coordinator);
    partitionedDatabaseConfig.partitions().forEach((partitionName, partitionConfig) -> partitionedDatabase.registerPartition(partitionName, coordinator.getResource(partitionName, partitionConfig.resolve(clusterConfig).withDefaultSerializer(copycatConfig.getDefaultSerializer().copy()).withDefaultExecutor(copycatConfig.getDefaultExecutor()))));
    partitionedDatabase.setPartitioner(new SimpleKeyHashPartitioner<>(partitionedDatabase.getRegisteredPartitions()));
    return partitionedDatabase;
}
#method_after
public static PartitionedDatabase create(String name, ClusterConfig clusterConfig, PartitionedDatabaseConfig partitionedDatabaseConfig) {
    CopycatConfig copycatConfig = new CopycatConfig().withName(name).withClusterConfig(clusterConfig).withDefaultExecutor(Executors.newSingleThreadExecutor(new NamedThreadFactory("copycat-coordinator-%d")));
    ClusterCoordinator coordinator = new DefaultClusterCoordinator(copycatConfig.resolve());
    PartitionedDatabase partitionedDatabase = new PartitionedDatabase(coordinator);
    partitionedDatabaseConfig.partitions().forEach((partitionName, partitionConfig) -> partitionedDatabase.registerPartition(partitionName, coordinator.getResource(partitionName, partitionConfig.resolve(clusterConfig).withDefaultSerializer(copycatConfig.getDefaultSerializer().copy()).withDefaultExecutor(copycatConfig.getDefaultExecutor()))));
    partitionedDatabase.setPartitioner(new SimpleKeyHashPartitioner(partitionedDatabase.getRegisteredPartitions()));
    return partitionedDatabase;
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    InstallationFuture future = null;
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            pushFlowMetrics(dpid, (OFStatsReply) msg);
            break;
        case BARRIER_REPLY:
            future = pendingFutures.get(msg.getXid());
            if (future != null) {
                future.satisfyRequirement(dpid);
            } else {
                log.warn("Received unknown Barrier Reply: {}", msg.getXid());
            }
            break;
        case ERROR:
            log.warn("received Error message {} from {}", msg, dpid);
            future = pendingFMs.get(msg.getXid());
            if (future != null) {
                future.fail((OFErrorMsg) msg, dpid);
            } else {
                log.warn("Received unknown Error Reply: {} {}", msg.getXid(), msg);
            }
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    InstallationFuture future = null;
    switch(msg.getType()) {
        case FLOW_REMOVED:
            OFFlowRemoved removed = (OFFlowRemoved) msg;
            FlowEntry fr = new FlowEntryBuilder(dpid, removed).build();
            providerService.flowRemoved(fr);
            break;
        case STATS_REPLY:
            if (((OFStatsReply) msg).getStatsType() != OFStatsType.FLOW) {
                pushFlowMetrics(dpid, (OFFlowStatsReply) msg);
            }
            break;
        case BARRIER_REPLY:
            future = pendingFutures.get(msg.getXid());
            if (future != null) {
                future.satisfyRequirement(dpid);
            } else {
                log.warn("Received unknown Barrier Reply: {}", msg.getXid());
            }
            break;
        case ERROR:
            log.warn("received Error message {} from {}", msg, dpid);
            future = pendingFMs.get(msg.getXid());
            if (future != null) {
                future.fail((OFErrorMsg) msg, dpid);
            } else {
                log.warn("Received unknown Error Reply: {} {}", msg.getXid(), msg);
            }
            break;
        default:
            log.debug("Unhandled message type: {}", msg.getType());
    }
}
#end_block

#method_before
private void pushFlowMetrics(Dpid dpid, OFStatsReply stats) {
    if (stats.getStatsType() != OFStatsType.FLOW) {
        return;
    }
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    final OFFlowStatsReply replies = (OFFlowStatsReply) stats;
    List<FlowEntry> flowEntries = replies.getEntries().stream().filter(entry -> !tableMissRule(dpid, entry)).map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    providerService.pushFlowMetrics(did, flowEntries);
}
#method_after
private void pushFlowMetrics(Dpid dpid, OFFlowStatsReply replies) {
    DeviceId did = DeviceId.deviceId(Dpid.uri(dpid));
    List<FlowEntry> flowEntries = replies.getEntries().stream().filter(entry -> !tableMissRule(dpid, entry)).map(entry -> new FlowEntryBuilder(dpid, entry).build()).collect(Collectors.toList());
    providerService.pushFlowMetrics(did, flowEntries);
}
#end_block

#method_before
@Override
public Intent getIntent(IntentId intentId) {
    Context timer = startTimer(getIntentTimer);
    try {
        Intent intent = localIntents.get(intentId);
        if (intent != null) {
            return intent;
        }
        intent = intents.get(intentId);
        if (intent != null) {
            localIntents.put(intentId, intent);
        }
        return intent;
    } finally {
        stopTimer(timer);
    }
}
#method_after
@Override
public Intent getIntent(Key intentKey) {
    return null;
}
#end_block

#method_before
@Override
public Intent getIntent(IntentId intentId) {
    Context timer = startTimer(getIntentTimer);
    try {
        Intent intent = localIntents.get(intentId);
        if (intent != null) {
            return intent;
        }
        intent = intents.get(intentId);
        if (intent != null) {
            localIntents.put(intentId, intent);
        }
        return intent;
    } finally {
        stopTimer(timer);
    }
}
#method_after
public Intent getIntent(IntentId intentId) {
    Context timer = startTimer(getIntentTimer);
    try {
        Intent intent = localIntents.get(intentId);
        if (intent != null) {
            return intent;
        }
        intent = intents.get(intentId);
        if (intent != null) {
            localIntents.put(intentId, intent);
        }
        return intent;
    } finally {
        stopTimer(timer);
    }
}
#end_block

#method_before
@Override
public IntentState getIntentState(IntentId id) {
    Context timer = startTimer(getIntentStateTimer);
    try {
        final IntentState localState = transientStates.get(id);
        if (localState != null) {
            return localState;
        }
        return states.get(id);
    } finally {
        stopTimer(timer);
    }
}
#method_after
@Override
public IntentState getIntentState(Key key) {
    // TODO: either implement this or remove this class
    return IntentState.FAILED;
/*
        Context timer = startTimer(getIntentStateTimer);
        try {
            final IntentState localState = transientStates.get(id);
            if (localState != null) {
                return localState;
            }
            return states.get(id);
        } finally {
            stopTimer(timer);
        }
        */
}
#end_block

#method_before
@Override
public List<Intent> getInstallableIntents(IntentId intentId) {
    Context timer = startTimer(getInstallableIntentsTimer);
    try {
        return installable.get(intentId);
    } finally {
        stopTimer(timer);
    }
}
#method_after
@Override
public List<Intent> getInstallableIntents(Key intentKey) {
    // TODO: implement this or delete class
    return null;
/*
        Context timer = startTimer(getInstallableIntentsTimer);
        try {
            return installable.get(intentId);
        } finally {
            stopTimer(timer);
        }
        */
}
#end_block

#method_before
@Override
public IntentState getIntentState(IntentId intentId) {
    for (IntentData data : current.values()) {
        if (Objects.equals(data.intent().id(), intentId)) {
            return data.state();
        }
    }
    return null;
}
#method_after
@Override
public IntentState getIntentState(Key intentKey) {
    IntentData data = current.get(intentKey);
    return (data != null) ? data.state() : null;
}
#end_block

#method_before
@Override
public List<Intent> getInstallableIntents(IntentId intentId) {
    for (IntentData data : current.values()) {
        if (Objects.equals(data.intent().id(), intentId)) {
            return data.installables();
        }
    }
    return null;
}
#method_after
@Override
public List<Intent> getInstallableIntents(Key intentKey) {
    // TODO: implement this or delete class
    return null;
/*
        for (IntentData data : current.values()) {
            if (Objects.equals(data.intent().id(), intentId)) {
                return data.installables();
            }
        }
        return null;
        */
}
#end_block

#method_before
@Override
public IntentState getIntentState(IntentId intentId) {
    for (IntentData data : current.values()) {
        if (Objects.equals(data.intent().id(), intentId)) {
            return data.state();
        }
    }
    return null;
}
#method_after
@Override
public IntentState getIntentState(Key intentKey) {
    IntentData data = current.get(intentKey);
    return (data != null) ? data.state() : null;
}
#end_block

#method_before
@Override
public List<Intent> getInstallableIntents(IntentId intentId) {
    for (IntentData data : current.values()) {
        if (Objects.equals(data.intent().id(), intentId)) {
            return data.installables();
        }
    }
    return null;
}
#method_after
@Override
public List<Intent> getInstallableIntents(Key intentKey) {
    IntentData data = current.get(intentKey);
    return (data != null) ? data.installables() : null;
}
#end_block

#method_before
@Override
public Intent getIntent(IntentId intentId) {
    Context timer = startTimer(getIntentTimer);
    try {
        return intents.get(intentId);
    } finally {
        stopTimer(timer);
    }
}
#method_after
@Override
public Intent getIntent(Key intentKey) {
    return null;
}
#end_block

#method_before
@Override
public Intent getIntent(IntentId intentId) {
    Context timer = startTimer(getIntentTimer);
    try {
        return intents.get(intentId);
    } finally {
        stopTimer(timer);
    }
}
#method_after
public Intent getIntent(IntentId intentId) {
    Context timer = startTimer(getIntentTimer);
    try {
        return intents.get(intentId);
    } finally {
        stopTimer(timer);
    }
}
#end_block

#method_before
@Override
public IntentState getIntentState(IntentId id) {
    Context timer = startTimer(getIntentStateTimer);
    try {
        final IntentState localState = transientStates.get(id);
        if (localState != null) {
            return localState;
        }
        return states.get(id);
    } finally {
        stopTimer(timer);
    }
}
#method_after
@Override
public IntentState getIntentState(Key key) {
    // TODO: either implement this or remove the class
    return IntentState.FAILED;
/*
        Context timer = startTimer(getIntentStateTimer);
        try {
            final IntentState localState = transientStates.get(id);
            if (localState != null) {
                return localState;
            }
            return states.get(id);
        } finally {
            stopTimer(timer);
        }
        */
}
#end_block

#method_before
@Override
public List<Intent> getInstallableIntents(IntentId intentId) {
    Context timer = startTimer(getInstallableIntentsTimer);
    try {
        return installable.get(intentId);
    } finally {
        stopTimer(timer);
    }
}
#method_after
@Override
public List<Intent> getInstallableIntents(Key intentKey) {
    // TODO: implement this or delete class
    return null;
/*
        Context timer = startTimer(getInstallableIntentsTimer);
        try {
            return installable.get(intentId);
        } finally {
            stopTimer(timer);
        }
        */
}
#end_block

#method_before
@Test
public void matchIPSrcTest() {
    Criterion criterion = Criteria.matchIPSrc(ipPrefix);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix.toString()));
}
#method_after
@Test
public void matchIPSrcTest() {
    Criterion criterion = Criteria.matchIPSrc(ipPrefix4);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix4.toString()));
}
#end_block

#method_before
@Test
public void matchIPDstTest() {
    Criterion criterion = Criteria.matchIPDst(ipPrefix);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix.toString()));
}
#method_after
@Test
public void matchIPDstTest() {
    Criterion criterion = Criteria.matchIPDst(ipPrefix4);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix4.toString()));
}
#end_block

#method_before
@Test
public void matchIPv6SrcTest() {
    Criterion criterion = Criteria.matchIPv6Src(ipPrefix);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix.toString()));
}
#method_after
@Test
public void matchIPv6SrcTest() {
    Criterion criterion = Criteria.matchIPv6Src(ipPrefix6);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix6.toString()));
}
#end_block

#method_before
@Test
public void matchIPv6DstTest() {
    Criterion criterion = Criteria.matchIPv6Dst(ipPrefix);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix.toString()));
}
#method_after
@Test
public void matchIPv6DstTest() {
    Criterion criterion = Criteria.matchIPv6Dst(ipPrefix6);
    ObjectNode result = criterionCodec.encode(criterion, context);
    assertThat(result.get("type").textValue(), is(criterion.type().toString()));
    assertThat(result.get("ip").asText(), is(ipPrefix6.toString()));
}
#end_block

#method_before
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                default:
                    log.warn("Unsupported stats type : {}", reply.getStatsType());
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            // Handle optical port stats
            if (((OFExperimenter) msg).getExperimenter() == 0x748771) {
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#method_after
@Override
public void processPacket(Dpid dpid, OFMessage msg) {
    Collection<OFFlowStatsEntry> flowStats;
    Collection<OFGroupStatsEntry> groupStats;
    Collection<OFGroupDescStatsEntry> groupDescStats;
    switch(msg.getType()) {
        case PORT_STATUS:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.portChanged(dpid, (OFPortStatus) msg);
            }
            break;
        case FEATURES_REPLY:
            for (OpenFlowSwitchListener l : ofSwitchListener) {
                l.switchChanged(dpid);
            }
            break;
        case PACKET_IN:
            OpenFlowPacketContext pktCtx = DefaultOpenFlowPacketContext.packetContextFromPacketIn(this.getSwitch(dpid), (OFPacketIn) msg);
            for (PacketListener p : ofPacketListener.values()) {
                p.handlePacket(pktCtx);
            }
            break;
        // ie. Back to back error could cause us to starve.
        case FLOW_REMOVED:
        case ERROR:
            executorMsgs.submit(new OFMessageHandler(dpid, msg));
            break;
        case STATS_REPLY:
            OFStatsReply reply = (OFStatsReply) msg;
            switch(reply.getStatsType()) {
                case PORT_DESC:
                    for (OpenFlowSwitchListener l : ofSwitchListener) {
                        l.switchChanged(dpid);
                    }
                    break;
                case FLOW:
                    flowStats = publishFlowStats(dpid, (OFFlowStatsReply) reply);
                    if (flowStats != null) {
                        OFFlowStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildFlowStatsReply();
                        rep.setEntries(Lists.newLinkedList(flowStats));
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP:
                    groupStats = publishGroupStats(dpid, (OFGroupStatsReply) reply);
                    if (groupStats != null) {
                        OFGroupStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                case GROUP_DESC:
                    groupDescStats = publishGroupDescStats(dpid, (OFGroupDescStatsReply) reply);
                    if (groupDescStats != null) {
                        OFGroupDescStatsReply.Builder rep = OFFactories.getFactory(msg.getVersion()).buildGroupDescStatsReply();
                        rep.setEntries(Lists.newLinkedList(groupDescStats));
                        rep.setXid(reply.getXid());
                        executorMsgs.submit(new OFMessageHandler(dpid, rep.build()));
                    }
                    break;
                default:
                    log.warn("Unsupported stats type : {}", reply.getStatsType());
            }
            break;
        case BARRIER_REPLY:
            executorBarrier.submit(new OFMessageHandler(dpid, msg));
            break;
        case EXPERIMENTER:
            // Handle optical port stats
            if (((OFExperimenter) msg).getExperimenter() == 0x748771) {
                OFCircuitPortStatus circuitPortStatus = (OFCircuitPortStatus) msg;
                OFPortStatus.Builder portStatus = this.getSwitch(dpid).factory().buildPortStatus();
                OFPortDesc.Builder portDesc = this.getSwitch(dpid).factory().buildPortDesc();
                portDesc.setPortNo(circuitPortStatus.getPortNo()).setHwAddr(circuitPortStatus.getHwAddr()).setName(circuitPortStatus.getName()).setConfig(circuitPortStatus.getConfig()).setState(circuitPortStatus.getState());
                portStatus.setReason(circuitPortStatus.getReason()).setDesc(portDesc.build());
                for (OpenFlowSwitchListener l : ofSwitchListener) {
                    l.portChanged(dpid, portStatus.build());
                }
            } else {
                log.warn("Handling experimenter type {} not yet implemented", ((OFExperimenter) msg).getExperimenter(), msg);
            }
            break;
        default:
            log.warn("Handling message type {} not yet implemented {}", msg.getType(), msg);
    }
}
#end_block

#method_before
private synchronized Collection<OFFlowStatsEntry> publishFlowStats(Dpid dpid, OFStatsReply reply) {
    // TODO: Get rid of synchronized
    final OFFlowStatsReply replies = (OFFlowStatsReply) reply;
    fullStats.putAll(dpid, replies.getEntries());
    if (!reply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
        return fullStats.removeAll(dpid);
    }
    return null;
}
#method_after
private synchronized Collection<OFFlowStatsEntry> publishFlowStats(Dpid dpid, OFFlowStatsReply reply) {
    // TODO: Get rid of synchronized
    fullFlowStats.putAll(dpid, reply.getEntries());
    if (!reply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
        return fullFlowStats.removeAll(dpid);
    }
    return null;
}
#end_block

#method_before
private synchronized Collection<OFGroupStatsEntry> publishGroupStats(Dpid dpid, OFStatsReply reply) {
    // TODO: Get rid of synchronized
    final OFGroupStatsReply replies = (OFGroupStatsReply) reply;
    groupStats.putAll(dpid, replies.getEntries());
    if (!reply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
        return groupStats.removeAll(dpid);
    }
    return null;
}
#method_after
private synchronized Collection<OFGroupStatsEntry> publishGroupStats(Dpid dpid, OFGroupStatsReply reply) {
    // TODO: Get rid of synchronized
    fullGroupStats.putAll(dpid, reply.getEntries());
    if (!reply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
        return fullGroupStats.removeAll(dpid);
    }
    return null;
}
#end_block

#method_before
private synchronized Collection<OFGroupDescStatsEntry> publishGroupDescStats(Dpid dpid, OFStatsReply reply) {
    // TODO: Get rid of synchronized
    final OFGroupDescStatsReply replies = (OFGroupDescStatsReply) reply;
    groupDescStats.putAll(dpid, replies.getEntries());
    if (!reply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
        return groupDescStats.removeAll(dpid);
    }
    return null;
}
#method_after
private synchronized Collection<OFGroupDescStatsEntry> publishGroupDescStats(Dpid dpid, OFGroupDescStatsReply reply) {
    // TODO: Get rid of synchronized
    fullGroupDescStats.putAll(dpid, reply.getEntries());
    if (!reply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
        return fullGroupDescStats.removeAll(dpid);
    }
    return null;
}
#end_block

#method_before
@Override
public Future<CompletedBatchOperation> executeBatch(BatchOperation<FlowRuleBatchEntry> batch) {
    final Set<Dpid> sws = Sets.newConcurrentHashSet();
    final Map<Long, FlowRuleBatchEntry> fmXids = new HashMap<>();
    /*
         * Use identity hash map for reference equality as we could have equal
         * flow mods for different switches.
         */
    Map<OFFlowMod, OpenFlowSwitch> mods = Maps.newIdentityHashMap();
    Map<OFFlowMod, OpenFlowSwitch.TableType> modTypes = Maps.newIdentityHashMap();
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        FlowRule flowRule = fbe.getTarget();
        final Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
        OpenFlowSwitch sw = controller.getSwitch(dpid);
        if (sw == null) {
            /*
                 * if a switch we are supposed to install to is gone then
                 * cancel (ie. rollback) the work that has been done so far
                 * and return the associated future.
                 */
            InstallationFuture failed = new InstallationFuture(sws, fmXids);
            failed.cancel(true);
            return failed;
        }
        sws.add(dpid);
        final Long flowModXid = xidCounter.getAndIncrement();
        FlowModBuilder builder = FlowModBuilder.builder(flowRule, sw.factory(), Optional.of(flowModXid));
        OFFlowMod mod = null;
        switch(fbe.getOperator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                break;
            default:
                log.error("Unsupported batch operation {}", fbe.getOperator());
        }
        if (mod != null) {
            mods.put(mod, sw);
            modTypes.put(mod, getTableType(flowRule.type()));
            fmXids.put(flowModXid, fbe);
        } else {
            log.error("Conversion of flowrule {} failed.", flowRule);
        }
    }
    InstallationFuture installation = new InstallationFuture(sws, fmXids);
    for (Long xid : fmXids.keySet()) {
        pendingFMs.put(xid, installation);
    }
    pendingFutures.put(installation.xid(), installation);
    for (Map.Entry<OFFlowMod, OpenFlowSwitch> entry : mods.entrySet()) {
        OpenFlowSwitch sw = entry.getValue();
        OFFlowMod mod = entry.getKey();
        OpenFlowSwitch.TableType tableType = modTypes.get(mod);
        if (tableType == OpenFlowSwitch.TableType.NONE) {
            sw.sendMsg(mod);
        } else {
            sw.sendMsg(mod, tableType);
        }
    }
    installation.verify();
    return installation;
}
#method_after
@Override
public Future<CompletedBatchOperation> executeBatch(BatchOperation<FlowRuleBatchEntry> batch) {
    final Set<Dpid> sws = Sets.newConcurrentHashSet();
    final Map<Long, FlowRuleBatchEntry> fmXids = new HashMap<>();
    /*
         * Use identity hash map for reference equality as we could have equal
         * flow mods for different switches.
         */
    Map<OFFlowMod, OpenFlowSwitch> mods = Maps.newIdentityHashMap();
    Map<OFFlowMod, OpenFlowSwitch.TableType> modTypes = Maps.newIdentityHashMap();
    for (FlowRuleBatchEntry fbe : batch.getOperations()) {
        FlowRule flowRule = fbe.target();
        final Dpid dpid = Dpid.dpid(flowRule.deviceId().uri());
        OpenFlowSwitch sw = controller.getSwitch(dpid);
        if (sw == null) {
            /*
                 * if a switch we are supposed to install to is gone then
                 * cancel (ie. rollback) the work that has been done so far
                 * and return the associated future.
                 */
            InstallationFuture failed = new InstallationFuture(sws, fmXids);
            failed.cancel(true);
            return failed;
        }
        sws.add(dpid);
        final Long flowModXid = xidCounter.getAndIncrement();
        FlowModBuilder builder = FlowModBuilder.builder(flowRule, sw.factory(), Optional.of(flowModXid));
        OFFlowMod mod = null;
        switch(fbe.operator()) {
            case ADD:
                mod = builder.buildFlowAdd();
                break;
            case REMOVE:
                mod = builder.buildFlowDel();
                break;
            case MODIFY:
                mod = builder.buildFlowMod();
                break;
            default:
                log.error("Unsupported batch operation {}", fbe.operator());
        }
        if (mod != null) {
            mods.put(mod, sw);
            modTypes.put(mod, getTableType(flowRule.type()));
            fmXids.put(flowModXid, fbe);
        } else {
            log.error("Conversion of flowrule {} failed.", flowRule);
        }
    }
    InstallationFuture installation = new InstallationFuture(sws, fmXids);
    for (Long xid : fmXids.keySet()) {
        pendingFMs.put(xid, installation);
    }
    pendingFutures.put(installation.xid(), installation);
    for (Map.Entry<OFFlowMod, OpenFlowSwitch> entry : mods.entrySet()) {
        OpenFlowSwitch sw = entry.getValue();
        OFFlowMod mod = entry.getKey();
        OpenFlowSwitch.TableType tableType = modTypes.get(mod);
        if (tableType == OpenFlowSwitch.TableType.NONE) {
            sw.sendMsg(mod);
        } else {
            sw.sendMsg(mod, tableType);
        }
    }
    installation.verify();
    return installation;
}
#end_block

#method_before
public void fail(OFErrorMsg msg, Dpid dpid) {
    ok.set(false);
    FlowEntry fe = null;
    FlowRuleBatchEntry fbe = fms.get(msg.getXid());
    failedId = fbe.id();
    FlowRule offending = fbe.getTarget();
    // TODO handle specific error msgs
    switch(msg.getErrType()) {
        case BAD_ACTION:
            OFBadActionErrorMsg bad = (OFBadActionErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, bad.getErrType().ordinal(), bad.getCode().ordinal());
            break;
        case BAD_INSTRUCTION:
            OFBadInstructionErrorMsg badins = (OFBadInstructionErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, badins.getErrType().ordinal(), badins.getCode().ordinal());
            break;
        case BAD_MATCH:
            OFBadMatchErrorMsg badMatch = (OFBadMatchErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, badMatch.getErrType().ordinal(), badMatch.getCode().ordinal());
            break;
        case BAD_REQUEST:
            OFBadRequestErrorMsg badReq = (OFBadRequestErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, badReq.getErrType().ordinal(), badReq.getCode().ordinal());
            break;
        case FLOW_MOD_FAILED:
            OFFlowModFailedErrorMsg fmFail = (OFFlowModFailedErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, fmFail.getErrType().ordinal(), fmFail.getCode().ordinal());
            break;
        case EXPERIMENTER:
        case GROUP_MOD_FAILED:
        case HELLO_FAILED:
        case METER_MOD_FAILED:
        case PORT_MOD_FAILED:
        case QUEUE_OP_FAILED:
        case ROLE_REQUEST_FAILED:
        case SWITCH_CONFIG_FAILED:
        case TABLE_FEATURES_FAILED:
        case TABLE_MOD_FAILED:
            fe = new DefaultFlowEntry(offending, msg.getErrType().ordinal(), 0);
            break;
        default:
            log.error("Unknown error type {}", msg.getErrType());
    }
    offendingFlowMods.add(fe);
    removeRequirement(dpid);
}
#method_after
public void fail(OFErrorMsg msg, Dpid dpid) {
    ok.set(false);
    FlowEntry fe = null;
    FlowRuleBatchEntry fbe = fms.get(msg.getXid());
    failedId = fbe.id();
    FlowRule offending = fbe.target();
    // TODO handle specific error msgs
    switch(msg.getErrType()) {
        case BAD_ACTION:
            OFBadActionErrorMsg bad = (OFBadActionErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, bad.getErrType().ordinal(), bad.getCode().ordinal());
            break;
        case BAD_INSTRUCTION:
            OFBadInstructionErrorMsg badins = (OFBadInstructionErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, badins.getErrType().ordinal(), badins.getCode().ordinal());
            break;
        case BAD_MATCH:
            OFBadMatchErrorMsg badMatch = (OFBadMatchErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, badMatch.getErrType().ordinal(), badMatch.getCode().ordinal());
            break;
        case BAD_REQUEST:
            OFBadRequestErrorMsg badReq = (OFBadRequestErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, badReq.getErrType().ordinal(), badReq.getCode().ordinal());
            break;
        case FLOW_MOD_FAILED:
            OFFlowModFailedErrorMsg fmFail = (OFFlowModFailedErrorMsg) msg;
            fe = new DefaultFlowEntry(offending, fmFail.getErrType().ordinal(), fmFail.getCode().ordinal());
            break;
        case EXPERIMENTER:
        case GROUP_MOD_FAILED:
        case HELLO_FAILED:
        case METER_MOD_FAILED:
        case PORT_MOD_FAILED:
        case QUEUE_OP_FAILED:
        case ROLE_REQUEST_FAILED:
        case SWITCH_CONFIG_FAILED:
        case TABLE_FEATURES_FAILED:
        case TABLE_MOD_FAILED:
            fe = new DefaultFlowEntry(offending, msg.getErrType().ordinal(), 0);
            break;
        default:
            log.error("Unknown error type {}", msg.getErrType());
    }
    offendingFlowMods.add(fe);
    removeRequirement(dpid);
}
#end_block

#method_before
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (isDone()) {
        return false;
    }
    ok.set(false);
    this.state = BatchState.CANCELLED;
    cleanUp();
    for (FlowRuleBatchEntry fbe : fms.values()) {
        if (fbe.getOperator() == FlowRuleOperation.ADD || fbe.getOperator() == FlowRuleOperation.MODIFY) {
            removeFlowRule(fbe.getTarget());
        } else if (fbe.getOperator() == FlowRuleOperation.REMOVE) {
            applyRule(fbe.getTarget());
        }
    }
    return true;
}
#method_after
@Override
public boolean cancel(boolean mayInterruptIfRunning) {
    if (isDone()) {
        return false;
    }
    ok.set(false);
    this.state = BatchState.CANCELLED;
    cleanUp();
    for (FlowRuleBatchEntry fbe : fms.values()) {
        if (fbe.operator() == FlowRuleOperation.ADD || fbe.operator() == FlowRuleOperation.MODIFY) {
            removeFlowRule(fbe.target());
        } else if (fbe.operator() == FlowRuleOperation.REMOVE) {
            applyRule(fbe.target());
        }
    }
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("xid", xid).add("pending devices", sws).add("devices in batch", fms.values().stream().map((fbe) -> fbe.getTarget().deviceId()).distinct().collect(Collectors.toList())).add("failedId", failedId).add("latchCount", countDownLatch.getCount()).add("state", state).add("no error?", ok.get()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("xid", xid).add("pending devices", sws).add("devices in batch", fms.values().stream().map((fbe) -> fbe.target().deviceId()).distinct().collect(Collectors.toList())).add("failedId", failedId).add("latchCount", countDownLatch.getCount()).add("state", state).add("no error?", ok.get()).toString();
}
#end_block

#method_before
@Override
public void startDriverHandshake() {
    log.debug("Starting driver handshake for sw {}", getStringId());
    if (startDriverHandshakeCalled) {
        throw new SwitchDriverSubHandshakeAlreadyStarted();
    }
    startDriverHandshakeCalled = true;
    factory = this.factory();
    try {
        nextDriverState();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
public void startDriverHandshake() {
    log.debug("Starting driver handshake for sw {}", getStringId());
    if (startDriverHandshakeCalled) {
        throw new SwitchDriverSubHandshakeAlreadyStarted();
    }
    startDriverHandshakeCalled = true;
    factory = this.factory();
    try {
        nextDriverState();
    } catch (IOException e) {
        log.error("Error {} during driver handshake for sw {}", e.getCause(), getStringId());
    }
}
#end_block

#method_before
@Override
public void processDriverHandshakeMessage(OFMessage m) {
    if (!startDriverHandshakeCalled) {
        throw new SwitchDriverSubHandshakeNotStarted();
    }
    if (driverHandshakeComplete.get()) {
        throw new SwitchDriverSubHandshakeCompleted(m);
    }
    try {
        processOFMessage(m);
    } catch (IOException e) {
        log.error("Error generated when processing OFMessage", e.getCause());
    }
}
#method_after
@Override
public void processDriverHandshakeMessage(OFMessage m) {
    if (!startDriverHandshakeCalled) {
        throw new SwitchDriverSubHandshakeNotStarted();
    }
    if (driverHandshakeComplete.get()) {
        throw new SwitchDriverSubHandshakeCompleted(m);
    }
    try {
        processOFMessage(m);
    } catch (IOException e) {
        log.error("Error generated when processing OFMessage {}", e.getCause());
    }
}
#end_block

#method_before
@Test
public void testGroupStoreOperations() {
    /* Set the Device AUDIT completed in the store */
    simpleGroupStore.deviceInitialAuditCompleted(D1);
    ApplicationId appId = new DefaultApplicationId(2, "org.groupstore.test");
    TestGroupKey key = new TestGroupKey("group1");
    PortNumber[] ports = { PortNumber.portNumber(31), PortNumber.portNumber(32) };
    List<PortNumber> outPorts = new ArrayList<PortNumber>();
    outPorts.add(ports[0]);
    outPorts.add(ports[1]);
    List<GroupBucket> buckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    GroupDescription groupDesc = new DefaultGroupDescription(D1, Group.Type.SELECT, groupBuckets, key, appId);
    InternalGroupStoreDelegate checkStoreGroupDelegate = new InternalGroupStoreDelegate(key, groupBuckets, GroupEvent.Type.GROUP_ADD_REQUESTED);
    simpleGroupStore.setDelegate(checkStoreGroupDelegate);
    /* Testing storeGroup operation */
    simpleGroupStore.storeGroupDescription(groupDesc);
    /* Testing getGroupCount operation */
    assertEquals(1, simpleGroupStore.getGroupCount(D1));
    /* Testing getGroup operation */
    Group createdGroup = simpleGroupStore.getGroup(D1, key);
    checkStoreGroupDelegate.verifyGroupId(createdGroup.id());
    /* Testing getGroups operation */
    Iterable<Group> createdGroups = simpleGroupStore.getGroups(D1);
    int groupCount = 0;
    for (Group group : createdGroups) {
        checkStoreGroupDelegate.verifyGroupId(group.id());
        groupCount++;
    }
    assertEquals(1, groupCount);
    simpleGroupStore.unsetDelegate(checkStoreGroupDelegate);
    /* Testing addOrUpdateGroupEntry operation from southbound */
    InternalGroupStoreDelegate addGroupEntryDelegate = new InternalGroupStoreDelegate(key, groupBuckets, GroupEvent.Type.GROUP_ADDED);
    simpleGroupStore.setDelegate(addGroupEntryDelegate);
    simpleGroupStore.addOrUpdateGroupEntry(createdGroup);
    simpleGroupStore.unsetDelegate(addGroupEntryDelegate);
    /* Testing updateGroupDescription for ADD operation from northbound */
    TestGroupKey addKey = new TestGroupKey("group1AddBuckets");
    PortNumber[] newNeighborPorts = { PortNumber.portNumber(41), PortNumber.portNumber(42) };
    List<PortNumber> newOutPorts = new ArrayList<PortNumber>();
    newOutPorts.add(newNeighborPorts[0]);
    newOutPorts.add(newNeighborPorts[1]);
    List<GroupBucket> toAddBuckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : newOutPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:03")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        toAddBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets toAddGroupBuckets = new GroupBuckets(toAddBuckets);
    buckets.addAll(toAddBuckets);
    GroupBuckets updatedGroupBuckets = new GroupBuckets(buckets);
    InternalGroupStoreDelegate updateGroupDescDelegate = new InternalGroupStoreDelegate(addKey, updatedGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(updateGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, key, UpdateType.ADD, toAddGroupBuckets, addKey);
    simpleGroupStore.unsetDelegate(updateGroupDescDelegate);
    /* Testing updateGroupDescription for REMOVE operation from northbound */
    TestGroupKey removeKey = new TestGroupKey("group1RemoveBuckets");
    List<GroupBucket> toRemoveBuckets = new ArrayList<GroupBucket>();
    toRemoveBuckets.add(updatedGroupBuckets.buckets().get(0));
    toRemoveBuckets.add(updatedGroupBuckets.buckets().get(1));
    GroupBuckets toRemoveGroupBuckets = new GroupBuckets(toRemoveBuckets);
    List<GroupBucket> remainingBuckets = new ArrayList<GroupBucket>();
    remainingBuckets.add(updatedGroupBuckets.buckets().get(2));
    remainingBuckets.add(updatedGroupBuckets.buckets().get(3));
    GroupBuckets remainingGroupBuckets = new GroupBuckets(remainingBuckets);
    InternalGroupStoreDelegate removeGroupDescDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(removeGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, addKey, UpdateType.REMOVE, toRemoveGroupBuckets, removeKey);
    simpleGroupStore.unsetDelegate(removeGroupDescDelegate);
    /* Testing getGroup operation */
    Group existingGroup = simpleGroupStore.getGroup(D1, removeKey);
    checkStoreGroupDelegate.verifyGroupId(existingGroup.id());
    /* Testing addOrUpdateGroupEntry operation from southbound */
    InternalGroupStoreDelegate updateGroupEntryDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_UPDATED);
    simpleGroupStore.setDelegate(updateGroupEntryDelegate);
    simpleGroupStore.addOrUpdateGroupEntry(existingGroup);
    simpleGroupStore.unsetDelegate(updateGroupEntryDelegate);
    /* Testing deleteGroupDescription operation from northbound */
    InternalGroupStoreDelegate deleteGroupDescDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_REMOVE_REQUESTED);
    simpleGroupStore.setDelegate(deleteGroupDescDelegate);
    simpleGroupStore.deleteGroupDescription(D1, removeKey);
    simpleGroupStore.unsetDelegate(deleteGroupDescDelegate);
    /* Testing removeGroupEntry operation from southbound */
    InternalGroupStoreDelegate removeGroupEntryDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_REMOVED);
    simpleGroupStore.setDelegate(removeGroupEntryDelegate);
    simpleGroupStore.removeGroupEntry(existingGroup);
    /* Testing getGroup operation */
    existingGroup = simpleGroupStore.getGroup(D1, removeKey);
    assertEquals(null, existingGroup);
    assertEquals(0, Iterables.size(simpleGroupStore.getGroups(D1)));
    assertEquals(0, simpleGroupStore.getGroupCount(D1));
    simpleGroupStore.unsetDelegate(removeGroupEntryDelegate);
}
#method_after
@Test
public void testGroupStoreOperations() {
    // Set the Device AUDIT completed in the store
    simpleGroupStore.deviceInitialAuditCompleted(D1);
    ApplicationId appId = new DefaultApplicationId(2, "org.groupstore.test");
    TestGroupKey key = new TestGroupKey("group1");
    PortNumber[] ports = { PortNumber.portNumber(31), PortNumber.portNumber(32) };
    List<PortNumber> outPorts = new ArrayList<PortNumber>();
    outPorts.add(ports[0]);
    outPorts.add(ports[1]);
    List<GroupBucket> buckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    GroupDescription groupDesc = new DefaultGroupDescription(D1, Group.Type.SELECT, groupBuckets, key, appId);
    InternalGroupStoreDelegate checkStoreGroupDelegate = new InternalGroupStoreDelegate(key, groupBuckets, GroupEvent.Type.GROUP_ADD_REQUESTED);
    simpleGroupStore.setDelegate(checkStoreGroupDelegate);
    // Testing storeGroup operation
    simpleGroupStore.storeGroupDescription(groupDesc);
    // Testing getGroupCount operation
    assertEquals(1, simpleGroupStore.getGroupCount(D1));
    // Testing getGroup operation
    Group createdGroup = simpleGroupStore.getGroup(D1, key);
    checkStoreGroupDelegate.verifyGroupId(createdGroup.id());
    // Testing getGroups operation
    Iterable<Group> createdGroups = simpleGroupStore.getGroups(D1);
    int groupCount = 0;
    for (Group group : createdGroups) {
        checkStoreGroupDelegate.verifyGroupId(group.id());
        groupCount++;
    }
    assertEquals(1, groupCount);
    simpleGroupStore.unsetDelegate(checkStoreGroupDelegate);
    // Testing addOrUpdateGroupEntry operation from southbound
    InternalGroupStoreDelegate addGroupEntryDelegate = new InternalGroupStoreDelegate(key, groupBuckets, GroupEvent.Type.GROUP_ADDED);
    simpleGroupStore.setDelegate(addGroupEntryDelegate);
    simpleGroupStore.addOrUpdateGroupEntry(createdGroup);
    simpleGroupStore.unsetDelegate(addGroupEntryDelegate);
    // Testing updateGroupDescription for ADD operation from northbound
    TestGroupKey addKey = new TestGroupKey("group1AddBuckets");
    PortNumber[] newNeighborPorts = { PortNumber.portNumber(41), PortNumber.portNumber(42) };
    List<PortNumber> newOutPorts = new ArrayList<PortNumber>();
    newOutPorts.add(newNeighborPorts[0]);
    newOutPorts.add(newNeighborPorts[1]);
    List<GroupBucket> toAddBuckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : newOutPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:03")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        toAddBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets toAddGroupBuckets = new GroupBuckets(toAddBuckets);
    buckets.addAll(toAddBuckets);
    GroupBuckets updatedGroupBuckets = new GroupBuckets(buckets);
    InternalGroupStoreDelegate updateGroupDescDelegate = new InternalGroupStoreDelegate(addKey, updatedGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(updateGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, key, UpdateType.ADD, toAddGroupBuckets, addKey);
    simpleGroupStore.unsetDelegate(updateGroupDescDelegate);
    // Testing updateGroupDescription for REMOVE operation from northbound
    TestGroupKey removeKey = new TestGroupKey("group1RemoveBuckets");
    List<GroupBucket> toRemoveBuckets = new ArrayList<GroupBucket>();
    toRemoveBuckets.add(updatedGroupBuckets.buckets().get(0));
    toRemoveBuckets.add(updatedGroupBuckets.buckets().get(1));
    GroupBuckets toRemoveGroupBuckets = new GroupBuckets(toRemoveBuckets);
    List<GroupBucket> remainingBuckets = new ArrayList<GroupBucket>();
    remainingBuckets.add(updatedGroupBuckets.buckets().get(2));
    remainingBuckets.add(updatedGroupBuckets.buckets().get(3));
    GroupBuckets remainingGroupBuckets = new GroupBuckets(remainingBuckets);
    InternalGroupStoreDelegate removeGroupDescDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_UPDATE_REQUESTED);
    simpleGroupStore.setDelegate(removeGroupDescDelegate);
    simpleGroupStore.updateGroupDescription(D1, addKey, UpdateType.REMOVE, toRemoveGroupBuckets, removeKey);
    simpleGroupStore.unsetDelegate(removeGroupDescDelegate);
    // Testing getGroup operation
    Group existingGroup = simpleGroupStore.getGroup(D1, removeKey);
    checkStoreGroupDelegate.verifyGroupId(existingGroup.id());
    // Testing addOrUpdateGroupEntry operation from southbound
    InternalGroupStoreDelegate updateGroupEntryDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_UPDATED);
    simpleGroupStore.setDelegate(updateGroupEntryDelegate);
    simpleGroupStore.addOrUpdateGroupEntry(existingGroup);
    simpleGroupStore.unsetDelegate(updateGroupEntryDelegate);
    // Testing deleteGroupDescription operation from northbound
    InternalGroupStoreDelegate deleteGroupDescDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_REMOVE_REQUESTED);
    simpleGroupStore.setDelegate(deleteGroupDescDelegate);
    simpleGroupStore.deleteGroupDescription(D1, removeKey);
    simpleGroupStore.unsetDelegate(deleteGroupDescDelegate);
    // Testing removeGroupEntry operation from southbound
    InternalGroupStoreDelegate removeGroupEntryDelegate = new InternalGroupStoreDelegate(removeKey, remainingGroupBuckets, GroupEvent.Type.GROUP_REMOVED);
    simpleGroupStore.setDelegate(removeGroupEntryDelegate);
    simpleGroupStore.removeGroupEntry(existingGroup);
    // Testing getGroup operation
    existingGroup = simpleGroupStore.getGroup(D1, removeKey);
    assertEquals(null, existingGroup);
    assertEquals(0, Iterables.size(simpleGroupStore.getGroups(D1)));
    assertEquals(0, simpleGroupStore.getGroupCount(D1));
    simpleGroupStore.unsetDelegate(removeGroupEntryDelegate);
}
#end_block

#method_before
@Override
public /*
     * The deviceId, type and buckets are used for hash.
     *
     * (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
int hashCode() {
    return super.hashCode() + Objects.hash(id);
}
#method_after
@Override
public int hashCode() {
    return super.hashCode() + Objects.hash(id);
}
#end_block

#method_before
@Override
public /*
     * The deviceId, groupId, type and buckets should be same.
     *
     * (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultGroup) {
        DefaultGroup that = (DefaultGroup) obj;
        return super.equals(obj) && Objects.equals(id, that.id);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultGroup) {
        DefaultGroup that = (DefaultGroup) obj;
        return super.equals(obj) && Objects.equals(id, that.id);
    }
    return false;
}
#end_block

#method_before
@Override
public void storeGroupDescription(GroupDescription groupDesc) {
    /* Check if a group is existing with the same key */
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        return;
    }
    if (deviceAuditStatus.get(groupDesc.deviceId()) == null) {
        /* Device group audit has not completed yet */
        /* Add this group description to pending group key table */
        /* Create a group entry object with Dummy Group ID */
        StoredGroupEntry group = new DefaultGroup(dummyGroupId, groupDesc);
        group.setState(GroupState.WAITING_AUDIT_COMPLETE);
        ConcurrentMap<GroupKey, StoredGroupEntry> pendingKeyTable = getPendingGroupKeyTable(groupDesc.deviceId());
        pendingKeyTable.put(groupDesc.appCookie(), group);
        return;
    }
    storeGroupDescriptionInternal(groupDesc);
}
#method_after
@Override
public void storeGroupDescription(GroupDescription groupDesc) {
    // Check if a group is existing with the same key
    if (getGroup(groupDesc.deviceId(), groupDesc.appCookie()) != null) {
        return;
    }
    if (deviceAuditStatus.get(groupDesc.deviceId()) == null) {
        // Device group audit has not completed yet
        // Add this group description to pending group key table
        // Create a group entry object with Dummy Group ID
        StoredGroupEntry group = new DefaultGroup(dummyGroupId, groupDesc);
        group.setState(GroupState.WAITING_AUDIT_COMPLETE);
        ConcurrentMap<GroupKey, StoredGroupEntry> pendingKeyTable = getPendingGroupKeyTable(groupDesc.deviceId());
        pendingKeyTable.put(groupDesc.appCookie(), group);
        return;
    }
    storeGroupDescriptionInternal(groupDesc);
}
#end_block

#method_before
private void storeGroupDescriptionInternal(GroupDescription groupDesc) {
    /* Get a new group identifier */
    GroupId id = new DefaultGroupId(getFreeGroupIdValue(groupDesc.deviceId()));
    /* Create a group entry object */
    StoredGroupEntry group = new DefaultGroup(id, groupDesc);
    /* Insert the newly created group entry into concurrent key and id maps */
    ConcurrentMap<GroupKey, StoredGroupEntry> keyTable = getGroupKeyTable(groupDesc.deviceId());
    keyTable.put(groupDesc.appCookie(), group);
    ConcurrentMap<GroupId, StoredGroupEntry> idTable = getGroupIdTable(groupDesc.deviceId());
    idTable.put(id, group);
    notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
}
#method_after
private void storeGroupDescriptionInternal(GroupDescription groupDesc) {
    // Get a new group identifier
    GroupId id = new DefaultGroupId(getFreeGroupIdValue(groupDesc.deviceId()));
    // Create a group entry object
    StoredGroupEntry group = new DefaultGroup(id, groupDesc);
    // Insert the newly created group entry into concurrent key and id maps
    ConcurrentMap<GroupKey, StoredGroupEntry> keyTable = getGroupKeyTable(groupDesc.deviceId());
    keyTable.put(groupDesc.appCookie(), group);
    ConcurrentMap<GroupId, StoredGroupEntry> idTable = getGroupIdTable(groupDesc.deviceId());
    idTable.put(id, group);
    notifyDelegate(new GroupEvent(GroupEvent.Type.GROUP_ADD_REQUESTED, group));
}
#end_block

#method_before
@Override
public void updateGroupDescription(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    /* Check if a group is existing with the provided key */
    Group oldGroup = getGroup(deviceId, oldAppCookie);
    if (oldGroup == null) {
        return;
    }
    List<GroupBucket> newBucketList = getUpdatedBucketList(oldGroup, type, newBuckets);
    if (newBucketList != null) {
        /* Create a new group object from the old group */
        GroupBuckets updatedBuckets = new GroupBuckets(newBucketList);
        GroupKey newCookie = (newAppCookie != null) ? newAppCookie : oldAppCookie;
        GroupDescription updatedGroupDesc = new DefaultGroupDescription(oldGroup.deviceId(), oldGroup.type(), updatedBuckets, newCookie, oldGroup.appId());
        StoredGroupEntry newGroup = new DefaultGroup(oldGroup.id(), updatedGroupDesc);
        newGroup.setState(GroupState.PENDING_UPDATE);
        newGroup.setLife(oldGroup.life());
        newGroup.setPackets(oldGroup.packets());
        newGroup.setBytes(oldGroup.bytes());
        /* Remove the old entry from maps and add new entry
             * using new key
             */
        ConcurrentMap<GroupKey, StoredGroupEntry> keyTable = getGroupKeyTable(oldGroup.deviceId());
        ConcurrentMap<GroupId, StoredGroupEntry> idTable = getGroupIdTable(oldGroup.deviceId());
        keyTable.remove(oldGroup.appCookie());
        idTable.remove(oldGroup.id());
        keyTable.put(newGroup.appCookie(), newGroup);
        idTable.put(newGroup.id(), newGroup);
        notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_REQUESTED, newGroup));
    }
}
#method_after
@Override
public void updateGroupDescription(DeviceId deviceId, GroupKey oldAppCookie, UpdateType type, GroupBuckets newBuckets, GroupKey newAppCookie) {
    // Check if a group is existing with the provided key
    Group oldGroup = getGroup(deviceId, oldAppCookie);
    if (oldGroup == null) {
        return;
    }
    List<GroupBucket> newBucketList = getUpdatedBucketList(oldGroup, type, newBuckets);
    if (newBucketList != null) {
        // Create a new group object from the old group
        GroupBuckets updatedBuckets = new GroupBuckets(newBucketList);
        GroupKey newCookie = (newAppCookie != null) ? newAppCookie : oldAppCookie;
        GroupDescription updatedGroupDesc = new DefaultGroupDescription(oldGroup.deviceId(), oldGroup.type(), updatedBuckets, newCookie, oldGroup.appId());
        StoredGroupEntry newGroup = new DefaultGroup(oldGroup.id(), updatedGroupDesc);
        newGroup.setState(GroupState.PENDING_UPDATE);
        newGroup.setLife(oldGroup.life());
        newGroup.setPackets(oldGroup.packets());
        newGroup.setBytes(oldGroup.bytes());
        // Remove the old entry from maps and add new entry using new key
        ConcurrentMap<GroupKey, StoredGroupEntry> keyTable = getGroupKeyTable(oldGroup.deviceId());
        ConcurrentMap<GroupId, StoredGroupEntry> idTable = getGroupIdTable(oldGroup.deviceId());
        keyTable.remove(oldGroup.appCookie());
        idTable.remove(oldGroup.id());
        keyTable.put(newGroup.appCookie(), newGroup);
        idTable.put(newGroup.id(), newGroup);
        notifyDelegate(new GroupEvent(Type.GROUP_UPDATE_REQUESTED, newGroup));
    }
}
#end_block

#method_before
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    GroupBuckets oldBuckets = oldGroup.buckets();
    List<GroupBucket> newBucketList = new ArrayList<GroupBucket>(oldBuckets.buckets());
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        /* Check if the any of the new buckets are part of the
             * old bucket list
             */
        for (GroupBucket addBucket : buckets.buckets()) {
            if (!newBucketList.contains(addBucket)) {
                newBucketList.add(addBucket);
                groupDescUpdated = true;
            }
        }
    } else if (type == UpdateType.REMOVE) {
        /* Check if the to be removed buckets are part of the
             * old bucket list
             */
        for (GroupBucket removeBucket : buckets.buckets()) {
            if (newBucketList.contains(removeBucket)) {
                newBucketList.remove(removeBucket);
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return newBucketList;
    } else {
        return null;
    }
}
#method_after
private List<GroupBucket> getUpdatedBucketList(Group oldGroup, UpdateType type, GroupBuckets buckets) {
    GroupBuckets oldBuckets = oldGroup.buckets();
    List<GroupBucket> newBucketList = new ArrayList<GroupBucket>(oldBuckets.buckets());
    boolean groupDescUpdated = false;
    if (type == UpdateType.ADD) {
        // the old bucket list
        for (GroupBucket addBucket : buckets.buckets()) {
            if (!newBucketList.contains(addBucket)) {
                newBucketList.add(addBucket);
                groupDescUpdated = true;
            }
        }
    } else if (type == UpdateType.REMOVE) {
        // old bucket list
        for (GroupBucket removeBucket : buckets.buckets()) {
            if (newBucketList.contains(removeBucket)) {
                newBucketList.remove(removeBucket);
                groupDescUpdated = true;
            }
        }
    }
    if (groupDescUpdated) {
        return newBucketList;
    } else {
        return null;
    }
}
#end_block

#method_before
@Override
public void deleteGroupDescription(DeviceId deviceId, GroupKey appCookie) {
    /* Check if a group is existing with the provided key */
    StoredGroupEntry existing = (groupEntriesByKey.get(deviceId) != null) ? groupEntriesByKey.get(deviceId).get(appCookie) : null;
    if (existing == null) {
        return;
    }
    synchronized (existing) {
        existing.setState(GroupState.PENDING_DELETE);
    }
    notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, existing));
}
#method_after
@Override
public void deleteGroupDescription(DeviceId deviceId, GroupKey appCookie) {
    // Check if a group is existing with the provided key
    StoredGroupEntry existing = (groupEntriesByKey.get(deviceId) != null) ? groupEntriesByKey.get(deviceId).get(appCookie) : null;
    if (existing == null) {
        return;
    }
    synchronized (existing) {
        existing.setState(GroupState.PENDING_DELETE);
    }
    notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, existing));
}
#end_block

#method_before
@Override
public void deviceInitialAuditCompleted(DeviceId deviceId) {
    synchronized (deviceAuditStatus) {
        deviceAuditStatus.putIfAbsent(deviceId, true);
        /* Execute all pending group requests */
        ConcurrentMap<GroupKey, StoredGroupEntry> pendingGroupRequests = getPendingGroupKeyTable(deviceId);
        for (Group group : pendingGroupRequests.values()) {
            GroupDescription tmp = new DefaultGroupDescription(group.deviceId(), group.type(), group.buckets(), group.appCookie(), group.appId());
            storeGroupDescriptionInternal(tmp);
        }
        getPendingGroupKeyTable(deviceId).clear();
    }
}
#method_after
@Override
public void deviceInitialAuditCompleted(DeviceId deviceId) {
    synchronized (deviceAuditStatus) {
        deviceAuditStatus.putIfAbsent(deviceId, true);
        // Execute all pending group requests
        ConcurrentMap<GroupKey, StoredGroupEntry> pendingGroupRequests = getPendingGroupKeyTable(deviceId);
        for (Group group : pendingGroupRequests.values()) {
            GroupDescription tmp = new DefaultGroupDescription(group.deviceId(), group.type(), group.buckets(), group.appCookie(), group.appId());
            storeGroupDescriptionInternal(tmp);
        }
        getPendingGroupKeyTable(deviceId).clear();
    }
}
#end_block

#method_before
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
    /* Check the reference counter */
    if (group.refernceCount() == 0) {
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, group));
    }
}
#method_after
@Override
public void addOrUpdateExtraneousGroupEntry(Group group) {
    ConcurrentMap<GroupId, Group> extraneousIdTable = getExtraneousGroupIdTable(group.deviceId());
    extraneousIdTable.put(group.id(), group);
    // Check the reference counter
    if (group.referenceCount() == 0) {
        notifyDelegate(new GroupEvent(Type.GROUP_REMOVE_REQUESTED, group));
    }
}
#end_block

#method_before
@Override
public /*
     * The type and treatment can change on a given bucket
     *
     * (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
int hashCode() {
    return Objects.hash(type, treatment);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, treatment);
}
#end_block

#method_before
@Override
public /*
     * The priority and statistics can change on a given treatment and selector
     *
     * (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultGroupBucket) {
        DefaultGroupBucket that = (DefaultGroupBucket) obj;
        return Objects.equals(type, that.type) && this.treatment.instructions().containsAll(that.treatment.instructions()) && that.treatment.instructions().containsAll(this.treatment.instructions());
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof DefaultGroupBucket) {
        DefaultGroupBucket that = (DefaultGroupBucket) obj;
        return Objects.equals(type, that.type) && this.treatment.instructions().containsAll(that.treatment.instructions()) && that.treatment.instructions().containsAll(this.treatment.instructions());
    }
    return false;
}
#end_block

#method_before
@Test
public void testGroupService() {
    PortNumber[] ports1 = { PortNumber.portNumber(31), PortNumber.portNumber(32) };
    PortNumber[] ports2 = { PortNumber.portNumber(41), PortNumber.portNumber(42) };
    /* Test Group creation before AUDIT process */
    TestGroupKey key = new TestGroupKey("group1BeforeAudit");
    List<GroupBucket> buckets = new ArrayList<GroupBucket>();
    List<PortNumber> outPorts = new ArrayList<PortNumber>();
    outPorts.addAll(Arrays.asList(ports1));
    outPorts.addAll(Arrays.asList(ports2));
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    GroupDescription newGroupDesc = new DefaultGroupDescription(DID, Group.Type.SELECT, groupBuckets, key, appId);
    groupService.addGroup(newGroupDesc);
    internalProvider.validate(DID, null);
    assertEquals(null, groupService.getGroup(DID, key));
    assertEquals(0, Iterables.size(groupService.getGroups(DID, appId)));
    /* Test initial group audit process */
    GroupId gId1 = new DefaultGroupId(1);
    Group group1 = createSouthboundGroupEntry(gId1, Arrays.asList(ports1), 0);
    GroupId gId2 = new DefaultGroupId(2);
    /* Non zero reference count will make the group manager to queue
         * the extraneous groups until reference count is zero.
         */
    Group group2 = createSouthboundGroupEntry(gId2, Arrays.asList(ports2), 2);
    List<Group> groupEntries = Arrays.asList(group1, group2);
    providerService.pushGroupMetrics(DID, groupEntries);
    /* First group metrics would trigger the device audit completion
         * post which all pending group requests are also executed.
         */
    Group createdGroup = groupService.getGroup(DID, key);
    int createdGroupId = createdGroup.id().id();
    assertNotEquals(gId1.id(), createdGroupId);
    assertNotEquals(gId2.id(), createdGroupId);
    List<GroupOperation> expectedGroupOps = Arrays.asList(GroupOperation.createDeleteGroupOperation(gId1, Group.Type.SELECT), GroupOperation.createAddGroupOperation(createdGroup.id(), Group.Type.SELECT, groupBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    group1 = createSouthboundGroupEntry(gId1, Arrays.asList(ports1), 0);
    group2 = createSouthboundGroupEntry(gId2, Arrays.asList(ports2), 0);
    groupEntries = Arrays.asList(group1, group2);
    providerService.pushGroupMetrics(DID, groupEntries);
    expectedGroupOps = Arrays.asList(GroupOperation.createDeleteGroupOperation(gId1, Group.Type.SELECT), GroupOperation.createDeleteGroupOperation(gId2, Group.Type.SELECT), GroupOperation.createAddGroupOperation(createdGroup.id(), Group.Type.SELECT, groupBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    createdGroup = new DefaultGroup(createdGroup.id(), DID, Group.Type.SELECT, groupBuckets);
    groupEntries = Arrays.asList(createdGroup);
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_ADDED));
    /* Test group add bucket operations */
    TestGroupKey addKey = new TestGroupKey("group1AddBuckets");
    PortNumber[] addPorts = { PortNumber.portNumber(51), PortNumber.portNumber(52) };
    outPorts.clear();
    outPorts.addAll(Arrays.asList(addPorts));
    List<GroupBucket> addBuckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        addBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupAddBuckets = new GroupBuckets(addBuckets);
    groupService.addBucketsToGroup(DID, key, groupAddBuckets, addKey, appId);
    GroupBuckets updatedBuckets = new GroupBuckets(buckets);
    expectedGroupOps = Arrays.asList(GroupOperation.createModifyGroupOperation(createdGroup.id(), Group.Type.SELECT, updatedBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    Group existingGroup = groupService.getGroup(DID, addKey);
    groupEntries = Arrays.asList(existingGroup);
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_UPDATED));
    /* Test group remove bucket operations */
    TestGroupKey removeKey = new TestGroupKey("group1RemoveBuckets");
    PortNumber[] removePorts = { PortNumber.portNumber(31), PortNumber.portNumber(32) };
    outPorts.clear();
    outPorts.addAll(Arrays.asList(removePorts));
    List<GroupBucket> removeBuckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        removeBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
        buckets.remove(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupRemoveBuckets = new GroupBuckets(removeBuckets);
    groupService.removeBucketsFromGroup(DID, addKey, groupRemoveBuckets, removeKey, appId);
    updatedBuckets = new GroupBuckets(buckets);
    expectedGroupOps = Arrays.asList(GroupOperation.createModifyGroupOperation(createdGroup.id(), Group.Type.SELECT, updatedBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    existingGroup = groupService.getGroup(DID, removeKey);
    groupEntries = Arrays.asList(existingGroup);
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_UPDATED));
    /* Test group remove operations */
    groupService.removeGroup(DID, removeKey, appId);
    expectedGroupOps = Arrays.asList(GroupOperation.createDeleteGroupOperation(createdGroup.id(), Group.Type.SELECT));
    internalProvider.validate(DID, expectedGroupOps);
    groupEntries = Collections.emptyList();
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_REMOVED));
}
#method_after
@Test
public void testGroupService() {
    PortNumber[] ports1 = { PortNumber.portNumber(31), PortNumber.portNumber(32) };
    PortNumber[] ports2 = { PortNumber.portNumber(41), PortNumber.portNumber(42) };
    // Test Group creation before AUDIT process
    TestGroupKey key = new TestGroupKey("group1BeforeAudit");
    List<GroupBucket> buckets = new ArrayList<GroupBucket>();
    List<PortNumber> outPorts = new ArrayList<PortNumber>();
    outPorts.addAll(Arrays.asList(ports1));
    outPorts.addAll(Arrays.asList(ports2));
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    GroupDescription newGroupDesc = new DefaultGroupDescription(DID, Group.Type.SELECT, groupBuckets, key, appId);
    groupService.addGroup(newGroupDesc);
    internalProvider.validate(DID, null);
    assertEquals(null, groupService.getGroup(DID, key));
    assertEquals(0, Iterables.size(groupService.getGroups(DID, appId)));
    // Test initial group audit process
    GroupId gId1 = new DefaultGroupId(1);
    Group group1 = createSouthboundGroupEntry(gId1, Arrays.asList(ports1), 0);
    GroupId gId2 = new DefaultGroupId(2);
    // Non zero reference count will make the group manager to queue
    // the extraneous groups until reference count is zero.
    Group group2 = createSouthboundGroupEntry(gId2, Arrays.asList(ports2), 2);
    List<Group> groupEntries = Arrays.asList(group1, group2);
    providerService.pushGroupMetrics(DID, groupEntries);
    // First group metrics would trigger the device audit completion
    // post which all pending group requests are also executed.
    Group createdGroup = groupService.getGroup(DID, key);
    int createdGroupId = createdGroup.id().id();
    assertNotEquals(gId1.id(), createdGroupId);
    assertNotEquals(gId2.id(), createdGroupId);
    List<GroupOperation> expectedGroupOps = Arrays.asList(GroupOperation.createDeleteGroupOperation(gId1, Group.Type.SELECT), GroupOperation.createAddGroupOperation(createdGroup.id(), Group.Type.SELECT, groupBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    group1 = createSouthboundGroupEntry(gId1, Arrays.asList(ports1), 0);
    group2 = createSouthboundGroupEntry(gId2, Arrays.asList(ports2), 0);
    groupEntries = Arrays.asList(group1, group2);
    providerService.pushGroupMetrics(DID, groupEntries);
    expectedGroupOps = Arrays.asList(GroupOperation.createDeleteGroupOperation(gId1, Group.Type.SELECT), GroupOperation.createDeleteGroupOperation(gId2, Group.Type.SELECT), GroupOperation.createAddGroupOperation(createdGroup.id(), Group.Type.SELECT, groupBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    createdGroup = new DefaultGroup(createdGroup.id(), DID, Group.Type.SELECT, groupBuckets);
    groupEntries = Arrays.asList(createdGroup);
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_ADDED));
    // Test group add bucket operations
    TestGroupKey addKey = new TestGroupKey("group1AddBuckets");
    PortNumber[] addPorts = { PortNumber.portNumber(51), PortNumber.portNumber(52) };
    outPorts.clear();
    outPorts.addAll(Arrays.asList(addPorts));
    List<GroupBucket> addBuckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        addBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupAddBuckets = new GroupBuckets(addBuckets);
    groupService.addBucketsToGroup(DID, key, groupAddBuckets, addKey, appId);
    GroupBuckets updatedBuckets = new GroupBuckets(buckets);
    expectedGroupOps = Arrays.asList(GroupOperation.createModifyGroupOperation(createdGroup.id(), Group.Type.SELECT, updatedBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    Group existingGroup = groupService.getGroup(DID, addKey);
    groupEntries = Arrays.asList(existingGroup);
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_UPDATED));
    // Test group remove bucket operations
    TestGroupKey removeKey = new TestGroupKey("group1RemoveBuckets");
    PortNumber[] removePorts = { PortNumber.portNumber(31), PortNumber.portNumber(32) };
    outPorts.clear();
    outPorts.addAll(Arrays.asList(removePorts));
    List<GroupBucket> removeBuckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        removeBuckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
        buckets.remove(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupRemoveBuckets = new GroupBuckets(removeBuckets);
    groupService.removeBucketsFromGroup(DID, addKey, groupRemoveBuckets, removeKey, appId);
    updatedBuckets = new GroupBuckets(buckets);
    expectedGroupOps = Arrays.asList(GroupOperation.createModifyGroupOperation(createdGroup.id(), Group.Type.SELECT, updatedBuckets));
    internalProvider.validate(DID, expectedGroupOps);
    existingGroup = groupService.getGroup(DID, removeKey);
    groupEntries = Arrays.asList(existingGroup);
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_UPDATED));
    // Test group remove operations
    groupService.removeGroup(DID, removeKey, appId);
    expectedGroupOps = Arrays.asList(GroupOperation.createDeleteGroupOperation(createdGroup.id(), Group.Type.SELECT));
    internalProvider.validate(DID, expectedGroupOps);
    groupEntries = Collections.emptyList();
    providerService.pushGroupMetrics(DID, groupEntries);
    internalListener.validateEvent(Arrays.asList(GroupEvent.Type.GROUP_REMOVED));
}
#end_block

#method_before
private Group createSouthboundGroupEntry(GroupId gId, List<PortNumber> ports, long referenceCount) {
    List<PortNumber> outPorts = new ArrayList<PortNumber>();
    outPorts.addAll(ports);
    List<GroupBucket> buckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    StoredGroupEntry group = new DefaultGroup(gId, DID, Group.Type.SELECT, groupBuckets);
    group.setRefernceCount(referenceCount);
    return group;
}
#method_after
private Group createSouthboundGroupEntry(GroupId gId, List<PortNumber> ports, long referenceCount) {
    List<PortNumber> outPorts = new ArrayList<PortNumber>();
    outPorts.addAll(ports);
    List<GroupBucket> buckets = new ArrayList<GroupBucket>();
    for (PortNumber portNumber : outPorts) {
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
        tBuilder.setOutput(portNumber).setEthDst(MacAddress.valueOf("00:00:00:00:00:02")).setEthSrc(MacAddress.valueOf("00:00:00:00:00:01")).pushMpls().setMpls(106);
        buckets.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder.build()));
    }
    GroupBuckets groupBuckets = new GroupBuckets(buckets);
    StoredGroupEntry group = new DefaultGroup(gId, DID, Group.Type.SELECT, groupBuckets);
    group.setReferenceCount(referenceCount);
    return group;
}
#end_block

#method_before
private void groupMissing(Group group) {
    checkValidity();
    GroupProvider gp = getProvider(group.deviceId());
    switch(group.state()) {
        case PENDING_DELETE:
            store.removeGroupEntry(group);
            break;
        case ADDED:
        case PENDING_ADD:
            GroupOperation groupAddOp = GroupOperation.createAddGroupOperation(group.id(), group.type(), group.buckets());
            GroupOperations groupOps = new GroupOperations(Arrays.asList(groupAddOp));
            gp.performGroupOperation(group.deviceId(), groupOps);
            break;
        default:
            log.debug("Group {} has not been installed.", group);
    }
}
#method_after
private void groupMissing(Group group) {
    checkValidity();
    GroupProvider gp = getProvider(group.deviceId());
    switch(group.state()) {
        case PENDING_DELETE:
            store.removeGroupEntry(group);
            break;
        case ADDED:
        case PENDING_ADD:
            GroupOperation groupAddOp = GroupOperation.createAddGroupOperation(group.id(), group.type(), group.buckets());
            GroupOperations groupOps = new GroupOperations(Arrays.asList(groupAddOp));
            gp.performGroupOperation(group.deviceId(), groupOps);
            break;
        default:
            log.debug("Group {} has not been installed.", group);
            break;
    }
}
#end_block

#method_before
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    DeviceId ingressDeviceId = deviceId(getDeviceId(ingressDeviceString));
    PortNumber ingressPortNumber = portNumber(getPortNumber(ingressDeviceString));
    ConnectPoint ingress = new ConnectPoint(ingressDeviceId, ingressPortNumber);
    DeviceId egressDeviceId = deviceId(getDeviceId(egressDeviceString));
    PortNumber egressPortNumber = portNumber(getPortNumber(egressDeviceString));
    ConnectPoint egress = new ConnectPoint(egressDeviceId, egressPortNumber);
    Intent intent = new OpticalConnectivityIntent(appId(), ingress, egress);
    service.submit(intent);
    print("Optical submitted:\n%s", intent.toString());
}
#method_after
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    DeviceId ingressDeviceId = deviceId(getDeviceId(ingressDeviceString));
    PortNumber ingressPortNumber = portNumber(getPortNumber(ingressDeviceString));
    ConnectPoint ingress = new ConnectPoint(ingressDeviceId, ingressPortNumber);
    DeviceId egressDeviceId = deviceId(getDeviceId(egressDeviceString));
    PortNumber egressPortNumber = portNumber(getPortNumber(egressDeviceString));
    ConnectPoint egress = new ConnectPoint(egressDeviceId, egressPortNumber);
    Intent intent = new OpticalConnectivityIntent(appId(), ingress, egress);
    service.submit(intent);
    print("Optical intent submitted:\n%s", intent.toString());
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder intentSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(InternalState.class);
    clusterCommunicator.addSubscriber(APP_BITS_REQUEST, new InternalBitServer());
    apps = new EventuallyConsistentMapImpl<>("apps", clusterService, clusterCommunicator, intentSerializer, new WallclockClockManager<>());
    states = new EventuallyConsistentMapImpl<>("app-states", clusterService, clusterCommunicator, intentSerializer, new WallclockClockManager<>());
    states.addListener(new InternalAppStatesListener());
    permissions = new EventuallyConsistentMapImpl<>("app-permissions", clusterService, clusterCommunicator, intentSerializer, new WallclockClockManager<>());
    // FIXME: figure out load from disk
    executor.schedule(this::pruneUninstalledApps, LOAD_TIMEOUT_MS, MILLISECONDS);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder intentSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(InternalState.class);
    clusterCommunicator.addSubscriber(APP_BITS_REQUEST, new InternalBitServer());
    apps = new EventuallyConsistentMapImpl<>("apps", clusterService, clusterCommunicator, intentSerializer, new WallclockClockManager<>());
    states = new EventuallyConsistentMapImpl<>("app-states", clusterService, clusterCommunicator, intentSerializer, new WallclockClockManager<>());
    states.addListener(new InternalAppStatesListener());
    permissions = new EventuallyConsistentMapImpl<>("app-permissions", clusterService, clusterCommunicator, intentSerializer, new WallclockClockManager<>());
    // FIXME: figure out load from disk; this will require resolving the dual authority problem
    executor.schedule(this::pruneUninstalledApps, LOAD_TIMEOUT_MS, MILLISECONDS);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    apps.destroy();
    states.destroy();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    apps.destroy();
    states.destroy();
    permissions.destroy();
    log.info("Stopped");
}
#end_block

#method_before
private void fetchBits(Application app) {
    ControllerNode localNode = clusterService.getLocalNode();
    ClusterMessage message = new ClusterMessage(localNode.id(), APP_BITS_REQUEST, app.id().name().getBytes());
    Map<ControllerNode, ListenableFuture<byte[]>> futures = new HashMap<>();
    CountDownLatch latch = new CountDownLatch(1);
    log.info("Downloading bits for application {}", app.id().name());
    for (ControllerNode node : clusterService.getNodes()) {
        try {
            ListenableFuture<byte[]> future = clusterCommunicator.sendAndReceive(message, node.id());
            future.addListener(new InternalBitListener(app, node, future, latch), executor);
        } catch (IOException e) {
            log.debug("Unable to request bits for application {} from node {}", app.id().name(), node.id());
        }
    }
    try {
        if (!latch.await(FETCH_TIMEOUT_MS, MILLISECONDS)) {
            log.warn("Unable to fetch bits for application {}", app.id().name());
        }
    } catch (InterruptedException e) {
        log.warn("Interrupted while fetching bits for application {}", app.id().name());
    }
}
#method_after
private void fetchBits(Application app) {
    ControllerNode localNode = clusterService.getLocalNode();
    ClusterMessage message = new ClusterMessage(localNode.id(), APP_BITS_REQUEST, app.id().name().getBytes());
    Map<ControllerNode, ListenableFuture<byte[]>> futures = new HashMap<>();
    CountDownLatch latch = new CountDownLatch(1);
    // FIXME: send message with name & version to make sure we don't get served old bits
    log.info("Downloading bits for application {}", app.id().name());
    for (ControllerNode node : clusterService.getNodes()) {
        try {
            ListenableFuture<byte[]> future = clusterCommunicator.sendAndReceive(message, node.id());
            future.addListener(new InternalBitListener(app, node, future, latch), executor);
        } catch (IOException e) {
            log.debug("Unable to request bits for application {} from node {}", app.id().name(), node.id());
        }
    }
    try {
        if (!latch.await(FETCH_TIMEOUT_MS, MILLISECONDS)) {
            log.warn("Unable to fetch bits for application {}", app.id().name());
        }
    } catch (InterruptedException e) {
        log.warn("Interrupted while fetching bits for application {}", app.id().name());
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        // this should only be called on the first iteration
        // note: this a "expensive", so it is not done in the constructor
        // - creates per Intent installation context (IntentUpdate)
        // - write Intents to store
        // - process (compile, install, etc.) each Intents
        // - generate FlowRuleBatch for this phase
        // build IntentUpdates
        List<IntentUpdate> updates = createIntentUpdates();
        // Write batch information
        BatchWrite batchWrite = createBatchWrite(updates);
        writeBatch(batchWrite);
        new IntentBatchApplyFirst(ops, processIntentUpdates(updates), endTime, 0, null).run();
    } catch (Exception e) {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // TODO: remove duplicate due to inlining
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        batchService.removeIntentOperations(ops);
    }
}
#method_after
@Override
public void run() {
    try {
        // this should only be called on the first iteration
        // note: this a "expensive", so it is not done in the constructor
        // - creates per Intent installation context (IntentUpdate)
        // - write Intents to store
        // - process (compile, install, etc.) each Intents
        // - generate FlowRuleBatch for this phase
        // build IntentUpdates
        List<IntentUpdate> updates = createIntentUpdates();
        // Write batch information
        BatchWrite batchWrite = createBatchWrite(updates);
        store.batchWrite(batchWrite);
        new IntentBatchApplyFirst(ops, processIntentUpdates(updates), endTime, 0, null).run();
    } catch (Exception e) {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // TODO: remove duplicate due to inlining
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        batchService.removeIntentOperations(ops);
    }
}
#end_block

#method_before
protected Future<CompletedBatchOperation> applyNextBatch(List<CompletedIntentUpdate> updates) {
    // TODO test this. (also, maybe save this batch)
    FlowRuleBatchOperation batch = createFlowRuleBatchOperation(updates);
    if (batch.size() > 0) {
        // FIXME apply batch might throw an exception
        return flowRuleService.applyBatch(batch);
    } else {
        // there are no flow rule batches; finalize the intent update
        BatchWrite batchWrite = createFinalizedBatchWrite(updates);
        writeBatch(batchWrite);
        return null;
    }
}
#method_after
protected Future<CompletedBatchOperation> applyNextBatch(List<CompletedIntentUpdate> updates) {
    // TODO test this. (also, maybe save this batch)
    FlowRuleBatchOperation batch = createFlowRuleBatchOperation(updates);
    if (batch.size() > 0) {
        // FIXME apply batch might throw an exception
        return flowRuleService.applyBatch(batch);
    } else {
        // there are no flow rule batches; finalize the intent update
        BatchWrite batchWrite = createFinalizedBatchWrite(updates);
        store.batchWrite(batchWrite);
        return null;
    }
}
#end_block

#method_before
@Override
public void sendMsg(List<OFMessage> msgs) {
}
#method_after
@Override
public void sendMsg(OFMessage msg, TableType tableType) {
}
#end_block

#method_before
@Override
public void sendMsg(List<OFMessage> msgs) {
}
#method_after
@Override
public void sendMsg(OFMessage msg, TableType tableType) {
}
#end_block

#method_before
@Override
public FlowRuleType type() {
    return type;
}
#method_after
@Override
public Type type() {
    return type;
}
#end_block

#method_before
public FlowRuleType type() {
    return FlowRuleType.Default;
}
#method_after
public Type type() {
    return Type.DEFAULT;
}
#end_block

#method_before
@Override
public void sendMsg(List<OFMessage> msgs) {
}
#method_after
@Override
public void sendMsg(OFMessage msg, TableType tableType) {
}
#end_block

#method_before
@Override
public FlowRuleType type() {
    return type;
}
#method_after
@Override
public Type type() {
    return type;
}
#end_block

#method_before
@Override
public void sendMsg(List<OFMessage> msgs) {
}
#method_after
@Override
public void sendMsg(OFMessage msg, TableType tableType) {
}
#end_block

#method_before
private int getDevicesConfig(String config) {
    for (String sub : config.split(",")) {
        String[] params = sub.split(":");
        if (params.length == 2) {
            NodeId that = new NodeId(params[0].trim());
            String nd = params[1];
            log.info("read: {} : {}", that, nd);
            if (clusterService.getLocalNode().id().equals(that)) {
                return Integer.valueOf(nd.trim());
            }
            continue;
        }
    }
    return DEF_NUMDEVICES;
}
#method_after
private int getDevicesConfig(String config) {
    for (String sub : config.split(",")) {
        String[] params = sub.split(":");
        if (params.length == 2) {
            NodeId that = new NodeId(params[0].trim());
            String nd = params[1];
            if (clusterService.getLocalNode().id().equals(that)) {
                return Integer.valueOf(nd.trim());
            }
            continue;
        }
    }
    return DEF_NUMDEVICES;
}
#end_block

#method_before
private void advertiseDevices() throws URISyntaxException {
    DeviceId did;
    ChassisId cid;
    // nodeIdHash takes into account for nodeID to avoid collisions when running multi-node providers.
    int nodeIdHash = (clusterService.getLocalNode().hashCode() % numDevices) * numDevices;
    for (int i = nodeIdHash; i < nodeIdHash + numDevices; i++) {
        did = DeviceId.deviceId(new URI(SCHEME, toHex(i), null));
        cid = new ChassisId(i);
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.SWITCH, "ON.Lab", "0.0.1", "0.0.1", "1234", cid);
        descriptions.put(i, desc);
        providerService.deviceConnected(did, desc);
        providerService.updatePorts(did, buildPorts());
        delay(EVENTINTERVAL);
    }
}
#method_after
private void advertiseDevices() throws URISyntaxException {
    DeviceId did;
    ChassisId cid;
    // nodeIdHash takes into account for nodeID to avoid collisions when running multi-node providers.
    long nodeIdHash = clusterService.getLocalNode().hashCode() << 16;
    for (int i = 0; i < numDevices; i++) {
        // mark 'last' device to facilitate chaining of islands together
        long id = (i + 1 == numDevices) ? nodeIdHash | 0xffff : nodeIdHash | i;
        did = DeviceId.deviceId(new URI(SCHEME, toHex(id), null));
        cid = new ChassisId(i);
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.SWITCH, "ON.Lab", "0.0.1", "0.0.1", "1234", cid);
        descriptions.put(i, desc);
        providerService.deviceConnected(did, desc);
        providerService.updatePorts(did, buildPorts());
        delay(EVENTINTERVAL);
    }
}
#end_block

#method_before
@Override
public void run() {
    try {
        // this should only be called on the first iteration
        // note: this a "expensive", so it is not done in the constructor
        // - creates per Intent installation context (IntentUpdate)
        // - write Intents to store
        // - process (compile, install, etc.) each Intents
        // - generate FlowRuleBatch for this phase
        // build IntentUpdates
        List<IntentUpdate> updates = createIntentUpdates();
        // Write batch information
        BatchWrite batchWrite = createBatchWrite(updates);
        writeBatch(batchWrite);
        new IntentBatchApplyFirst(ops, processIntentUpdates(updates), endTime, 0, null).run();
    } catch (Exception e) {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // TODO: remove duplicate due to inlining
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        batchService.removeIntentOperations(ops);
    }
}
#method_after
@Override
public void run() {
    try {
        // this should only be called on the first iteration
        // note: this a "expensive", so it is not done in the constructor
        // - creates per Intent installation context (IntentUpdate)
        // - write Intents to store
        // - process (compile, install, etc.) each Intents
        // - generate FlowRuleBatch for this phase
        // build IntentUpdates
        List<IntentUpdate> updates = createIntentUpdates();
        // Write batch information
        BatchWrite batchWrite = createBatchWrite(updates);
        store.batchWrite(batchWrite);
        new IntentBatchApplyFirst(ops, processIntentUpdates(updates), endTime, 0, null).run();
    } catch (Exception e) {
        log.error("Error submitting batches:", e);
        // FIXME incomplete Intents should be cleaned up
        // (transition to FAILED, etc.)
        // TODO: remove duplicate due to inlining
        // the batch has failed
        // TODO: maybe we should do more?
        log.error("Walk the plank, matey...");
        batchService.removeIntentOperations(ops);
    }
}
#end_block

#method_before
protected Future<CompletedBatchOperation> applyNextBatch(List<CompletedIntentUpdate> updates) {
    // TODO test this. (also, maybe save this batch)
    FlowRuleBatchOperation batch = createFlowRuleBatchOperation(updates);
    if (batch.size() > 0) {
        // FIXME apply batch might throw an exception
        return flowRuleService.applyBatch(batch);
    } else {
        // there are no flow rule batches; finalize the intent update
        BatchWrite batchWrite = createFinalizedBatchWrite(updates);
        writeBatch(batchWrite);
        return null;
    }
}
#method_after
protected Future<CompletedBatchOperation> applyNextBatch(List<CompletedIntentUpdate> updates) {
    // TODO test this. (also, maybe save this batch)
    FlowRuleBatchOperation batch = createFlowRuleBatchOperation(updates);
    if (batch.size() > 0) {
        // FIXME apply batch might throw an exception
        return flowRuleService.applyBatch(batch);
    } else {
        // there are no flow rule batches; finalize the intent update
        BatchWrite batchWrite = createFinalizedBatchWrite(updates);
        store.batchWrite(batchWrite);
        return null;
    }
}
#end_block

#method_before
private IntentUpdate createIntentUpdate(IntentOperation operation) {
    switch(operation.type()) {
        case SUBMIT:
            return new InstallRequest(operation.intent());
        case WITHDRAW:
            {
                Intent oldIntent = store.getIntent(operation.intentId());
                if (oldIntent == null) {
                    return new DoNothing1();
                }
                List<Intent> installables = store.getInstallableIntents(oldIntent.id());
                if (installables == null) {
                    return new WithdrawStateChange1(oldIntent);
                }
                return new WithdrawRequest(oldIntent, installables);
            }
        case REPLACE:
            {
                Intent newIntent = operation.intent();
                Intent oldIntent = store.getIntent(operation.intentId());
                if (oldIntent == null) {
                    return new InstallRequest(newIntent);
                }
                List<Intent> installables = store.getInstallableIntents(oldIntent.id());
                if (installables == null) {
                    if (!newIntent.equals(oldIntent)) {
                        return new WithdrawStateChange2(oldIntent);
                    } else {
                        return new DoNothing2(newIntent);
                    }
                }
                return new ReplaceRequest(newIntent, oldIntent, installables);
            }
        case UPDATE:
            {
                Intent oldIntent = store.getIntent(operation.intentId());
                if (oldIntent == null) {
                    return new DoNothing1();
                }
                List<Intent> installables = getInstallableIntents(oldIntent.id());
                if (installables == null) {
                    return new InstallRequest(oldIntent);
                }
                return new ReplaceRequest(oldIntent, oldIntent, installables);
            }
        default:
            // illegal state
            return new DoNothing1();
    }
}
#method_after
private IntentUpdate createIntentUpdate(IntentOperation operation) {
    switch(operation.type()) {
        case SUBMIT:
            return new InstallRequest(operation.intent());
        case WITHDRAW:
            {
                Intent oldIntent = store.getIntent(operation.intentId());
                if (oldIntent == null) {
                    return new DoNothing();
                }
                List<Intent> installables = store.getInstallableIntents(oldIntent.id());
                if (installables == null) {
                    return new WithdrawStateChange1(oldIntent);
                }
                return new WithdrawRequest(oldIntent, installables);
            }
        case REPLACE:
            {
                Intent newIntent = operation.intent();
                Intent oldIntent = store.getIntent(operation.intentId());
                if (oldIntent == null) {
                    return new InstallRequest(newIntent);
                }
                List<Intent> installables = store.getInstallableIntents(oldIntent.id());
                if (installables == null) {
                    if (newIntent.equals(oldIntent)) {
                        return new InstallRequest(newIntent);
                    } else {
                        return new WithdrawStateChange2(oldIntent);
                    }
                }
                return new ReplaceRequest(newIntent, oldIntent, installables);
            }
        case UPDATE:
            {
                Intent oldIntent = store.getIntent(operation.intentId());
                if (oldIntent == null) {
                    return new DoNothing();
                }
                List<Intent> installables = getInstallableIntents(oldIntent.id());
                if (installables == null) {
                    return new InstallRequest(oldIntent);
                }
                return new ReplaceRequest(oldIntent, oldIntent, installables);
            }
        default:
            // illegal state
            return new DoNothing();
    }
}
#end_block

#method_before
public boolean modified(ComponentContext context) {
    if (context == null) {
        log.info("No configuration change, using defaults: pktRate={}", DEFAULT_RATE);
        return false;
    }
    Dictionary<?, ?> properties = context.getProperties();
    int newRate;
    try {
        String s = String.valueOf(properties.get("pktRate"));
        newRate = isNullOrEmpty(s) ? pktRate : Integer.valueOf(s);
    } catch (Exception e) {
        log.warn(e.getMessage());
        newRate = pktRate;
    }
    if (newRate != pktRate) {
        pktRate = newRate;
        packetDriver.submit(new PacketDriver());
        log.info("Using new settings: pktRate={}", pktRate);
        return true;
    }
    return false;
}
#method_after
@Modified
public boolean modified(ComponentContext context) {
    if (context == null) {
        log.info("No configuration change, using defaults: pktRate={}", DEFAULT_RATE);
        return false;
    }
    Dictionary<?, ?> properties = context.getProperties();
    int newRate;
    try {
        String s = String.valueOf(properties.get("pktRate"));
        newRate = isNullOrEmpty(s) ? pktRate : Integer.valueOf(s);
    } catch (Exception e) {
        log.warn(e.getMessage());
        newRate = pktRate;
    }
    if (newRate != pktRate) {
        pktRate = newRate;
        packetDriver.submit(new PacketDriver());
        log.info("Using new settings: pktRate={}", pktRate);
        return true;
    }
    return false;
}
#end_block

#method_before
public void modified(ComponentContext context) {
    if (context == null) {
        log.info("No configs, using defaults: flicker={}, eventRate={}", FLICKER, DEFAULT_RATE);
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    boolean flickSetting;
    int newRate;
    try {
        String s = (String) properties.get("flicker");
        flickSetting = isNullOrEmpty(s) ? flicker : Boolean.valueOf(s);
        s = (String) properties.get("eventRate");
        newRate = isNullOrEmpty(s) ? eventRate : Integer.valueOf(s);
    } catch (Exception e) {
        log.warn(e.getMessage());
        flickSetting = flicker;
        newRate = eventRate;
    }
    if (flicker != flickSetting) {
        flicker = flickSetting;
    }
    if (flicker) {
        if (eventRate != newRate) {
            eventRate = newRate;
        }
        linkDriver.submit(new LinkDriver());
    }
    log.info("Using new settings: flicker={}, eventRate={}", flicker, eventRate);
}
#method_after
@Modified
public void modified(ComponentContext context) {
    if (context == null) {
        log.info("No configs, using defaults: flicker={}, eventRate={}", FLICKER, DEFAULT_RATE);
        return;
    }
    Dictionary<?, ?> properties = context.getProperties();
    boolean flickSetting;
    int newRate;
    try {
        String s = (String) properties.get("flicker");
        flickSetting = isNullOrEmpty(s) ? flicker : Boolean.valueOf(s);
        s = (String) properties.get("eventRate");
        newRate = isNullOrEmpty(s) ? eventRate : Integer.valueOf(s);
    } catch (Exception e) {
        log.warn(e.getMessage());
        flickSetting = flicker;
        newRate = eventRate;
    }
    if (flicker != flickSetting) {
        flicker = flickSetting;
    }
    if (flicker) {
        if (eventRate != newRate) {
            eventRate = newRate;
        }
        linkDriver.submit(new LinkDriver());
    }
    log.info("Using new settings: flicker={}, eventRate={}", flicker, eventRate);
}
#end_block

#method_before
@Override
@Activate
public void activate() {
    localIntents = new ConcurrentHashMap<>();
    createIntentTimer = createResponseTimer("createIntent");
    removeIntentTimer = createResponseTimer("removeIntent");
    setInstallableIntentsTimer = createResponseTimer("setInstallableIntents");
    getInstallableIntentsTimer = createResponseTimer("getInstallableIntents");
    removeInstalledIntentsTimer = createResponseTimer("removeInstalledIntents");
    setStateTimer = createResponseTimer("setState");
    getIntentCountTimer = createResponseTimer("getIntentCount");
    getIntentsTimer = createResponseTimer("getIntents");
    getIntentTimer = createResponseTimer("getIntent");
    getIntentStateTimer = createResponseTimer("getIntentState");
    // We need a way to add serializer for intents which has been plugged-in.
    // As a short term workaround, relax Kryo config to
    // registrationRequired=false
    super.activate();
    super.serializer = new KryoSerializer() {

        @Override
        protected void setupKryoPool() {
            serializerPool = KryoNamespace.newBuilder().setRegistrationRequired(false).register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).build();
        }
    };
    final Config config = theInstance.getConfig();
    MapConfig intentsCfg = config.getMapConfig(INTENTS_MAP_NAME);
    intentsCfg.setAsyncBackupCount(MapConfig.MAX_BACKUP_COUNT - intentsCfg.getBackupCount());
    IMap<byte[], byte[]> rawIntents = super.theInstance.getMap(INTENTS_MAP_NAME);
    intents = new SMap<>(rawIntents, super.serializer);
    intentsListenerId = intents.addEntryListener(new RemoteIntentsListener(), true);
    MapConfig statesCfg = config.getMapConfig(INTENT_STATES_MAP_NAME);
    statesCfg.setAsyncBackupCount(MapConfig.MAX_BACKUP_COUNT - statesCfg.getBackupCount());
    IMap<byte[], byte[]> rawStates = super.theInstance.getMap(INTENT_STATES_MAP_NAME);
    states = new SMap<>(rawStates, super.serializer);
    EntryListener<IntentId, IntentState> listener = new RemoteIntentStateListener();
    stateListenerId = states.addEntryListener(listener, true);
    transientStates.clear();
    MapConfig installableCfg = config.getMapConfig(INSTALLABLE_INTENTS_MAP_NAME);
    installableCfg.setAsyncBackupCount(MapConfig.MAX_BACKUP_COUNT - installableCfg.getBackupCount());
    IMap<byte[], byte[]> rawInstallables = super.theInstance.getMap(INSTALLABLE_INTENTS_MAP_NAME);
    installable = new SMap<>(rawInstallables, super.serializer);
    log.info("Started");
}
#method_after
@Override
@Activate
public void activate() {
    localIntents = new ConcurrentHashMap<>();
    setInstallableIntentsTimer = createResponseTimer("setInstallableIntents");
    getInstallableIntentsTimer = createResponseTimer("getInstallableIntents");
    removeInstalledIntentsTimer = createResponseTimer("removeInstalledIntents");
    setStateTimer = createResponseTimer("setState");
    getIntentCountTimer = createResponseTimer("getIntentCount");
    getIntentsTimer = createResponseTimer("getIntents");
    getIntentTimer = createResponseTimer("getIntent");
    getIntentStateTimer = createResponseTimer("getIntentState");
    // We need a way to add serializer for intents which has been plugged-in.
    // As a short term workaround, relax Kryo config to
    // registrationRequired=false
    super.activate();
    super.serializer = new KryoSerializer() {

        @Override
        protected void setupKryoPool() {
            serializerPool = KryoNamespace.newBuilder().setRegistrationRequired(false).register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).build();
        }
    };
    final Config config = theInstance.getConfig();
    MapConfig intentsCfg = config.getMapConfig(INTENTS_MAP_NAME);
    intentsCfg.setAsyncBackupCount(MapConfig.MAX_BACKUP_COUNT - intentsCfg.getBackupCount());
    IMap<byte[], byte[]> rawIntents = super.theInstance.getMap(INTENTS_MAP_NAME);
    intents = new SMap<>(rawIntents, super.serializer);
    intentsListenerId = intents.addEntryListener(new RemoteIntentsListener(), true);
    MapConfig statesCfg = config.getMapConfig(INTENT_STATES_MAP_NAME);
    statesCfg.setAsyncBackupCount(MapConfig.MAX_BACKUP_COUNT - statesCfg.getBackupCount());
    IMap<byte[], byte[]> rawStates = super.theInstance.getMap(INTENT_STATES_MAP_NAME);
    states = new SMap<>(rawStates, super.serializer);
    EntryListener<IntentId, IntentState> listener = new RemoteIntentStateListener();
    stateListenerId = states.addEntryListener(listener, true);
    transientStates.clear();
    MapConfig installableCfg = config.getMapConfig(INSTALLABLE_INTENTS_MAP_NAME);
    installableCfg.setAsyncBackupCount(MapConfig.MAX_BACKUP_COUNT - installableCfg.getBackupCount());
    IMap<byte[], byte[]> rawInstallables = super.theInstance.getMap(INSTALLABLE_INTENTS_MAP_NAME);
    installable = new SMap<>(rawInstallables, super.serializer);
    log.info("Started");
}
#end_block

#method_before
@Activate
public void activate() {
    createIntentTimer = createResponseTimer("createIntent");
    removeIntentTimer = createResponseTimer("removeIntent");
    setInstallableIntentsTimer = createResponseTimer("setInstallableIntents");
    getInstallableIntentsTimer = createResponseTimer("getInstallableIntents");
    removeInstalledIntentsTimer = createResponseTimer("removeInstalledIntents");
    setStateTimer = createResponseTimer("setState");
    getIntentCountTimer = createResponseTimer("getIntentCount");
    getIntentsTimer = createResponseTimer("getIntents");
    getIntentTimer = createResponseTimer("getIntent");
    getIntentStateTimer = createResponseTimer("getIntentState");
    // We need a way to add serializer for intents which has been plugged-in.
    // As a short term workaround, relax Kryo config to
    // registrationRequired=false
    serializer = new KryoSerializer() {

        @Override
        protected void setupKryoPool() {
            serializerPool = KryoNamespace.newBuilder().setRegistrationRequired(false).register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).build();
        }
    };
    keyCache = CacheBuilder.newBuilder().softValues().build(new CacheLoader<IntentId, String>() {

        @Override
        public String load(IntentId key) {
            return key.toString();
        }
    });
    intents = new IntentIdMap<>(dbAdminService, dbService, INTENTS_TABLE, serializer);
    states = new IntentIdMap<>(dbAdminService, dbService, STATES_TABLE, serializer);
    transientStates.clear();
    installable = new IntentIdMap<>(dbAdminService, dbService, INSTALLABLE_TABLE, serializer);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    setInstallableIntentsTimer = createResponseTimer("setInstallableIntents");
    getInstallableIntentsTimer = createResponseTimer("getInstallableIntents");
    removeInstalledIntentsTimer = createResponseTimer("removeInstalledIntents");
    setStateTimer = createResponseTimer("setState");
    getIntentCountTimer = createResponseTimer("getIntentCount");
    getIntentsTimer = createResponseTimer("getIntents");
    getIntentTimer = createResponseTimer("getIntent");
    getIntentStateTimer = createResponseTimer("getIntentState");
    // We need a way to add serializer for intents which has been plugged-in.
    // As a short term workaround, relax Kryo config to
    // registrationRequired=false
    serializer = new KryoSerializer() {

        @Override
        protected void setupKryoPool() {
            serializerPool = KryoNamespace.newBuilder().setRegistrationRequired(false).register(KryoNamespaces.API).nextId(KryoNamespaces.BEGIN_USER_CUSTOM_ID).build();
        }
    };
    keyCache = CacheBuilder.newBuilder().softValues().build(new CacheLoader<IntentId, String>() {

        @Override
        public String load(IntentId key) {
            return key.toString();
        }
    });
    intents = new IntentIdMap<>(dbAdminService, dbService, INTENTS_TABLE, serializer);
    states = new IntentIdMap<>(dbAdminService, dbService, STATES_TABLE, serializer);
    transientStates.clear();
    installable = new IntentIdMap<>(dbAdminService, dbService, INSTALLABLE_TABLE, serializer);
    log.info("Started");
}
#end_block

#method_before
private void advertiseDevices() {
    DeviceId did;
    ChassisId cid;
    // nodeIdHash takes into account for nodeID so that no collision running multi-node providers
    int nodeIdHash = clusterService.getLocalNode().hashCode() * NUMDEVICES;
    for (int i = nodeIdHash; i < nodeIdHash + NUMDEVICES; i++) {
        did = DeviceId.deviceId(String.format("%s:%d", SCHEME, i));
        cid = new ChassisId(i);
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.SWITCH, "ON.Lab", "0.0.1", "0.0.1", "1234", cid);
        descriptions.put(i, desc);
        providerService.deviceConnected(did, desc);
        providerService.updatePorts(did, buildPorts());
        delay(EVENTINTERVAL);
    }
}
#method_after
private void advertiseDevices() {
    DeviceId did;
    ChassisId cid;
    // nodeIdHash takes into account for nodeID to avoid collisions when running multi-node providers.
    int nodeIdHash = (clusterService.getLocalNode().hashCode() % NUMDEVICES) * NUMDEVICES;
    for (int i = nodeIdHash; i < nodeIdHash + NUMDEVICES; i++) {
        did = DeviceId.deviceId(String.format("%s:%d", SCHEME, i));
        cid = new ChassisId(i);
        DeviceDescription desc = new DefaultDeviceDescription(did.uri(), Device.Type.SWITCH, "ON.Lab", "0.0.1", "0.0.1", "1234", cid);
        descriptions.put(i, desc);
        providerService.deviceConnected(did, desc);
        providerService.updatePorts(did, buildPorts());
        delay(EVENTINTERVAL);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(type().toString()).add("icmpv6Type", Integer.toString(icmpv6Type & 0xff)).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(type().toString()).add("icmpv6Type", icmpv6Type & 0xff).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(type().toString()).add("icmpv6Code", Integer.toString(icmpv6Code & 0xff)).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(type().toString()).add("icmpv6Code", icmpv6Code & 0xff).toString();
}
#end_block

#method_before
private void createDevices(int numDevices, int numPorts) {
    List<Device> devices = new ArrayList<>();
    for (int i = 1; i <= numDevices; i++) {
        DeviceId devId = getDeviceId(i);
        Device device = createMock(Device.class);
        expect(device.id()).andReturn(devId).anyTimes();
        replay(device);
        devices.add(device);
        List<Port> ports = new ArrayList<>();
        for (int j = 1; j <= numPorts; j++) {
            Port port = createMock(Port.class);
            expect(port.number()).andReturn(PortNumber.portNumber(j)).anyTimes();
            replay(port);
            ports.add(port);
        }
        expect(deviceService.getPorts(devId)).andReturn(ports).anyTimes();
        expect(deviceService.getDevice(devId)).andReturn(device).anyTimes();
    }
    expect(deviceService.getDevices()).andReturn(devices).anyTimes();
    replay(deviceService);
    // Edge ports are always the first port on the device
    for (int i = 1; i <= numDevices; i++) {
        EDGE_PORTS.add(new ConnectPoint(getDeviceId(i), P1));
    }
}
#method_after
private void createDevices(int numDevices, int numPorts) {
    List<Device> devices = new ArrayList<>();
    for (int i = 1; i <= numDevices; i++) {
        DeviceId devId = getDeviceId(i);
        Device device = createMock(Device.class);
        expect(device.id()).andReturn(devId).anyTimes();
        replay(device);
        devices.add(device);
        List<Port> ports = new ArrayList<>();
        for (int j = 1; j <= numPorts; j++) {
            Port port = createMock(Port.class);
            expect(port.number()).andReturn(PortNumber.portNumber(j)).anyTimes();
            replay(port);
            ports.add(port);
        }
        expect(deviceService.getPorts(devId)).andReturn(ports).anyTimes();
        expect(deviceService.getDevice(devId)).andReturn(device).anyTimes();
    }
    expect(deviceService.getDevices()).andReturn(devices).anyTimes();
    replay(deviceService);
}
#end_block

#method_before
@Test
public void testNotKnown() {
    expect(hostService.getHostsByIp(IP1)).andReturn(Collections.<Host>emptySet());
    replay(hostService);
    assertFalse(proxyArp.known(IP1));
}
#method_after
@Test
public void testNotKnown() {
    expect(hostService.getHostsByIp(IP1)).andReturn(Collections.<Host>emptySet());
    replay(hostService);
    assertFalse(proxyArp.isKnown(IP1));
}
#end_block

#method_before
@Test
public void testKnown() {
    Host host1 = createMock(Host.class);
    Host host2 = createMock(Host.class);
    expect(hostService.getHostsByIp(IP1)).andReturn(Sets.newHashSet(host1, host2));
    replay(hostService);
    assertTrue(proxyArp.known(IP1));
}
#method_after
@Test
public void testKnown() {
    Host host1 = createMock(Host.class);
    Host host2 = createMock(Host.class);
    expect(hostService.getHostsByIp(IP1)).andReturn(Sets.newHashSet(host1, host2));
    replay(hostService);
    assertTrue(proxyArp.isKnown(IP1));
}
#end_block

#method_before
@Override
public OpenFlowSwitchDriver getOFSwitchImpl(Dpid dpid, OFDescStatsReply desc, OFVersion ofv) {
    String vendor = desc.getMfrDesc();
    String hw = desc.getHwDesc();
    if (vendor.startsWith("Stanford University, Ericsson Research and CPqD Research") && hw.startsWith("OpenFlow 1.3 Reference Userspace Switch")) {
        return new OFSwitchImplCPqD13(dpid, desc);
    }
    if (hw.startsWith("Open vSwitch")) {
        if (ofv == OFVersion.OF_10) {
            return new OFSwitchImplOVS10(dpid, desc);
        } else if (ofv == OFVersion.OF_13) {
            return new OFSwitchImplOVS13(dpid, desc);
        }
    }
    String sw = desc.getSwDesc();
    if (sw.startsWith("LINC-OE")) {
        log.warn("Optical Emulator LINC-OE with DPID:{} found..", dpid);
        return new OFOpticalSwitchImplLINC13(dpid, desc);
    }
    log.warn("DriverManager could not identify switch desc: {}. " + "Assigning AbstractOpenFlowSwich", desc);
    return new AbstractOpenFlowSwitch(dpid, desc) {

        @Override
        public void setRole(RoleState state) {
            this.role = RoleState.MASTER;
        }

        @Override
        public void write(List<OFMessage> msgs) {
            channel.write(msgs);
        }

        @Override
        public void write(OFMessage msg) {
            channel.write(Collections.singletonList(msg));
        }

        @Override
        public Boolean supportNxRole() {
            return false;
        }

        @Override
        public void startDriverHandshake() {
            if (factory().getVersion() == OFVersion.OF_10) {
                OFFlowAdd.Builder fmBuilder = factory().buildFlowAdd();
                fmBuilder.setPriority(0);
                write(fmBuilder.build());
            }
        }

        @Override
        public void processDriverHandshakeMessage(OFMessage m) {
        }

        @Override
        public boolean isDriverHandshakeComplete() {
            return true;
        }

        @Override
        public List<OFPortDesc> getPorts() {
            if (this.factory().getVersion() == OFVersion.OF_10) {
                return Collections.unmodifiableList(features.getPorts());
            } else {
                return Collections.unmodifiableList(ports.getEntries());
            }
        }
    };
}
#method_after
@Override
public OpenFlowSwitchDriver getOFSwitchImpl(Dpid dpid, OFDescStatsReply desc, OFVersion ofv) {
    String vendor = desc.getMfrDesc();
    String hw = desc.getHwDesc();
    if (vendor.startsWith("Stanford University, Ericsson Research and CPqD Research") && hw.startsWith("OpenFlow 1.3 Reference Userspace Switch")) {
        return new OFSwitchImplCPqD13(dpid, desc);
    }
    if (hw.startsWith("Open vSwitch")) {
        if (ofv == OFVersion.OF_10) {
            return new OFSwitchImplOVS10(dpid, desc);
        } else if (ofv == OFVersion.OF_13) {
            return new OFSwitchImplOVS13(dpid, desc);
        }
    }
    String sw = desc.getSwDesc();
    if (sw.startsWith("LINC-OE")) {
        log.warn("Optical Emulator LINC-OE with DPID:{} found..", dpid);
        return new OFOpticalSwitchImplLINC13(dpid, desc);
    }
    log.warn("DriverManager could not identify switch desc: {}. " + "Assigning AbstractOpenFlowSwich", desc);
    return new AbstractOpenFlowSwitch(dpid, desc) {

        @Override
        public void setRole(RoleState state) {
            this.role = RoleState.MASTER;
        }

        @Override
        public void write(List<OFMessage> msgs) {
            channel.write(msgs);
        }

        @Override
        public void write(OFMessage msg) {
            channel.write(Collections.singletonList(msg));
        }

        @Override
        public Boolean supportNxRole() {
            return false;
        }

        @Override
        public void startDriverHandshake() {
            if (factory().getVersion() == OFVersion.OF_10) {
                OFFlowAdd.Builder fmBuilder = factory().buildFlowAdd();
                fmBuilder.setPriority(LOWEST_PRIORITY);
                write(fmBuilder.build());
            }
        }

        @Override
        public void processDriverHandshakeMessage(OFMessage m) {
        }

        @Override
        public boolean isDriverHandshakeComplete() {
            return true;
        }

        @Override
        public List<OFPortDesc> getPorts() {
            if (this.factory().getVersion() == OFVersion.OF_10) {
                return Collections.unmodifiableList(features.getPorts());
            } else {
                return Collections.unmodifiableList(ports.getEntries());
            }
        }
    };
}
#end_block

#method_before
private boolean tableMissRule(Dpid dpid, OFFlowStatsEntry reply) {
    if (reply.getMatch().getMatchFields().iterator().hasNext()) {
        return false;
    }
    if (reply.getVersion().equals(OFVersion.OF_10)) {
        return reply.getPriority() == 0 && reply.getActions().isEmpty();
    }
    for (OFInstruction ins : reply.getInstructions()) {
        if (ins.getType() == OFInstructionType.APPLY_ACTIONS) {
            OFInstructionApplyActions apply = (OFInstructionApplyActions) ins;
            List<OFAction> acts = apply.getActions();
            for (OFAction act : acts) {
                if (act.getType() == OFActionType.OUTPUT) {
                    OFActionOutput out = (OFActionOutput) act;
                    if (out.getPort() == OFPort.CONTROLLER) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
#method_after
private boolean tableMissRule(Dpid dpid, OFFlowStatsEntry reply) {
    if (reply.getMatch().getMatchFields().iterator().hasNext()) {
        return false;
    }
    if (reply.getVersion().equals(OFVersion.OF_10)) {
        return reply.getPriority() == LOWEST_PRIORITY && reply.getActions().isEmpty();
    }
    for (OFInstruction ins : reply.getInstructions()) {
        if (ins.getType() == OFInstructionType.APPLY_ACTIONS) {
            OFInstructionApplyActions apply = (OFInstructionApplyActions) ins;
            List<OFAction> acts = apply.getActions();
            for (OFAction act : acts) {
                if (act.getType() == OFActionType.OUTPUT) {
                    OFActionOutput out = (OFActionOutput) act;
                    if (out.getPort() == OFPort.CONTROLLER) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void startDriverHandshake() {
    OFFlowAdd.Builder fmBuilder = factory().buildFlowAdd();
    fmBuilder.setPriority(0);
    write(fmBuilder.build());
}
#method_after
@Override
public void startDriverHandshake() {
    OFFlowAdd.Builder fmBuilder = factory().buildFlowAdd();
    fmBuilder.setPriority(LOWEST_PRIORITY);
    write(fmBuilder.build());
}
#end_block

#method_before
DefaultDriver merge(DefaultDriver other) {
    // Merge the fingerprints.
    ImmutableSet.Builder<String> fingerprints = ImmutableSet.builder();
    fingerprints.addAll(other.fingerprints).addAll(this.fingerprints);
    // Merge the behaviours.
    ImmutableMap.Builder<Class<? extends Behaviour>, Class<? extends Behaviour>> behaviours = ImmutableMap.builder();
    behaviours.putAll(other.behaviours).putAll(this.behaviours);
    // Merge the properties.
    ImmutableMap.Builder<String, String> properties = ImmutableMap.builder();
    properties.putAll(other.properties).putAll(this.properties);
    return new DefaultDriver(name, manufacturer, hwVersion, swVersion, fingerprints.build(), behaviours.build(), properties.build());
}
#method_after
DefaultDriver merge(DefaultDriver other) {
    // Merge the behaviours.
    ImmutableMap.Builder<Class<? extends Behaviour>, Class<? extends Behaviour>> behaviours = ImmutableMap.builder();
    behaviours.putAll(other.behaviours).putAll(this.behaviours);
    // Merge the properties.
    ImmutableMap.Builder<String, String> properties = ImmutableMap.builder();
    properties.putAll(other.properties).putAll(this.properties);
    return new DefaultDriver(name, manufacturer, hwVersion, swVersion, behaviours.build(), properties.build());
}
#end_block

#method_before
<T extends Behaviour> T createBehaviour(DriverData data, Class<T> behaviourClass, boolean handler) {
    checkArgument(handler || !HandlerBehaviour.class.isAssignableFrom(behaviourClass), "{} is applicable only to handler context", behaviourClass.getName());
    // Locate the implementation of the requested behaviour.
    Class<? extends Behaviour> implementation = behaviours.get(behaviourClass);
    checkArgument(implementation != null, "{} not supported", behaviourClass.getName());
    // Create an instance of the behaviour and apply data as its context.
    T behaviour = createBehaviour(behaviourClass, implementation);
    behaviour.setData(data);
    return behaviour;
}
#method_after
public <T extends Behaviour> T createBehaviour(DriverData data, Class<T> behaviourClass, boolean handler) {
    checkArgument(handler || !HandlerBehaviour.class.isAssignableFrom(behaviourClass), "{} is applicable only to handler context", behaviourClass.getName());
    // Locate the implementation of the requested behaviour.
    Class<? extends Behaviour> implementation = behaviours.get(behaviourClass);
    checkArgument(implementation != null, "{} not supported", behaviourClass.getName());
    // Create an instance of the behaviour and apply data as its context.
    T behaviour = createBehaviour(behaviourClass, implementation);
    behaviour.setData(data);
    return behaviour;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private <T extends Behaviour> T createBehaviour(Class<T> behaviourClass, Class<? extends Behaviour> implementation) {
    try {
        return (T) implementation.newInstance();
    } catch (InstantiationException | IllegalAccessException e) {
        // TODO: add a specific unchecked exception
        throw new RuntimeException("Unable to create behaviour", e);
    }
}
#method_after
@SuppressWarnings("unchecked")
private <T extends Behaviour> T createBehaviour(Class<T> behaviourClass, Class<? extends Behaviour> implementation) {
    try {
        return (T) implementation.newInstance();
    } catch (InstantiationException | IllegalAccessException e) {
        // TODO: add a specific unchecked exception
        throw new IllegalArgumentException("Unable to create behaviour", e);
    }
}
#end_block

#method_before
@Override
public String toString() {
    return toStringHelper(this).add("name", name).add("manufacturer", manufacturer).add("hwVersion", hwVersion).add("swVersion", swVersion).add("fingerprints", fingerprints).add("behaviours", behaviours).add("properties", properties).toString();
}
#method_after
@Override
public String toString() {
    return toStringHelper(this).add("name", name).add("manufacturer", manufacturer).add("hwVersion", hwVersion).add("swVersion", swVersion).add("behaviours", behaviours).add("properties", properties).toString();
}
#end_block

#method_before
public DefaultDriverProvider loadDrivers(InputStream driversStream) {
    DefaultDriverProvider provider = new DefaultDriverProvider();
    return provider;
}
#method_after
public DefaultDriverProvider loadDrivers(InputStream driversStream) throws IOException {
    try {
        XMLConfiguration cfg = new XMLConfiguration();
        cfg.setRootElementName(DRIVERS);
        cfg.setAttributeSplittingDisabled(true);
        cfg.load(driversStream);
        return loadDrivers(cfg);
    } catch (ConfigurationException e) {
        throw new IOException("Unable to load drivers", e);
    }
}
#end_block

#method_before
public DefaultDriverProvider loadDrivers(InputStream driversStream) {
    DefaultDriverProvider provider = new DefaultDriverProvider();
    return provider;
}
#method_after
public DefaultDriverProvider loadDrivers(HierarchicalConfiguration driversCfg) {
    DefaultDriverProvider provider = new DefaultDriverProvider();
    for (HierarchicalConfiguration cfg : driversCfg.configurationsAt(DRIVER)) {
        provider.addDriver(loadDriver(cfg));
    }
    return provider;
}
#end_block

#method_before
@Before
public void setUp() {
    ddc = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", of("circus.lux", "alpha"), ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    data = new DefaultDriverData(ddc);
}
#method_after
@Before
public void setUp() {
    ddc = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    data = new DefaultDriverData(ddc);
}
#end_block

#method_before
@Test
public void basics() {
    assertSame("incorrect type", ddc, data.type());
    assertTrue("incorrect toString", data.toString().contains("alpha"));
}
#method_after
@Test
public void basics() {
    assertSame("incorrect type", ddc, data.type());
    assertTrue("incorrect toString", data.toString().contains("foo.bar"));
}
#end_block

#method_before
@Before
public void setUp() {
    ddc = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", of("circus.lux", "alpha"), ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class, TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("foo", "bar"));
    data = new DefaultDriverData(ddc);
    handler = new DefaultDriverHandler(data);
}
#method_after
@Before
public void setUp() {
    ddc = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class, TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("foo", "bar"));
    data = new DefaultDriverData(ddc);
    handler = new DefaultDriverHandler(data);
}
#end_block

#method_before
@Test
public void basics() {
    assertSame("incorrect data", data, handler.data());
    assertTrue("incorrect toString", handler.toString().contains("alpha"));
}
#method_after
@Test
public void basics() {
    assertSame("incorrect data", data, handler.data());
    assertTrue("incorrect toString", handler.toString().contains("1.2a"));
}
#end_block

#method_before
@Test
public void basics() {
    DefaultDriverProvider ddp = new DefaultDriverProvider();
    DefaultDriver one = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", of("circus.lux", "alpha"), ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    DefaultDriver two = new DefaultDriver("foo.bar", "", "", "", of("beta"), ImmutableMap.of(TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("goo", "wee"));
    DefaultDriver three = new DefaultDriver("goo.foo", "BigTop", "better", "2.2", of("gamma"), ImmutableMap.of(TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("goo", "gee"));
    ddp.addDrivers(of(one, two, three));
    Set<Driver> drivers = ddp.getDrivers();
    assertEquals("incorrect types", 2, drivers.size());
}
#method_after
@Test
public void basics() {
    DefaultDriverProvider ddp = new DefaultDriverProvider();
    DefaultDriver one = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    DefaultDriver two = new DefaultDriver("foo.bar", "", "", "", ImmutableMap.of(TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("goo", "wee"));
    DefaultDriver three = new DefaultDriver("goo.foo", "BigTop", "better", "2.2", ImmutableMap.of(TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("goo", "gee"));
    ddp.addDrivers(of(one, two, three));
    Set<Driver> drivers = ddp.getDrivers();
    assertEquals("incorrect types", 2, drivers.size());
}
#end_block

#method_before
@Override
public DefaultDriver type() {
    return type;
}
#method_after
@Override
public Driver type() {
    return type;
}
#end_block

#method_before
@Test
public void basics() {
    DefaultDriver ddc = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", of("circus.lux", "alpha"), ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    assertEquals("incorrect name", "foo.bar", ddc.name());
    assertEquals("incorrect mfr", "Circus", ddc.manufacturer());
    assertEquals("incorrect hw", "lux", ddc.hwVersion());
    assertEquals("incorrect sw", "1.2a", ddc.swVersion());
    assertEquals("incorrect fingerprint count", 2, ddc.fingerprints().size());
    assertTrue("incorrect fingerprint", ddc.fingerprints().contains("alpha"));
    assertEquals("incorrect behaviour count", 1, ddc.behaviours().size());
    assertTrue("incorrect behaviour", ddc.hasBehaviour(TestBehaviour.class));
    assertEquals("incorrect property count", 1, ddc.properties().size());
    assertEquals("incorrect key count", 1, ddc.keys().size());
    assertEquals("incorrect property", "bar", ddc.value("foo"));
    assertTrue("incorrect toString", ddc.toString().contains("alpha"));
}
#method_after
@Test
public void basics() {
    DefaultDriver ddc = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    assertEquals("incorrect name", "foo.bar", ddc.name());
    assertEquals("incorrect mfr", "Circus", ddc.manufacturer());
    assertEquals("incorrect hw", "lux", ddc.hwVersion());
    assertEquals("incorrect sw", "1.2a", ddc.swVersion());
    assertEquals("incorrect behaviour count", 1, ddc.behaviours().size());
    assertTrue("incorrect behaviour", ddc.hasBehaviour(TestBehaviour.class));
    assertEquals("incorrect property count", 1, ddc.properties().size());
    assertEquals("incorrect key count", 1, ddc.keys().size());
    assertEquals("incorrect property", "bar", ddc.value("foo"));
    assertTrue("incorrect toString", ddc.toString().contains("lux"));
}
#end_block

#method_before
@Test
public void merge() {
    DefaultDriver one = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", of("circus.lux", "alpha"), ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    DefaultDriver ddc = one.merge(new DefaultDriver("foo.bar", "", "", "", of("beta"), ImmutableMap.of(TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("goo", "wee")));
    assertEquals("incorrect name", "foo.bar", ddc.name());
    assertEquals("incorrect mfr", "Circus", ddc.manufacturer());
    assertEquals("incorrect hw", "lux", ddc.hwVersion());
    assertEquals("incorrect sw", "1.2a", ddc.swVersion());
    assertEquals("incorrect fingerprint count", 3, ddc.fingerprints().size());
    assertTrue("incorrect fingerprint", ddc.fingerprints().contains("beta"));
    assertEquals("incorrect behaviour count", 2, ddc.behaviours().size());
    assertTrue("incorrect behaviour", ddc.hasBehaviour(TestBehaviourTwo.class));
    assertEquals("incorrect property count", 2, ddc.properties().size());
    assertEquals("incorrect key count", 2, ddc.keys().size());
    assertEquals("incorrect property", "wee", ddc.value("goo"));
    assertTrue("incorrect toString", ddc.toString().contains("beta"));
}
#method_after
@Test
public void merge() {
    DefaultDriver one = new DefaultDriver("foo.bar", "Circus", "lux", "1.2a", ImmutableMap.of(TestBehaviour.class, TestBehaviourImpl.class), ImmutableMap.of("foo", "bar"));
    DefaultDriver ddc = one.merge(new DefaultDriver("foo.bar", "", "", "", ImmutableMap.of(TestBehaviourTwo.class, TestBehaviourTwoImpl.class), ImmutableMap.of("goo", "wee")));
    assertEquals("incorrect name", "foo.bar", ddc.name());
    assertEquals("incorrect mfr", "Circus", ddc.manufacturer());
    assertEquals("incorrect hw", "lux", ddc.hwVersion());
    assertEquals("incorrect sw", "1.2a", ddc.swVersion());
    assertEquals("incorrect behaviour count", 2, ddc.behaviours().size());
    assertTrue("incorrect behaviour", ddc.hasBehaviour(TestBehaviourTwo.class));
    assertEquals("incorrect property count", 2, ddc.properties().size());
    assertEquals("incorrect key count", 2, ddc.keys().size());
    assertEquals("incorrect property", "wee", ddc.value("goo"));
    assertTrue("incorrect toString", ddc.toString().contains("Circus"));
}
#end_block

#method_before
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    EthCriterion eth;
    IPCriterion ip;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    TcpPortCriterion tp;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inport = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inport.port().toLong()));
                break;
            case ETH_SRC:
                eth = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(eth.mac().toLong()));
                break;
            case ETH_DST:
                eth = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(eth.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType()));
                break;
            case IPV4_DST:
                ip = (IPCriterion) c;
                ip4Prefix = ip.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_SRC:
                ip = (IPCriterion) c;
                ip4Prefix = ip.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                break;
            case TCP_DST:
                tp = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tp.tcpPort()));
                break;
            case TCP_SRC:
                tp = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tp.tcpPort()));
                break;
            case MPLS_LABEL:
                Criteria.MplsCriterion mp = (Criteria.MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().intValue()));
                break;
            case OCH_SIGID:
                LambdaCriterion lc = (LambdaCriterion) c;
                mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID((byte) 1, (byte) 2, lc.lambda(), (short) 1));
                break;
            case OCH_SIGTYPE:
                Criteria.OpticalSignalTypeCriterion sc = (Criteria.OpticalSignalTypeCriterion) c;
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(sc.signalType()));
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case ICMPV4_CODE:
            case ICMPV4_TYPE:
            case ICMPV6_CODE:
            case ICMPV6_TYPE:
            case IN_PHY_PORT:
            case IPV6_DST:
                ip = (IPCriterion) c;
                ip6Prefix = ip.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_EXTHDR:
            case IPV6_FLABEL:
            case IPV6_ND_SLL:
            case IPV6_ND_TARGET:
            case IPV6_ND_TLL:
            case IPV6_SRC:
                ip = (IPCriterion) c;
                ip6Prefix = ip.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IP_DSCP:
            case IP_ECN:
            case METADATA:
            case MPLS_BOS:
            case MPLS_TC:
            case PBB_ISID:
            case SCTP_DST:
            case SCTP_SRC:
            case TUNNEL_ID:
            case UDP_DST:
            case UDP_SRC:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#method_after
protected Match buildMatch() {
    Match.Builder mBuilder = factory.buildMatch();
    EthCriterion eth;
    IPCriterion ip;
    Ip4Prefix ip4Prefix;
    Ip6Prefix ip6Prefix;
    TcpPortCriterion tp;
    for (Criterion c : selector.criteria()) {
        switch(c.type()) {
            case IN_PORT:
                PortCriterion inport = (PortCriterion) c;
                mBuilder.setExact(MatchField.IN_PORT, OFPort.of((int) inport.port().toLong()));
                break;
            case ETH_SRC:
                eth = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_SRC, MacAddress.of(eth.mac().toLong()));
                break;
            case ETH_DST:
                eth = (EthCriterion) c;
                mBuilder.setExact(MatchField.ETH_DST, MacAddress.of(eth.mac().toLong()));
                break;
            case ETH_TYPE:
                EthTypeCriterion ethType = (EthTypeCriterion) c;
                mBuilder.setExact(MatchField.ETH_TYPE, EthType.of(ethType.ethType()));
                break;
            case IPV4_DST:
                ip = (IPCriterion) c;
                ip4Prefix = ip.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_DST, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IPV4_SRC:
                ip = (IPCriterion) c;
                ip4Prefix = ip.ip().getIp4Prefix();
                if (ip4Prefix.prefixLength() != Ip4Prefix.MAX_MASK_LENGTH) {
                    Ip4Address maskAddr = Ip4Address.makeMaskPrefix(ip4Prefix.prefixLength());
                    Masked<IPv4Address> maskedIp = Masked.of(IPv4Address.of(ip4Prefix.address().toInt()), IPv4Address.of(maskAddr.toInt()));
                    mBuilder.setMasked(MatchField.IPV4_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV4_SRC, IPv4Address.of(ip4Prefix.address().toInt()));
                }
                break;
            case IP_PROTO:
                IPProtocolCriterion p = (IPProtocolCriterion) c;
                mBuilder.setExact(MatchField.IP_PROTO, IpProtocol.of(p.protocol()));
                break;
            case VLAN_PCP:
                VlanPcpCriterion vpcp = (VlanPcpCriterion) c;
                mBuilder.setExact(MatchField.VLAN_PCP, VlanPcp.of(vpcp.priority()));
                break;
            case VLAN_VID:
                VlanIdCriterion vid = (VlanIdCriterion) c;
                mBuilder.setExact(MatchField.VLAN_VID, OFVlanVidMatch.ofVlanVid(VlanVid.ofVlan(vid.vlanId().toShort())));
                break;
            case TCP_DST:
                tp = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_DST, TransportPort.of(tp.tcpPort()));
                break;
            case TCP_SRC:
                tp = (TcpPortCriterion) c;
                mBuilder.setExact(MatchField.TCP_SRC, TransportPort.of(tp.tcpPort()));
                break;
            case MPLS_LABEL:
                Criteria.MplsCriterion mp = (Criteria.MplsCriterion) c;
                mBuilder.setExact(MatchField.MPLS_LABEL, U32.of(mp.label().intValue()));
                break;
            case OCH_SIGID:
                LambdaCriterion lc = (LambdaCriterion) c;
                mBuilder.setExact(MatchField.OCH_SIGID, new CircuitSignalID((byte) 1, (byte) 2, lc.lambda(), (short) 1));
                break;
            case OCH_SIGTYPE:
                Criteria.OpticalSignalTypeCriterion sc = (Criteria.OpticalSignalTypeCriterion) c;
                mBuilder.setExact(MatchField.OCH_SIGTYPE, U8.of(sc.signalType()));
                break;
            case IPV6_DST:
                ip = (IPCriterion) c;
                ip6Prefix = ip.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_DST, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_DST, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case IPV6_SRC:
                ip = (IPCriterion) c;
                ip6Prefix = ip.ip().getIp6Prefix();
                if (ip6Prefix.prefixLength() != Ip6Prefix.MAX_MASK_LENGTH) {
                    Ip6Address maskAddr = Ip6Address.makeMaskPrefix(ip6Prefix.prefixLength());
                    Masked<IPv6Address> maskedIp = Masked.of(IPv6Address.of(ip6Prefix.address().toString()), IPv6Address.of(maskAddr.toString()));
                    mBuilder.setMasked(MatchField.IPV6_SRC, maskedIp);
                } else {
                    mBuilder.setExact(MatchField.IPV6_SRC, IPv6Address.of(ip6Prefix.address().toString()));
                }
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case ICMPV4_CODE:
            case ICMPV4_TYPE:
            case ICMPV6_CODE:
            case ICMPV6_TYPE:
            case IN_PHY_PORT:
            case IPV6_EXTHDR:
            case IPV6_FLABEL:
            case IPV6_ND_SLL:
            case IPV6_ND_TARGET:
            case IPV6_ND_TLL:
            case IP_DSCP:
            case IP_ECN:
            case METADATA:
            case MPLS_BOS:
            case MPLS_TC:
            case PBB_ISID:
            case SCTP_DST:
            case SCTP_SRC:
            case TUNNEL_ID:
            case UDP_DST:
            case UDP_SRC:
            default:
                log.warn("Match type {} not yet implemented.", c.type());
        }
    }
    return mBuilder.build();
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInport(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case ETH_SRC:
                MacAddress sMac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(sMac);
                break;
            case ETH_DST:
                MacAddress dMac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(dMac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case IPV4_DST:
                Ip4Prefix dip;
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    dip = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    dip = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(dip);
                break;
            case IPV4_SRC:
                Ip4Prefix sip;
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    sip = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    sip = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(sip);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case VLAN_VID:
                VlanId vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                builder.matchVlanId(vlanId);
                break;
            case TCP_DST:
                builder.matchTcpDst((short) match.get(MatchField.TCP_DST).getPort());
                break;
            case TCP_SRC:
                builder.matchTcpSrc((short) match.get(MatchField.TCP_SRC).getPort());
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue());
                break;
            case OCH_SIGID:
                builder.matchLambda(match.get(MatchField.OCH_SIGID).getChannelNumber());
                break;
            case OCH_SIGTYPE:
                builder.matchOpticalSignalType(match.get(MatchField.OCH_SIGTYPE).getValue());
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case ICMPV4_CODE:
            case ICMPV4_TYPE:
            case ICMPV6_CODE:
            case ICMPV6_TYPE:
            case IN_PHY_PORT:
            case IPV6_DST:
                Ip6Prefix dipv6;
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    dipv6 = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    dipv6 = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(dipv6);
                break;
            case IPV6_FLABEL:
            case IPV6_ND_SLL:
            case IPV6_ND_TARGET:
            case IPV6_ND_TLL:
            case IPV6_SRC:
                Ip6Prefix sipv6;
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    sipv6 = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    sipv6 = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(sipv6);
                break;
            case IP_DSCP:
            case IP_ECN:
            case METADATA:
            case MPLS_TC:
            case SCTP_DST:
            case SCTP_SRC:
            case TUNNEL_ID:
            case UDP_DST:
            case UDP_SRC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInport(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case ETH_SRC:
                MacAddress sMac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                builder.matchEthSrc(sMac);
                break;
            case ETH_DST:
                MacAddress dMac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                builder.matchEthDst(dMac);
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case IPV4_DST:
                Ip4Prefix dip;
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    dip = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    dip = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(dip);
                break;
            case IPV4_SRC:
                Ip4Prefix sip;
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    sip = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    sip = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(sip);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case VLAN_VID:
                VlanId vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                builder.matchVlanId(vlanId);
                break;
            case TCP_DST:
                builder.matchTcpDst((short) match.get(MatchField.TCP_DST).getPort());
                break;
            case TCP_SRC:
                builder.matchTcpSrc((short) match.get(MatchField.TCP_SRC).getPort());
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue());
                break;
            case OCH_SIGID:
                builder.matchLambda(match.get(MatchField.OCH_SIGID).getChannelNumber());
                break;
            case OCH_SIGTYPE:
                builder.matchOpticalSignalType(match.get(MatchField.OCH_SIGTYPE).getValue());
                break;
            case IPV6_DST:
                Ip6Prefix dipv6;
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    dipv6 = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    dipv6 = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(dipv6);
                break;
            case IPV6_SRC:
                Ip6Prefix sipv6;
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    sipv6 = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    sipv6 = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(sipv6);
                break;
            case ARP_OP:
            case ARP_SHA:
            case ARP_SPA:
            case ARP_THA:
            case ARP_TPA:
            case ICMPV4_CODE:
            case ICMPV4_TYPE:
            case ICMPV6_CODE:
            case ICMPV6_TYPE:
            case IN_PHY_PORT:
            case IPV6_FLABEL:
            case IPV6_ND_SLL:
            case IPV6_ND_TARGET:
            case IPV6_ND_TLL:
            case IP_DSCP:
            case IP_ECN:
            case METADATA:
            case MPLS_TC:
            case SCTP_DST:
            case SCTP_SRC:
            case TUNNEL_ID:
            case UDP_DST:
            case UDP_SRC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
private void installRule(PacketContext context, PortNumber portNumber) {
    // We don't yet support bufferids in the flowservice so packet out first.
    packetOut(context, portNumber);
    if (!packetOutOnly) {
        // Install the flow rule to handle this type of message from now on.
        Ethernet inPkt = context.inPacket().parsed();
        if (inPkt == null) {
            return;
        }
        TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
        builder.matchEthType(inPkt.getEtherType()).matchEthSrc(inPkt.getSourceMAC()).matchEthDst(inPkt.getDestinationMAC()).matchInport(context.inPacket().receivedFrom().port());
        TrafficTreatment.Builder treat = DefaultTrafficTreatment.builder();
        treat.setOutput(portNumber);
        FlowRule f = new DefaultFlowRule(context.inPacket().receivedFrom().deviceId(), builder.build(), treat.build(), PRIORITY, appId, TIMEOUT, false);
        flowRuleService.applyFlowRules(f);
    }
}
#method_after
private void installRule(PacketContext context, PortNumber portNumber) {
    // We don't yet support bufferids in the flowservice so packet out first.
    packetOut(context, portNumber);
    if (!packetOutOnly) {
        // Install the flow rule to handle this type of message from now on.
        Ethernet inPkt = context.inPacket().parsed();
        TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
        builder.matchEthType(inPkt.getEtherType()).matchEthSrc(inPkt.getSourceMAC()).matchEthDst(inPkt.getDestinationMAC()).matchInport(context.inPacket().receivedFrom().port());
        TrafficTreatment.Builder treat = DefaultTrafficTreatment.builder();
        treat.setOutput(portNumber);
        FlowRule f = new DefaultFlowRule(context.inPacket().receivedFrom().deviceId(), builder.build(), treat.build(), PRIORITY, appId, TIMEOUT, false);
        flowRuleService.applyFlowRules(f);
    }
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int headerLength = 2 + options.length;
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[headerLength + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put(this.headerExtLength);
    bb.put(this.options, 0, options.length);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(this.type);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int headerLength = FIXED_HEADER_LENGTH + options.length;
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[headerLength + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put(this.headerExtLength);
    bb.put(this.options, 0, options.length);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(this.type);
    }
    return data;
}
#end_block

#method_before
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.nextHeader = bb.get();
    this.headerExtLength = bb.get();
    int optionLength = 6 + 8 * this.headerExtLength;
    this.options = new byte[optionLength];
    bb.get(this.options, 0, optionLength);
    IPacket payload;
    if (IPv6.PROTOCOL_CLASS_MAP.containsKey(this.nextHeader)) {
        final Class<? extends IPacket> clazz = IPv6.PROTOCOL_CLASS_MAP.get(this.nextHeader);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for BaseOptions packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#method_after
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.nextHeader = bb.get();
    this.headerExtLength = bb.get();
    int optionLength = FIXED_OPTIONS_LENGTH + LENGTH_UNIT * this.headerExtLength;
    this.options = new byte[optionLength];
    bb.get(this.options, 0, optionLength);
    IPacket payload;
    if (IPv6.PROTOCOL_CLASS_MAP.containsKey(this.nextHeader)) {
        final Class<? extends IPacket> clazz = IPv6.PROTOCOL_CLASS_MAP.get(this.nextHeader);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for BaseOptions packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#end_block

#method_before
/*
     * The remaining fields including payload, padding length and next header
     * are encrypted and considered as the payload of ESP.
     */
public int getSecurityParamIndex() {
    return this.securityParamIndex;
}
#method_after
// 
// NOTE: The remaining fields including payload data, padding length and
// next header are encrypted and all considered as a payload of ESP.
// 
public int getSecurityParamIndex() {
    return this.securityParamIndex;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.putInt(this.securityParamIndex);
    bb.putInt(this.sequence);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_ESP);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.putInt(this.securityParamIndex);
    bb.putInt(this.sequence);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_ESP);
    }
    return data;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int headerLength = 4 + routingData.length;
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[headerLength + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put(this.headerExtLength);
    bb.put(this.routingType);
    bb.put(this.segmentsLeft);
    bb.put(this.routingData, 0, routingData.length);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_ROUTING);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int headerLength = FIXED_HEADER_LENGTH + routingData.length;
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[headerLength + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put(this.headerExtLength);
    bb.put(this.routingType);
    bb.put(this.segmentsLeft);
    bb.put(this.routingData, 0, routingData.length);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_ROUTING);
    }
    return data;
}
#end_block

#method_before
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.nextHeader = bb.get();
    this.headerExtLength = bb.get();
    this.routingType = bb.get();
    this.segmentsLeft = bb.get();
    int dataLength = 4 + 8 * this.headerExtLength;
    this.routingData = new byte[dataLength];
    bb.get(this.routingData, 0, dataLength);
    IPacket payload;
    if (IPv6.PROTOCOL_CLASS_MAP.containsKey(this.nextHeader)) {
        final Class<? extends IPacket> clazz = IPv6.PROTOCOL_CLASS_MAP.get(this.nextHeader);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for Routing packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#method_after
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.nextHeader = bb.get();
    this.headerExtLength = bb.get();
    this.routingType = bb.get();
    this.segmentsLeft = bb.get();
    int dataLength = FIXED_ROUTING_DATA_LENGTH + LENGTH_UNIT * this.headerExtLength;
    this.routingData = new byte[dataLength];
    bb.get(this.routingData, 0, dataLength);
    IPacket payload;
    if (IPv6.PROTOCOL_CLASS_MAP.containsKey(this.nextHeader)) {
        final Class<? extends IPacket> clazz = IPv6.PROTOCOL_CLASS_MAP.get(this.nextHeader);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for Routing packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int headerLength = 12 + integrityCheck.length;
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[headerLength + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put(this.payloadLength);
    bb.putShort((short) 0);
    bb.putInt(this.securityParamIndex);
    bb.putInt(this.sequence);
    bb.put(this.integrityCheck, 0, integrityCheck.length);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_AH);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int headerLength = FIXED_HEADER_LENGTH + integrityCheck.length;
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[headerLength + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put(this.payloadLength);
    bb.putShort((short) 0);
    bb.putInt(this.securityParamIndex);
    bb.putInt(this.sequence);
    bb.put(this.integrityCheck, 0, integrityCheck.length);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_AH);
    }
    return data;
}
#end_block

#method_before
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.nextHeader = bb.get();
    this.payloadLength = bb.get();
    bb.getShort();
    this.securityParamIndex = bb.getInt();
    this.sequence = bb.getInt();
    int icvLength = (this.payloadLength + 2) * 4 - 12;
    this.integrityCheck = new byte[icvLength];
    bb.get(this.integrityCheck, 0, icvLength);
    IPacket payload;
    if (IPv6.PROTOCOL_CLASS_MAP.containsKey(this.nextHeader)) {
        final Class<? extends IPacket> clazz = IPv6.PROTOCOL_CLASS_MAP.get(this.nextHeader);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for Authentication packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#method_after
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.nextHeader = bb.get();
    this.payloadLength = bb.get();
    bb.getShort();
    this.securityParamIndex = bb.getInt();
    this.sequence = bb.getInt();
    int icvLength = getTotalLength() - FIXED_HEADER_LENGTH;
    this.integrityCheck = new byte[icvLength];
    bb.get(this.integrityCheck, 0, icvLength);
    IPacket payload;
    if (IPv6.PROTOCOL_CLASS_MAP.containsKey(this.nextHeader)) {
        final Class<? extends IPacket> clazz = IPv6.PROTOCOL_CLASS_MAP.get(this.nextHeader);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for Authentication packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put((byte) 0);
    bb.putShort((short) ((this.fragmentOffset & 0x1fff) << 3 | this.moreFragment & 0x1));
    bb.putInt(this.identification);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_FRAG);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = 0;
    if (payloadData != null) {
        payloadLength = payloadData.length;
    }
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.nextHeader);
    bb.put((byte) 0);
    bb.putShort((short) ((this.fragmentOffset & 0x1fff) << 3 | this.moreFragment & 0x1));
    bb.putInt(this.identification);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    if (this.parent != null && this.parent instanceof IExtensionHeader) {
        ((IExtensionHeader) this.parent).setNextHeader(IPv6.PROTOCOL_FRAG);
    }
    return data;
}
#end_block

#method_before
private void retry() {
    log.debug("Execution timed out, retrying.");
    if (future.cancel(true)) {
        // cancel success; batch is reverted
        // reset the timer
        resetTimeoutLimit();
        installAttempt++;
        if (installAttempt == maxAttemps) {
            log.warn("Install request timed out: {}", ops);
            for (IntentUpdate update : intentUpdates) {
                update.batchFailed();
            }
        } else if (installAttempt > maxAttemps) {
            abandonShip();
            return;
        }
        // else just resubmit the work
        future = applyNextBatch();
        executor.submit(this);
    } else {
        log.error("Cancelling FlowRuleBatch failed.");
        // FIXME
        // cancel failed... batch is broken; shouldn't happen!
        // we could manually reverse everything
        // ... or just core dump and send email to Ali
        abandonShip();
    }
}
#method_after
private void retry() {
    log.debug("Execution timed out, retrying.");
    if (future.cancel(true)) {
        // cancel success; batch is reverted
        // reset the timer
        resetTimeoutLimit();
        installAttempt++;
        if (installAttempt == maxAttempts) {
            log.warn("Install request timed out: {}", ops);
            for (IntentUpdate update : intentUpdates) {
                update.batchFailed();
            }
        } else if (installAttempt > maxAttempts) {
            abandonShip();
            return;
        }
        // else just resubmit the work
        future = applyNextBatch();
        executor.submit(this);
    } else {
        log.error("Cancelling FlowRuleBatch failed.");
        // FIXME
        // cancel failed... batch is broken; shouldn't happen!
        // we could manually reverse everything
        // ... or just core dump and send email to Ali
        abandonShip();
    }
}
#end_block

#method_before
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.currentHopLimit);
    bb.put((byte) ((this.mFlag & 0x1) << 7 | (this.oFlag & 0x1) << 6));
    bb.putShort(routerLifetime);
    bb.putInt(reachableTime);
    bb.putInt(retransTimer);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    return data;
}
#method_after
@Override
public byte[] serialize() {
    byte[] payloadData = null;
    if (this.payload != null) {
        this.payload.setParent(this);
        payloadData = this.payload.serialize();
    }
    int payloadLength = payloadData == null ? 0 : (short) payloadData.length;
    final byte[] data = new byte[HEADER_LENGTH + payloadLength];
    final ByteBuffer bb = ByteBuffer.wrap(data);
    bb.put(this.currentHopLimit);
    bb.put((byte) ((this.mFlag & 0x1) << 7 | (this.oFlag & 0x1) << 6));
    bb.putShort(routerLifetime);
    bb.putInt(reachableTime);
    bb.putInt(retransmitTimer);
    if (payloadData != null) {
        bb.put(payloadData);
    }
    return data;
}
#end_block

#method_before
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    int bscratch;
    this.currentHopLimit = bb.get();
    bscratch = bb.get();
    this.mFlag = (byte) ((bscratch >> 7) & 0x1);
    this.oFlag = (byte) ((bscratch >> 6) & 0x1);
    this.routerLifetime = bb.getShort();
    this.reachableTime = bb.getInt();
    this.retransTimer = bb.getInt();
    this.payload = new Data();
    this.payload = this.payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#method_after
@Override
public IPacket deserialize(byte[] data, int offset, int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    int bscratch;
    this.currentHopLimit = bb.get();
    bscratch = bb.get();
    this.mFlag = (byte) ((bscratch >> 7) & 0x1);
    this.oFlag = (byte) ((bscratch >> 6) & 0x1);
    this.routerLifetime = bb.getShort();
    this.reachableTime = bb.getInt();
    this.retransmitTimer = bb.getInt();
    this.payload = new Data();
    this.payload = this.payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 5807;
    int result = super.hashCode();
    result = prime * result + this.currentHopLimit;
    result = prime * result + this.mFlag;
    result = prime * result + this.oFlag;
    result = prime * result + this.routerLifetime;
    result = prime * result + this.reachableTime;
    result = prime * result + this.retransTimer;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 5807;
    int result = super.hashCode();
    result = prime * result + this.currentHopLimit;
    result = prime * result + this.mFlag;
    result = prime * result + this.oFlag;
    result = prime * result + this.routerLifetime;
    result = prime * result + this.reachableTime;
    result = prime * result + this.retransmitTimer;
    return result;
}
#end_block

#method_before
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof RouterAdvertisement)) {
        return false;
    }
    final RouterAdvertisement other = (RouterAdvertisement) obj;
    if (this.currentHopLimit != other.currentHopLimit) {
        return false;
    }
    if (this.mFlag != other.mFlag) {
        return false;
    }
    if (this.oFlag != other.oFlag) {
        return false;
    }
    if (this.routerLifetime != other.routerLifetime) {
        return false;
    }
    if (this.reachableTime != other.reachableTime) {
        return false;
    }
    if (this.retransTimer != other.retransTimer) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(final Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof RouterAdvertisement)) {
        return false;
    }
    final RouterAdvertisement other = (RouterAdvertisement) obj;
    if (this.currentHopLimit != other.currentHopLimit) {
        return false;
    }
    if (this.mFlag != other.mFlag) {
        return false;
    }
    if (this.oFlag != other.oFlag) {
        return false;
    }
    if (this.routerLifetime != other.routerLifetime) {
        return false;
    }
    if (this.reachableTime != other.reachableTime) {
        return false;
    }
    if (this.retransmitTimer != other.retransmitTimer) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Test
public void testSerialize() {
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.setCurrentHopLimit((byte) 3);
    ra.setMFlag((byte) 1);
    ra.setOFlag((byte) 1);
    ra.setRouterLifetime((short) 0x258);
    ra.setReachableTime(0x3e8);
    ra.setRetransTimer(0x1f4);
    ra.setPayload(data);
    assertArrayEquals(ra.serialize(), bytePacket);
}
#method_after
@Test
public void testSerialize() {
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.setCurrentHopLimit((byte) 3);
    ra.setMFlag((byte) 1);
    ra.setOFlag((byte) 1);
    ra.setRouterLifetime((short) 0x258);
    ra.setReachableTime(0x3e8);
    ra.setRetransmitTimer(0x1f4);
    ra.setPayload(data);
    assertArrayEquals(ra.serialize(), bytePacket);
}
#end_block

#method_before
@Test
public void testDeserialize() {
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.deserialize(bytePacket, 0, bytePacket.length);
    assertThat(ra.getCurrentHopLimit(), is((byte) 3));
    assertThat(ra.getMFlag(), is((byte) 1));
    assertThat(ra.getOFlag(), is((byte) 1));
    assertThat(ra.getRouterLifetime(), is((short) 0x258));
    assertThat(ra.getReachableTime(), is(0x3e8));
    assertThat(ra.getRetransTimer(), is(0x1f4));
}
#method_after
@Test
public void testDeserialize() {
    RouterAdvertisement ra = new RouterAdvertisement();
    ra.deserialize(bytePacket, 0, bytePacket.length);
    assertThat(ra.getCurrentHopLimit(), is((byte) 3));
    assertThat(ra.getMFlag(), is((byte) 1));
    assertThat(ra.getOFlag(), is((byte) 1));
    assertThat(ra.getRouterLifetime(), is((short) 0x258));
    assertThat(ra.getReachableTime(), is(0x3e8));
    assertThat(ra.getRetransmitTimer(), is(0x1f4));
}
#end_block

#method_before
@Test
public void testEqual() {
    RouterAdvertisement ra1 = new RouterAdvertisement();
    ra1.setCurrentHopLimit((byte) 3);
    ra1.setMFlag((byte) 1);
    ra1.setOFlag((byte) 1);
    ra1.setRouterLifetime((short) 0x258);
    ra1.setReachableTime(0x3e8);
    ra1.setRetransTimer(0x1f4);
    RouterAdvertisement ra2 = new RouterAdvertisement();
    ra2.setCurrentHopLimit((byte) 3);
    ra2.setMFlag((byte) 0);
    ra2.setOFlag((byte) 0);
    ra2.setRouterLifetime((short) 0x1f4);
    ra2.setReachableTime(0x3e8);
    ra2.setRetransTimer(0x1f4);
    assertTrue(ra1.equals(ra1));
    assertFalse(ra1.equals(ra2));
}
#method_after
@Test
public void testEqual() {
    RouterAdvertisement ra1 = new RouterAdvertisement();
    ra1.setCurrentHopLimit((byte) 3);
    ra1.setMFlag((byte) 1);
    ra1.setOFlag((byte) 1);
    ra1.setRouterLifetime((short) 0x258);
    ra1.setReachableTime(0x3e8);
    ra1.setRetransmitTimer(0x1f4);
    RouterAdvertisement ra2 = new RouterAdvertisement();
    ra2.setCurrentHopLimit((byte) 3);
    ra2.setMFlag((byte) 0);
    ra2.setOFlag((byte) 0);
    ra2.setRouterLifetime((short) 0x1f4);
    ra2.setReachableTime(0x3e8);
    ra2.setRetransmitTimer(0x1f4);
    assertTrue(ra1.equals(ra1));
    assertFalse(ra1.equals(ra2));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context == null) {
        return;
    }
    Ethernet eth = context.inPacket().parsed();
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    ConnectPoint heardOn = context.inPacket().receivedFrom();
    // If this is not an edge port, bail out.
    Topology topology = topologyService.currentTopology();
    if (topologyService.isInfrastructure(topology, heardOn)) {
        return;
    }
    HostLocation hloc = new HostLocation(heardOn, System.currentTimeMillis());
    HostId hid = HostId.hostId(eth.getSourceMAC(), vlan);
    // ARP: possible new hosts, update both location and IP
    if (eth.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arp = (ARP) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET, arp.getSenderProtocolAddress());
        HostDescription hdescr = new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc, ip);
        providerService.hostDetected(hid, hdescr);
    // IPv4: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV4) {
        HostDescription hdescr = new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc);
        providerService.hostDetected(hid, hdescr);
    // NeighborAdvertisement and NeighborSolicitation: possible new hosts, update both location and IP
    // IPv6: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV6) {
        IpAddress ip = null;
        IPacket payload = eth.getPayload();
        while (payload != null) {
            if (payload instanceof NeighborAdvertisement || payload instanceof NeighborSolicitation) {
                byte[] sourceAddress = ((IPv6) eth.getPayload()).getSourceAddress();
                // Ignore DAD packets, in which source address is all zeros.
                for (byte b : sourceAddress) {
                    if (b != 0) {
                        ip = IpAddress.valueOf(IpAddress.Version.INET6, sourceAddress);
                        break;
                    }
                }
            }
            payload = payload.getPayload();
        }
        HostDescription hdescr = (ip == null) ? new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc) : new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc, ip);
        providerService.hostDetected(hid, hdescr);
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context == null) {
        return;
    }
    Ethernet eth = context.inPacket().parsed();
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    ConnectPoint heardOn = context.inPacket().receivedFrom();
    // If this is not an edge port, bail out.
    Topology topology = topologyService.currentTopology();
    if (topologyService.isInfrastructure(topology, heardOn)) {
        return;
    }
    HostLocation hloc = new HostLocation(heardOn, System.currentTimeMillis());
    HostId hid = HostId.hostId(eth.getSourceMAC(), vlan);
    // ARP: possible new hosts, update both location and IP
    if (eth.getEtherType() == Ethernet.TYPE_ARP) {
        ARP arp = (ARP) eth.getPayload();
        IpAddress ip = IpAddress.valueOf(IpAddress.Version.INET, arp.getSenderProtocolAddress());
        HostDescription hdescr = new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc, ip);
        providerService.hostDetected(hid, hdescr);
    // IPv4: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV4) {
        HostDescription hdescr = new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc);
        providerService.hostDetected(hid, hdescr);
    // NeighborAdvertisement and NeighborSolicitation: possible new hosts, update both location and IP
    // IPv6: update location only
    } else if (eth.getEtherType() == Ethernet.TYPE_IPV6) {
        IpAddress ip = null;
        IPv6 ipv6 = (IPv6) eth.getPayload();
        IPacket iPkt = ipv6;
        while (iPkt != null) {
            if (iPkt instanceof NeighborAdvertisement || iPkt instanceof NeighborSolicitation) {
                IpAddress sourceAddress = IpAddress.valueOf(IpAddress.Version.INET6, ipv6.getSourceAddress());
                // Ignore DAD packets, in which source address is all zeros.
                if (!sourceAddress.isZero()) {
                    ip = sourceAddress;
                    break;
                }
            }
            iPkt = iPkt.getPayload();
        }
        HostDescription hdescr = (ip == null) ? new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc) : new DefaultHostDescription(eth.getSourceMAC(), vlan, hloc, ip);
        providerService.hostDetected(hid, hdescr);
    }
}
#end_block

#method_before
private boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    boolean enabled = false;
    try {
        String flag = (String) properties.get(propertyName);
        if (flag != null) {
            enabled = flag.equals("true");
        }
    } catch (Exception e) {
        // No propertyName defined.
        log.debug("No property {} is found in configuration", propertyName);
    }
    return enabled;
}
#method_after
private static boolean isPropertyEnabled(Dictionary<?, ?> properties, String propertyName) {
    boolean enabled = false;
    try {
        String flag = (String) properties.get(propertyName);
        if (flag != null) {
            enabled = flag.equals("true");
        }
    } catch (ClassCastException e) {
        // No propertyName defined.
        enabled = false;
    }
    return enabled;
}
#end_block

#method_before
@Override
public Set<Link> getEgressLinks(ConnectPoint src) {
    Set<Link> egress = new HashSet<>();
    for (LinkKey linkKey : srcLinks.get(src.deviceId())) {
        if (linkKey.src().equals(src)) {
            Link link = links.get(linkKey);
            if (link != null) {
                egress.add(link);
            } else {
                log.info("Egress link was null, skipped");
            }
        }
    }
    return egress;
}
#method_after
@Override
public Set<Link> getEgressLinks(ConnectPoint src) {
    Set<Link> egress = new HashSet<>();
    for (LinkKey linkKey : srcLinks.get(src.deviceId())) {
        if (linkKey.src().equals(src)) {
            Link link = links.get(linkKey);
            if (link != null) {
                egress.add(link);
            } else {
                log.debug("Egress link for {} was null, skipped", linkKey);
            }
        }
    }
    return egress;
}
#end_block

#method_before
@Override
public Set<Link> getIngressLinks(ConnectPoint dst) {
    Set<Link> ingress = new HashSet<>();
    for (LinkKey linkKey : dstLinks.get(dst.deviceId())) {
        if (linkKey.dst().equals(dst)) {
            Link link = links.get(linkKey);
            if (link != null) {
                ingress.add(link);
            } else {
                log.info("Ingress link was null, skipped");
            }
        }
    }
    return ingress;
}
#method_after
@Override
public Set<Link> getIngressLinks(ConnectPoint dst) {
    Set<Link> ingress = new HashSet<>();
    for (LinkKey linkKey : dstLinks.get(dst.deviceId())) {
        if (linkKey.dst().equals(dst)) {
            Link link = links.get(linkKey);
            if (link != null) {
                ingress.add(link);
            } else {
                log.debug("Ingress link for {} was null, skipped", linkKey);
            }
        }
    }
    return ingress;
}
#end_block

#method_before
private SQueue<IntentOperations> getQueue(ApplicationId appId) {
    SQueue<IntentOperations> queue = batchQueues.get(appId);
    if (queue == null) {
        synchronized (this) {
            // FIXME how will other instances find out about new queues
            String topic = getTopic(appId);
            IQueue<byte[]> rawQueue = theInstance.getQueue("intent-states");
            queue = new SQueue<>(rawQueue, serializer);
            batchQueues.putIfAbsent(appId, queue);
            // TODO others should run for leadership when they hear about this topic
            leadershipService.runForLeadership(topic);
        }
    }
    return queue;
}
#method_after
private SQueue<IntentOperations> getQueue(ApplicationId appId) {
    SQueue<IntentOperations> queue = batchQueues.get(appId);
    if (queue == null) {
        synchronized (this) {
            // FIXME how will other instances find out about new queues
            String topic = getTopic(appId);
            IQueue<byte[]> rawQueue = theInstance.getQueue(topic);
            queue = new SQueue<>(rawQueue, serializer);
            batchQueues.putIfAbsent(appId, queue);
            // TODO others should run for leadership when they hear about this topic
            leadershipService.runForLeadership(topic);
        }
    }
    return queue;
}
#end_block

#method_before
private void submitIntents(List<Intent> intents) {
    IntentOperations.Builder builder = IntentOperations.builder(appId());
    for (Intent intent : intents) {
        if (add) {
            builder.addSubmitOperation(intent);
        } else {
            builder.addWithdrawOperation(intent.id());
        }
    }
    IntentOperations ops = builder.build();
    start = System.currentTimeMillis();
    service.execute(ops);
    try {
        if (latch.await(10, TimeUnit.SECONDS)) {
            printResults(count);
        } else {
            print("Failure: %d intents not installed", latch.getCount());
        }
    } catch (InterruptedException e) {
        print(e.toString());
    }
}
#method_after
private void submitIntents(List<Intent> intents) {
    IntentOperations.Builder builder = IntentOperations.builder(appId());
    for (Intent intent : intents) {
        if (add) {
            builder.addSubmitOperation(intent);
        } else {
            builder.addWithdrawOperation(intent.id());
        }
    }
    IntentOperations ops = builder.build();
    start = System.currentTimeMillis();
    service.execute(ops);
    try {
        if (latch.await(30, TimeUnit.SECONDS)) {
            printResults(count);
        } else {
            print("Failure: %d intents not installed", latch.getCount());
        }
    } catch (InterruptedException e) {
        print(e.toString());
    }
}
#end_block

#method_before
private TrafficTreatment buildTreatment() {
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    // If this is a drop rule
    if (actions.size() == 0) {
        builder.drop();
        return builder.build();
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanId(VlanId.vlanId(pcp.getVlanPcp().getValue()));
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    builder.setLambda(((OFOxmOchSigidBasic) ct.getField()).getValue().getChannelNumber());
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_MPLS:
            case POP_PBB:
            case POP_VLAN:
            case PUSH_MPLS:
            case PUSH_PBB:
            case PUSH_VLAN:
            case SET_FIELD:
                // TODO handle 1.3 set field actions correctly
                break;
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            case SET_QUEUE:
            case STRIP_VLAN:
            case COPY_TTL_IN:
            case COPY_TTL_OUT:
            case DEC_MPLS_TTL:
            case DEC_NW_TTL:
            case ENQUEUE:
            case GROUP:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder.build();
}
#method_after
private TrafficTreatment buildTreatment() {
    TrafficTreatment.Builder builder = DefaultTrafficTreatment.builder();
    // If this is a drop rule
    if (actions.size() == 0) {
        builder.drop();
        return builder.build();
    }
    for (OFAction act : actions) {
        switch(act.getType()) {
            case OUTPUT:
                OFActionOutput out = (OFActionOutput) act;
                builder.setOutput(PortNumber.portNumber(out.getPort().getPortNumber()));
                break;
            case SET_VLAN_VID:
                OFActionSetVlanVid vlan = (OFActionSetVlanVid) act;
                builder.setVlanId(VlanId.vlanId(vlan.getVlanVid().getVlan()));
                break;
            case SET_VLAN_PCP:
                OFActionSetVlanPcp pcp = (OFActionSetVlanPcp) act;
                builder.setVlanId(VlanId.vlanId(pcp.getVlanPcp().getValue()));
                break;
            case SET_DL_DST:
                OFActionSetDlDst dldst = (OFActionSetDlDst) act;
                builder.setEthDst(MacAddress.valueOf(dldst.getDlAddr().getLong()));
                break;
            case SET_DL_SRC:
                OFActionSetDlSrc dlsrc = (OFActionSetDlSrc) act;
                builder.setEthSrc(MacAddress.valueOf(dlsrc.getDlAddr().getLong()));
                break;
            case SET_NW_DST:
                OFActionSetNwDst nwdst = (OFActionSetNwDst) act;
                IPv4Address di = nwdst.getNwAddr();
                builder.setIpDst(Ip4Address.valueOf(di.getInt()));
                break;
            case SET_NW_SRC:
                OFActionSetNwSrc nwsrc = (OFActionSetNwSrc) act;
                IPv4Address si = nwsrc.getNwAddr();
                builder.setIpSrc(Ip4Address.valueOf(si.getInt()));
                break;
            case EXPERIMENTER:
                OFActionExperimenter exp = (OFActionExperimenter) act;
                if (exp.getExperimenter() == 0x80005A06) {
                    OFActionCircuit ct = (OFActionCircuit) exp;
                    builder.setLambda(((OFOxmOchSigidBasic) ct.getField()).getValue().getChannelNumber());
                } else {
                    log.warn("Unsupported OFActionExperimenter {}", exp.getExperimenter());
                }
                break;
            case SET_FIELD:
                // TODO handle 1.3 set field actions correctly
                break;
            case SET_TP_DST:
            case SET_TP_SRC:
            case POP_MPLS:
            case POP_PBB:
            case POP_VLAN:
            case PUSH_MPLS:
            case PUSH_PBB:
            case PUSH_VLAN:
            case SET_MPLS_LABEL:
            case SET_MPLS_TC:
            case SET_MPLS_TTL:
            case SET_NW_ECN:
            case SET_NW_TOS:
            case SET_NW_TTL:
            case SET_QUEUE:
            case STRIP_VLAN:
            case COPY_TTL_IN:
            case COPY_TTL_OUT:
            case DEC_MPLS_TTL:
            case DEC_NW_TTL:
            case ENQUEUE:
            case GROUP:
            default:
                log.warn("Action type {} not yet implemented.", act.getType());
        }
    }
    return builder.build();
}
#end_block

#method_before
@Override
public short id() {
    return 0;
}
#method_after
@Override
public int id() {
    return 0;
}
#end_block

#method_before
@Override
public Load load(Link link, ApplicationId appId, Optional<GroupId> groupId) {
    Statistics stats = getStatistics(link.src());
    FluentIterable.from(stats.current()).filter(hasApplicationId(appId)).filter(hasGroupId(groupId)).toSet();
    FluentIterable.from(stats.previous()).filter(hasApplicationId(appId)).filter(hasGroupId(groupId)).toSet();
    return new DefaultLoad(aggregate(stats.current()), aggregate(stats.previous()));
}
#method_after
@Override
public Load load(Link link, ApplicationId appId, Optional<GroupId> groupId) {
    Statistics stats = getStatistics(link.src());
    if (!stats.isValid()) {
        return new DefaultLoad();
    }
    ImmutableSet<FlowEntry> current = FluentIterable.from(stats.current()).filter(hasApplicationId(appId)).filter(hasGroupId(groupId)).toSet();
    ImmutableSet<FlowEntry> previous = FluentIterable.from(stats.previous()).filter(hasApplicationId(appId)).filter(hasGroupId(groupId)).toSet();
    return new DefaultLoad(aggregate(current), aggregate(previous));
}
#end_block

#method_before
private long aggregate(Set<FlowEntry> values) {
    long sum = 0;
    for (FlowEntry f : values) {
        sum += f.bytes();
    }
    return sum;
}
#method_after
// TODO: make aggregation function generic by passing a function
// (applying Java 8 Stream API?)
private long aggregate(Set<FlowEntry> values) {
    long sum = 0;
    for (FlowEntry f : values) {
        sum += f.bytes();
    }
    return sum;
}
#end_block

#method_before
private static Predicate<FlowEntry> hasGroupId(Optional<GroupId> groupId) {
    return new Predicate<FlowEntry>() {

        @Override
        public boolean apply(FlowEntry flowEntry) {
            if (!groupId.isPresent()) {
                return false;
            }
            return flowEntry.groupId() == groupId.get().id();
        }
    };
}
#method_after
private static Predicate<FlowEntry> hasGroupId(Optional<GroupId> groupId) {
    return new Predicate<FlowEntry>() {

        @Override
        public boolean apply(FlowEntry flowEntry) {
            if (!groupId.isPresent()) {
                return false;
            }
            // FlowEntry.groupId() still returns a short value, not int.
            return flowEntry.groupId() == groupId.get().id();
        }
    };
}
#end_block

#method_before
@Activate
public void activate() {
    store.setDelegate(delegate);
    trackerService.setDelegate(topoDelegate);
    batchService.setDelegate(batchDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    executor = newSingleThreadExecutor(namedThreads("onos-intents"));
    monitorExecutor = newSingleThreadExecutor(namedThreads("onos-intent-monitor"));
    final InternalResourceListener resourceListener = new InternalResourceListener();
    resourceStore.addListener(resourceListener);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    store.setDelegate(delegate);
    trackerService.setDelegate(topoDelegate);
    batchService.setDelegate(batchDelegate);
    eventDispatcher.addSink(IntentEvent.class, listenerRegistry);
    executor = newSingleThreadExecutor(namedThreads("onos-intents"));
    monitorExecutor = newSingleThreadExecutor(namedThreads("onos-intent-monitor"));
    idGenerator = coreService.getIdGenerator("intent-ids");
    Intent.bindIdGenerator(idGenerator);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    store.unsetDelegate(delegate);
    trackerService.unsetDelegate(topoDelegate);
    batchService.unsetDelegate(batchDelegate);
    eventDispatcher.removeSink(IntentEvent.class);
    executor.shutdown();
    monitorExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    store.unsetDelegate(delegate);
    trackerService.unsetDelegate(topoDelegate);
    batchService.unsetDelegate(batchDelegate);
    eventDispatcher.removeSink(IntentEvent.class);
    executor.shutdown();
    monitorExecutor.shutdown();
    Intent.unbindIdGenerator(idGenerator);
    log.info("Stopped");
}
#end_block

#method_before
private void executeInstallingPhase(IntentUpdate update) {
    if (update.newInstallables() == null) {
        // no failed intents allowed past this point...
        return;
    }
    // Indicate that the intent is entering the installing phase.
    update.setState(update.newIntent(), INSTALLING);
    List<FlowRuleBatchOperation> batches = Lists.newArrayList();
    for (Intent installable : update.newInstallables()) {
        registerSubclassInstallerIfNeeded(installable);
        trackerService.addTrackedResources(update.newIntent().id(), installable.resources());
        try {
            batches.addAll(getInstaller(installable).install(installable));
        } catch (IntentException e) {
            log.warn("Unable to install intent {} due to:", update.newIntent().id(), e);
        // FIXME we failed... intent should be recompiled
        // TODO: remove resources
        // recompile!!!
        }
    }
    update.setBatches(batches);
}
#method_after
private void executeInstallingPhase(IntentUpdate update) {
    if (update.newInstallables() == null) {
        // no failed intents allowed past this point...
        return;
    }
    // Indicate that the intent is entering the installing phase.
    update.setState(update.newIntent(), INSTALLING);
    List<FlowRuleBatchOperation> batches = Lists.newArrayList();
    for (Intent installable : update.newInstallables()) {
        registerSubclassInstallerIfNeeded(installable);
        trackerService.addTrackedResources(update.newIntent().id(), installable.resources());
        try {
            batches.addAll(getInstaller(installable).install(installable));
        } catch (IntentException e) {
            log.warn("Unable to install intent {} due to:", update.newIntent().id(), e);
            trackerService.removeTrackedResources(update.newIntent().id(), installable.resources());
        // FIXME we failed... intent should be recompiled
        }
    }
    update.addBatches(batches);
}
#end_block

#method_before
private void executeWithdrawingPhase(IntentUpdate update) {
    if (!update.oldIntent().equals(update.newIntent())) {
        update.setState(update.oldIntent(), WITHDRAWING);
    }
    // else newIntent is FAILED
    uninstallIntent(update);
// If all went well, disassociate the top-level intent with its
// installable derivatives and mark it as withdrawn.
// FIXME need to clean up
// store.removeInstalledIntents(intent.id());
}
#method_after
private void executeWithdrawingPhase(IntentUpdate update) {
    if (!update.oldIntent().equals(update.newIntent())) {
        update.setState(update.oldIntent(), WITHDRAWING);
    }
    // else newIntent is FAILED
    update.addBatches(uninstallIntent(update.oldIntent(), update.oldInstallables()));
}
#end_block

#method_before
/**
 * Uninstalls all installable intents associated with the given intent.
 *
 * @param update intent update
 */
private void uninstallIntent(IntentUpdate update) {
    if (update.oldInstallables == null) {
        return;
    }
    List<FlowRuleBatchOperation> batches = Lists.newArrayList();
    for (Intent installable : update.oldInstallables()) {
        trackerService.removeTrackedResources(update.oldIntent().id(), installable.resources());
        try {
            batches.addAll(getInstaller(installable).uninstall(installable));
        } catch (IntentException e) {
            log.warn("Unable to uninstall intent {} due to:", update.oldIntent().id(), e);
        // TODO: this should never happen. but what if it does?
        }
    }
    update.setBatches(batches);
// FIXME: next state for old is WITHDRAWN or FAILED
}
#method_after
private List<FlowRuleBatchOperation> uninstallIntent(Intent intent, List<Intent> installables) {
    if (installables == null) {
        return Collections.emptyList();
    }
    List<FlowRuleBatchOperation> batches = Lists.newArrayList();
    for (Intent installable : installables) {
        trackerService.removeTrackedResources(intent.id(), installable.resources());
        try {
            batches.addAll(getInstaller(installable).uninstall(installable));
        } catch (IntentException e) {
            log.warn("Unable to uninstall intent {} due to:", intent.id(), e);
        // TODO: this should never happen. but what if it does?
        }
    }
    return batches;
}
#end_block

#method_before
private void executeReplacementPhase(IntentUpdate update) {
    checkArgument(update.oldInstallables().size() == update.newInstallables().size(), "Old and New Intent must have equivalent installable intents.");
    if (!update.oldIntent().equals(update.newIntent())) {
        // only set the old intent's state if it is different
        update.setState(update.oldIntent(), WITHDRAWING);
    }
    update.setState(update.newIntent(), INSTALLING);
    List<FlowRuleBatchOperation> batches = Lists.newArrayList();
    for (int i = 0; i < update.oldInstallables().size(); i++) {
        Intent oldInstallable = update.oldInstallables().get(i);
        Intent newInstallable = update.newInstallables().get(i);
        if (oldInstallable.equals(newInstallable)) {
            continue;
        }
        checkArgument(oldInstallable.getClass().equals(newInstallable.getClass()), "Installable Intent type mismatch.");
        trackerService.removeTrackedResources(update.oldIntent().id(), oldInstallable.resources());
        trackerService.addTrackedResources(update.newIntent().id(), newInstallable.resources());
        try {
            batches.addAll(getInstaller(newInstallable).replace(oldInstallable, newInstallable));
        } catch (IntentException e) {
            log.warn("Unable to update intent {} due to:", update.oldIntent().id(), e);
        // FIXME... we failed. need to uninstall (if same) or revert (if different)
        }
    }
    update.setBatches(batches);
}
#method_after
private void executeReplacementPhase(IntentUpdate update) {
    checkArgument(update.oldInstallables().size() == update.newInstallables().size(), "Old and New Intent must have equivalent installable intents.");
    if (!update.oldIntent().equals(update.newIntent())) {
        // only set the old intent's state if it is different
        update.setState(update.oldIntent(), WITHDRAWING);
    }
    update.setState(update.newIntent(), INSTALLING);
    List<FlowRuleBatchOperation> batches = Lists.newArrayList();
    for (int i = 0; i < update.oldInstallables().size(); i++) {
        Intent oldInstallable = update.oldInstallables().get(i);
        Intent newInstallable = update.newInstallables().get(i);
        // FIXME revisit this
        // if (oldInstallable.equals(newInstallable)) {
        // continue;
        // }
        checkArgument(oldInstallable.getClass().equals(newInstallable.getClass()), "Installable Intent type mismatch.");
        trackerService.removeTrackedResources(update.oldIntent().id(), oldInstallable.resources());
        trackerService.addTrackedResources(update.newIntent().id(), newInstallable.resources());
        try {
            batches.addAll(getInstaller(newInstallable).replace(oldInstallable, newInstallable));
        } catch (IntentException e) {
            log.warn("Unable to update intent {} due to:", update.oldIntent().id(), e);
            // FIXME... we failed. need to uninstall (if same) or revert (if different)
            trackerService.removeTrackedResources(update.newIntent().id(), newInstallable.resources());
            update.setState(update.newIntent(), FAILED);
            batches = uninstallIntent(update.oldIntent(), update.oldInstallables());
        }
    }
    update.addBatches(batches);
}
#end_block

#method_before
void setState(Intent intent, IntentState newState) {
    // TODO: clean this up, or set to debug
    IntentState oldState = stateMap.get(intent);
    log.info("intent id: {}, old state: {}, new state: {}", intent.id(), oldState, newState);
    stateMap.put(intent, newState);
    IntentEvent event = store.setState(intent, newState);
    if (event != null) {
        eventDispatcher.post(event);
    }
}
#method_after
void setState(Intent intent, IntentState newState) {
    // TODO: clean this up, or set to debug
    IntentState oldState = stateMap.get(intent);
    log.debug("intent id: {}, old state: {}, new state: {}", intent.id(), oldState, newState);
    stateMap.put(intent, newState);
    IntentEvent event = store.setState(intent, newState);
    if (event != null) {
        eventDispatcher.post(event);
    }
}
#end_block

#method_before
private Future<CompletedBatchOperation> applyNextBatch() {
    if (work.isEmpty()) {
        return null;
    }
    FlowRuleBatchOperation batch = work.remove(0);
    return flowRuleService.applyBatch(batch);
}
#method_after
private Future<CompletedBatchOperation> applyNextBatch() {
    // TODO test this. (also, maybe save this batch)
    FlowRuleBatchOperation batch = new FlowRuleBatchOperation(Collections.emptyList());
    for (IntentUpdate update : intentUpdates) {
        if (!update.isComplete()) {
            batch.addAll(update.currentBatch());
        }
    }
    return (batch.size() > 0) ? flowRuleService.applyBatch(batch) : null;
}
#end_block

#method_before
private void processFutures() {
    if (future == null) {
        // FIXME look at this
        return;
    }
    try {
        CompletedBatchOperation completed = future.get(100, TimeUnit.NANOSECONDS);
        if (completed.isSuccess()) {
            future = applyNextBatch();
        } else {
            // TODO check if future succeeded and if not report fail items
            log.warn("Failed items: {}", completed.failedItems());
        // FIXME revert.... by submitting a new batch
        // uninstallIntent(intent, RECOMPILING);
        }
    } catch (TimeoutException | InterruptedException | ExecutionException te) {
        // TODO look into error message
        log.debug("Intallations of intent {} is still pending", ops);
    }
}
#method_after
private void processFutures() {
    if (future == null) {
        // FIXME look at this
        return;
    }
    try {
        CompletedBatchOperation completed = future.get(100, TimeUnit.NANOSECONDS);
        updateBatches(completed);
        future = applyNextBatch();
    } catch (TimeoutException | InterruptedException | ExecutionException te) {
        // TODO look into error message
        log.debug("Installation of intents are still pending: {}", ops);
    }
}
#end_block

#method_before
@Override
public void run() {
    processFutures();
    if (future == null) {
        // woohoo! we are done!
        updateIntents();
        batchService.removeIntentOperations(ops);
    } else if (endTime < System.currentTimeMillis()) {
        log.warn("Install request timed out");
    // future.cancel(true);
    // TODO retry and/or report the failure
    } else {
        // resubmit ourselves if we are not done yet
        monitorExecutor.submit(this);
    }
}
#method_after
@Override
public void run() {
    try {
        if (intentUpdates.isEmpty()) {
            // this should only be called on the first iteration
            // note: this a "expensive", so it is not done in the constructor
            buildIntentUpdates();
        }
        processFutures();
        if (isComplete()) {
            // there are no outstanding batches; we are done
            batchService.removeIntentOperations(ops);
        } else if (endTime < System.currentTimeMillis()) {
            retry();
        } else {
            // we are not done yet, yield the thread by resubmitting ourselves
            monitorExecutor.submit(this);
        }
    } catch (Exception e) {
        log.error("Error submitting batches:", e);
    }
}
#end_block

#method_before
@Override
public void execute(IntentOperations operations) {
    log.info("Execute operations: {}", operations);
    // FIXME: perhaps we want to track this task so that we can cancel it.
    executor.execute(new IntentTask(operations));
}
#method_after
@Override
public void execute(IntentOperations operations) {
    log.info("Execute {} operation(s).", operations.operations().size());
    log.debug("Execute operations: {}", operations.operations());
    // FIXME: perhaps we want to track this task so that we can cancel it.
    monitorExecutor.execute(new IntentInstallMonitor(operations));
}
#end_block

#method_before
@Activate
public void activate() {
    serializer = new KryoSerializer();
    Set<String> tables = null;
    int retries = 0;
    do {
        try {
            tables = databaseAdminService.listTables();
        } catch (DatabaseException e) {
            log.debug("DatabaseException", e);
            retries++;
            if (retries > 10) {
                log.error("Failed to list tables, moving on", e);
                tables = new HashSet<>();
            }
        }
    } while (tables == null);
    if (!tables.contains(LINK_RESOURCE_ALLOCATIONS)) {
        databaseAdminService.createTable(LINK_RESOURCE_ALLOCATIONS);
    }
    if (!tables.contains(INTENT_ALLOCATIONS)) {
        databaseAdminService.createTable(INTENT_ALLOCATIONS);
    }
    eventDispatcher.addSink(LinkResourceEvent.class, listenerRegistry);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    serializer = new KryoSerializer();
    createTable(LINK_RESOURCE_ALLOCATIONS);
    createTable(INTENT_ALLOCATIONS);
    log.info("Started");
}
#end_block

#method_before
@Override
public void releaseResources(LinkResourceAllocations allocations) {
    checkNotNull(allocations);
    final IntentId intendId = allocations.intendId();
    final String dbIntentId = toIntentDbKey(intendId);
    final Collection<Link> links = allocations.links();
    // TODO: does release must happen in a batch?
    boolean success;
    do {
        Builder tx = BatchWriteRequest.newBuilder();
        // TODO: Should IntentId -> Allocation be updated conditionally?
        tx.remove(INTENT_ALLOCATIONS, dbIntentId);
        for (Link link : links) {
            final LinkKey linkId = LinkKey.linkKey(link);
            final String dbLinkId = toLinkDbKey(linkId);
            VersionedValue vv = databaseService.get(LINK_RESOURCE_ALLOCATIONS, dbLinkId);
            if (vv == null || vv.value() == null) {
                // something is wrong, but it is already freed
                log.warn("There was no resource left to release on {}", linkId);
                continue;
            }
            List<LinkResourceAllocations> before = decodeLinkAllocations(vv.value());
            List<LinkResourceAllocations> after = new ArrayList<>(before);
            after.remove(allocations);
            byte[] oldValue = encodeLinkAllocations(before);
            byte[] newValue = encodeLinkAllocations(after);
            tx.putIfValueMatches(LINK_RESOURCE_ALLOCATIONS, dbLinkId, oldValue, newValue);
        }
        BatchWriteResult batchWrite = databaseService.batchWrite(tx.build());
        success = batchWrite.isSuccessful();
    } while (!success);
    // Issue events to force recompilation of intents.
    // TODO: This should be optimized to determine which resources were released
    eventDispatcher.post(new LinkResourceEvent(LinkResourceEvent.Type.BANDWIDTH_AVAILABLE, allocations));
    eventDispatcher.post(new LinkResourceEvent(LinkResourceEvent.Type.LAMBDA_AVAILABLE, allocations));
}
#method_after
@Override
public LinkResourceEvent releaseResources(LinkResourceAllocations allocations) {
    checkNotNull(allocations);
    final IntentId intendId = allocations.intendId();
    final String dbIntentId = toIntentDbKey(intendId);
    final Collection<Link> links = allocations.links();
    // TODO: does release must happen in a batch?
    boolean success;
    do {
        Builder tx = BatchWriteRequest.newBuilder();
        // TODO: Should IntentId -> Allocation be updated conditionally?
        tx.remove(INTENT_ALLOCATIONS, dbIntentId);
        for (Link link : links) {
            final LinkKey linkId = LinkKey.linkKey(link);
            final String dbLinkId = toLinkDbKey(linkId);
            VersionedValue vv = databaseService.get(LINK_RESOURCE_ALLOCATIONS, dbLinkId);
            if (vv == null || vv.value() == null) {
                // something is wrong, but it is already freed
                log.warn("There was no resource left to release on {}", linkId);
                continue;
            }
            List<LinkResourceAllocations> before = decodeLinkAllocations(vv.value());
            List<LinkResourceAllocations> after = new ArrayList<>(before);
            after.remove(allocations);
            byte[] oldValue = encodeLinkAllocations(before);
            byte[] newValue = encodeLinkAllocations(after);
            tx.putIfValueMatches(LINK_RESOURCE_ALLOCATIONS, dbLinkId, oldValue, newValue);
        }
        BatchWriteResult batchWrite = databaseService.batchWrite(tx.build());
        success = batchWrite.isSuccessful();
    } while (!success);
    // Issue events to force recompilation of intents.
    final List<LinkResourceAllocations> releasedResources = ImmutableList.of(allocations);
    return new LinkResourceEvent(LinkResourceEvent.Type.ADDITIONAL_RESOURCES_AVAILABLE, releasedResources);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    simpleStore = new SimpleLinkResourceStore();
    simpleStore.eventDispatcher = new MockEventDelivery();
    simpleStore.activate();
    store = simpleStore;
    link1 = newLink("of:1", 1, "of:2", 2);
    link2 = newLink("of:2", 1, "of:3", 2);
    link3 = newLink("of:3", 1, "of:4", 2);
}
#method_after
@Before
public void setUp() throws Exception {
    simpleStore = new SimpleLinkResourceStore();
    simpleStore.activate();
    store = simpleStore;
    link1 = newLink("of:1", 1, "of:2", 2);
    link2 = newLink("of:2", 1, "of:3", 2);
    link3 = newLink("of:3", 1, "of:4", 2);
}
#end_block

#method_before
@Activate
public void activate() {
    linkResourceAllocationsMap = new HashMap<>();
    allocatedResources = new HashMap<>();
    freeResources = new HashMap<>();
    eventDispatcher.addSink(LinkResourceEvent.class, listenerRegistry);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    linkResourceAllocationsMap = new HashMap<>();
    allocatedResources = new HashMap<>();
    freeResources = new HashMap<>();
    log.info("Started");
}
#end_block

#method_before
@Override
public synchronized void releaseResources(LinkResourceAllocations allocations) {
    checkNotNull(allocations);
    linkResourceAllocationsMap.remove(allocations.intendId());
    for (Link link : allocations.links()) {
        addFreeResources(link, allocations);
        Set<LinkResourceAllocations> linkAllocs = allocatedResources.get(link);
        if (linkAllocs == null) {
            log.error("Missing resource allocation.");
        } else {
            linkAllocs.remove(allocations);
        }
        allocatedResources.put(link, linkAllocs);
    }
    // TODO: This should be optimized to determine which resources were released
    eventDispatcher.post(new LinkResourceEvent(LinkResourceEvent.Type.BANDWIDTH_AVAILABLE, allocations));
    eventDispatcher.post(new LinkResourceEvent(LinkResourceEvent.Type.LAMBDA_AVAILABLE, allocations));
}
#method_after
@Override
public synchronized LinkResourceEvent releaseResources(LinkResourceAllocations allocations) {
    checkNotNull(allocations);
    linkResourceAllocationsMap.remove(allocations.intendId());
    for (Link link : allocations.links()) {
        addFreeResources(link, allocations);
        Set<LinkResourceAllocations> linkAllocs = allocatedResources.get(link);
        if (linkAllocs == null) {
            log.error("Missing resource allocation.");
        } else {
            linkAllocs.remove(allocations);
        }
        allocatedResources.put(link, linkAllocs);
    }
    final List<LinkResourceAllocations> releasedResources = ImmutableList.of(allocations);
    return new LinkResourceEvent(LinkResourceEvent.Type.ADDITIONAL_RESOURCES_AVAILABLE, releasedResources);
}
#end_block

#method_before
private void tryAcquireLeadership(String path) {
    Lock lock = openContests.get(path);
    verifyNotNull(lock, "Lock should not be null");
    lock.lockAsync(TERM_DURATION_MS).whenComplete((response, error) -> {
        if (error == null) {
            threadPool.schedule(new ReelectionTask(lock), TERM_DURATION_MS / 2, TimeUnit.MILLISECONDS);
            notifyListeners(new LeadershipEvent(LeadershipEvent.Type.LEADER_ELECTED, new Leadership(lock.path(), localNode, lock.epoch())));
            return;
        } else {
            log.warn("Failed to acquire lock for {}. Will retry in {} ms", path, WAIT_BEFORE_RETRY_MS, error);
            threadPool.schedule(new TryLeadership(lock), WAIT_BEFORE_RETRY_MS, TimeUnit.MILLISECONDS);
        }
    });
}
#method_after
private void tryAcquireLeadership(String path) {
    Lock lock = openContests.get(path);
    if (lock == null) {
        // withdrew from race.
        return;
    }
    lock.lockAsync(TERM_DURATION_MS).whenComplete((response, error) -> {
        if (error == null) {
            threadPool.schedule(new ReelectionTask(lock), TERM_DURATION_MS / 2, TimeUnit.MILLISECONDS);
            notifyListeners(new LeadershipEvent(LeadershipEvent.Type.LEADER_ELECTED, new Leadership(lock.path(), localNode, lock.epoch())));
            return;
        } else {
            log.warn("Failed to acquire lock for {}. Will retry in {} ms", path, WAIT_BEFORE_RETRY_MS, error);
            threadPool.schedule(new TryLeadership(lock), WAIT_BEFORE_RETRY_MS, TimeUnit.MILLISECONDS);
        }
    });
}
#end_block

#method_before
@Override
public void run() {
    boolean lockExtended = false;
    try {
        lockExtended = lock.extendExpiration(TERM_DURATION_MS);
    } catch (Exception e) {
        log.warn("Attempt to extend lock failed with an exception.", e);
    }
    if (lockExtended) {
        notifyListeners(new LeadershipEvent(LeadershipEvent.Type.LEADER_REELECTED, new Leadership(lock.path(), localNode, lock.epoch())));
        threadPool.schedule(this, TERM_DURATION_MS / 2, TimeUnit.MILLISECONDS);
    } else {
        // we don't need to notify here.
        if (openContests.containsKey(lock.path())) {
            notifyListeners(new LeadershipEvent(LeadershipEvent.Type.LEADER_BOOTED, new Leadership(lock.path(), localNode, lock.epoch())));
            // Retry leadership after a brief wait.
            threadPool.schedule(new TryLeadership(lock), WAIT_BEFORE_RETRY_MS, TimeUnit.MILLISECONDS);
        }
    }
}
#method_after
@Override
public void run() {
    if (!openContests.containsKey(lock.path())) {
        log.debug("Node withdrew from leadership race for {}. Cancelling reelection task.", lock.path());
        return;
    }
    boolean lockExtended = false;
    try {
        lockExtended = lock.extendExpiration(TERM_DURATION_MS);
    } catch (Exception e) {
        log.warn("Attempt to extend lock failed with an exception.", e);
    }
    if (lockExtended) {
        notifyListeners(new LeadershipEvent(LeadershipEvent.Type.LEADER_REELECTED, new Leadership(lock.path(), localNode, lock.epoch())));
        threadPool.schedule(this, TERM_DURATION_MS / 2, TimeUnit.MILLISECONDS);
    } else {
        // we don't need to notify here.
        if (openContests.containsKey(lock.path())) {
            notifyListeners(new LeadershipEvent(LeadershipEvent.Type.LEADER_BOOTED, new Leadership(lock.path(), localNode, lock.epoch())));
            // Retry leadership after a brief wait.
            threadPool.schedule(new TryLeadership(lock), WAIT_BEFORE_RETRY_MS, TimeUnit.MILLISECONDS);
        }
    }
}
#end_block

#method_before
private FlowRuleBatchEntry createBatchEntry(FlowRuleOperation operation, LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> outPorts) {
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
    for (PortNumber outPort : outPorts) {
        treatmentBuilder.setOutput(outPort);
    }
    TrafficTreatment treatment = treatmentBuilder.build();
    TrafficSelector selector = DefaultTrafficSelector.builder(intent.selector()).build();
    FlowRule rule = new DefaultFlowRule(deviceId, selector, treatment, 123, appId, 0, true);
    return new FlowRuleBatchEntry(operation, rule);
}
#method_after
private FlowRuleBatchEntry createBatchEntry(FlowRuleOperation operation, LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> outPorts) {
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
    for (PortNumber outPort : outPorts) {
        treatmentBuilder.setOutput(outPort);
    }
    TrafficTreatment treatment = treatmentBuilder.build();
    TrafficSelector selector = DefaultTrafficSelector.builder(intent.selector()).build();
    FlowRule rule = new DefaultFlowRule(deviceId, selector, treatment, 123, appId, (short) (intent.id().fingerprint() & 0xffff), 0, true);
    return new FlowRuleBatchEntry(operation, rule);
}
#end_block

#method_before
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    if (outputJson()) {
        print("%s", json(service, service.getIntents()));
    } else {
        for (Intent intent : service.getIntents()) {
            IntentState state = service.getIntentState(intent.id());
            print("id=%s, state=%s, type=%s, appId=%s", intent.id(), state, intent.getClass().getSimpleName(), intent.appId().name());
            printDetails(service, intent);
        }
    }
}
#method_after
@Override
protected void execute() {
    IntentService service = get(IntentService.class);
    if (intentsSummary) {
        IntentSummaries intentSummaries = new IntentSummaries();
        intentSummaries.collectIntentSummary(service, service.getIntents());
        if (outputJson()) {
            print("%s", intentSummaries.json());
        } else {
            intentSummaries.printSummary();
        }
        return;
    }
    if (outputJson()) {
        print("%s", json(service, service.getIntents()));
    } else {
        for (Intent intent : service.getIntents()) {
            IntentState state = service.getIntentState(intent.id());
            print("id=%s, state=%s, type=%s, appId=%s", intent.id(), state, intent.getClass().getSimpleName(), intent.appId().name());
            printDetails(service, intent);
        }
    }
}
#end_block

#method_before
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent) {
    Set<Link> links = new HashSet<>();
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        links.addAll(path.links());
    }
    Intent result = new LinkCollectionIntent(intent.appId(), intent.selector(), intent.treatment(), links, intent.egressPoints());
    return Arrays.asList(result);
}
#method_after
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable, Set<LinkResourceAllocations> resources) {
    Set<Link> links = new HashSet<>();
    // FIXME: need to handle the case where ingress/egress points are on same switch
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        links.addAll(path.links());
    }
    Intent result = new LinkCollectionIntent(intent.appId(), intent.selector(), intent.treatment(), links, intent.egressPoints(), null);
    return Arrays.asList(result);
}
#end_block

#method_before
@Override
public void run() {
    try {
        if (remoteNode == null) {
            remoteNode = getControllerNode(remoteMember);
            if (remoteNode == null) {
                throw new IOException("Remote node is offline!");
            }
        }
        byte[] response = clusterCommunicator.sendAndReceive(message, remoteNode.id()).get(RETRY_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);
        if (!connectionOK.getAndSet(true)) {
            log.info("Connectivity to {} restored", remoteNode);
        }
        future.complete(verifyNotNull(SERIALIZER.decode(response)));
    } catch (IOException | TimeoutException e) {
        if (connectionOK.getAndSet(false)) {
            log.warn("Detected connectivity issues with {}", remoteNode, e);
        }
        log.debug("RPCTask for {} failed.", request, e);
        future.completeExceptionally(e);
    } catch (ExecutionException e) {
        log.warn("RPCTask execution for {} failed: {}", request, e.getMessage());
        log.debug("RPCTask execution for {} failed.", request, e);
        future.completeExceptionally(e);
    } catch (InterruptedException e) {
        log.warn("RPCTask for {} was interrupted: {}", request, e.getMessage());
        log.debug("RPCTask for {} was interrupted.", request, e);
        future.completeExceptionally(e);
        Thread.currentThread().interrupt();
    } catch (Exception e) {
        log.warn("RPCTask for {} terribly failed.", request, e);
        future.completeExceptionally(e);
    }
}
#method_after
@Override
public void run() {
    try {
        if (remoteNode == null) {
            remoteNode = getControllerNode(remoteMember);
            if (remoteNode == null) {
                throw new IOException("Remote node is offline!");
            }
        }
        byte[] response = clusterCommunicator.sendAndReceive(message, remoteNode.id()).get(RETRY_INTERVAL_MILLIS, TimeUnit.MILLISECONDS);
        if (!connectionOK.getAndSet(true)) {
            log.info("Connectivity to {} restored", remoteNode);
        }
        future.complete(verifyNotNull(SERIALIZER.decode(response)));
    } catch (IOException | TimeoutException e) {
        if (connectionOK.getAndSet(false)) {
            log.warn("Detected connectivity issues with {}. Reason: {}", remoteNode, e.getMessage());
        }
        log.debug("RPCTask for {} failed.", request, e);
        future.completeExceptionally(e);
    } catch (ExecutionException e) {
        log.warn("RPCTask execution for {} failed: {}", request, e.getMessage());
        log.debug("RPCTask execution for {} failed.", request, e);
        future.completeExceptionally(e);
    } catch (InterruptedException e) {
        log.warn("RPCTask for {} was interrupted: {}", request, e.getMessage());
        log.debug("RPCTask for {} was interrupted.", request, e);
        future.completeExceptionally(e);
        Thread.currentThread().interrupt();
    } catch (Exception e) {
        log.warn("RPCTask for {} terribly failed.", request, e);
        future.completeExceptionally(e);
    }
}
#end_block

#method_before
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    log.info("Device {} connected", deviceId);
    final NodeId myNodeId = clusterService.getLocalNode().id();
    // check my Role
    mastershipService.requestRoleFor(deviceId);
    final MastershipTerm term = termService.getMastershipTerm(deviceId);
    if (!myNodeId.equals(term.master())) {
        log.info("Role of this node is STANDBY for {}", deviceId);
        // TODO: Do we need to explicitly tell the Provider that
        // this instance is not the MASTER
        applyRole(deviceId, MastershipRole.STANDBY);
        return;
    }
    log.info("Role of this node is MASTER for {}", deviceId);
    // tell clock provider if this instance is the master
    deviceClockProviderService.setMastershipTerm(deviceId, term);
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    applyRole(deviceId, MastershipRole.MASTER);
    // that this instance is the master.
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
// else {
// post(new DeviceEvent(DEVICE_MASTERSHIP_CHANGED,
// store.getDevice(deviceId)));
// }
}
#method_after
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    log.info("Device {} connected", deviceId);
    final NodeId myNodeId = clusterService.getLocalNode().id();
    // check my Role
    mastershipService.requestRoleFor(deviceId);
    final MastershipTerm term = termService.getMastershipTerm(deviceId);
    if (!myNodeId.equals(term.master())) {
        log.info("Role of this node is STANDBY for {}", deviceId);
        // TODO: Do we need to explicitly tell the Provider that
        // this instance is not the MASTER
        applyRole(deviceId, MastershipRole.STANDBY);
        return;
    }
    log.info("Role of this node is MASTER for {}", deviceId);
    // tell clock provider if this instance is the master
    deviceClockProviderService.setMastershipTerm(deviceId, term);
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    applyRole(deviceId, MastershipRole.MASTER);
    // that this instance is the master.
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#end_block

#method_before
@Activate
public void activate() {
    providerService = providerRegistry.register(this);
    deviceService.addListener(listener);
    packetSevice.addProcessor(listener, 0);
    masterService.addListener(roleListener);
    LinkDiscovery ld;
    for (Device device : deviceService.getDevices()) {
        ld = new LinkDiscovery(device, packetSevice, masterService, providerService, useBDDP);
        discoverers.put(device.id(), ld);
        for (Port p : deviceService.getPorts(device.id())) {
            if (!p.number().isLogical()) {
                ld.addPort(p);
            }
        }
    }
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    providerService = providerRegistry.register(this);
    deviceService.addListener(listener);
    packetSevice.addProcessor(listener, 0);
    masterService.addListener(roleListener);
    LinkDiscovery ld;
    for (Device device : deviceService.getDevices()) {
        ld = new LinkDiscovery(device, packetSevice, masterService, providerService, useBDDP);
        discoverers.put(device.id(), ld);
        for (Port p : deviceService.getPorts(device.id())) {
            if (!p.number().isLogical()) {
                ld.addPort(p);
            }
        }
    }
    executor = newSingleThreadScheduledExecutor(namedThreads("device-sync-%d"));
    executor.scheduleAtFixedRate(new SyncDeviceInfoTask(), INIT_DELAY, DELAY, TimeUnit.SECONDS);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    for (LinkDiscovery ld : discoverers.values()) {
        ld.stop();
    }
    providerRegistry.unregister(this);
    deviceService.removeListener(listener);
    packetSevice.removeProcessor(listener);
    providerService = null;
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    executor.shutdownNow();
    for (LinkDiscovery ld : discoverers.values()) {
        ld.stop();
    }
    providerRegistry.unregister(this);
    deviceService.removeListener(listener);
    packetSevice.removeProcessor(listener);
    masterService.removeListener(roleListener);
    providerService = null;
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void event(MastershipEvent event) {
    if (MastershipEvent.Type.BACKUPS_CHANGED.equals(event.type())) {
        // only need new master events
        return;
    }
    DeviceId deviceId = event.subject();
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.warn("Device {} doesn't exist, or isn't there yet", deviceId);
        return;
    }
    if (!discoverers.containsKey(deviceId)) {
        // TODO: ideally, should never reach here
        log.debug("Device mastership changed ({}) {}", event.type(), deviceId);
        discoverers.put(deviceId, new LinkDiscovery(device, packetSevice, masterService, providerService, useBDDP));
    }
}
#method_after
@Override
public void event(MastershipEvent event) {
    if (MastershipEvent.Type.BACKUPS_CHANGED.equals(event.type())) {
        // only need new master events
        return;
    }
    DeviceId deviceId = event.subject();
    Device device = deviceService.getDevice(deviceId);
    if (device == null) {
        log.warn("Device {} doesn't exist, or isn't there yet", deviceId);
        return;
    }
    synchronized (discoverers) {
        if (!discoverers.containsKey(deviceId)) {
            // TODO: ideally, should never reach here
            log.debug("Device mastership changed ({}) {}", event.type(), deviceId);
            discoverers.put(deviceId, new LinkDiscovery(device, packetSevice, masterService, providerService, useBDDP));
        }
    }
}
#end_block

#method_before
@Override
public void event(DeviceEvent event) {
    LinkDiscovery ld = null;
    Device device = event.subject();
    Port port = event.port();
    if (device == null) {
        log.error("Device is null.");
        return;
    }
    log.trace("{} {} {}", event.type(), event.subject(), event);
    final DeviceId deviceId = device.id();
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_UPDATED:
            ld = discoverers.get(deviceId);
            if (ld == null) {
                log.debug("Device added ({}) {}", event.type(), deviceId);
                discoverers.put(deviceId, new LinkDiscovery(device, packetSevice, masterService, providerService, useBDDP));
            } else {
                if (ld.isStopped()) {
                    log.debug("Device restarted ({}) {}", event.type(), deviceId);
                    ld.start();
                }
            }
            break;
        case PORT_ADDED:
        case PORT_UPDATED:
            if (port.isEnabled()) {
                ld = discoverers.get(deviceId);
                if (ld == null) {
                    return;
                }
                if (!port.number().isLogical()) {
                    log.debug("Port added {}", port);
                    ld.addPort(port);
                }
            } else {
                log.debug("Port down {}", port);
                ConnectPoint point = new ConnectPoint(deviceId, port.number());
                providerService.linksVanished(point);
            }
            break;
        case PORT_REMOVED:
            log.debug("Port removed {}", port);
            ConnectPoint point = new ConnectPoint(deviceId, port.number());
            providerService.linksVanished(point);
            // TODO: Don't we need to removePort from ld?
            break;
        case DEVICE_REMOVED:
        case DEVICE_SUSPENDED:
            log.debug("Device removed {}", deviceId);
            ld = discoverers.get(deviceId);
            if (ld == null) {
                return;
            }
            ld.stop();
            providerService.linksVanished(deviceId);
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            ld = discoverers.get(deviceId);
            if (ld == null) {
                return;
            }
            if (deviceService.isAvailable(deviceId)) {
                log.debug("Device up {}", deviceId);
                ld.start();
            } else {
                providerService.linksVanished(deviceId);
                log.debug("Device down {}", deviceId);
                ld.stop();
            }
            break;
        default:
            log.debug("Unknown event {}", event);
    }
}
#method_after
@Override
public void event(DeviceEvent event) {
    LinkDiscovery ld = null;
    Device device = event.subject();
    Port port = event.port();
    if (device == null) {
        log.error("Device is null.");
        return;
    }
    log.trace("{} {} {}", event.type(), event.subject(), event);
    final DeviceId deviceId = device.id();
    switch(event.type()) {
        case DEVICE_ADDED:
        case DEVICE_UPDATED:
            synchronized (discoverers) {
                ld = discoverers.get(deviceId);
                if (ld == null) {
                    log.debug("Device added ({}) {}", event.type(), deviceId);
                    discoverers.put(deviceId, new LinkDiscovery(device, packetSevice, masterService, providerService, useBDDP));
                } else {
                    if (ld.isStopped()) {
                        log.debug("Device restarted ({}) {}", event.type(), deviceId);
                        ld.start();
                    }
                }
            }
            break;
        case PORT_ADDED:
        case PORT_UPDATED:
            if (port.isEnabled()) {
                ld = discoverers.get(deviceId);
                if (ld == null) {
                    return;
                }
                if (!port.number().isLogical()) {
                    log.debug("Port added {}", port);
                    ld.addPort(port);
                }
            } else {
                log.debug("Port down {}", port);
                ConnectPoint point = new ConnectPoint(deviceId, port.number());
                providerService.linksVanished(point);
            }
            break;
        case PORT_REMOVED:
            log.debug("Port removed {}", port);
            ConnectPoint point = new ConnectPoint(deviceId, port.number());
            providerService.linksVanished(point);
            // TODO: Don't we need to removePort from ld?
            break;
        case DEVICE_REMOVED:
        case DEVICE_SUSPENDED:
            log.debug("Device removed {}", deviceId);
            ld = discoverers.get(deviceId);
            if (ld == null) {
                return;
            }
            ld.stop();
            providerService.linksVanished(deviceId);
            break;
        case DEVICE_AVAILABILITY_CHANGED:
            ld = discoverers.get(deviceId);
            if (ld == null) {
                return;
            }
            if (deviceService.isAvailable(deviceId)) {
                log.debug("Device up {}", deviceId);
                ld.start();
            } else {
                providerService.linksVanished(deviceId);
                log.debug("Device down {}", deviceId);
                ld.stop();
            }
            break;
        default:
            log.debug("Unknown event {}", event);
    }
}
#end_block

#method_before
@Override
public List<DeviceEvent> updatePorts(ProviderId providerId, DeviceId deviceId, List<PortDescription> portDescriptions) {
    Device device = devices.get(deviceId);
    if (device == null) {
        log.debug("Device {} doesn't exist or hasn't been initialized yet", deviceId);
        return Collections.emptyList();
    }
    checkArgument(device != null, DEVICE_NOT_FOUND, deviceId);
    Map<ProviderId, DeviceDescriptions> descsMap = deviceDescs.get(deviceId);
    checkArgument(descsMap != null, DEVICE_NOT_FOUND, deviceId);
    List<DeviceEvent> events = new ArrayList<>();
    synchronized (descsMap) {
        DeviceDescriptions descs = descsMap.get(providerId);
        // every provider must provide DeviceDescription.
        checkArgument(descs != null, "Device description for Device ID %s from Provider %s was not found", deviceId, providerId);
        Map<PortNumber, Port> ports = getPortMap(deviceId);
        // Add new ports
        Set<PortNumber> processed = new HashSet<>();
        for (PortDescription portDescription : portDescriptions) {
            final PortNumber number = portDescription.portNumber();
            processed.add(portDescription.portNumber());
            final Port oldPort = ports.get(number);
            final Port newPort;
            // event suppression hook?
            // update description
            descs.putPortDesc(portDescription);
            newPort = composePort(device, number, descsMap);
            events.add(oldPort == null ? createPort(device, newPort, ports) : updatePort(device, oldPort, newPort, ports));
        }
        events.addAll(pruneOldPorts(device, ports, processed));
    }
    return FluentIterable.from(events).filter(notNull()).toList();
}
#method_after
@Override
public List<DeviceEvent> updatePorts(ProviderId providerId, DeviceId deviceId, List<PortDescription> portDescriptions) {
    Device device = devices.get(deviceId);
    if (device == null) {
        log.debug("Device {} doesn't exist or hasn't been initialized yet", deviceId);
        return Collections.emptyList();
    }
    Map<ProviderId, DeviceDescriptions> descsMap = deviceDescs.get(deviceId);
    checkArgument(descsMap != null, DEVICE_NOT_FOUND, deviceId);
    List<DeviceEvent> events = new ArrayList<>();
    synchronized (descsMap) {
        DeviceDescriptions descs = descsMap.get(providerId);
        // every provider must provide DeviceDescription.
        checkArgument(descs != null, "Device description for Device ID %s from Provider %s was not found", deviceId, providerId);
        Map<PortNumber, Port> ports = getPortMap(deviceId);
        // Add new ports
        Set<PortNumber> processed = new HashSet<>();
        for (PortDescription portDescription : portDescriptions) {
            final PortNumber number = portDescription.portNumber();
            processed.add(portDescription.portNumber());
            final Port oldPort = ports.get(number);
            final Port newPort;
            // event suppression hook?
            // update description
            descs.putPortDesc(portDescription);
            newPort = composePort(device, number, descsMap);
            events.add(oldPort == null ? createPort(device, newPort, ports) : updatePort(device, oldPort, newPort, ports));
        }
        events.addAll(pruneOldPorts(device, ports, processed));
    }
    return FluentIterable.from(events).filter(notNull()).toList();
}
#end_block

#method_before
// Applies the specified role to the device; ignores NONE
private boolean applyRoleAndProbe(DeviceId deviceId, MastershipRole newRole) {
    if (newRole.equals(MastershipRole.NONE)) {
        // no-op
        return true;
    }
    Device device = store.getDevice(deviceId);
    // FIXME relinquish role
    if (device == null) {
        log.warn("{} was not there. Cannot apply role {}", deviceId, newRole);
        return false;
    }
    DeviceProvider provider = getProvider(deviceId);
    if (provider == null) {
        log.warn("Provider for {} was not found. Cannot apply role {}", deviceId, newRole);
        return false;
    }
    provider.roleChanged(deviceId, newRole);
    if (newRole.equals(MastershipRole.MASTER)) {
        // only trigger event when request was sent to provider
        // TODO: consider removing this from Device event type?
        post(new DeviceEvent(DEVICE_MASTERSHIP_CHANGED, device));
        provider.triggerProbe(deviceId);
    }
    return true;
}
#method_after
// Applies the specified role to the device; ignores NONE
private boolean applyRoleAndProbe(DeviceId deviceId, MastershipRole newRole) {
    if (newRole.equals(MastershipRole.NONE)) {
        // no-op
        return true;
    }
    DeviceProvider provider = getProvider(deviceId);
    if (provider == null) {
        log.warn("Provider for {} was not found. Cannot apply role {}", deviceId, newRole);
        return false;
    }
    provider.roleChanged(deviceId, newRole);
    if (newRole.equals(MastershipRole.MASTER)) {
        // only trigger event when request was sent to provider
        provider.triggerProbe(deviceId);
    }
    return true;
}
#end_block

#method_before
@Override
public IPacket deserialize(final byte[] data, final int offset, final int length) {
    if (length <= 0) {
        return null;
    }
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    if (this.destinationMACAddress == null) {
        this.destinationMACAddress = MacAddress.valueOf(new byte[6]);
    }
    final byte[] dstAddr = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    bb.get(dstAddr);
    this.destinationMACAddress = MacAddress.valueOf(dstAddr);
    if (this.sourceMACAddress == null) {
        this.sourceMACAddress = MacAddress.valueOf(new byte[6]);
    }
    final byte[] srcAddr = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    bb.get(srcAddr);
    this.sourceMACAddress = MacAddress.valueOf(srcAddr);
    short ethType = bb.getShort();
    if (ethType == (short) 0x8100) {
        final short tci = bb.getShort();
        this.priorityCode = (byte) (tci >> 13 & 0x07);
        this.vlanID = (short) (tci & 0x0fff);
        ethType = bb.getShort();
    } else {
        this.vlanID = Ethernet.VLAN_UNTAGGED;
    }
    this.etherType = ethType;
    IPacket payload;
    if (Ethernet.etherTypeClassMap.containsKey(this.etherType)) {
        final Class<? extends IPacket> clazz = Ethernet.etherTypeClassMap.get(this.etherType);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for Ethernet packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#method_after
@Override
public IPacket deserialize(final byte[] data, final int offset, final int length) {
    if (length <= 0) {
        return null;
    }
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    if (this.destinationMACAddress == null) {
        this.destinationMACAddress = MacAddress.valueOf(new byte[6]);
    }
    final byte[] dstAddr = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    bb.get(dstAddr);
    this.destinationMACAddress = MacAddress.valueOf(dstAddr);
    if (this.sourceMACAddress == null) {
        this.sourceMACAddress = MacAddress.valueOf(new byte[6]);
    }
    final byte[] srcAddr = new byte[MacAddress.MAC_ADDRESS_LENGTH];
    bb.get(srcAddr);
    this.sourceMACAddress = MacAddress.valueOf(srcAddr);
    short ethType = bb.getShort();
    if (ethType == (short) 0x8100) {
        final short tci = bb.getShort();
        this.priorityCode = (byte) (tci >> 13 & 0x07);
        this.vlanID = (short) (tci & 0x0fff);
        ethType = bb.getShort();
    } else {
        this.vlanID = Ethernet.VLAN_UNTAGGED;
    }
    this.etherType = ethType;
    IPacket payload;
    if (Ethernet.ETHER_TYPE_CLASS_MAP.containsKey(this.etherType)) {
        final Class<? extends IPacket> clazz = Ethernet.ETHER_TYPE_CLASS_MAP.get(this.etherType);
        try {
            payload = clazz.newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Error parsing payload for Ethernet packet", e);
        }
    } else {
        payload = new Data();
    }
    this.payload = payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#end_block

#method_before
@Override
public IPacket deserialize(final byte[] data, final int offset, final int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.sourcePort = bb.getShort();
    this.destinationPort = bb.getShort();
    this.length = bb.getShort();
    this.checksum = bb.getShort();
    if (UDP.decodeMap.containsKey(this.destinationPort)) {
        try {
            this.payload = UDP.decodeMap.get(this.destinationPort).getConstructor().newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Failure instantiating class", e);
        }
    } else if (UDP.decodeMap.containsKey(this.sourcePort)) {
        try {
            this.payload = UDP.decodeMap.get(this.sourcePort).getConstructor().newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Failure instantiating class", e);
        }
    } else {
        this.payload = new Data();
    }
    this.payload = this.payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#method_after
@Override
public IPacket deserialize(final byte[] data, final int offset, final int length) {
    final ByteBuffer bb = ByteBuffer.wrap(data, offset, length);
    this.sourcePort = bb.getShort();
    this.destinationPort = bb.getShort();
    this.length = bb.getShort();
    this.checksum = bb.getShort();
    if (UDP.DECODE_MAP.containsKey(this.destinationPort)) {
        try {
            this.payload = UDP.DECODE_MAP.get(this.destinationPort).getConstructor().newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Failure instantiating class", e);
        }
    } else if (UDP.DECODE_MAP.containsKey(this.sourcePort)) {
        try {
            this.payload = UDP.DECODE_MAP.get(this.sourcePort).getConstructor().newInstance();
        } catch (final Exception e) {
            throw new RuntimeException("Failure instantiating class", e);
        }
    } else {
        this.payload = new Data();
    }
    this.payload = this.payload.deserialize(data, bb.position(), bb.limit() - bb.position());
    this.payload.setParent(this);
    return this;
}
#end_block

#method_before
public String getNameString() {
    LLDPOrganizationalTLV tlv = getNameTLV();
    if (tlv != null) {
        return new String(tlv.getInfoString(), Charset.forName("UTF-8"));
    }
    return null;
}
#method_after
public String getNameString() {
    LLDPOrganizationalTLV tlv = getNameTLV();
    if (tlv != null) {
        return new String(tlv.getInfoString(), StandardCharsets.UTF_8);
    }
    return null;
}
#end_block

#method_before
public String getDeviceString() {
    LLDPOrganizationalTLV tlv = getDeviceTLV();
    if (tlv != null) {
        return new String(tlv.getInfoString(), Charset.forName("UTF-8"));
    }
    return null;
}
#method_after
public String getDeviceString() {
    LLDPOrganizationalTLV tlv = getDeviceTLV();
    if (tlv != null) {
        return new String(tlv.getInfoString(), StandardCharsets.UTF_8);
    }
    return null;
}
#end_block

#method_before
private void setOUIName(final String name) {
    this.bb = ByteBuffer.wrap(ouiName);
    this.bb.put(ONLabLddp.ONLAB_OUI);
    this.bb.put(NAME_TLV_SUBTYPE);
    this.bb.put(name.getBytes(Charset.forName("UTF-8")));
    this.ouiNameTLV.setLength(NAME_TLV_SIZE);
    this.ouiNameTLV.setType(NAME_TLV_TYPE);
    this.ouiNameTLV.setValue(ouiName);
}
#method_after
private void setOUIName(final String name) {
    this.bb = ByteBuffer.wrap(ouiName);
    this.bb.put(ONLabLddp.ONLAB_OUI);
    this.bb.put(NAME_TLV_SUBTYPE);
    this.bb.put(name.getBytes(StandardCharsets.UTF_8));
    this.ouiNameTLV.setLength(NAME_TLV_SIZE);
    this.ouiNameTLV.setType(NAME_TLV_TYPE);
    this.ouiNameTLV.setValue(ouiName);
}
#end_block

#method_before
@Override
public boolean extendExpiration(int leaseDurationMillis) {
    if (!isLocked()) {
        log.warn("Ignoring request to extend expiration for lock {}." + " ExtendExpiration must be called for locks that are already acquired.", path);
    }
    if (databaseService.putIfValueMatches(DistributedLockManager.ONOS_LOCK_TABLE_NAME, path, lockId, lockId)) {
        lockExpirationTime = DateTime.now().plusMillis(leaseDurationMillis);
        log.debug("Succeeded in extending lock {} expiration time to {}", lockExpirationTime);
        return true;
    } else {
        log.info("Failed to extend expiration for {}", path);
        return false;
    }
}
#method_after
@Override
public boolean extendExpiration(int leaseDurationMillis) {
    if (!isLocked()) {
        log.warn("Ignoring request to extend expiration for lock {}." + " ExtendExpiration must be called for locks that are already acquired.", path);
        return false;
    }
    if (databaseService.putIfValueMatches(DistributedLockManager.ONOS_LOCK_TABLE_NAME, path, lockId, lockId)) {
        lockExpirationTime = DateTime.now().plusMillis(leaseDurationMillis);
        log.debug("Succeeded in extending lock {} expiration time to {}", lockExpirationTime);
        return true;
    } else {
        log.info("Failed to extend expiration for {}", path);
        return false;
    }
}
#end_block

#method_before
public static Instruction pushMpls() {
    return new ModEtherTypeInstruction(L2SubType.MPLS_PUSH);
}
#method_after
public static Instruction pushMpls() {
    return new PushHeaderInstructions(L2SubType.MPLS_PUSH, new Ethernet().setEtherType(Ethernet.MPLS_UNICAST));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(port, type());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), port);
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onlab.onos.fwd");
    uglyMap.put(DeviceId.deviceId("of:0000000000000001"), 1);
    uglyMap.put(DeviceId.deviceId("of:0000000000000002"), 2);
    uglyMap.put(DeviceId.deviceId("of:0000000000000003"), 3);
    deviceService.addListener(listener);
    for (Device d : deviceService.getDevices()) {
        pushRules(d);
    }
    log.info("Started with Application ID {}", appId.id());
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication("org.onlab.onos.testapp" + ".mplsfwd");
    uglyMap.put(DeviceId.deviceId("of:0000000000000001"), 1);
    uglyMap.put(DeviceId.deviceId("of:0000000000000002"), 2);
    uglyMap.put(DeviceId.deviceId("of:0000000000000003"), 3);
    deviceService.addListener(listener);
    for (Device d : deviceService.getDevices()) {
        pushRules(d);
    }
    log.info("Started with Application ID {}", appId.id());
}
#end_block

#method_before
private void pushRules(Device device) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    int inport = 1;
    int outport = 2;
    Integer mplsLabel = 101;
    Integer switchNumber = uglyMap.get(device.id());
    if (switchNumber == null) {
        return;
    }
    switch(switchNumber) {
        case 1:
            sbuilder.matchInport(PortNumber.portNumber(inport));
            tbuilder.setOutput(PortNumber.portNumber(outport)).pushMpls().setMpls(mplsLabel);
            break;
        case 2:
            sbuilder.matchMplsLabel(mplsLabel).matchEthType(Ethernet.MPLS_UNICAST).matchInport(PortNumber.portNumber(inport));
            tbuilder.setOutput(PortNumber.portNumber(outport));
            break;
        case 3:
            sbuilder.matchMplsLabel(mplsLabel).matchEthType(Ethernet.MPLS_UNICAST).matchInport(PortNumber.portNumber(inport));
            tbuilder.setOutput(PortNumber.portNumber(outport));
            break;
        default:
    }
    TrafficTreatment treatement = tbuilder.build();
    TrafficSelector selector = sbuilder.build();
    FlowRule f = new DefaultFlowRule(device.id(), selector, treatement, 100, appId, 600, false);
    flowRuleService.applyFlowRules(f);
}
#method_after
private void pushRules(Device device) {
    TrafficSelector.Builder sbuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tbuilder = DefaultTrafficTreatment.builder();
    int inport = 1;
    int outport = 2;
    Integer mplsLabel = 101;
    Integer switchNumber = uglyMap.get(device.id());
    if (switchNumber == null) {
        return;
    }
    switch(switchNumber) {
        case 1:
            sbuilder.matchInport(PortNumber.portNumber(inport));
            tbuilder.setOutput(PortNumber.portNumber(outport)).pushMpls().setMpls(mplsLabel);
            break;
        case 2:
            sbuilder.matchMplsLabel(mplsLabel).matchEthType(Ethernet.MPLS_UNICAST).matchInport(PortNumber.portNumber(inport));
            tbuilder.setOutput(PortNumber.portNumber(outport));
            break;
        case 3:
            sbuilder.matchMplsLabel(mplsLabel).matchEthType(Ethernet.MPLS_UNICAST).matchInport(PortNumber.portNumber(inport));
            tbuilder.popMpls().setOutput(PortNumber.portNumber(outport));
            break;
        default:
    }
    TrafficTreatment treatement = tbuilder.build();
    TrafficSelector selector = sbuilder.build();
    FlowRule f = new DefaultFlowRule(device.id(), selector, treatement, 100, appId, 600, false);
    flowRuleService.applyFlowRules(f);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(criteria);
}
#method_after
@Override
public int hashCode() {
    return criteria.hashCode();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(port, type());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), port);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mac, type);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, mac);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(ethType, type());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), ethType);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(ip, type);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, ip);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(proto, type());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), proto);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(vlanPcp);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), vlanPcp);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(vlanId, type());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), vlanId);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(tcpPort, type);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, tcpPort);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mplsLabel);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(mplsLabel, type());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(lambda, type);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, lambda);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(signalType, type);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type, signalType);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(mac, type(), subtype);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), subtype, mac);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(vlanId, type(), subtype());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), subtype(), vlanId);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(vlanPcp, type(), subtype());
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(type(), subtype(), vlanPcp);
}
#end_block

#method_before
private OFAction buildL2Modification(Instruction i) {
    L2ModificationInstruction l2m = (L2ModificationInstruction) i;
    ModEtherInstruction eth;
    OFOxm<?> oxm = null;
    switch(l2m.subtype()) {
        case ETH_DST:
            eth = (ModEtherInstruction) l2m;
            oxm = factory().oxms().ethDst(MacAddress.of(eth.mac().toLong()));
            break;
        case ETH_SRC:
            eth = (ModEtherInstruction) l2m;
            oxm = factory().oxms().ethSrc(MacAddress.of(eth.mac().toLong()));
            break;
        case VLAN_ID:
            ModVlanIdInstruction vlanId = (ModVlanIdInstruction) l2m;
            oxm = factory().oxms().vlanVid(OFVlanVidMatch.ofVlan(vlanId.vlanId().toShort()));
            break;
        case VLAN_PCP:
            ModVlanPcpInstruction vlanPcp = (ModVlanPcpInstruction) l2m;
            oxm = factory().oxms().vlanPcp(VlanPcp.of(vlanPcp.vlanPcp()));
            break;
        case MPLS_PUSH:
            return factory().actions().pushMpls(EthType.MPLS_UNICAST);
        case MPLS_LABEL:
            ModMplsLabelInstruction mplsLabel = (ModMplsLabelInstruction) l2m;
            oxm = factory().oxms().mplsLabel(U32.of(mplsLabel.label().longValue()));
            break;
        default:
            log.warn("Unimplemented action type {}.", l2m.subtype());
            break;
    }
    if (oxm != null) {
        return factory().actions().buildSetField().setField(oxm).build();
    }
    return null;
}
#method_after
private OFAction buildL2Modification(Instruction i) {
    L2ModificationInstruction l2m = (L2ModificationInstruction) i;
    ModEtherInstruction eth;
    OFOxm<?> oxm = null;
    switch(l2m.subtype()) {
        case ETH_DST:
            eth = (ModEtherInstruction) l2m;
            oxm = factory().oxms().ethDst(MacAddress.of(eth.mac().toLong()));
            break;
        case ETH_SRC:
            eth = (ModEtherInstruction) l2m;
            oxm = factory().oxms().ethSrc(MacAddress.of(eth.mac().toLong()));
            break;
        case VLAN_ID:
            ModVlanIdInstruction vlanId = (ModVlanIdInstruction) l2m;
            oxm = factory().oxms().vlanVid(OFVlanVidMatch.ofVlan(vlanId.vlanId().toShort()));
            break;
        case VLAN_PCP:
            ModVlanPcpInstruction vlanPcp = (ModVlanPcpInstruction) l2m;
            oxm = factory().oxms().vlanPcp(VlanPcp.of(vlanPcp.vlanPcp()));
            break;
        case MPLS_PUSH:
            PushHeaderInstructions pushHeaderInstructions = (PushHeaderInstructions) l2m;
            return factory().actions().pushMpls(EthType.of(pushHeaderInstructions.ethernetType().getEtherType()));
        case MPLS_POP:
            PushHeaderInstructions popHeaderInstructions = (PushHeaderInstructions) l2m;
            return factory().actions().popMpls(EthType.of(popHeaderInstructions.ethernetType().getEtherType()));
        case MPLS_LABEL:
            ModMplsLabelInstruction mplsLabel = (ModMplsLabelInstruction) l2m;
            oxm = factory().oxms().mplsLabel(U32.of(mplsLabel.label().longValue()));
            break;
        default:
            log.warn("Unimplemented action type {}.", l2m.subtype());
            break;
    }
    if (oxm != null) {
        return factory().actions().buildSetField().setField(oxm).build();
    }
    return null;
}
#end_block

#method_before
private TrafficTreatment buildTrafficTreatment() {
    final TrafficTreatment.Builder builder = builder();
    if (!isNullOrEmpty(rewriteMacAddressString)) {
        final MacAddress rewriteMacAddress = MacAddress.valueOf(rewriteMacAddressString);
        final Instruction modifySrcMacInstruction = new ModEtherInstruction(L2ModificationInstruction.L2SubType.ETH_SRC, rewriteMacAddress);
        final Instruction modifyDstMacInstruction = new ModEtherInstruction(L2ModificationInstruction.L2SubType.ETH_DST, rewriteMacAddress);
        builder.add(modifySrcMacInstruction);
        builder.add(modifyDstMacInstruction);
    }
    return builder.build();
}
#method_after
private TrafficTreatment buildTrafficTreatment() {
    final TrafficTreatment.Builder builder = builder();
    if (!isNullOrEmpty(rewriteSrcMacAddressString)) {
        final MacAddress rewriteSrcMacAddress = MacAddress.valueOf(rewriteSrcMacAddressString);
        builder.setEthSrc(rewriteSrcMacAddress);
    }
    if (!isNullOrEmpty(rewriteDstMacAddressString)) {
        final MacAddress rewriteDstMacAddress = MacAddress.valueOf(rewriteDstMacAddressString);
        builder.setEthDst(rewriteDstMacAddress);
    }
    return builder.build();
}
#end_block

#method_before
@Override
public void reply(Ethernet eth, ConnectPoint inPort) {
    checkNotNull(eth, REQUEST_NULL);
    checkArgument(eth.getEtherType() == Ethernet.TYPE_ARP, REQUEST_NOT_ARP);
    ARP arp = (ARP) eth.getPayload();
    checkArgument(arp.getOpCode() == ARP.OP_REQUEST, NOT_ARP_REQUEST);
    checkNotNull(inPort);
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Ip4Address target = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(target)) {
                    Ethernet arpReply = buildArpReply(target, addresses.mac(), eth);
                    sendTo(arpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip4Address source = Ip4Address.valueOf(arp.getSenderProtocolAddress());
        Set<PortAddresses> sourceAddresses = findPortInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    Set<Host> hosts = hostService.getHostsByIp(Ip4Address.valueOf(arp.getTargetProtocolAddress()));
    Host dst = null;
    Host src = hostService.getHost(HostId.hostId(eth.getSourceMAC(), VlanId.vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        flood(eth);
        return;
    }
    // 
    for (IpAddress ipAddress : dst.ipAddresses()) {
        Ip4Address ip4Address = ipAddress.getIp4Address();
        if (ip4Address != null) {
            Ethernet arpReply = buildArpReply(ip4Address, dst.mac(), eth);
            // TODO: check send status with host service.
            sendTo(arpReply, src.location());
            break;
        }
    }
}
#method_after
@Override
public void reply(Ethernet eth, ConnectPoint inPort) {
    checkNotNull(eth, REQUEST_NULL);
    checkArgument(eth.getEtherType() == Ethernet.TYPE_ARP, REQUEST_NOT_ARP);
    ARP arp = (ARP) eth.getPayload();
    checkArgument(arp.getOpCode() == ARP.OP_REQUEST, NOT_ARP_REQUEST);
    checkNotNull(inPort);
    // for one of our external addresses.
    if (isOutsidePort(inPort)) {
        Ip4Address target = Ip4Address.valueOf(arp.getTargetProtocolAddress());
        Set<PortAddresses> addressSet = hostService.getAddressBindingsForPort(inPort);
        for (PortAddresses addresses : addressSet) {
            for (InterfaceIpAddress ia : addresses.ipAddresses()) {
                if (ia.ipAddress().equals(target)) {
                    Ethernet arpReply = buildArpReply(target, addresses.mac(), eth);
                    sendTo(arpReply, inPort);
                }
            }
        }
        return;
    } else {
        // If the source address matches one of our external addresses
        // it could be a request from an internal host to an external
        // address. Forward it over to the correct ports.
        Ip4Address source = Ip4Address.valueOf(arp.getSenderProtocolAddress());
        Set<PortAddresses> sourceAddresses = findPortsInSubnet(source);
        boolean matched = false;
        for (PortAddresses pa : sourceAddresses) {
            for (InterfaceIpAddress ia : pa.ipAddresses()) {
                if (ia.ipAddress().equals(source)) {
                    matched = true;
                    sendTo(eth, pa.connectPoint());
                }
            }
        }
        if (matched) {
            return;
        }
    }
    // Continue with normal proxy ARP case
    VlanId vlan = VlanId.vlanId(eth.getVlanID());
    Set<Host> hosts = hostService.getHostsByIp(Ip4Address.valueOf(arp.getTargetProtocolAddress()));
    Host dst = null;
    Host src = hostService.getHost(HostId.hostId(eth.getSourceMAC(), VlanId.vlanId(eth.getVlanID())));
    for (Host host : hosts) {
        if (host.vlan().equals(vlan)) {
            dst = host;
            break;
        }
    }
    if (src == null || dst == null) {
        flood(eth);
        return;
    }
    // 
    for (IpAddress ipAddress : dst.ipAddresses()) {
        Ip4Address ip4Address = ipAddress.getIp4Address();
        if (ip4Address != null) {
            Ethernet arpReply = buildArpReply(ip4Address, dst.mac(), eth);
            // TODO: check send status with host service.
            sendTo(arpReply, src.location());
            break;
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().build();
    List<Constraint> contraint = Lists.newArrayList();
    List<Host> hosts = Lists.newArrayList(hostService.getHosts());
    while (!hosts.isEmpty()) {
        Host src = hosts.remove(0);
        for (Host dst : hosts) {
            HostToHostIntent intent = new HostToHostIntent(appId, src.id(), dst.id(), selector, treatment, contraint);
            existingIntents.add(intent);
            intentService.submit(intent);
        }
    }
}
#method_after
@Override
public void run() {
    TrafficSelector selector = DefaultTrafficSelector.builder().build();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().build();
    List<Constraint> constraint = Lists.newArrayList();
    List<Host> hosts = Lists.newArrayList(hostService.getHosts());
    while (!hosts.isEmpty()) {
        Host src = hosts.remove(0);
        for (Host dst : hosts) {
            HostToHostIntent intent = new HostToHostIntent(appId, src.id(), dst.id(), selector, treatment, constraint);
            existingIntents.add(intent);
            intentService.submit(intent);
        }
    }
}
#end_block

#method_before
protected TrafficSelector buildTrafficSelector() {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    Short ethType = Ethernet.TYPE_IPV4;
    if (!isNullOrEmpty(ethTypeString)) {
        EthType ethTypeParameter = EthType.valueOf(ethTypeString);
        ethType = ethTypeParameter.value();
    }
    selectorBuilder.matchEthType(ethType);
    if (!isNullOrEmpty(srcMacString)) {
        selectorBuilder.matchEthSrc(MacAddress.valueOf(srcMacString));
    }
    if (!isNullOrEmpty(dstMacString)) {
        selectorBuilder.matchEthDst(MacAddress.valueOf(dstMacString));
    }
    if (!isNullOrEmpty(ipProtoString)) {
        selectorBuilder.matchIPProtocol(Byte.parseByte(ipProtoString));
    }
    if (!isNullOrEmpty(srcIpString)) {
        selectorBuilder.matchIPSrc(IpPrefix.valueOf(srcIpString));
    }
    if (!isNullOrEmpty(dstIpString)) {
        selectorBuilder.matchIPDst(IpPrefix.valueOf(dstIpString));
    }
    if (!isNullOrEmpty(srcTcpString)) {
        selectorBuilder.matchTcpSrc(Short.parseShort(srcTcpString));
    }
    if (!isNullOrEmpty(dstTcpString)) {
        selectorBuilder.matchTcpSrc(Short.parseShort(dstTcpString));
    }
    return selectorBuilder.build();
}
#method_after
protected TrafficSelector buildTrafficSelector() {
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    Short ethType = Ethernet.TYPE_IPV4;
    if (!isNullOrEmpty(ethTypeString)) {
        EthType ethTypeParameter = EthType.valueOf(ethTypeString);
        ethType = ethTypeParameter.value();
    }
    selectorBuilder.matchEthType(ethType);
    if (!isNullOrEmpty(srcMacString)) {
        selectorBuilder.matchEthSrc(MacAddress.valueOf(srcMacString));
    }
    if (!isNullOrEmpty(dstMacString)) {
        selectorBuilder.matchEthDst(MacAddress.valueOf(dstMacString));
    }
    if (!isNullOrEmpty(ipProtoString)) {
        selectorBuilder.matchIPProtocol((byte) Short.parseShort(ipProtoString));
    }
    if (!isNullOrEmpty(srcIpString)) {
        selectorBuilder.matchIPSrc(IpPrefix.valueOf(srcIpString));
    }
    if (!isNullOrEmpty(dstIpString)) {
        selectorBuilder.matchIPDst(IpPrefix.valueOf(dstIpString));
    }
    if (!isNullOrEmpty(srcTcpString)) {
        selectorBuilder.matchTcpSrc((short) Integer.parseInt(srcTcpString));
    }
    if (!isNullOrEmpty(dstTcpString)) {
        selectorBuilder.matchTcpSrc((short) Integer.parseInt(dstTcpString));
    }
    return selectorBuilder.build();
}
#end_block

#method_before
@GET
@Path("{id}")
public Response getDevice(@PathParam("id") String id) {
    Device device = get(DeviceService.class).getDevice(deviceId(id));
    return ok(codec(Device.class).encode(device, this)).build();
}
#method_after
@GET
@Path("{id}")
public Response getDevice(@PathParam("id") String id) {
    Device device = nullIsNotFound(get(DeviceService.class).getDevice(deviceId(id)), DEVICE_NOT_FOUND);
    return ok(codec(Device.class).encode(device, this)).build();
}
#end_block

#method_before
@GET
@Path("{id}/ports")
public Response getDevicePorts(@PathParam("id") String id) {
    DeviceService service = get(DeviceService.class);
    Device device = nullIsNotFound(service.getDevice(deviceId(id)), "Device not found");
    List<Port> ports = checkNotNull(service.getPorts(deviceId(id)), "Ports could not be retrieved");
    ObjectNode result = codec(Device.class).encode(device, this);
    result.set("ports", codec(Port.class).encode(ports, this));
    return ok(result).build();
}
#method_after
@GET
@Path("{id}/ports")
public Response getDevicePorts(@PathParam("id") String id) {
    DeviceService service = get(DeviceService.class);
    Device device = nullIsNotFound(service.getDevice(deviceId(id)), DEVICE_NOT_FOUND);
    List<Port> ports = checkNotNull(service.getPorts(deviceId(id)), "Ports could not be retrieved");
    ObjectNode result = codec(Device.class).encode(device, this);
    result.set("ports", codec(Port.class).encode(ports, this));
    return ok(result).build();
}
#end_block

#method_before
protected List<Constraint> buildConstraints() {
    final List<Constraint> constraints = new LinkedList<>();
    // Check for a bandwidth specification
    if (!isNullOrEmpty(bandwidthString)) {
        final double bandwidthValue = Double.parseDouble(bandwidthString);
        constraints.add(new BandwidthConstraint(Bandwidth.valueOf(bandwidthValue)));
    }
    // Check for a lambda specification
    if (!isNullOrEmpty(lambdaString)) {
        final int lambdaValue = Integer.parseInt(lambdaString);
        constraints.add(new LambdaConstraint(Lambda.valueOf(lambdaValue)));
    }
    return constraints;
}
#method_after
protected List<Constraint> buildConstraints() {
    final List<Constraint> constraints = new LinkedList<>();
    // Check for a bandwidth specification
    if (!isNullOrEmpty(bandwidthString)) {
        final double bandwidthValue = Double.parseDouble(bandwidthString);
        constraints.add(new BandwidthConstraint(Bandwidth.valueOf(bandwidthValue)));
    }
    // Check for a lambda specification
    if (lambda) {
        constraints.add(new LambdaConstraint(null));
    }
    return constraints;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("id", id()).add("appId", appId()).add("selector", selector()).add("treatment", treatment()).add("path", path).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("id", id()).add("appId", appId()).add("selector", selector()).add("treatment", treatment()).add("constraints", constraints()).add("path", path).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("id", id()).add("appId", appId()).add("selector", selector()).add("treatment", treatment()).add("ingress", ingressPoints()).add("egress", egressPoint()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("id", id()).add("appId", appId()).add("selector", selector()).add("treatment", treatment()).add("ingress", ingressPoints()).add("egress", egressPoint()).add("constraints", constraints()).toString();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    setUpInterfaceService();
    setUpSdnIpConfigService();
    setUpHostService();
    intentService = createMock(IntentService.class);
    random = new Random();
    router = new Router(APPID, intentService, hostService, sdnIpConfigService, interfaceService);
}
#method_after
@Before
public void setUp() throws Exception {
    setUpInterfaceService();
    setUpSdnIpConfigService();
    hostService = new TestHostService();
    intentService = createMock(IntentService.class);
    random = new Random();
    router = new Router(APPID, intentService, hostService, sdnIpConfigService, interfaceService);
}
#end_block

#method_before
private void setUpInterfaceService() {
    interfaceService = createMock(InterfaceService.class);
    Set<Interface> interfaces = Sets.newHashSet();
    Set<InterfaceIpAddress> interfaceIpAddresses1 = Sets.newHashSet();
    interfaceIpAddresses1.add(new InterfaceIpAddress(IpAddress.valueOf("192.168.10.101"), IpPrefix.valueOf("192.168.10.0/24"), null, IpAddress.valueOf("192.168.10.1")));
    Interface sw1Eth1 = new Interface(SW1_ETH1, interfaceIpAddresses1, MacAddress.valueOf("00:00:00:00:00:01"));
    interfaces.add(sw1Eth1);
    Set<InterfaceIpAddress> interfaceIpAddresses2 = Sets.newHashSet();
    interfaceIpAddresses2.add(new InterfaceIpAddress(IpAddress.valueOf("192.168.20.101"), IpPrefix.valueOf("192.168.20.0/24"), null, IpAddress.valueOf("192.168.20.1")));
    Interface sw2Eth1 = new Interface(SW2_ETH1, interfaceIpAddresses2, MacAddress.valueOf("00:00:00:00:00:02"));
    interfaces.add(sw2Eth1);
    Set<InterfaceIpAddress> interfaceIpAddresses3 = Sets.newHashSet();
    interfaceIpAddresses3.add(new InterfaceIpAddress(IpAddress.valueOf("192.168.30.101"), IpPrefix.valueOf("192.168.30.0/24"), null, IpAddress.valueOf("192.168.30.1")));
    Interface sw3Eth1 = new Interface(SW3_ETH1, interfaceIpAddresses3, MacAddress.valueOf("00:00:00:00:00:03"));
    interfaces.add(sw3Eth1);
    expect(interfaceService.getInterface(SW1_ETH1)).andReturn(sw1Eth1).anyTimes();
    expect(interfaceService.getInterface(SW2_ETH1)).andReturn(sw2Eth1).anyTimes();
    expect(interfaceService.getInterface(SW3_ETH1)).andReturn(sw3Eth1).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    replay(interfaceService);
}
#method_after
private void setUpInterfaceService() {
    interfaceService = createMock(InterfaceService.class);
    Set<Interface> interfaces = Sets.newHashSet();
    Set<InterfaceIpAddress> interfaceIpAddresses1 = Sets.newHashSet();
    interfaceIpAddresses1.add(new InterfaceIpAddress(IpAddress.valueOf("192.168.10.101"), IpPrefix.valueOf("192.168.10.0/24")));
    Interface sw1Eth1 = new Interface(SW1_ETH1, interfaceIpAddresses1, MacAddress.valueOf("00:00:00:00:00:01"));
    interfaces.add(sw1Eth1);
    Set<InterfaceIpAddress> interfaceIpAddresses2 = Sets.newHashSet();
    interfaceIpAddresses2.add(new InterfaceIpAddress(IpAddress.valueOf("192.168.20.101"), IpPrefix.valueOf("192.168.20.0/24")));
    Interface sw2Eth1 = new Interface(SW2_ETH1, interfaceIpAddresses2, MacAddress.valueOf("00:00:00:00:00:02"));
    interfaces.add(sw2Eth1);
    Set<InterfaceIpAddress> interfaceIpAddresses3 = Sets.newHashSet();
    interfaceIpAddresses3.add(new InterfaceIpAddress(IpAddress.valueOf("192.168.30.101"), IpPrefix.valueOf("192.168.30.0/24")));
    Interface sw3Eth1 = new Interface(SW3_ETH1, interfaceIpAddresses3, MacAddress.valueOf("00:00:00:00:00:03"));
    interfaces.add(sw3Eth1);
    expect(interfaceService.getInterface(SW1_ETH1)).andReturn(sw1Eth1).anyTimes();
    expect(interfaceService.getInterface(SW2_ETH1)).andReturn(sw2Eth1).anyTimes();
    expect(interfaceService.getInterface(SW3_ETH1)).andReturn(sw3Eth1).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    replay(interfaceService);
}
#end_block

#method_before
private void setUpSdnIpConfigService() {
    sdnIpConfigService = createMock(SdnIpConfigService.class);
    Map<IpAddress, BgpPeer> peers = new HashMap<>();
    String peerSw1Eth1 = "192.168.10.1";
    peers.put(IpAddress.valueOf(peerSw1Eth1), new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    String peer1Sw2Eth1 = "192.168.20.1";
    peers.put(IpAddress.valueOf(peer1Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer1Sw2Eth1));
    String peer2Sw2Eth1 = "192.168.30.1";
    peers.put(IpAddress.valueOf(peer2Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:03", 1, peer2Sw2Eth1));
    expect(sdnIpConfigService.getBgpPeers()).andReturn(peers).anyTimes();
    replay(sdnIpConfigService);
}
#method_after
private void setUpSdnIpConfigService() {
    sdnIpConfigService = createMock(SdnIpConfigService.class);
    bgpPeers = new HashMap<>();
    String peerSw1Eth1 = "192.168.10.1";
    bgpPeers.put(IpAddress.valueOf(peerSw1Eth1), new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    String peer1Sw2Eth1 = "192.168.20.1";
    bgpPeers.put(IpAddress.valueOf(peer1Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer1Sw2Eth1));
    String peer2Sw2Eth1 = "192.168.30.1";
    bgpPeers.put(IpAddress.valueOf(peer2Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:03", 1, peer2Sw2Eth1));
    expect(sdnIpConfigService.getBgpPeers()).andReturn(bgpPeers).anyTimes();
    replay(sdnIpConfigService);
}
#end_block

#method_before
@Test
public void testAddRoutes() throws InterruptedException, TestUtilsException {
    int numRoutes = 100;
    final CountDownLatch latch = new CountDownLatch(numRoutes);
    List<RouteUpdate> routeUpdates = generateRouteUpdates(numRoutes);
    // Set up expectation
    reset(intentService);
    for (RouteUpdate update : routeUpdates) {
        IpAddress nextHopAddress = update.routeEntry().nextHop();
        Interface egressInterface = null;
        // Find out the egress interface
        for (Interface intf : interfaceService.getInterfaces()) {
            int flag = 0;
            for (InterfaceIpAddress intfIpAddress : intf.ipAddresses()) {
                if (intfIpAddress.peerAddress().equals(nextHopAddress)) {
                    flag = 1;
                    break;
                }
            }
            if (flag == 1) {
                egressInterface = intf;
                break;
            }
        }
        MultiPointToSinglePointIntent intent = getIntentForUpdate(update, generateMacAddress(nextHopAddress), egressInterface);
        intentService.submit(intent);
        expectLastCall().andAnswer(new IAnswer<Object>() {

            @Override
            public Object answer() throws Throwable {
                latch.countDown();
                return null;
            }
        }).once();
    }
    replay(intentService);
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    // Add route updates
    for (RouteUpdate update : routeUpdates) {
        router.processRouteAdd(update.routeEntry());
    }
    latch.await(5000, TimeUnit.MILLISECONDS);
    assertEquals(router.getRoutes().size(), numRoutes);
    assertEquals(router.getPushedRouteIntents().size(), numRoutes);
    verify(intentService);
}
#method_after
@Test
public void testAddRoutes() throws InterruptedException, TestUtilsException {
    int numRoutes = 100;
    final CountDownLatch latch = new CountDownLatch(numRoutes);
    List<RouteUpdate> routeUpdates = generateRouteUpdates(numRoutes);
    // Set up expectation
    reset(intentService);
    for (RouteUpdate update : routeUpdates) {
        IpAddress nextHopAddress = update.routeEntry().nextHop();
        // Find out the egress ConnectPoint
        ConnectPoint egressConnectPoint = getConnectPoint(nextHopAddress);
        MultiPointToSinglePointIntent intent = getIntentForUpdate(update, generateMacAddress(nextHopAddress), egressConnectPoint);
        intentService.submit(intent);
        expectLastCall().andAnswer(new IAnswer<Object>() {

            @Override
            public Object answer() throws Throwable {
                latch.countDown();
                return null;
            }
        }).once();
    }
    replay(intentService);
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    // Add route updates
    for (RouteUpdate update : routeUpdates) {
        router.processRouteAdd(update.routeEntry());
    }
    latch.await(5000, TimeUnit.MILLISECONDS);
    assertEquals(router.getRoutes().size(), numRoutes);
    assertEquals(router.getPushedRouteIntents().size(), numRoutes);
    verify(intentService);
}
#end_block

#method_before
@Test
public void testDeleteRoutes() throws InterruptedException, TestUtilsException {
    int numRoutes = 1;
    List<RouteUpdate> routeUpdates = generateRouteUpdates(numRoutes);
    final CountDownLatch installCount = new CountDownLatch(numRoutes);
    final CountDownLatch deleteCount = new CountDownLatch(numRoutes);
    // Set up expectation
    reset(intentService);
    for (RouteUpdate update : routeUpdates) {
        IpAddress nextHopAddress = update.routeEntry().nextHop();
        Interface egressInterface = null;
        // Find out the egress interface
        for (Interface intf : interfaceService.getInterfaces()) {
            int flag = 0;
            for (InterfaceIpAddress intfIpAddress : intf.ipAddresses()) {
                if (intfIpAddress.peerAddress().equals(nextHopAddress)) {
                    flag = 1;
                    break;
                }
            }
            if (flag == 1) {
                egressInterface = intf;
                break;
            }
        }
        MultiPointToSinglePointIntent intent = getIntentForUpdate(update, generateMacAddress(nextHopAddress), egressInterface);
        intentService.submit(intent);
        expectLastCall().andAnswer(new IAnswer<Object>() {

            @Override
            public Object answer() throws Throwable {
                installCount.countDown();
                return null;
            }
        }).once();
        intentService.withdraw(intent);
        expectLastCall().andAnswer(new IAnswer<Object>() {

            @Override
            public Object answer() throws Throwable {
                deleteCount.countDown();
                return null;
            }
        }).once();
    }
    replay(intentService);
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    // Send the add updates first
    for (RouteUpdate update : routeUpdates) {
        router.processRouteAdd(update.routeEntry());
    }
    // Give some time to let the intents be submitted
    installCount.await(5000, TimeUnit.MILLISECONDS);
    // Send the DELETE updates
    for (RouteUpdate update : routeUpdates) {
        router.processRouteDelete(update.routeEntry());
    }
    deleteCount.await(5000, TimeUnit.MILLISECONDS);
    assertEquals(0, router.getRoutes().size());
    assertEquals(0, router.getPushedRouteIntents().size());
    verify(intentService);
}
#method_after
@Test
public void testDeleteRoutes() throws InterruptedException, TestUtilsException {
    int numRoutes = 100;
    List<RouteUpdate> routeUpdates = generateRouteUpdates(numRoutes);
    final CountDownLatch installCount = new CountDownLatch(numRoutes);
    final CountDownLatch deleteCount = new CountDownLatch(numRoutes);
    // Set up expectation
    reset(intentService);
    for (RouteUpdate update : routeUpdates) {
        IpAddress nextHopAddress = update.routeEntry().nextHop();
        // Find out the egress ConnectPoint
        ConnectPoint egressConnectPoint = getConnectPoint(nextHopAddress);
        MultiPointToSinglePointIntent intent = getIntentForUpdate(update, generateMacAddress(nextHopAddress), egressConnectPoint);
        intentService.submit(intent);
        expectLastCall().andAnswer(new IAnswer<Object>() {

            @Override
            public Object answer() throws Throwable {
                installCount.countDown();
                return null;
            }
        }).once();
        intentService.withdraw(intent);
        expectLastCall().andAnswer(new IAnswer<Object>() {

            @Override
            public Object answer() throws Throwable {
                deleteCount.countDown();
                return null;
            }
        }).once();
    }
    replay(intentService);
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    // Send the add updates first
    for (RouteUpdate update : routeUpdates) {
        router.processRouteAdd(update.routeEntry());
    }
    // Give some time to let the intents be submitted
    installCount.await(5000, TimeUnit.MILLISECONDS);
    // Send the DELETE updates
    for (RouteUpdate update : routeUpdates) {
        router.processRouteDelete(update.routeEntry());
    }
    deleteCount.await(5000, TimeUnit.MILLISECONDS);
    assertEquals(0, router.getRoutes().size());
    assertEquals(0, router.getPushedRouteIntents().size());
    verify(intentService);
}
#end_block

#method_before
private List<RouteUpdate> generateRouteUpdates(int numRoutes) {
    List<RouteUpdate> routeUpdates = new ArrayList<>(numRoutes);
    Set<Ip4Prefix> prefixes = new HashSet<>();
    for (int i = 0; i < numRoutes; i++) {
        Ip4Prefix prefix;
        do {
            // Generate a random prefix length between MIN_PREFIX_LENGTH
            // and MAX_PREFIX_LENGTH
            int prefixLength = random.nextInt((MAX_PREFIX_LENGTH - MIN_PREFIX_LENGTH) + 1) + MIN_PREFIX_LENGTH;
            prefix = new Ip4Prefix(new Ip4Address(random.nextInt()), (short) prefixLength);
        // We have to ensure we don't generate the same prefix twice
        // (this is quite easy to happen with small prefix lengths).
        // TODO:
        // The IpPrefix does the comparison using 32 bits length,
        // but we need to compare only the prefix length. So I use
        // Ip4Prefix for this moment and changed to IpPrefix. This
        // can be improved in the future.
        } while (prefixes.contains(prefix));
        prefixes.add(prefix);
        // Randomly select a peer to use as the next hop
        BgpPeer nextHop = null;
        int peerNumber = random.nextInt(sdnIpConfigService.getBgpPeers().size());
        int j = 0;
        for (BgpPeer peer : sdnIpConfigService.getBgpPeers().values()) {
            if (j++ == peerNumber) {
                nextHop = peer;
                break;
            }
        }
        assertNotNull(nextHop);
        RouteUpdate update = new RouteUpdate(RouteUpdate.Type.UPDATE, new RouteEntry(IpPrefix.valueOf(prefix.toString()), nextHop.ipAddress()));
        routeUpdates.add(update);
    }
    return routeUpdates;
}
#method_after
private List<RouteUpdate> generateRouteUpdates(int numRoutes) {
    List<RouteUpdate> routeUpdates = new ArrayList<>(numRoutes);
    Set<Ip4Prefix> prefixes = new HashSet<>();
    for (int i = 0; i < numRoutes; i++) {
        Ip4Prefix prefix;
        do {
            // Generate a random prefix length between MIN_PREFIX_LENGTH
            // and MAX_PREFIX_LENGTH
            int prefixLength = random.nextInt((MAX_PREFIX_LENGTH - MIN_PREFIX_LENGTH) + 1) + MIN_PREFIX_LENGTH;
            prefix = Ip4Prefix.valueOf(Ip4Address.valueOf(random.nextInt()), prefixLength);
        // We have to ensure we don't generate the same prefix twice
        // (this is quite easy to happen with small prefix lengths).
        // TODO:
        // The IpPrefix does the comparison using 32 bits length,
        // but we need to compare only the prefix length. So I use
        // Ip4Prefix for this moment and changed to IpPrefix. This
        // can be improved in the future.
        } while (prefixes.contains(prefix));
        prefixes.add(prefix);
        // Randomly select a peer to use as the next hop
        BgpPeer nextHop = null;
        int peerNumber = random.nextInt(sdnIpConfigService.getBgpPeers().size());
        int j = 0;
        for (BgpPeer peer : sdnIpConfigService.getBgpPeers().values()) {
            if (j++ == peerNumber) {
                nextHop = peer;
                break;
            }
        }
        assertNotNull(nextHop);
        RouteUpdate update = new RouteUpdate(RouteUpdate.Type.UPDATE, new RouteEntry(prefix, nextHop.ipAddress()));
        routeUpdates.add(update);
    }
    return routeUpdates;
}
#end_block

#method_before
private MultiPointToSinglePointIntent getIntentForUpdate(RouteUpdate update, MacAddress nextHopMac, Interface egressInterface) {
    IpPrefix ip4Prefix = update.routeEntry().prefix();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip4Prefix);
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(nextHopMac);
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    for (Interface intf : interfaceService.getInterfaces()) {
        if (!intf.equals(egressInterface)) {
            ConnectPoint srcPort = intf.connectPoint();
            ingressPoints.add(srcPort);
        }
    }
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressInterface.connectPoint());
    return intent;
}
#method_after
private MultiPointToSinglePointIntent getIntentForUpdate(RouteUpdate update, MacAddress nextHopMac, ConnectPoint egressConnectPoint) {
    IpPrefix ip4Prefix = update.routeEntry().prefix();
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(ip4Prefix);
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(nextHopMac);
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    for (Interface intf : interfaceService.getInterfaces()) {
        if (!intf.connectPoint().equals(egressConnectPoint)) {
            ConnectPoint srcPort = intf.connectPoint();
            ingressPoints.add(srcPort);
        }
    }
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressConnectPoint);
    return intent;
}
#end_block

#method_before
public static MacAddress generateMacAddress(IpAddress ipAddress) {
    byte[] macAddress = new byte[MAC_ADDRESS_LENGTH];
    ByteBuffer bb = ByteBuffer.wrap(macAddress);
    // Put the IP address bytes into the lower four bytes of the MAC
    // address. Leave the first two bytes set to 0.
    bb.position(2);
    bb.put(ipAddress.toOctets());
    return MacAddress.valueOf(bb.array());
}
#method_after
static MacAddress generateMacAddress(IpAddress ipAddress) {
    byte[] macAddress = new byte[MAC_ADDRESS_LENGTH];
    ByteBuffer bb = ByteBuffer.wrap(macAddress);
    // Put the IP address bytes into the lower four bytes of the MAC
    // address. Leave the first two bytes set to 0.
    bb.position(2);
    bb.put(ipAddress.toOctets());
    return MacAddress.valueOf(bb.array());
}
#end_block

#method_before
@javax.ws.rs.Path("/teardown/{intentId}")
@POST
public Response withdrawIntent(@PathParam("intentId") String intentId) {
    log.info("Receiving Teardown request...");
    log.info("Withdraw intentId = {} ", intentId);
    String reply = "ok\n";
    return Response.ok(reply).build();
}
#method_after
@javax.ws.rs.Path("/cancellation/{intentId}")
@DELETE
public Response withdrawIntent(@PathParam("intentId") String intentId) {
    log.info("Receiving Teardown request...");
    log.info("Withdraw intentId = {} ", intentId);
    String reply = "ok\n";
    return Response.ok(reply).build();
}
#end_block

#method_before
@javax.ws.rs.Path("/modify/{intentId}/{bandwidth}")
@POST
public Response modifyBandwidth(@PathParam("intentId") String intentId, @PathParam("bandwidth") String bandwidth) {
    log.info("Receiving Modify request...");
    log.info("Modify bw for intentId = {} with new bandwidth = {}", intentId, bandwidth);
    String reply = "ok\n";
    return Response.ok(reply).build();
}
#method_after
@javax.ws.rs.Path("/modification/{intentId}/{bandwidth}")
@POST
public Response modifyBandwidth(@PathParam("intentId") String intentId, @PathParam("bandwidth") String bandwidth) {
    log.info("Receiving Modify request...");
    log.info("Modify bw for intentId = {} with new bandwidth = {}", intentId, bandwidth);
    String reply = "ok\n";
    return Response.ok(reply).build();
}
#end_block

#method_before
private void setUpHostService() {
    hostService = createMock(HostService.class);
    hostService.addListener(anyObject(HostListener.class));
    expectLastCall().anyTimes();
    IpPrefix host1Address = IpPrefix.valueOf("192.168.10.1/32");
    Host host1 = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(SW1_ETH1, 1), Sets.newHashSet(IpPrefix.valueOf("192.168.10.1/32")));
    expect(hostService.getHostsByIp(host1Address)).andReturn(Sets.newHashSet(host1)).anyTimes();
    hostService.startMonitoringIp(host1Address.toIpAddress());
    expectLastCall().anyTimes();
    IpPrefix host2Address = IpPrefix.valueOf("192.168.20.1/32");
    Host host2 = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(SW2_ETH1, 1), Sets.newHashSet(host2Address));
    expect(hostService.getHostsByIp(host2Address)).andReturn(Sets.newHashSet(host2)).anyTimes();
    hostService.startMonitoringIp(host2Address.toIpAddress());
    expectLastCall().anyTimes();
    IpPrefix host3Address = IpPrefix.valueOf("192.168.30.1/32");
    Host host3 = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:03"), VlanId.NONE, new HostLocation(SW3_ETH1, 1), Sets.newHashSet(host3Address));
    expect(hostService.getHostsByIp(host3Address)).andReturn(Sets.newHashSet(host3)).anyTimes();
    hostService.startMonitoringIp(host3Address.toIpAddress());
    expectLastCall().anyTimes();
    replay(hostService);
}
#method_after
private void setUpHostService() {
    hostService = createMock(HostService.class);
    hostService.addListener(anyObject(HostListener.class));
    expectLastCall().anyTimes();
    IpAddress host1Address = IpAddress.valueOf("192.168.10.1");
    Host host1 = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(SW1_ETH1, 1), Sets.newHashSet(host1Address));
    expect(hostService.getHostsByIp(host1Address)).andReturn(Sets.newHashSet(host1)).anyTimes();
    hostService.startMonitoringIp(host1Address);
    expectLastCall().anyTimes();
    IpAddress host2Address = IpAddress.valueOf("192.168.20.1");
    Host host2 = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(SW2_ETH1, 1), Sets.newHashSet(host2Address));
    expect(hostService.getHostsByIp(host2Address)).andReturn(Sets.newHashSet(host2)).anyTimes();
    hostService.startMonitoringIp(host2Address);
    expectLastCall().anyTimes();
    IpAddress host3Address = IpAddress.valueOf("192.168.30.1");
    Host host3 = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:03"), VlanId.NONE, new HostLocation(SW3_ETH1, 1), Sets.newHashSet(host3Address));
    expect(hostService.getHostsByIp(host3Address)).andReturn(Sets.newHashSet(host3)).anyTimes();
    hostService.startMonitoringIp(host3Address);
    expectLastCall().anyTimes();
    replay(hostService);
}
#end_block

#method_before
@Test
public void testIntentSync() throws TestUtilsException {
    // 
    // Construct routes and intents.
    // This test simulates the following cases during the master change
    // time interval:
    // 1. RouteEntry1 did not change.
    // 2. RouteEntry2 was deleted.
    // 3. RouteEntry3 was newly added.
    // 4. RouteEntry4 was updated to RouteEntry4Update.
    // 5. RouteEntry5 did not change, but its intent id changed.
    // 
    RouteEntry routeEntry1 = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    RouteEntry routeEntry2 = new RouteEntry(IpPrefix.valueOf("2.2.2.0/24"), IpAddress.valueOf("192.168.20.1"));
    RouteEntry routeEntry3 = new RouteEntry(IpPrefix.valueOf("3.3.3.0/24"), IpAddress.valueOf("192.168.30.1"));
    RouteEntry routeEntry4 = new RouteEntry(IpPrefix.valueOf("4.4.4.0/24"), IpAddress.valueOf("192.168.30.1"));
    RouteEntry routeEntry4Update = new RouteEntry(IpPrefix.valueOf("4.4.4.0/24"), IpAddress.valueOf("192.168.20.1"));
    RouteEntry routeEntry5 = new RouteEntry(IpPrefix.valueOf("5.5.5.0/24"), IpAddress.valueOf("192.168.10.1"));
    MultiPointToSinglePointIntent intent1 = intentBuilder(routeEntry1.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    MultiPointToSinglePointIntent intent2 = intentBuilder(routeEntry2.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent3 = intentBuilder(routeEntry3.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4 = intentBuilder(routeEntry4.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4Update = intentBuilder(routeEntry4Update.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent5 = intentBuilder(routeEntry5.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Compose a intent, which is equal to intent5 but the id is different.
    MultiPointToSinglePointIntent intent5New = staticIntentBuilder(intent5, routeEntry5, "00:00:00:00:00:01");
    assertTrue(TestUtils.callMethod(router, "compareMultiPointToSinglePointIntents", new Class<?>[] { MultiPointToSinglePointIntent.class, MultiPointToSinglePointIntent.class }, intent5, intent5New).equals(true));
    assertTrue(!intent5.equals(intent5New));
    // Set up the bgpRoutes and pushedRouteIntents fields in Router class
    InvertedRadixTree<RouteEntry> bgpRoutes = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry1.prefix()), routeEntry1);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry3.prefix()), routeEntry3);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry4Update.prefix()), routeEntry4Update);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry5.prefix()), routeEntry5);
    TestUtils.setField(router, "bgpRoutes", bgpRoutes);
    ConcurrentHashMap<IpPrefix, MultiPointToSinglePointIntent> pushedRouteIntents = new ConcurrentHashMap<>();
    pushedRouteIntents.put(routeEntry1.prefix(), intent1);
    pushedRouteIntents.put(routeEntry3.prefix(), intent3);
    pushedRouteIntents.put(routeEntry4Update.prefix(), intent4Update);
    pushedRouteIntents.put(routeEntry5.prefix(), intent5New);
    TestUtils.setField(router, "pushedRouteIntents", pushedRouteIntents);
    // Set up expectation
    reset(intentService);
    Set<Intent> intents = new HashSet<Intent>();
    intents.add(intent1);
    intents.add(intent2);
    intents.add(intent4);
    intents.add(intent5);
    expect(intentService.getIntents()).andReturn(intents).anyTimes();
    intentService.withdraw(intent2);
    intentService.submit(intent3);
    intentService.withdraw(intent4);
    intentService.submit(intent4Update);
    replay(intentService);
    // Start the test
    router.leaderChanged(true);
    TestUtils.callMethod(router, "syncIntents", new Class<?>[] {});
    // Verify
    assertEquals(router.getRoutes().size(), 4);
    assertTrue(router.getRoutes().contains(routeEntry1));
    assertTrue(router.getRoutes().contains(routeEntry3));
    assertTrue(router.getRoutes().contains(routeEntry4Update));
    assertTrue(router.getRoutes().contains(routeEntry5));
    assertEquals(router.getPushedRouteIntents().size(), 4);
    assertTrue(router.getPushedRouteIntents().contains(intent1));
    assertTrue(router.getPushedRouteIntents().contains(intent3));
    assertTrue(router.getPushedRouteIntents().contains(intent4Update));
    assertTrue(router.getPushedRouteIntents().contains(intent5));
    verify(intentService);
}
#method_after
@Test
public void testIntentSync() throws TestUtilsException {
    // 
    // Construct routes and intents.
    // This test simulates the following cases during the master change
    // time interval:
    // 1. RouteEntry1 did not change and the intent also did not change.
    // 2. RouteEntry2 was deleted, but the intent was not deleted.
    // 3. RouteEntry3 was newly added, and the intent was also submitted.
    // 4. RouteEntry4 was updated to RouteEntry4Update, and the intent was
    // also updated to a new one.
    // 5. RouteEntry5 did not change, but its intent id changed.
    // 6. RouteEntry6 was newly added, but the intent was not submitted.
    // 
    RouteEntry routeEntry1 = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    RouteEntry routeEntry2 = new RouteEntry(IpPrefix.valueOf("2.2.2.0/24"), IpAddress.valueOf("192.168.20.1"));
    RouteEntry routeEntry3 = new RouteEntry(IpPrefix.valueOf("3.3.3.0/24"), IpAddress.valueOf("192.168.30.1"));
    RouteEntry routeEntry4 = new RouteEntry(IpPrefix.valueOf("4.4.4.0/24"), IpAddress.valueOf("192.168.30.1"));
    RouteEntry routeEntry4Update = new RouteEntry(IpPrefix.valueOf("4.4.4.0/24"), IpAddress.valueOf("192.168.20.1"));
    RouteEntry routeEntry5 = new RouteEntry(IpPrefix.valueOf("5.5.5.0/24"), IpAddress.valueOf("192.168.10.1"));
    RouteEntry routeEntry6 = new RouteEntry(IpPrefix.valueOf("6.6.6.0/24"), IpAddress.valueOf("192.168.10.1"));
    MultiPointToSinglePointIntent intent1 = intentBuilder(routeEntry1.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    MultiPointToSinglePointIntent intent2 = intentBuilder(routeEntry2.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent3 = intentBuilder(routeEntry3.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4 = intentBuilder(routeEntry4.prefix(), "00:00:00:00:00:03", SW3_ETH1);
    MultiPointToSinglePointIntent intent4Update = intentBuilder(routeEntry4Update.prefix(), "00:00:00:00:00:02", SW2_ETH1);
    MultiPointToSinglePointIntent intent5 = intentBuilder(routeEntry5.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Compose a intent, which is equal to intent5 but the id is different.
    MultiPointToSinglePointIntent intent5New = staticIntentBuilder(intent5, routeEntry5, "00:00:00:00:00:01");
    assertTrue(TestUtils.callMethod(router, "compareMultiPointToSinglePointIntents", new Class<?>[] { MultiPointToSinglePointIntent.class, MultiPointToSinglePointIntent.class }, intent5, intent5New).equals(true));
    assertTrue(!intent5.equals(intent5New));
    MultiPointToSinglePointIntent intent6 = intentBuilder(routeEntry6.prefix(), "00:00:00:00:00:01", SW1_ETH1);
    // Set up the bgpRoutes and pushedRouteIntents fields in Router class
    InvertedRadixTree<RouteEntry> bgpRoutes = new ConcurrentInvertedRadixTree<>(new DefaultByteArrayNodeFactory());
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry1.prefix()), routeEntry1);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry3.prefix()), routeEntry3);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry4Update.prefix()), routeEntry4Update);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry5.prefix()), routeEntry5);
    bgpRoutes.put(RouteEntry.createBinaryString(routeEntry6.prefix()), routeEntry6);
    TestUtils.setField(router, "bgpRoutes", bgpRoutes);
    ConcurrentHashMap<IpPrefix, MultiPointToSinglePointIntent> pushedRouteIntents = new ConcurrentHashMap<>();
    pushedRouteIntents.put(routeEntry1.prefix(), intent1);
    pushedRouteIntents.put(routeEntry3.prefix(), intent3);
    pushedRouteIntents.put(routeEntry4Update.prefix(), intent4Update);
    pushedRouteIntents.put(routeEntry5.prefix(), intent5New);
    pushedRouteIntents.put(routeEntry6.prefix(), intent6);
    TestUtils.setField(router, "pushedRouteIntents", pushedRouteIntents);
    // Set up expectation
    reset(intentService);
    Set<Intent> intents = new HashSet<Intent>();
    intents.add(intent1);
    intents.add(intent2);
    intents.add(intent4);
    intents.add(intent5);
    expect(intentService.getIntents()).andReturn(intents).anyTimes();
    intentService.withdraw(intent2);
    intentService.submit(intent3);
    intentService.withdraw(intent4);
    intentService.submit(intent4Update);
    intentService.submit(intent6);
    replay(intentService);
    // Start the test
    router.leaderChanged(true);
    TestUtils.callMethod(router, "syncIntents", new Class<?>[] {});
    // Verify
    assertEquals(router.getRoutes().size(), 5);
    assertTrue(router.getRoutes().contains(routeEntry1));
    assertTrue(router.getRoutes().contains(routeEntry3));
    assertTrue(router.getRoutes().contains(routeEntry4Update));
    assertTrue(router.getRoutes().contains(routeEntry5));
    assertTrue(router.getRoutes().contains(routeEntry6));
    assertEquals(router.getPushedRouteIntents().size(), 5);
    assertTrue(router.getPushedRouteIntents().contains(intent1));
    assertTrue(router.getPushedRouteIntents().contains(intent3));
    assertTrue(router.getPushedRouteIntents().contains(intent4Update));
    assertTrue(router.getPushedRouteIntents().contains(intent5));
    assertTrue(router.getPushedRouteIntents().contains(intent6));
    verify(intentService);
}
#end_block

#method_before
private void executeRouteAdd(RouteEntry routeEntry) {
    log.debug("Executing route add: {}", routeEntry);
    // Monitor the IP address so we'll get notified of updates to the MAC
    // address.
    hostService.startMonitoringIp(routeEntry.nextHop());
    // See if we know the MAC address of the next hop
    MacAddress nextHopMacAddress = null;
    Set<Host> hosts = hostService.getHostsByIp(routeEntry.nextHop().toPrefix());
    if (!hosts.isEmpty()) {
        // TODO how to handle if multiple hosts are returned?
        nextHopMacAddress = hosts.iterator().next().mac();
    }
    if (nextHopMacAddress == null) {
        routesWaitingOnArp.put(routeEntry.nextHop(), routeEntry);
        return;
    }
    addRouteIntentToNextHop(routeEntry.prefix(), routeEntry.nextHop(), nextHopMacAddress);
}
#method_after
private void executeRouteAdd(RouteEntry routeEntry) {
    log.debug("Executing route add: {}", routeEntry);
    // Monitor the IP address so we'll get notified of updates to the MAC
    // address.
    hostService.startMonitoringIp(routeEntry.nextHop());
    // See if we know the MAC address of the next hop
    MacAddress nextHopMacAddress = null;
    Set<Host> hosts = hostService.getHostsByIp(routeEntry.nextHop());
    if (!hosts.isEmpty()) {
        // TODO how to handle if multiple hosts are returned?
        nextHopMacAddress = hosts.iterator().next().mac();
    }
    if (nextHopMacAddress == null) {
        routesWaitingOnArp.put(routeEntry.nextHop(), routeEntry);
        return;
    }
    addRouteIntentToNextHop(routeEntry.prefix(), routeEntry.nextHop(), nextHopMacAddress);
}
#end_block

#method_before
@Override
public void event(HostEvent event) {
    if (event.type() == HostEvent.Type.HOST_ADDED || event.type() == HostEvent.Type.HOST_UPDATED) {
        Host host = event.subject();
        for (IpPrefix ip : host.ipAddresses()) {
            updateMac(ip.toIpAddress(), host.mac());
        }
    }
}
#method_after
@Override
public void event(HostEvent event) {
    if (event.type() == HostEvent.Type.HOST_ADDED || event.type() == HostEvent.Type.HOST_UPDATED) {
        Host host = event.subject();
        for (IpAddress ip : host.ipAddresses()) {
            updateMac(ip, host.mac());
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    bgpPeers = setUpBgpPeers();
    interfaces = setUpInterfaces();
    initRouter();
}
#method_after
@Before
public void setUp() throws Exception {
    setUpBgpPeers();
    setUpInterfaceService();
    setUpHostService();
    intentService = createMock(IntentService.class);
    router = new Router(APPID, intentService, hostService, sdnIpConfigService, interfaceService);
}
#end_block

#method_before
private Map<IpAddress, BgpPeer> setUpBgpPeers() {
    configuredPeers = new HashMap<>();
    String peerSw1Eth1 = "192.168.10.1";
    configuredPeers.put(IpAddress.valueOf(peerSw1Eth1), new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    // Two BGP peers are connected to switch 2 port 1.
    String peer1Sw2Eth1 = "192.168.20.1";
    configuredPeers.put(IpAddress.valueOf(peer1Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer1Sw2Eth1));
    String peer2Sw2Eth1 = "192.168.20.2";
    configuredPeers.put(IpAddress.valueOf(peer2Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer2Sw2Eth1));
    return configuredPeers;
}
#method_after
private void setUpBgpPeers() {
    Map<IpAddress, BgpPeer> peers = new HashMap<>();
    String peerSw1Eth1 = "192.168.10.1";
    peers.put(IpAddress.valueOf(peerSw1Eth1), new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    // Two BGP peers are connected to switch 2 port 1.
    String peer1Sw2Eth1 = "192.168.20.1";
    peers.put(IpAddress.valueOf(peer1Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer1Sw2Eth1));
    String peer2Sw2Eth1 = "192.168.20.2";
    peers.put(IpAddress.valueOf(peer2Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer2Sw2Eth1));
    sdnIpConfigService = createMock(SdnIpConfigService.class);
    expect(sdnIpConfigService.getBgpPeers()).andReturn(peers).anyTimes();
    replay(sdnIpConfigService);
}
#end_block

#method_before
@Test
public void testProcessRouteAdd() throws TestUtilsException {
    // Construct a route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct a MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Reset host service
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>(1);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.10.1/32"));
    hosts.add(new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber(1), 1), ipPrefixes));
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.10.1/32"))).andReturn(hosts);
    replay(hostService);
    // Set up test expectation
    reset(intentService);
    intentService.submit(intent);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntry));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intent);
    verify(intentService);
}
#method_after
@Test
public void testProcessRouteAdd() throws TestUtilsException {
    // Construct a route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct a MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(SW2_ETH1);
    ingressPoints.add(SW3_ETH1);
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, SW1_ETH1);
    // Set up test expectation
    reset(intentService);
    intentService.submit(intent);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntry));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intent);
    verify(intentService);
}
#end_block

#method_before
@Test
public void testRouteUpdate() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Start to construct a new route entry and new intent
    RouteEntry routeEntryUpdate = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.20.1"));
    // Construct a new MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilderNew = DefaultTrafficSelector.builder();
    selectorBuilderNew.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntryUpdate.prefix());
    TrafficTreatment.Builder treatmentBuilderNew = DefaultTrafficTreatment.builder();
    treatmentBuilderNew.setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    ConnectPoint egressPointNew = new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPointsNew = new HashSet<ConnectPoint>();
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1")));
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intentNew = new MultiPointToSinglePointIntent(APPID, selectorBuilderNew.build(), treatmentBuilderNew.build(), ingressPointsNew, egressPointNew);
    // Reset host service
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>(1);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.20.1/32"));
    hosts.add(new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber(1), 1), ipPrefixes));
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.20.1/32"))).andReturn(hosts);
    replay(hostService);
    // Set up test expectation
    reset(intentService);
    intentService.withdraw(intent);
    intentService.submit(intentNew);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntryUpdate);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntryUpdate));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intentNew);
    verify(intentService);
}
#method_after
@Test
public void testRouteUpdate() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(SW2_ETH1);
    ingressPoints.add(SW3_ETH1);
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, SW1_ETH1);
    // Start to construct a new route entry and new intent
    RouteEntry routeEntryUpdate = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.20.1"));
    // Construct a new MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilderNew = DefaultTrafficSelector.builder();
    selectorBuilderNew.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntryUpdate.prefix());
    TrafficTreatment.Builder treatmentBuilderNew = DefaultTrafficTreatment.builder();
    treatmentBuilderNew.setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    Set<ConnectPoint> ingressPointsNew = new HashSet<ConnectPoint>();
    ingressPointsNew.add(SW1_ETH1);
    ingressPointsNew.add(SW3_ETH1);
    MultiPointToSinglePointIntent intentNew = new MultiPointToSinglePointIntent(APPID, selectorBuilderNew.build(), treatmentBuilderNew.build(), ingressPointsNew, SW2_ETH1);
    // Set up test expectation
    reset(intentService);
    intentService.withdraw(intent);
    intentService.submit(intentNew);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntryUpdate);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntryUpdate));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intentNew);
    verify(intentService);
}
#end_block

#method_before
@Test
public void testProcessRouteDelete() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Set up expectation
    reset(intentService);
    intentService.withdraw(intent);
    replay(intentService);
    // Call route deleting method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteDelete(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 0);
    assertEquals(router.getPushedRouteIntents().size(), 0);
    verify(intentService);
}
#method_after
@Test
public void testProcessRouteDelete() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(SW2_ETH1);
    ingressPoints.add(SW3_ETH1);
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, SW1_ETH1);
    // Set up expectation
    reset(intentService);
    intentService.withdraw(intent);
    replay(intentService);
    // Call route deleting method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteDelete(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 0);
    assertEquals(router.getPushedRouteIntents().size(), 0);
    verify(intentService);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    bgpPeers = setUpBgpPeers();
    interfaces = setUpInterfaces();
    initRouter();
}
#method_after
@Before
public void setUp() throws Exception {
    setUpSdnIpConfigService();
    setUpInterfaceService();
    hostService = createMock(HostService.class);
    intentService = createMock(IntentService.class);
    router = new Router(APPID, intentService, hostService, sdnIpConfigService, interfaceService);
    internalHostListener = router.new InternalHostListener();
}
#end_block

#method_before
@Test
public void testProcessRouteAdd() throws TestUtilsException {
    // Construct a route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct a MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Reset host service.
    // Return a empty host Set to trigger the asynchronous ARP
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>();
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.10.1/32"))).andReturn(hosts);
    hostService.startMonitoringIp(routeEntry.nextHop());
    replay(hostService);
    // Set up test expectation
    reset(intentService);
    intentService.submit(intent);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntry);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.10.1/32"));
    Host host = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber(1), 1), ipPrefixes);
    HostEvent hostEvent = new HostEvent(HostEvent.Type.HOST_ADDED, host);
    internalHostListener.event(hostEvent);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntry));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intent);
    verify(intentService);
}
#method_after
@Test
public void testProcessRouteAdd() throws TestUtilsException {
    // Construct a route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct a route intent
    MultiPointToSinglePointIntent intent = staticIntentBuilder();
    // Set up test expectation
    reset(hostService);
    expect(hostService.getHostsByIp(anyObject(IpPrefix.class))).andReturn(new HashSet<Host>()).anyTimes();
    hostService.startMonitoringIp(IpAddress.valueOf("192.168.10.1"));
    replay(hostService);
    reset(intentService);
    intentService.submit(intent);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntry);
    Host host = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(SW1_ETH1.deviceId(), SW1_ETH1.port(), 1), Sets.newHashSet(IpPrefix.valueOf("192.168.10.1/32")));
    internalHostListener.event(new HostEvent(HostEvent.Type.HOST_ADDED, host));
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntry));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intent);
    verify(intentService);
    verify(hostService);
}
#end_block

#method_before
@Test
public void testRouteUpdate() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Start to construct a new route entry and new intent
    RouteEntry routeEntryUpdate = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.20.1"));
    // Construct a new MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilderNew = DefaultTrafficSelector.builder();
    selectorBuilderNew.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntryUpdate.prefix());
    TrafficTreatment.Builder treatmentBuilderNew = DefaultTrafficTreatment.builder();
    treatmentBuilderNew.setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    ConnectPoint egressPointNew = new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPointsNew = new HashSet<ConnectPoint>();
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1")));
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intentNew = new MultiPointToSinglePointIntent(APPID, selectorBuilderNew.build(), treatmentBuilderNew.build(), ingressPointsNew, egressPointNew);
    // Reset host service
    // Return a empty host Set to trigger the asynchronous ARP
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>();
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.20.1/32"))).andReturn(hosts);
    hostService.startMonitoringIp(routeEntryUpdate.nextHop());
    replay(hostService);
    // Set up test expectation
    reset(intentService);
    intentService.withdraw(intent);
    intentService.submit(intentNew);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntryUpdate);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.20.1/32"));
    Host host = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber(1), 1), ipPrefixes);
    HostEvent hostEvent = new HostEvent(HostEvent.Type.HOST_ADDED, host);
    internalHostListener.event(hostEvent);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntryUpdate));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intentNew);
    verify(intentService);
}
#method_after
@Test
public void testRouteUpdate() throws TestUtilsException {
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    MultiPointToSinglePointIntent intent = staticIntentBuilder();
    // Set up the bgpRoutes field of Router class with existing route, and
    // pushedRouteIntents field with the corresponding existing intent
    setBgpRoutesField(routeEntry);
    setPushedRouteIntentsField(routeEntry, intent);
    // Start to construct a new route entry and new intent
    RouteEntry routeEntryUpdate = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.20.1"));
    // Construct a new MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilderNew = DefaultTrafficSelector.builder();
    selectorBuilderNew.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntryUpdate.prefix());
    TrafficTreatment.Builder treatmentBuilderNew = DefaultTrafficTreatment.builder();
    treatmentBuilderNew.setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    Set<ConnectPoint> ingressPointsNew = new HashSet<ConnectPoint>();
    ingressPointsNew.add(SW1_ETH1);
    ingressPointsNew.add(SW3_ETH1);
    MultiPointToSinglePointIntent intentNew = new MultiPointToSinglePointIntent(APPID, selectorBuilderNew.build(), treatmentBuilderNew.build(), ingressPointsNew, SW2_ETH1);
    // Set up test expectation
    reset(hostService);
    expect(hostService.getHostsByIp(anyObject(IpPrefix.class))).andReturn(new HashSet<Host>()).anyTimes();
    hostService.startMonitoringIp(IpAddress.valueOf("192.168.20.1"));
    replay(hostService);
    reset(intentService);
    intentService.withdraw(intent);
    intentService.submit(intentNew);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntryUpdate);
    Host host = new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(SW2_ETH1.deviceId(), SW2_ETH1.port(), 1), Sets.newHashSet(IpPrefix.valueOf("192.168.20.1/32")));
    internalHostListener.event(new HostEvent(HostEvent.Type.HOST_ADDED, host));
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntryUpdate));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intentNew);
    verify(intentService);
    verify(hostService);
}
#end_block

#method_before
@Test
public void testProcessRouteDelete() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Set up expectation
    reset(intentService);
    intentService.withdraw(intent);
    replay(intentService);
    // Call route deleting method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteDelete(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 0);
    assertEquals(router.getPushedRouteIntents().size(), 0);
    verify(intentService);
}
#method_after
@Test
public void testProcessRouteDelete() throws TestUtilsException {
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    MultiPointToSinglePointIntent intent = staticIntentBuilder();
    // Set up the bgpRoutes field of Router class with existing route, and
    // pushedRouteIntents field with the corresponding existing intent
    setBgpRoutesField(routeEntry);
    setPushedRouteIntentsField(routeEntry, intent);
    // Set up expectation
    reset(intentService);
    intentService.withdraw(intent);
    replay(intentService);
    // Call route deleting method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteDelete(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 0);
    assertEquals(router.getPushedRouteIntents().size(), 0);
    verify(intentService);
}
#end_block

#method_before
private void initRouter() {
    intentService = createMock(IntentService.class);
    hostService = createMock(HostService.class);
    interfaceService = createMock(InterfaceService.class);
    sdnIpConfigService = createMock(SdnIpConfigService.class);
    expect(sdnIpConfigService.getBgpPeers()).andReturn(bgpPeers).anyTimes();
    replay(sdnIpConfigService);
    router = new Router(APPID, intentService, hostService, sdnIpConfigService, interfaceService);
}
#method_after
private void initRouter() {
    intentService = createMock(IntentService.class);
    hostService = createMock(HostService.class);
    interfaceService = createMock(InterfaceService.class);
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    Set<IpPrefix> ipAddressesOnSw1Eth1 = new HashSet<IpPrefix>();
    ipAddressesOnSw1Eth1.add(IpPrefix.valueOf("192.168.10.0/24"));
    Interface expectedInterface = new Interface(new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1")), ipAddressesOnSw1Eth1, MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber(1));
    expect(interfaceService.getInterface(egressPoint)).andReturn(expectedInterface).anyTimes();
    Set<IpPrefix> ipAddressesOnSw2Eth1 = new HashSet<IpPrefix>();
    ipAddressesOnSw2Eth1.add(IpPrefix.valueOf("192.168.20.0/24"));
    Interface expectedInterfaceNew = new Interface(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")), ipAddressesOnSw2Eth1, MacAddress.valueOf("00:00:00:00:00:02"));
    ConnectPoint egressPointNew = new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber(1));
    expect(interfaceService.getInterface(egressPointNew)).andReturn(expectedInterfaceNew).anyTimes();
    replay(interfaceService);
    sdnIpConfigService = createMock(SdnIpConfigService.class);
    expect(sdnIpConfigService.getBgpPeers()).andReturn(bgpPeers).anyTimes();
    replay(sdnIpConfigService);
    router = new Router(APPID, intentService, hostService, sdnIpConfigService, interfaceService);
}
#end_block

#method_before
private Map<IpAddress, BgpPeer> setUpBgpPeers() {
    configuredPeers = new HashMap<>();
    String peerSw1Eth1 = "192.168.10.1";
    configuredPeers.put(IpAddress.valueOf(peerSw1Eth1), new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    assertNotNull(new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    // Two BGP peers are connected to switch 2 port 1.
    String peer1Sw2Eth1 = "192.168.20.1";
    configuredPeers.put(IpAddress.valueOf(peer1Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer1Sw2Eth1));
    String peer2Sw2Eth1 = "192.168.20.2";
    configuredPeers.put(IpAddress.valueOf(peer2Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer2Sw2Eth1));
    return configuredPeers;
}
#method_after
private Map<IpAddress, BgpPeer> setUpBgpPeers() {
    configuredPeers = new HashMap<>();
    String peerSw1Eth1 = "192.168.10.1";
    configuredPeers.put(IpAddress.valueOf(peerSw1Eth1), new BgpPeer("00:00:00:00:00:00:00:01", 1, peerSw1Eth1));
    // Two BGP peers are connected to switch 2 port 1.
    String peer1Sw2Eth1 = "192.168.20.1";
    configuredPeers.put(IpAddress.valueOf(peer1Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer1Sw2Eth1));
    String peer2Sw2Eth1 = "192.168.20.2";
    configuredPeers.put(IpAddress.valueOf(peer2Sw2Eth1), new BgpPeer("00:00:00:00:00:00:00:02", 1, peer2Sw2Eth1));
    return configuredPeers;
}
#end_block

#method_before
@Test
public void testProcessRouteAdd() throws TestUtilsException {
    // Construct a route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct a MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Reset host service
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>(1);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.10.1/32"));
    hosts.add(new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber(1), 1), ipPrefixes));
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.10.1/32"))).andReturn(hosts);
    replay(hostService);
    // Reset interfaceService
    Set<IpPrefix> ipAddressesOnSw1Eth1 = new HashSet<IpPrefix>();
    ipAddressesOnSw1Eth1.add(IpPrefix.valueOf("192.168.10.0/24"));
    Interface expectedInterface = new Interface(new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1")), ipAddressesOnSw1Eth1, MacAddress.valueOf("00:00:00:00:00:01"));
    reset(interfaceService);
    expect(interfaceService.getInterface(egressPoint)).andReturn(expectedInterface).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    replay(interfaceService);
    // Set up test expectation
    reset(intentService);
    intentService.submit(intent);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntry));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intent);
    verify(intentService);
}
#method_after
@Test
public void testProcessRouteAdd() throws TestUtilsException {
    // Construct a route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct a MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Reset host service
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>(1);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.10.1/32"));
    hosts.add(new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:01"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber(1), 1), ipPrefixes));
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.10.1/32"))).andReturn(hosts);
    replay(hostService);
    // Set up test expectation
    reset(intentService);
    intentService.submit(intent);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntry);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntry));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intent);
    verify(intentService);
}
#end_block

#method_before
@Test
public void testRouteUpdate() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Start to construct a new route entry and new intent
    RouteEntry routeEntryUpdate = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.20.1"));
    // Construct a new MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilderNew = DefaultTrafficSelector.builder();
    selectorBuilderNew.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntryUpdate.prefix());
    TrafficTreatment.Builder treatmentBuilderNew = DefaultTrafficTreatment.builder();
    treatmentBuilderNew.setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    ConnectPoint egressPointNew = new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPointsNew = new HashSet<ConnectPoint>();
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1")));
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intentNew = new MultiPointToSinglePointIntent(APPID, selectorBuilderNew.build(), treatmentBuilderNew.build(), ingressPointsNew, egressPointNew);
    // Reset host service
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>(1);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.20.1/32"));
    hosts.add(new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber(1), 1), ipPrefixes));
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.20.1/32"))).andReturn(hosts);
    replay(hostService);
    // Reset interface service
    Set<IpPrefix> ipAddressesOnSw2Eth1 = new HashSet<IpPrefix>();
    ipAddressesOnSw2Eth1.add(IpPrefix.valueOf("192.168.20.0/24"));
    Interface expectedInterfaceNew = new Interface(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")), ipAddressesOnSw2Eth1, MacAddress.valueOf("00:00:00:00:00:02"));
    reset(interfaceService);
    expect(interfaceService.getInterface(egressPointNew)).andReturn(expectedInterfaceNew).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    replay(interfaceService);
    // Set up test expectation
    reset(intentService);
    intentService.withdraw(intent);
    intentService.submit(intentNew);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntryUpdate);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntryUpdate));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intentNew);
    verify(intentService);
}
#method_after
@Test
public void testRouteUpdate() throws TestUtilsException {
    // Firstly add a route
    testProcessRouteAdd();
    // Construct the existing route entry
    RouteEntry routeEntry = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.10.1"));
    // Construct the existing MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilder = DefaultTrafficSelector.builder();
    selectorBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntry.prefix());
    TrafficTreatment.Builder treatmentBuilder = DefaultTrafficTreatment.builder();
    treatmentBuilder.setEthDst(MacAddress.valueOf("00:00:00:00:00:01"));
    ConnectPoint egressPoint = new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPoints = new HashSet<ConnectPoint>();
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1")));
    ingressPoints.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intent = new MultiPointToSinglePointIntent(APPID, selectorBuilder.build(), treatmentBuilder.build(), ingressPoints, egressPoint);
    // Start to construct a new route entry and new intent
    RouteEntry routeEntryUpdate = new RouteEntry(IpPrefix.valueOf("1.1.1.0/24"), IpAddress.valueOf("192.168.20.1"));
    // Construct a new MultiPointToSinglePointIntent intent
    TrafficSelector.Builder selectorBuilderNew = DefaultTrafficSelector.builder();
    selectorBuilderNew.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(routeEntryUpdate.prefix());
    TrafficTreatment.Builder treatmentBuilderNew = DefaultTrafficTreatment.builder();
    treatmentBuilderNew.setEthDst(MacAddress.valueOf("00:00:00:00:00:02"));
    ConnectPoint egressPointNew = new ConnectPoint(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber("1"));
    Set<ConnectPoint> ingressPointsNew = new HashSet<ConnectPoint>();
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000001"), PortNumber.portNumber("1")));
    ingressPointsNew.add(new ConnectPoint(DeviceId.deviceId("of:0000000000000003"), PortNumber.portNumber("1")));
    MultiPointToSinglePointIntent intentNew = new MultiPointToSinglePointIntent(APPID, selectorBuilderNew.build(), treatmentBuilderNew.build(), ingressPointsNew, egressPointNew);
    // Reset host service
    reset(hostService);
    Set<Host> hosts = new HashSet<Host>(1);
    Set<IpPrefix> ipPrefixes = new HashSet<IpPrefix>();
    ipPrefixes.add(IpPrefix.valueOf("192.168.20.1/32"));
    hosts.add(new DefaultHost(ProviderId.NONE, HostId.NONE, MacAddress.valueOf("00:00:00:00:00:02"), VlanId.NONE, new HostLocation(DeviceId.deviceId("of:0000000000000002"), PortNumber.portNumber(1), 1), ipPrefixes));
    expect(hostService.getHostsByIp(IpPrefix.valueOf("192.168.20.1/32"))).andReturn(hosts);
    replay(hostService);
    // Set up test expectation
    reset(intentService);
    intentService.withdraw(intent);
    intentService.submit(intentNew);
    replay(intentService);
    // Call the processRouteAdd() method in Router class
    router.leaderChanged(true);
    TestUtils.setField(router, "isActivatedLeader", true);
    router.processRouteAdd(routeEntryUpdate);
    // Verify
    assertEquals(router.getRoutes().size(), 1);
    assertTrue(router.getRoutes().contains(routeEntryUpdate));
    assertEquals(router.getPushedRouteIntents().size(), 1);
    assertEquals(router.getPushedRouteIntents().iterator().next(), intentNew);
    verify(intentService);
}
#end_block

#method_before
@Activate
protected void activate() {
    linkProviderService = linkProviderRegistry.register(this);
    deviceProviderService = deviceProviderRegistry.register(this);
    log.info("Starting optical network configuration process... ");
    log.info("Optical config file set to {}", configFileName);
    loadOpticalConfig();
    parseOpticalConfig();
    publishOpticalConfig();
}
#method_after
@Activate
protected void activate() {
    linkProviderService = linkProviderRegistry.register(this);
    deviceProviderService = deviceProviderRegistry.register(this);
    log.info("Starting optical network configuration process...");
    log.info("Optical config file set to {}", configFileName);
    loadOpticalConfig();
    parseOpticalConfig();
    publishOpticalConfig();
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    linkProviderRegistry.unregister(this);
    linkProviderService = null;
    deviceProviderRegistry.unregister(this);
    deviceProviderService = null;
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    linkProviderRegistry.unregister(this);
    linkProviderService = null;
    deviceProviderRegistry.unregister(this);
    deviceProviderService = null;
    RAW_ROADMS.clear();
    RAW_WDMLINKS.clear();
    RAW_PKTOPTLINKS.clear();
    log.info("Stopped");
}
#end_block

#method_before
private void loadOpticalConfig() {
    ObjectMapper mapper = new ObjectMapper();
    opticalNetworkConfig = new OpticalNetworkConfig();
    try {
        opticalNetworkConfig = mapper.readValue(new File(configFileName), OpticalNetworkConfig.class);
    } catch (JsonParseException e) {
        String err = String.format("JsonParseException while loading network " + "config from file: %s: %s", configFileName, e.getMessage());
        log.error(err);
    } catch (JsonMappingException e) {
        String err = String.format("JsonMappingException while loading network config " + "from file: %s: %s", configFileName, e.getMessage());
        log.error(err);
    } catch (IOException e) {
        String err = String.format("IOException while loading network config " + "from file: %s %s", configFileName, e.getMessage());
        log.error(err);
    }
}
#method_after
private void loadOpticalConfig() {
    ObjectMapper mapper = new ObjectMapper();
    opticalNetworkConfig = new OpticalNetworkConfig();
    try {
        opticalNetworkConfig = mapper.readValue(new File(configFileName), OpticalNetworkConfig.class);
    } catch (JsonParseException e) {
        String err = String.format("JsonParseException while loading network " + "config from file: %s: %s", configFileName, e.getMessage());
        log.error(err, e);
    } catch (JsonMappingException e) {
        String err = String.format("JsonMappingException while loading network config " + "from file: %s: %s", configFileName, e.getMessage());
        log.error(err, e);
    } catch (IOException e) {
        String err = String.format("IOException while loading network config " + "from file: %s %s", configFileName, e.getMessage());
        log.error(err, e);
    }
}
#end_block

#method_before
private void parseOpticalConfig() {
    List<OpticalSwitchDiscription> swList = opticalNetworkConfig.getOpticalSwitches();
    List<OpticalLinkDiscription> lkList = opticalNetworkConfig.getOpticalLinks();
    for (OpticalSwitchDiscription sw : swList) {
        String swtype = sw.getType();
        boolean allow = sw.isAllowed();
        if (swtype.equals(ROADM)) {
            int regNum = 0;
            Set<Map.Entry<String, JsonNode>> m = sw.params.entrySet();
            for (Map.Entry<String, JsonNode> e : m) {
                String key = e.getKey();
                JsonNode j = e.getValue();
                if (key.equals("numRegen")) {
                    regNum = j.asInt();
                }
            }
            Roadm newRoadm = new Roadm(sw.getName());
            newRoadm.setName(sw.name);
            newRoadm.setNodeId(sw.nodeDpid);
            newRoadm.setLongtitude(sw.longitude);
            newRoadm.setLatitude(sw.latitude);
            newRoadm.setRegenNum(regNum);
            rawRoadms.add(newRoadm);
            log.info(newRoadm.toString());
        }
    }
    for (OpticalLinkDiscription lk : lkList) {
        String lktype = lk.getType();
        switch(lktype) {
            case WDM_LINK:
                WdmLink newWdmLink = new WdmLink();
                newWdmLink.setSrcNodeId(lk.getNodeDpid1());
                newWdmLink.setSnkNodeId(lk.getNodeDpid2());
                // default weight for each WDM link.
                newWdmLink.setAdminWeight(1000);
                Set<Map.Entry<String, JsonNode>> m = lk.params.entrySet();
                for (Map.Entry<String, JsonNode> e : m) {
                    String key = e.getKey();
                    JsonNode j = e.getValue();
                    if (key.equals("nodeName1")) {
                        newWdmLink.setSrcNodeName(j.asText());
                    } else if (key.equals("nodeName2")) {
                        newWdmLink.setSnkNodeName(j.asText());
                    } else if (key.equals("port1")) {
                        newWdmLink.setSrcPort(j.asInt());
                    } else if (key.equals("port2")) {
                        newWdmLink.setSnkPort(j.asInt());
                    } else if (key.equals("distKms")) {
                        newWdmLink.setDistance(j.asDouble());
                    } else if (key.equals("numWaves")) {
                        newWdmLink.setWavelengthNumber(j.asInt());
                    } else {
                        log.error("error found");
                    // TODO add exception processing;
                    }
                }
                rawWdmLinkes.add(newWdmLink);
                log.info(newWdmLink.toString());
                break;
            case PKT_OPT_LINK:
                PktOptLink newPktOptLink = new PktOptLink();
                newPktOptLink.setSrcNodeId(lk.getNodeDpid1());
                newPktOptLink.setSnkNodeId(lk.getNodeDpid2());
                // default weight for each WDM link.
                newPktOptLink.setAdminWeight(10);
                Set<Map.Entry<String, JsonNode>> ptm = lk.params.entrySet();
                for (Map.Entry<String, JsonNode> e : ptm) {
                    String key = e.getKey();
                    JsonNode j = e.getValue();
                    if (key.equals("nodeName1")) {
                        newPktOptLink.setSrcNodeName(j.asText());
                    } else if (key.equals("nodeName2")) {
                        newPktOptLink.setSnkNodeName(j.asText());
                    } else if (key.equals("port1")) {
                        newPktOptLink.setSrcPort(j.asInt());
                    } else if (key.equals("port2")) {
                        newPktOptLink.setSnkPort(j.asInt());
                    } else if (key.equals("bandWidth")) {
                        newPktOptLink.setBandwdith(j.asDouble());
                    } else {
                        log.error("error found");
                    // TODO add exception processing;
                    }
                }
                rawPktOptLinkes.add(newPktOptLink);
                log.info(newPktOptLink.toString());
                break;
            default:
        }
    }
}
#method_after
private void parseOpticalConfig() {
    List<OpticalSwitchDescription> swList = opticalNetworkConfig.getOpticalSwitches();
    List<OpticalLinkDescription> lkList = opticalNetworkConfig.getOpticalLinks();
    for (OpticalSwitchDescription sw : swList) {
        String swtype = sw.getType();
        boolean allow = sw.isAllowed();
        if (swtype.equals(ROADM) && allow) {
            int regNum = 0;
            Set<Map.Entry<String, JsonNode>> m = sw.params.entrySet();
            for (Map.Entry<String, JsonNode> e : m) {
                String key = e.getKey();
                JsonNode j = e.getValue();
                if (key.equals("numRegen")) {
                    regNum = j.asInt();
                }
            }
            Roadm newRoadm = new Roadm();
            newRoadm.setName(sw.name);
            newRoadm.setNodeId(sw.nodeDpid);
            newRoadm.setLongtitude(sw.longitude);
            newRoadm.setLatitude(sw.latitude);
            newRoadm.setRegenNum(regNum);
            RAW_ROADMS.add(newRoadm);
            log.info(newRoadm.toString());
        }
    }
    for (OpticalLinkDescription lk : lkList) {
        String lktype = lk.getType();
        switch(lktype) {
            case WDM_LINK:
                WdmLink newWdmLink = new WdmLink();
                newWdmLink.setSrcNodeId(lk.getNodeDpid1());
                newWdmLink.setSnkNodeId(lk.getNodeDpid2());
                // default weight for each WDM link.
                newWdmLink.setAdminWeight(1000);
                Set<Map.Entry<String, JsonNode>> m = lk.params.entrySet();
                for (Map.Entry<String, JsonNode> e : m) {
                    String key = e.getKey();
                    JsonNode j = e.getValue();
                    if (key.equals("nodeName1")) {
                        newWdmLink.setSrcNodeName(j.asText());
                    } else if (key.equals("nodeName2")) {
                        newWdmLink.setSnkNodeName(j.asText());
                    } else if (key.equals("port1")) {
                        newWdmLink.setSrcPort(j.asInt());
                    } else if (key.equals("port2")) {
                        newWdmLink.setSnkPort(j.asInt());
                    } else if (key.equals("distKms")) {
                        newWdmLink.setDistance(j.asDouble());
                    } else if (key.equals("numWaves")) {
                        newWdmLink.setWavelengthNumber(j.asInt());
                    } else {
                        log.error("error found");
                    // TODO add exception processing;
                    }
                }
                RAW_WDMLINKS.add(newWdmLink);
                log.info(newWdmLink.toString());
                break;
            case PKT_OPT_LINK:
                PktOptLink newPktOptLink = new PktOptLink();
                newPktOptLink.setSrcNodeId(lk.getNodeDpid1());
                newPktOptLink.setSnkNodeId(lk.getNodeDpid2());
                // default weight for each packet-optical link.
                newPktOptLink.setAdminWeight(10);
                Set<Map.Entry<String, JsonNode>> ptm = lk.params.entrySet();
                for (Map.Entry<String, JsonNode> e : ptm) {
                    String key = e.getKey();
                    JsonNode j = e.getValue();
                    if (key.equals("nodeName1")) {
                        newPktOptLink.setSrcNodeName(j.asText());
                    } else if (key.equals("nodeName2")) {
                        newPktOptLink.setSnkNodeName(j.asText());
                    } else if (key.equals("port1")) {
                        newPktOptLink.setSrcPort(j.asInt());
                    } else if (key.equals("port2")) {
                        newPktOptLink.setSnkPort(j.asInt());
                    } else if (key.equals("bandWidth")) {
                        newPktOptLink.setBandwdith(j.asDouble());
                    } else {
                        log.error("error found");
                    // TODO add exception processing;
                    }
                }
                RAW_PKTOPTLINKS.add(newPktOptLink);
                log.info(newPktOptLink.toString());
                break;
            default:
        }
    }
}
#end_block

#method_before
private void publishOpticalConfig() {
    if (deviceProviderService == null || linkProviderService == null) {
        return;
    }
    Iterator<Roadm> iterWDMlink = rawRoadms.iterator();
    while (iterWDMlink.hasNext()) {
        Roadm value = iterWDMlink.next();
        DeviceId did = deviceId("of:" + value.getNodeId().replace(":", ""));
        DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set("switchType", "ROADM").build();
        extendedAttributes = DefaultAnnotations.builder().set("switchName", value.getName()).build();
        extendedAttributes = DefaultAnnotations.builder().set("latitude", Double.toString(value.getLatitude())).build();
        extendedAttributes = DefaultAnnotations.builder().set("longtitude", Double.toString(value.getLongtitude())).build();
        extendedAttributes = DefaultAnnotations.builder().set("regNum", Integer.toString(value.getRegenNum())).build();
        DeviceDescription description = new DefaultDeviceDescription(did.uri(), Device.Type.SWITCH, "", "", "", "", extendedAttributes);
        deviceProviderService.deviceConnected(did, description);
    }
    // Discover the WDM link objects
    Iterator<WdmLink> iterWdmlink = rawWdmLinkes.iterator();
    while (iterWDMlink.hasNext()) {
        WdmLink value = iterWdmlink.next();
        DeviceId srcNodeId = deviceId("of:" + value.getSrcNodeId().replace(":", ""));
        DeviceId snkNodeId = deviceId("of:" + value.getSnkNodeId().replace(":", ""));
        PortNumber srcPort = PortNumber.portNumber(value.getSrcPort());
        PortNumber snkPort = PortNumber.portNumber(value.getSnkPort());
        ConnectPoint srcPoint = new ConnectPoint(srcNodeId, srcPort);
        ConnectPoint snkPoint = new ConnectPoint(snkNodeId, snkPort);
        DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set("linkType", "WDM").build();
        extendedAttributes = DefaultAnnotations.builder().set("distance", Double.toString(value.getDistance())).build();
        extendedAttributes = DefaultAnnotations.builder().set("adminWeight", Double.toString(value.getAdminWeight())).build();
        extendedAttributes = DefaultAnnotations.builder().set("wavelengthNum", Integer.toString(value.getWavelengthNumber())).build();
        DefaultLinkDescription linkDescription = new DefaultLinkDescription(srcPoint, snkPoint, Link.Type.DIRECT, extendedAttributes);
        linkProviderService.linkDetected(linkDescription);
    }
    // Discover the packet optical link objects
    Iterator<PktOptLink> iterPktOptlink = rawPktOptLinkes.iterator();
    while (iterPktOptlink.hasNext()) {
        PktOptLink value = iterPktOptlink.next();
        DeviceId srcNodeId = deviceId("of:" + value.getSrcNodeId().replace(":", ""));
        DeviceId snkNodeId = deviceId("of:" + value.getSnkNodeId().replace(":", ""));
        PortNumber srcPort = PortNumber.portNumber(value.getSrcPort());
        PortNumber snkPort = PortNumber.portNumber(value.getSnkPort());
        ConnectPoint srcPoint = new ConnectPoint(srcNodeId, srcPort);
        ConnectPoint snkPoint = new ConnectPoint(snkNodeId, snkPort);
        DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set("linkType", "PktOptLink").build();
        extendedAttributes = DefaultAnnotations.builder().set("distance", Double.toString(value.getBandwidth())).build();
        extendedAttributes = DefaultAnnotations.builder().set("adminWeight", Double.toString(value.getAdminWeight())).build();
        DefaultLinkDescription linkDescription = new DefaultLinkDescription(srcPoint, snkPoint, Link.Type.DIRECT, extendedAttributes);
        linkProviderService.linkDetected(linkDescription);
    }
}
#method_after
private void publishOpticalConfig() {
    if (deviceProviderService == null || linkProviderService == null) {
        return;
    }
    // Discover the optical ROADM objects
    Iterator<Roadm> iterWdmNode = RAW_ROADMS.iterator();
    while (iterWdmNode.hasNext()) {
        Roadm value = iterWdmNode.next();
        DeviceId did = deviceId("of:" + value.getNodeId().replace(":", ""));
        ChassisId cid = new ChassisId(value.getNodeId());
        DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set(OPTICAL_ANNOTATION + "switchType", "ROADM").set(OPTICAL_ANNOTATION + "switchName", value.getName()).set(OPTICAL_ANNOTATION + "latitude", Double.toString(value.getLatitude())).set(OPTICAL_ANNOTATION + "longtitude", Double.toString(value.getLongtitude())).set(OPTICAL_ANNOTATION + "regNum", Integer.toString(value.getRegenNum())).build();
        DeviceDescription description = new DefaultDeviceDescription(did.uri(), Device.Type.SWITCH, "", "", "", "", cid, extendedAttributes);
        deviceProviderService.deviceConnected(did, description);
    }
    // Discover the optical WDM link objects
    Iterator<WdmLink> iterWdmlink = RAW_WDMLINKS.iterator();
    while (iterWdmlink.hasNext()) {
        WdmLink value = iterWdmlink.next();
        DeviceId srcNodeId = deviceId("of:" + value.getSrcNodeId().replace(":", ""));
        DeviceId snkNodeId = deviceId("of:" + value.getSnkNodeId().replace(":", ""));
        PortNumber srcPort = PortNumber.portNumber(value.getSrcPort());
        PortNumber snkPort = PortNumber.portNumber(value.getSnkPort());
        ConnectPoint srcPoint = new ConnectPoint(srcNodeId, srcPort);
        ConnectPoint snkPoint = new ConnectPoint(snkNodeId, snkPort);
        DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set(OPTICAL_ANNOTATION + "linkType", "WDM").set(OPTICAL_ANNOTATION + "distance", Double.toString(value.getDistance())).set(OPTICAL_ANNOTATION + "cost", Double.toString(value.getDistance())).set(OPTICAL_ANNOTATION + "adminWeight", Double.toString(value.getAdminWeight())).set(OPTICAL_ANNOTATION + "wavelengthNum", Integer.toString(value.getWavelengthNumber())).build();
        DefaultLinkDescription linkDescription = new DefaultLinkDescription(srcPoint, snkPoint, Link.Type.DIRECT, extendedAttributes);
        linkProviderService.linkDetected(linkDescription);
        log.info(String.format("WDM link: %s : %s", linkDescription.src().toString(), linkDescription.dst().toString()));
    }
    // Discover the packet optical link objects
    Iterator<PktOptLink> iterPktOptlink = RAW_PKTOPTLINKS.iterator();
    while (iterPktOptlink.hasNext()) {
        PktOptLink value = iterPktOptlink.next();
        DeviceId srcNodeId = deviceId("of:" + value.getSrcNodeId().replace(":", ""));
        DeviceId snkNodeId = deviceId("of:" + value.getSnkNodeId().replace(":", ""));
        PortNumber srcPort = PortNumber.portNumber(value.getSrcPort());
        PortNumber snkPort = PortNumber.portNumber(value.getSnkPort());
        ConnectPoint srcPoint = new ConnectPoint(srcNodeId, srcPort);
        ConnectPoint snkPoint = new ConnectPoint(snkNodeId, snkPort);
        DefaultAnnotations extendedAttributes = DefaultAnnotations.builder().set(OPTICAL_ANNOTATION + "linkType", "PktOptLink").set(OPTICAL_ANNOTATION + "bandwidth", Double.toString(value.getBandwidth())).set(OPTICAL_ANNOTATION + "cost", Double.toString(value.getBandwidth())).set(OPTICAL_ANNOTATION + "adminWeight", Double.toString(value.getAdminWeight())).build();
        DefaultLinkDescription linkDescription = new DefaultLinkDescription(srcPoint, snkPoint, Link.Type.DIRECT, extendedAttributes);
        linkProviderService.linkDetected(linkDescription);
        log.info(String.format("Packet-optical link: %s : %s", linkDescription.src().toString(), linkDescription.dst().toString()));
    }
}
#end_block

#method_before
@Override
public void triggerProbe(Device device) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void triggerProbe(Device device) {
// TODO We may want to consider re-reading config files and publishing them based on this event.
}
#end_block

#method_before
@Override
public void roleChanged(Device device, MastershipRole newRole) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void roleChanged(Device device, MastershipRole newRole) {
// TODO Auto-generated method stub.
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuffer(" srcNodeName: ").append(this.srcNodeName).append(" snkNodeName: ").append(this.snkNodeName).append(" srcNodeId: ").append(this.srcNodeId).append(" snkNodeId: ").append(this.snkNodeId).append(" srcPort: ").append(this.srcPort).append(" snkPort: ").append(this.snkPort).append(" bandwidth: ").append(this.bandwidth).append(" adminWeight: ").append(this.adminWeight).toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder(" srcNodeName: ").append(this.srcNodeName).append(" snkNodeName: ").append(this.snkNodeName).append(" srcNodeId: ").append(this.srcNodeId).append(" snkNodeId: ").append(this.snkNodeId).append(" srcPort: ").append(this.srcPort).append(" snkPort: ").append(this.snkPort).append(" bandwidth: ").append(this.bandwidth).append(" cost: ").append(this.cost).append(" adminWeight: ").append(this.adminWeight).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuffer(" ROADM Name: ").append(this.name).append(" nodeID: ").append(this.nodeID).append(" longtitude: ").append(this.longtitude).append(" latitude: ").append(this.latitude).append(" regenNum: ").append(this.regenNum).append(" 10GTportNum: ").append(this.tPort10G).append(" 40GTportNum: ").append(this.tPort40G).append(" 100GTportNum: ").append(this.tPort100G).append(" WportNum: ").append(this.wPort).toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder(" ROADM Name: ").append(this.name).append(" nodeID: ").append(this.nodeID).append(" longtitude: ").append(this.longtitude).append(" latitude: ").append(this.latitude).append(" regenNum: ").append(this.regenNum).append(" 10GTportNum: ").append(this.tPort10G).append(" 40GTportNum: ").append(this.tPort40G).append(" 100GTportNum: ").append(this.tPort100G).append(" WportNum: ").append(this.wPort).toString();
}
#end_block

#method_before
@Override
public String toString() {
    return new StringBuffer(" srcNodeName: ").append(this.srcNodeName).append(" snkNodeName: ").append(this.snkNodeName).append(" srcNodeId: ").append(this.srcNodeId).append(" snkNodeId: ").append(this.snkNodeId).append(" srcPort: ").append(this.srcPort).append(" snkPort: ").append(this.snkPort).append(" distance: ").append(this.distance).append(" wavelengthNumber: ").append(this.wavelengthNumber).append(" adminWeight: ").append(this.adminWeight).toString();
}
#method_after
@Override
public String toString() {
    return new StringBuilder(" srcNodeName: ").append(this.srcNodeName).append(" snkNodeName: ").append(this.snkNodeName).append(" srcNodeId: ").append(this.srcNodeId).append(" snkNodeId: ").append(this.snkNodeId).append(" srcPort: ").append(this.srcPort).append(" snkPort: ").append(this.snkPort).append(" distance: ").append(this.distance).append(" cost: ").append(this.cost).append(" wavelengthNumber: ").append(this.wavelengthNumber).append(" adminWeight: ").append(this.adminWeight).toString();
}
#end_block

#method_before
public List<OpticalSwitchDiscription> getOpticalSwitches() {
    return opticalSwitches;
}
#method_after
public List<OpticalSwitchDescription> getOpticalSwitches() {
    return opticalSwitches;
}
#end_block

#method_before
public void setOpticalSwitches(List<OpticalSwitchDiscription> switches) {
    this.opticalSwitches = switches;
}
#method_after
public void setOpticalSwitches(List<OpticalSwitchDescription> switches) {
    this.opticalSwitches = switches;
}
#end_block

#method_before
public List<OpticalLinkDiscription> getOpticalLinks() {
    return opticalLinks;
}
#method_after
public List<OpticalLinkDescription> getOpticalLinks() {
    return opticalLinks;
}
#end_block

#method_before
public void setOpticalLinks(List<OpticalLinkDiscription> links) {
    this.opticalLinks = links;
}
#method_after
public void setOpticalLinks(List<OpticalLinkDescription> links) {
    this.opticalLinks = links;
}
#end_block

